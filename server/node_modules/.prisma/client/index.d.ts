
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model District
 * 
 */
export type District = $Result.DefaultSelection<Prisma.$DistrictPayload>
/**
 * Model Manager
 * 
 */
export type Manager = $Result.DefaultSelection<Prisma.$ManagerPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model SupplierProduct
 * 
 */
export type SupplierProduct = $Result.DefaultSelection<Prisma.$SupplierProductPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderAttachment
 * 
 */
export type OrderAttachment = $Result.DefaultSelection<Prisma.$OrderAttachmentPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Expeditor
 * 
 */
export type Expeditor = $Result.DefaultSelection<Prisma.$ExpeditorPayload>
/**
 * Model Stock
 * 
 */
export type Stock = $Result.DefaultSelection<Prisma.$StockPayload>
/**
 * Model StockTransaction
 * 
 */
export type StockTransaction = $Result.DefaultSelection<Prisma.$StockTransactionPayload>
/**
 * Model SummaryOrderJournal
 * 
 */
export type SummaryOrderJournal = $Result.DefaultSelection<Prisma.$SummaryOrderJournalPayload>
/**
 * Model SummaryOrdersJournal
 * 
 */
export type SummaryOrdersJournal = $Result.DefaultSelection<Prisma.$SummaryOrdersJournalPayload>
/**
 * Model AssemblyOrdersJournal
 * 
 */
export type AssemblyOrdersJournal = $Result.DefaultSelection<Prisma.$AssemblyOrdersJournalPayload>
/**
 * Model ProductionStaff
 * 
 */
export type ProductionStaff = $Result.DefaultSelection<Prisma.$ProductionStaffPayload>
/**
 * Model ProductionJournal
 * 
 */
export type ProductionJournal = $Result.DefaultSelection<Prisma.$ProductionJournalPayload>
/**
 * Model ProductionItem
 * 
 */
export type ProductionItem = $Result.DefaultSelection<Prisma.$ProductionItemPayload>
/**
 * Model ProductionItemValue
 * 
 */
export type ProductionItemValue = $Result.DefaultSelection<Prisma.$ProductionItemValuePayload>
/**
 * Model PurchasePriceList
 * 
 */
export type PurchasePriceList = $Result.DefaultSelection<Prisma.$PurchasePriceListPayload>
/**
 * Model PurchasePriceListSupplier
 * 
 */
export type PurchasePriceListSupplier = $Result.DefaultSelection<Prisma.$PurchasePriceListSupplierPayload>
/**
 * Model PurchasePriceItem
 * 
 */
export type PurchasePriceItem = $Result.DefaultSelection<Prisma.$PurchasePriceItemPayload>
/**
 * Model SalesPriceList
 * 
 */
export type SalesPriceList = $Result.DefaultSelection<Prisma.$SalesPriceListPayload>
/**
 * Model SalesPriceItem
 * 
 */
export type SalesPriceItem = $Result.DefaultSelection<Prisma.$SalesPriceItemPayload>
/**
 * Model ProductionMml
 * 
 */
export type ProductionMml = $Result.DefaultSelection<Prisma.$ProductionMmlPayload>
/**
 * Model ProductionMmlNode
 * 
 */
export type ProductionMmlNode = $Result.DefaultSelection<Prisma.$ProductionMmlNodePayload>
/**
 * Model ProductionRun
 * 
 */
export type ProductionRun = $Result.DefaultSelection<Prisma.$ProductionRunPayload>
/**
 * Model ProductionRunValue
 * 
 */
export type ProductionRunValue = $Result.DefaultSelection<Prisma.$ProductionRunValuePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.district`: Exposes CRUD operations for the **District** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Districts
    * const districts = await prisma.district.findMany()
    * ```
    */
  get district(): Prisma.DistrictDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierProduct`: Exposes CRUD operations for the **SupplierProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierProducts
    * const supplierProducts = await prisma.supplierProduct.findMany()
    * ```
    */
  get supplierProduct(): Prisma.SupplierProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderAttachment`: Exposes CRUD operations for the **OrderAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderAttachments
    * const orderAttachments = await prisma.orderAttachment.findMany()
    * ```
    */
  get orderAttachment(): Prisma.OrderAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expeditor`: Exposes CRUD operations for the **Expeditor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expeditors
    * const expeditors = await prisma.expeditor.findMany()
    * ```
    */
  get expeditor(): Prisma.ExpeditorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stock`: Exposes CRUD operations for the **Stock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stock.findMany()
    * ```
    */
  get stock(): Prisma.StockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockTransaction`: Exposes CRUD operations for the **StockTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockTransactions
    * const stockTransactions = await prisma.stockTransaction.findMany()
    * ```
    */
  get stockTransaction(): Prisma.StockTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.summaryOrderJournal`: Exposes CRUD operations for the **SummaryOrderJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SummaryOrderJournals
    * const summaryOrderJournals = await prisma.summaryOrderJournal.findMany()
    * ```
    */
  get summaryOrderJournal(): Prisma.SummaryOrderJournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.summaryOrdersJournal`: Exposes CRUD operations for the **SummaryOrdersJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SummaryOrdersJournals
    * const summaryOrdersJournals = await prisma.summaryOrdersJournal.findMany()
    * ```
    */
  get summaryOrdersJournal(): Prisma.SummaryOrdersJournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assemblyOrdersJournal`: Exposes CRUD operations for the **AssemblyOrdersJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssemblyOrdersJournals
    * const assemblyOrdersJournals = await prisma.assemblyOrdersJournal.findMany()
    * ```
    */
  get assemblyOrdersJournal(): Prisma.AssemblyOrdersJournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionStaff`: Exposes CRUD operations for the **ProductionStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionStaffs
    * const productionStaffs = await prisma.productionStaff.findMany()
    * ```
    */
  get productionStaff(): Prisma.ProductionStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionJournal`: Exposes CRUD operations for the **ProductionJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionJournals
    * const productionJournals = await prisma.productionJournal.findMany()
    * ```
    */
  get productionJournal(): Prisma.ProductionJournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionItem`: Exposes CRUD operations for the **ProductionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionItems
    * const productionItems = await prisma.productionItem.findMany()
    * ```
    */
  get productionItem(): Prisma.ProductionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionItemValue`: Exposes CRUD operations for the **ProductionItemValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionItemValues
    * const productionItemValues = await prisma.productionItemValue.findMany()
    * ```
    */
  get productionItemValue(): Prisma.ProductionItemValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchasePriceList`: Exposes CRUD operations for the **PurchasePriceList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasePriceLists
    * const purchasePriceLists = await prisma.purchasePriceList.findMany()
    * ```
    */
  get purchasePriceList(): Prisma.PurchasePriceListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchasePriceListSupplier`: Exposes CRUD operations for the **PurchasePriceListSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasePriceListSuppliers
    * const purchasePriceListSuppliers = await prisma.purchasePriceListSupplier.findMany()
    * ```
    */
  get purchasePriceListSupplier(): Prisma.PurchasePriceListSupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchasePriceItem`: Exposes CRUD operations for the **PurchasePriceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasePriceItems
    * const purchasePriceItems = await prisma.purchasePriceItem.findMany()
    * ```
    */
  get purchasePriceItem(): Prisma.PurchasePriceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesPriceList`: Exposes CRUD operations for the **SalesPriceList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesPriceLists
    * const salesPriceLists = await prisma.salesPriceList.findMany()
    * ```
    */
  get salesPriceList(): Prisma.SalesPriceListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesPriceItem`: Exposes CRUD operations for the **SalesPriceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesPriceItems
    * const salesPriceItems = await prisma.salesPriceItem.findMany()
    * ```
    */
  get salesPriceItem(): Prisma.SalesPriceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionMml`: Exposes CRUD operations for the **ProductionMml** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionMmls
    * const productionMmls = await prisma.productionMml.findMany()
    * ```
    */
  get productionMml(): Prisma.ProductionMmlDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionMmlNode`: Exposes CRUD operations for the **ProductionMmlNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionMmlNodes
    * const productionMmlNodes = await prisma.productionMmlNode.findMany()
    * ```
    */
  get productionMmlNode(): Prisma.ProductionMmlNodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionRun`: Exposes CRUD operations for the **ProductionRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionRuns
    * const productionRuns = await prisma.productionRun.findMany()
    * ```
    */
  get productionRun(): Prisma.ProductionRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionRunValue`: Exposes CRUD operations for the **ProductionRunValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionRunValues
    * const productionRunValues = await prisma.productionRunValue.findMany()
    * ```
    */
  get productionRunValue(): Prisma.ProductionRunValueDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    District: 'District',
    Manager: 'Manager',
    Product: 'Product',
    Customer: 'Customer',
    Supplier: 'Supplier',
    SupplierProduct: 'SupplierProduct',
    Order: 'Order',
    OrderAttachment: 'OrderAttachment',
    OrderItem: 'OrderItem',
    Expeditor: 'Expeditor',
    Stock: 'Stock',
    StockTransaction: 'StockTransaction',
    SummaryOrderJournal: 'SummaryOrderJournal',
    SummaryOrdersJournal: 'SummaryOrdersJournal',
    AssemblyOrdersJournal: 'AssemblyOrdersJournal',
    ProductionStaff: 'ProductionStaff',
    ProductionJournal: 'ProductionJournal',
    ProductionItem: 'ProductionItem',
    ProductionItemValue: 'ProductionItemValue',
    PurchasePriceList: 'PurchasePriceList',
    PurchasePriceListSupplier: 'PurchasePriceListSupplier',
    PurchasePriceItem: 'PurchasePriceItem',
    SalesPriceList: 'SalesPriceList',
    SalesPriceItem: 'SalesPriceItem',
    ProductionMml: 'ProductionMml',
    ProductionMmlNode: 'ProductionMmlNode',
    ProductionRun: 'ProductionRun',
    ProductionRunValue: 'ProductionRunValue'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "district" | "manager" | "product" | "customer" | "supplier" | "supplierProduct" | "order" | "orderAttachment" | "orderItem" | "expeditor" | "stock" | "stockTransaction" | "summaryOrderJournal" | "summaryOrdersJournal" | "assemblyOrdersJournal" | "productionStaff" | "productionJournal" | "productionItem" | "productionItemValue" | "purchasePriceList" | "purchasePriceListSupplier" | "purchasePriceItem" | "salesPriceList" | "salesPriceItem" | "productionMml" | "productionMmlNode" | "productionRun" | "productionRunValue"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      District: {
        payload: Prisma.$DistrictPayload<ExtArgs>
        fields: Prisma.DistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistrictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistrictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findFirst: {
            args: Prisma.DistrictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistrictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findMany: {
            args: Prisma.DistrictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          create: {
            args: Prisma.DistrictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          createMany: {
            args: Prisma.DistrictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistrictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          delete: {
            args: Prisma.DistrictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          update: {
            args: Prisma.DistrictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          deleteMany: {
            args: Prisma.DistrictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistrictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DistrictUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          upsert: {
            args: Prisma.DistrictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          aggregate: {
            args: Prisma.DistrictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistrict>
          }
          groupBy: {
            args: Prisma.DistrictGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistrictCountArgs<ExtArgs>
            result: $Utils.Optional<DistrictCountAggregateOutputType> | number
          }
        }
      }
      Manager: {
        payload: Prisma.$ManagerPayload<ExtArgs>
        fields: Prisma.ManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findFirst: {
            args: Prisma.ManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findMany: {
            args: Prisma.ManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          create: {
            args: Prisma.ManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          createMany: {
            args: Prisma.ManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          delete: {
            args: Prisma.ManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          update: {
            args: Prisma.ManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          deleteMany: {
            args: Prisma.ManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          upsert: {
            args: Prisma.ManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          aggregate: {
            args: Prisma.ManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManager>
          }
          groupBy: {
            args: Prisma.ManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManagerCountArgs<ExtArgs>
            result: $Utils.Optional<ManagerCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      SupplierProduct: {
        payload: Prisma.$SupplierProductPayload<ExtArgs>
        fields: Prisma.SupplierProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          findFirst: {
            args: Prisma.SupplierProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          findMany: {
            args: Prisma.SupplierProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>[]
          }
          create: {
            args: Prisma.SupplierProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          createMany: {
            args: Prisma.SupplierProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>[]
          }
          delete: {
            args: Prisma.SupplierProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          update: {
            args: Prisma.SupplierProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          deleteMany: {
            args: Prisma.SupplierProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>[]
          }
          upsert: {
            args: Prisma.SupplierProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          aggregate: {
            args: Prisma.SupplierProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierProduct>
          }
          groupBy: {
            args: Prisma.SupplierProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierProductCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderAttachment: {
        payload: Prisma.$OrderAttachmentPayload<ExtArgs>
        fields: Prisma.OrderAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          findFirst: {
            args: Prisma.OrderAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          findMany: {
            args: Prisma.OrderAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>[]
          }
          create: {
            args: Prisma.OrderAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          createMany: {
            args: Prisma.OrderAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>[]
          }
          delete: {
            args: Prisma.OrderAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          update: {
            args: Prisma.OrderAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.OrderAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.OrderAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          aggregate: {
            args: Prisma.OrderAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderAttachment>
          }
          groupBy: {
            args: Prisma.OrderAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<OrderAttachmentCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Expeditor: {
        payload: Prisma.$ExpeditorPayload<ExtArgs>
        fields: Prisma.ExpeditorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpeditorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpeditorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          findFirst: {
            args: Prisma.ExpeditorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpeditorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          findMany: {
            args: Prisma.ExpeditorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>[]
          }
          create: {
            args: Prisma.ExpeditorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          createMany: {
            args: Prisma.ExpeditorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpeditorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>[]
          }
          delete: {
            args: Prisma.ExpeditorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          update: {
            args: Prisma.ExpeditorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          deleteMany: {
            args: Prisma.ExpeditorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpeditorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpeditorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>[]
          }
          upsert: {
            args: Prisma.ExpeditorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          aggregate: {
            args: Prisma.ExpeditorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpeditor>
          }
          groupBy: {
            args: Prisma.ExpeditorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpeditorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpeditorCountArgs<ExtArgs>
            result: $Utils.Optional<ExpeditorCountAggregateOutputType> | number
          }
        }
      }
      Stock: {
        payload: Prisma.$StockPayload<ExtArgs>
        fields: Prisma.StockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findFirst: {
            args: Prisma.StockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findMany: {
            args: Prisma.StockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          create: {
            args: Prisma.StockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          createMany: {
            args: Prisma.StockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          delete: {
            args: Prisma.StockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          update: {
            args: Prisma.StockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          deleteMany: {
            args: Prisma.StockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          upsert: {
            args: Prisma.StockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          aggregate: {
            args: Prisma.StockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStock>
          }
          groupBy: {
            args: Prisma.StockGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockCountArgs<ExtArgs>
            result: $Utils.Optional<StockCountAggregateOutputType> | number
          }
        }
      }
      StockTransaction: {
        payload: Prisma.$StockTransactionPayload<ExtArgs>
        fields: Prisma.StockTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          findFirst: {
            args: Prisma.StockTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          findMany: {
            args: Prisma.StockTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>[]
          }
          create: {
            args: Prisma.StockTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          createMany: {
            args: Prisma.StockTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>[]
          }
          delete: {
            args: Prisma.StockTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          update: {
            args: Prisma.StockTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          deleteMany: {
            args: Prisma.StockTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>[]
          }
          upsert: {
            args: Prisma.StockTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          aggregate: {
            args: Prisma.StockTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockTransaction>
          }
          groupBy: {
            args: Prisma.StockTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<StockTransactionCountAggregateOutputType> | number
          }
        }
      }
      SummaryOrderJournal: {
        payload: Prisma.$SummaryOrderJournalPayload<ExtArgs>
        fields: Prisma.SummaryOrderJournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SummaryOrderJournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SummaryOrderJournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          findFirst: {
            args: Prisma.SummaryOrderJournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SummaryOrderJournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          findMany: {
            args: Prisma.SummaryOrderJournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>[]
          }
          create: {
            args: Prisma.SummaryOrderJournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          createMany: {
            args: Prisma.SummaryOrderJournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SummaryOrderJournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>[]
          }
          delete: {
            args: Prisma.SummaryOrderJournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          update: {
            args: Prisma.SummaryOrderJournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          deleteMany: {
            args: Prisma.SummaryOrderJournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SummaryOrderJournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SummaryOrderJournalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>[]
          }
          upsert: {
            args: Prisma.SummaryOrderJournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          aggregate: {
            args: Prisma.SummaryOrderJournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSummaryOrderJournal>
          }
          groupBy: {
            args: Prisma.SummaryOrderJournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<SummaryOrderJournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.SummaryOrderJournalCountArgs<ExtArgs>
            result: $Utils.Optional<SummaryOrderJournalCountAggregateOutputType> | number
          }
        }
      }
      SummaryOrdersJournal: {
        payload: Prisma.$SummaryOrdersJournalPayload<ExtArgs>
        fields: Prisma.SummaryOrdersJournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SummaryOrdersJournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SummaryOrdersJournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          findFirst: {
            args: Prisma.SummaryOrdersJournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SummaryOrdersJournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          findMany: {
            args: Prisma.SummaryOrdersJournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>[]
          }
          create: {
            args: Prisma.SummaryOrdersJournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          createMany: {
            args: Prisma.SummaryOrdersJournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SummaryOrdersJournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>[]
          }
          delete: {
            args: Prisma.SummaryOrdersJournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          update: {
            args: Prisma.SummaryOrdersJournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          deleteMany: {
            args: Prisma.SummaryOrdersJournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SummaryOrdersJournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SummaryOrdersJournalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>[]
          }
          upsert: {
            args: Prisma.SummaryOrdersJournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          aggregate: {
            args: Prisma.SummaryOrdersJournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSummaryOrdersJournal>
          }
          groupBy: {
            args: Prisma.SummaryOrdersJournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<SummaryOrdersJournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.SummaryOrdersJournalCountArgs<ExtArgs>
            result: $Utils.Optional<SummaryOrdersJournalCountAggregateOutputType> | number
          }
        }
      }
      AssemblyOrdersJournal: {
        payload: Prisma.$AssemblyOrdersJournalPayload<ExtArgs>
        fields: Prisma.AssemblyOrdersJournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssemblyOrdersJournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssemblyOrdersJournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          findFirst: {
            args: Prisma.AssemblyOrdersJournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssemblyOrdersJournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          findMany: {
            args: Prisma.AssemblyOrdersJournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>[]
          }
          create: {
            args: Prisma.AssemblyOrdersJournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          createMany: {
            args: Prisma.AssemblyOrdersJournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssemblyOrdersJournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>[]
          }
          delete: {
            args: Prisma.AssemblyOrdersJournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          update: {
            args: Prisma.AssemblyOrdersJournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          deleteMany: {
            args: Prisma.AssemblyOrdersJournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssemblyOrdersJournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssemblyOrdersJournalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>[]
          }
          upsert: {
            args: Prisma.AssemblyOrdersJournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          aggregate: {
            args: Prisma.AssemblyOrdersJournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssemblyOrdersJournal>
          }
          groupBy: {
            args: Prisma.AssemblyOrdersJournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssemblyOrdersJournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssemblyOrdersJournalCountArgs<ExtArgs>
            result: $Utils.Optional<AssemblyOrdersJournalCountAggregateOutputType> | number
          }
        }
      }
      ProductionStaff: {
        payload: Prisma.$ProductionStaffPayload<ExtArgs>
        fields: Prisma.ProductionStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          findFirst: {
            args: Prisma.ProductionStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          findMany: {
            args: Prisma.ProductionStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>[]
          }
          create: {
            args: Prisma.ProductionStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          createMany: {
            args: Prisma.ProductionStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>[]
          }
          delete: {
            args: Prisma.ProductionStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          update: {
            args: Prisma.ProductionStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          deleteMany: {
            args: Prisma.ProductionStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>[]
          }
          upsert: {
            args: Prisma.ProductionStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          aggregate: {
            args: Prisma.ProductionStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionStaff>
          }
          groupBy: {
            args: Prisma.ProductionStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionStaffCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionStaffCountAggregateOutputType> | number
          }
        }
      }
      ProductionJournal: {
        payload: Prisma.$ProductionJournalPayload<ExtArgs>
        fields: Prisma.ProductionJournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionJournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionJournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          findFirst: {
            args: Prisma.ProductionJournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionJournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          findMany: {
            args: Prisma.ProductionJournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>[]
          }
          create: {
            args: Prisma.ProductionJournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          createMany: {
            args: Prisma.ProductionJournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionJournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>[]
          }
          delete: {
            args: Prisma.ProductionJournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          update: {
            args: Prisma.ProductionJournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          deleteMany: {
            args: Prisma.ProductionJournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionJournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionJournalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>[]
          }
          upsert: {
            args: Prisma.ProductionJournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          aggregate: {
            args: Prisma.ProductionJournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionJournal>
          }
          groupBy: {
            args: Prisma.ProductionJournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionJournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionJournalCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionJournalCountAggregateOutputType> | number
          }
        }
      }
      ProductionItem: {
        payload: Prisma.$ProductionItemPayload<ExtArgs>
        fields: Prisma.ProductionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          findFirst: {
            args: Prisma.ProductionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          findMany: {
            args: Prisma.ProductionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>[]
          }
          create: {
            args: Prisma.ProductionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          createMany: {
            args: Prisma.ProductionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>[]
          }
          delete: {
            args: Prisma.ProductionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          update: {
            args: Prisma.ProductionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          deleteMany: {
            args: Prisma.ProductionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>[]
          }
          upsert: {
            args: Prisma.ProductionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          aggregate: {
            args: Prisma.ProductionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionItem>
          }
          groupBy: {
            args: Prisma.ProductionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionItemCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionItemCountAggregateOutputType> | number
          }
        }
      }
      ProductionItemValue: {
        payload: Prisma.$ProductionItemValuePayload<ExtArgs>
        fields: Prisma.ProductionItemValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionItemValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionItemValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          findFirst: {
            args: Prisma.ProductionItemValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionItemValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          findMany: {
            args: Prisma.ProductionItemValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>[]
          }
          create: {
            args: Prisma.ProductionItemValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          createMany: {
            args: Prisma.ProductionItemValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionItemValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>[]
          }
          delete: {
            args: Prisma.ProductionItemValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          update: {
            args: Prisma.ProductionItemValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          deleteMany: {
            args: Prisma.ProductionItemValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionItemValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionItemValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>[]
          }
          upsert: {
            args: Prisma.ProductionItemValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          aggregate: {
            args: Prisma.ProductionItemValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionItemValue>
          }
          groupBy: {
            args: Prisma.ProductionItemValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionItemValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionItemValueCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionItemValueCountAggregateOutputType> | number
          }
        }
      }
      PurchasePriceList: {
        payload: Prisma.$PurchasePriceListPayload<ExtArgs>
        fields: Prisma.PurchasePriceListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasePriceListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasePriceListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          findFirst: {
            args: Prisma.PurchasePriceListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasePriceListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          findMany: {
            args: Prisma.PurchasePriceListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>[]
          }
          create: {
            args: Prisma.PurchasePriceListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          createMany: {
            args: Prisma.PurchasePriceListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasePriceListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>[]
          }
          delete: {
            args: Prisma.PurchasePriceListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          update: {
            args: Prisma.PurchasePriceListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          deleteMany: {
            args: Prisma.PurchasePriceListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasePriceListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchasePriceListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>[]
          }
          upsert: {
            args: Prisma.PurchasePriceListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          aggregate: {
            args: Prisma.PurchasePriceListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasePriceList>
          }
          groupBy: {
            args: Prisma.PurchasePriceListGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceListGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasePriceListCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceListCountAggregateOutputType> | number
          }
        }
      }
      PurchasePriceListSupplier: {
        payload: Prisma.$PurchasePriceListSupplierPayload<ExtArgs>
        fields: Prisma.PurchasePriceListSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasePriceListSupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasePriceListSupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          findFirst: {
            args: Prisma.PurchasePriceListSupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasePriceListSupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          findMany: {
            args: Prisma.PurchasePriceListSupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>[]
          }
          create: {
            args: Prisma.PurchasePriceListSupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          createMany: {
            args: Prisma.PurchasePriceListSupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasePriceListSupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>[]
          }
          delete: {
            args: Prisma.PurchasePriceListSupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          update: {
            args: Prisma.PurchasePriceListSupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          deleteMany: {
            args: Prisma.PurchasePriceListSupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasePriceListSupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchasePriceListSupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>[]
          }
          upsert: {
            args: Prisma.PurchasePriceListSupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          aggregate: {
            args: Prisma.PurchasePriceListSupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasePriceListSupplier>
          }
          groupBy: {
            args: Prisma.PurchasePriceListSupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceListSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasePriceListSupplierCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceListSupplierCountAggregateOutputType> | number
          }
        }
      }
      PurchasePriceItem: {
        payload: Prisma.$PurchasePriceItemPayload<ExtArgs>
        fields: Prisma.PurchasePriceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasePriceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasePriceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          findFirst: {
            args: Prisma.PurchasePriceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasePriceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          findMany: {
            args: Prisma.PurchasePriceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>[]
          }
          create: {
            args: Prisma.PurchasePriceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          createMany: {
            args: Prisma.PurchasePriceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasePriceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>[]
          }
          delete: {
            args: Prisma.PurchasePriceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          update: {
            args: Prisma.PurchasePriceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchasePriceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasePriceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchasePriceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchasePriceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          aggregate: {
            args: Prisma.PurchasePriceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasePriceItem>
          }
          groupBy: {
            args: Prisma.PurchasePriceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasePriceItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceItemCountAggregateOutputType> | number
          }
        }
      }
      SalesPriceList: {
        payload: Prisma.$SalesPriceListPayload<ExtArgs>
        fields: Prisma.SalesPriceListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesPriceListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesPriceListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          findFirst: {
            args: Prisma.SalesPriceListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesPriceListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          findMany: {
            args: Prisma.SalesPriceListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>[]
          }
          create: {
            args: Prisma.SalesPriceListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          createMany: {
            args: Prisma.SalesPriceListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesPriceListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>[]
          }
          delete: {
            args: Prisma.SalesPriceListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          update: {
            args: Prisma.SalesPriceListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          deleteMany: {
            args: Prisma.SalesPriceListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesPriceListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesPriceListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>[]
          }
          upsert: {
            args: Prisma.SalesPriceListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          aggregate: {
            args: Prisma.SalesPriceListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesPriceList>
          }
          groupBy: {
            args: Prisma.SalesPriceListGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesPriceListGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesPriceListCountArgs<ExtArgs>
            result: $Utils.Optional<SalesPriceListCountAggregateOutputType> | number
          }
        }
      }
      SalesPriceItem: {
        payload: Prisma.$SalesPriceItemPayload<ExtArgs>
        fields: Prisma.SalesPriceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesPriceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesPriceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          findFirst: {
            args: Prisma.SalesPriceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesPriceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          findMany: {
            args: Prisma.SalesPriceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>[]
          }
          create: {
            args: Prisma.SalesPriceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          createMany: {
            args: Prisma.SalesPriceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesPriceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>[]
          }
          delete: {
            args: Prisma.SalesPriceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          update: {
            args: Prisma.SalesPriceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          deleteMany: {
            args: Prisma.SalesPriceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesPriceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesPriceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>[]
          }
          upsert: {
            args: Prisma.SalesPriceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          aggregate: {
            args: Prisma.SalesPriceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesPriceItem>
          }
          groupBy: {
            args: Prisma.SalesPriceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesPriceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesPriceItemCountArgs<ExtArgs>
            result: $Utils.Optional<SalesPriceItemCountAggregateOutputType> | number
          }
        }
      }
      ProductionMml: {
        payload: Prisma.$ProductionMmlPayload<ExtArgs>
        fields: Prisma.ProductionMmlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionMmlFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionMmlFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          findFirst: {
            args: Prisma.ProductionMmlFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionMmlFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          findMany: {
            args: Prisma.ProductionMmlFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>[]
          }
          create: {
            args: Prisma.ProductionMmlCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          createMany: {
            args: Prisma.ProductionMmlCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionMmlCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>[]
          }
          delete: {
            args: Prisma.ProductionMmlDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          update: {
            args: Prisma.ProductionMmlUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          deleteMany: {
            args: Prisma.ProductionMmlDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionMmlUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionMmlUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>[]
          }
          upsert: {
            args: Prisma.ProductionMmlUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          aggregate: {
            args: Prisma.ProductionMmlAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionMml>
          }
          groupBy: {
            args: Prisma.ProductionMmlGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionMmlGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionMmlCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionMmlCountAggregateOutputType> | number
          }
        }
      }
      ProductionMmlNode: {
        payload: Prisma.$ProductionMmlNodePayload<ExtArgs>
        fields: Prisma.ProductionMmlNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionMmlNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionMmlNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          findFirst: {
            args: Prisma.ProductionMmlNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionMmlNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          findMany: {
            args: Prisma.ProductionMmlNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>[]
          }
          create: {
            args: Prisma.ProductionMmlNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          createMany: {
            args: Prisma.ProductionMmlNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionMmlNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>[]
          }
          delete: {
            args: Prisma.ProductionMmlNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          update: {
            args: Prisma.ProductionMmlNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          deleteMany: {
            args: Prisma.ProductionMmlNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionMmlNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionMmlNodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>[]
          }
          upsert: {
            args: Prisma.ProductionMmlNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          aggregate: {
            args: Prisma.ProductionMmlNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionMmlNode>
          }
          groupBy: {
            args: Prisma.ProductionMmlNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionMmlNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionMmlNodeCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionMmlNodeCountAggregateOutputType> | number
          }
        }
      }
      ProductionRun: {
        payload: Prisma.$ProductionRunPayload<ExtArgs>
        fields: Prisma.ProductionRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          findFirst: {
            args: Prisma.ProductionRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          findMany: {
            args: Prisma.ProductionRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>[]
          }
          create: {
            args: Prisma.ProductionRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          createMany: {
            args: Prisma.ProductionRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>[]
          }
          delete: {
            args: Prisma.ProductionRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          update: {
            args: Prisma.ProductionRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          deleteMany: {
            args: Prisma.ProductionRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>[]
          }
          upsert: {
            args: Prisma.ProductionRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          aggregate: {
            args: Prisma.ProductionRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionRun>
          }
          groupBy: {
            args: Prisma.ProductionRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionRunCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionRunCountAggregateOutputType> | number
          }
        }
      }
      ProductionRunValue: {
        payload: Prisma.$ProductionRunValuePayload<ExtArgs>
        fields: Prisma.ProductionRunValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionRunValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionRunValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          findFirst: {
            args: Prisma.ProductionRunValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionRunValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          findMany: {
            args: Prisma.ProductionRunValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>[]
          }
          create: {
            args: Prisma.ProductionRunValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          createMany: {
            args: Prisma.ProductionRunValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionRunValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>[]
          }
          delete: {
            args: Prisma.ProductionRunValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          update: {
            args: Prisma.ProductionRunValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          deleteMany: {
            args: Prisma.ProductionRunValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionRunValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionRunValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>[]
          }
          upsert: {
            args: Prisma.ProductionRunValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          aggregate: {
            args: Prisma.ProductionRunValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionRunValue>
          }
          groupBy: {
            args: Prisma.ProductionRunValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionRunValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionRunValueCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionRunValueCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    district?: DistrictOmit
    manager?: ManagerOmit
    product?: ProductOmit
    customer?: CustomerOmit
    supplier?: SupplierOmit
    supplierProduct?: SupplierProductOmit
    order?: OrderOmit
    orderAttachment?: OrderAttachmentOmit
    orderItem?: OrderItemOmit
    expeditor?: ExpeditorOmit
    stock?: StockOmit
    stockTransaction?: StockTransactionOmit
    summaryOrderJournal?: SummaryOrderJournalOmit
    summaryOrdersJournal?: SummaryOrdersJournalOmit
    assemblyOrdersJournal?: AssemblyOrdersJournalOmit
    productionStaff?: ProductionStaffOmit
    productionJournal?: ProductionJournalOmit
    productionItem?: ProductionItemOmit
    productionItemValue?: ProductionItemValueOmit
    purchasePriceList?: PurchasePriceListOmit
    purchasePriceListSupplier?: PurchasePriceListSupplierOmit
    purchasePriceItem?: PurchasePriceItemOmit
    salesPriceList?: SalesPriceListOmit
    salesPriceItem?: SalesPriceItemOmit
    productionMml?: ProductionMmlOmit
    productionMmlNode?: ProductionMmlNodeOmit
    productionRun?: ProductionRunOmit
    productionRunValue?: ProductionRunValueOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdMmls: number
    productionRuns: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdMmls?: boolean | UserCountOutputTypeCountCreatedMmlsArgs
    productionRuns?: boolean | UserCountOutputTypeCountProductionRunsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedMmlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductionRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunWhereInput
  }


  /**
   * Count Type DistrictCountOutputType
   */

  export type DistrictCountOutputType = {
    customers: number
  }

  export type DistrictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | DistrictCountOutputTypeCountCustomersArgs
  }

  // Custom InputTypes
  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistrictCountOutputType
     */
    select?: DistrictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * Count Type ManagerCountOutputType
   */

  export type ManagerCountOutputType = {
    customers: number
  }

  export type ManagerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | ManagerCountOutputTypeCountCustomersArgs
  }

  // Custom InputTypes
  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCountOutputType
     */
    select?: ManagerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderItems: number
    stockTransactions: number
    suppliers: number
    summaryJournalEntries: number
    productionItems: number
    purchasePriceItems: number
    salesPriceItems: number
    productionMmls: number
    mmlNodes: number
    productionRuns: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    stockTransactions?: boolean | ProductCountOutputTypeCountStockTransactionsArgs
    suppliers?: boolean | ProductCountOutputTypeCountSuppliersArgs
    summaryJournalEntries?: boolean | ProductCountOutputTypeCountSummaryJournalEntriesArgs
    productionItems?: boolean | ProductCountOutputTypeCountProductionItemsArgs
    purchasePriceItems?: boolean | ProductCountOutputTypeCountPurchasePriceItemsArgs
    salesPriceItems?: boolean | ProductCountOutputTypeCountSalesPriceItemsArgs
    productionMmls?: boolean | ProductCountOutputTypeCountProductionMmlsArgs
    mmlNodes?: boolean | ProductCountOutputTypeCountMmlNodesArgs
    productionRuns?: boolean | ProductCountOutputTypeCountProductionRunsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransactionWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSummaryJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummaryOrderJournalWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchasePriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSalesPriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesPriceItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductionMmlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountMmlNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlNodeWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductionRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
    summaryJournalEntries: number
    salesPriceLists: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    summaryJournalEntries?: boolean | CustomerCountOutputTypeCountSummaryJournalEntriesArgs
    salesPriceLists?: boolean | CustomerCountOutputTypeCountSalesPriceListsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSummaryJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummaryOrderJournalWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesPriceListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesPriceListWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    products: number
    purchasePriceListSuppliers: number
    purchasePriceItems: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SupplierCountOutputTypeCountProductsArgs
    purchasePriceListSuppliers?: boolean | SupplierCountOutputTypeCountPurchasePriceListSuppliersArgs
    purchasePriceItems?: boolean | SupplierCountOutputTypeCountPurchasePriceItemsArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierProductWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchasePriceListSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceListSupplierWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchasePriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceItemWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    stockTransactions: number
    attachments: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    stockTransactions?: boolean | OrderCountOutputTypeCountStockTransactionsArgs
    attachments?: boolean | OrderCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountStockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransactionWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderAttachmentWhereInput
  }


  /**
   * Count Type ExpeditorCountOutputType
   */

  export type ExpeditorCountOutputType = {
    orders: number
  }

  export type ExpeditorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ExpeditorCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * ExpeditorCountOutputType without action
   */
  export type ExpeditorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpeditorCountOutputType
     */
    select?: ExpeditorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpeditorCountOutputType without action
   */
  export type ExpeditorCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type ProductionStaffCountOutputType
   */

  export type ProductionStaffCountOutputType = {
    journals: number
  }

  export type ProductionStaffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journals?: boolean | ProductionStaffCountOutputTypeCountJournalsArgs
  }

  // Custom InputTypes
  /**
   * ProductionStaffCountOutputType without action
   */
  export type ProductionStaffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaffCountOutputType
     */
    select?: ProductionStaffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionStaffCountOutputType without action
   */
  export type ProductionStaffCountOutputTypeCountJournalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionJournalWhereInput
  }


  /**
   * Count Type ProductionJournalCountOutputType
   */

  export type ProductionJournalCountOutputType = {
    items: number
  }

  export type ProductionJournalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ProductionJournalCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductionJournalCountOutputType without action
   */
  export type ProductionJournalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournalCountOutputType
     */
    select?: ProductionJournalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionJournalCountOutputType without action
   */
  export type ProductionJournalCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionItemWhereInput
  }


  /**
   * Count Type ProductionItemCountOutputType
   */

  export type ProductionItemCountOutputType = {
    values: number
  }

  export type ProductionItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | ProductionItemCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * ProductionItemCountOutputType without action
   */
  export type ProductionItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemCountOutputType
     */
    select?: ProductionItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionItemCountOutputType without action
   */
  export type ProductionItemCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionItemValueWhereInput
  }


  /**
   * Count Type PurchasePriceListCountOutputType
   */

  export type PurchasePriceListCountOutputType = {
    suppliers: number
    items: number
  }

  export type PurchasePriceListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suppliers?: boolean | PurchasePriceListCountOutputTypeCountSuppliersArgs
    items?: boolean | PurchasePriceListCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchasePriceListCountOutputType without action
   */
  export type PurchasePriceListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListCountOutputType
     */
    select?: PurchasePriceListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchasePriceListCountOutputType without action
   */
  export type PurchasePriceListCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceListSupplierWhereInput
  }

  /**
   * PurchasePriceListCountOutputType without action
   */
  export type PurchasePriceListCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceItemWhereInput
  }


  /**
   * Count Type SalesPriceListCountOutputType
   */

  export type SalesPriceListCountOutputType = {
    items: number
  }

  export type SalesPriceListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SalesPriceListCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SalesPriceListCountOutputType without action
   */
  export type SalesPriceListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceListCountOutputType
     */
    select?: SalesPriceListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesPriceListCountOutputType without action
   */
  export type SalesPriceListCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesPriceItemWhereInput
  }


  /**
   * Count Type ProductionMmlCountOutputType
   */

  export type ProductionMmlCountOutputType = {
    nodes: number
    runs: number
    suppliersWithPrimaryMml: number
    priceListSuppliers: number
  }

  export type ProductionMmlCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | ProductionMmlCountOutputTypeCountNodesArgs
    runs?: boolean | ProductionMmlCountOutputTypeCountRunsArgs
    suppliersWithPrimaryMml?: boolean | ProductionMmlCountOutputTypeCountSuppliersWithPrimaryMmlArgs
    priceListSuppliers?: boolean | ProductionMmlCountOutputTypeCountPriceListSuppliersArgs
  }

  // Custom InputTypes
  /**
   * ProductionMmlCountOutputType without action
   */
  export type ProductionMmlCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlCountOutputType
     */
    select?: ProductionMmlCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionMmlCountOutputType without action
   */
  export type ProductionMmlCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlNodeWhereInput
  }

  /**
   * ProductionMmlCountOutputType without action
   */
  export type ProductionMmlCountOutputTypeCountRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunWhereInput
  }

  /**
   * ProductionMmlCountOutputType without action
   */
  export type ProductionMmlCountOutputTypeCountSuppliersWithPrimaryMmlArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * ProductionMmlCountOutputType without action
   */
  export type ProductionMmlCountOutputTypeCountPriceListSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceListSupplierWhereInput
  }


  /**
   * Count Type ProductionMmlNodeCountOutputType
   */

  export type ProductionMmlNodeCountOutputType = {
    children: number
    runValues: number
  }

  export type ProductionMmlNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ProductionMmlNodeCountOutputTypeCountChildrenArgs
    runValues?: boolean | ProductionMmlNodeCountOutputTypeCountRunValuesArgs
  }

  // Custom InputTypes
  /**
   * ProductionMmlNodeCountOutputType without action
   */
  export type ProductionMmlNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNodeCountOutputType
     */
    select?: ProductionMmlNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionMmlNodeCountOutputType without action
   */
  export type ProductionMmlNodeCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlNodeWhereInput
  }

  /**
   * ProductionMmlNodeCountOutputType without action
   */
  export type ProductionMmlNodeCountOutputTypeCountRunValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunValueWhereInput
  }


  /**
   * Count Type ProductionRunCountOutputType
   */

  export type ProductionRunCountOutputType = {
    values: number
  }

  export type ProductionRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | ProductionRunCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * ProductionRunCountOutputType without action
   */
  export type ProductionRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunCountOutputType
     */
    select?: ProductionRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionRunCountOutputType without action
   */
  export type ProductionRunCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunValueWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    name: string | null
    role: string | null
    telegramId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    name: string | null
    role: string | null
    telegramId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    name: number
    role: number
    telegramId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    role?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    role?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    role?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    name: string
    role: string
    telegramId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productionStaff?: boolean | User$productionStaffArgs<ExtArgs>
    createdMmls?: boolean | User$createdMmlsArgs<ExtArgs>
    productionRuns?: boolean | User$productionRunsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "name" | "role" | "telegramId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionStaff?: boolean | User$productionStaffArgs<ExtArgs>
    createdMmls?: boolean | User$createdMmlsArgs<ExtArgs>
    productionRuns?: boolean | User$productionRunsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      productionStaff: Prisma.$ProductionStaffPayload<ExtArgs> | null
      createdMmls: Prisma.$ProductionMmlPayload<ExtArgs>[]
      productionRuns: Prisma.$ProductionRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      name: string
      role: string
      telegramId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionStaff<T extends User$productionStaffArgs<ExtArgs> = {}>(args?: Subset<T, User$productionStaffArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdMmls<T extends User$createdMmlsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdMmlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionRuns<T extends User$productionRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$productionRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly telegramId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.productionStaff
   */
  export type User$productionStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    where?: ProductionStaffWhereInput
  }

  /**
   * User.createdMmls
   */
  export type User$createdMmlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    where?: ProductionMmlWhereInput
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    cursor?: ProductionMmlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionMmlScalarFieldEnum | ProductionMmlScalarFieldEnum[]
  }

  /**
   * User.productionRuns
   */
  export type User$productionRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    where?: ProductionRunWhereInput
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    cursor?: ProductionRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model District
   */

  export type AggregateDistrict = {
    _count: DistrictCountAggregateOutputType | null
    _avg: DistrictAvgAggregateOutputType | null
    _sum: DistrictSumAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  export type DistrictAvgAggregateOutputType = {
    id: number | null
  }

  export type DistrictSumAggregateOutputType = {
    id: number | null
  }

  export type DistrictMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
  }

  export type DistrictMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
  }

  export type DistrictCountAggregateOutputType = {
    id: number
    code: number
    name: number
    _all: number
  }


  export type DistrictAvgAggregateInputType = {
    id?: true
  }

  export type DistrictSumAggregateInputType = {
    id?: true
  }

  export type DistrictMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type DistrictMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type DistrictCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    _all?: true
  }

  export type DistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which District to aggregate.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Districts
    **/
    _count?: true | DistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DistrictAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DistrictSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistrictMaxAggregateInputType
  }

  export type GetDistrictAggregateType<T extends DistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistrict[P]>
      : GetScalarType<T[P], AggregateDistrict[P]>
  }




  export type DistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistrictWhereInput
    orderBy?: DistrictOrderByWithAggregationInput | DistrictOrderByWithAggregationInput[]
    by: DistrictScalarFieldEnum[] | DistrictScalarFieldEnum
    having?: DistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistrictCountAggregateInputType | true
    _avg?: DistrictAvgAggregateInputType
    _sum?: DistrictSumAggregateInputType
    _min?: DistrictMinAggregateInputType
    _max?: DistrictMaxAggregateInputType
  }

  export type DistrictGroupByOutputType = {
    id: number
    code: string
    name: string
    _count: DistrictCountAggregateOutputType | null
    _avg: DistrictAvgAggregateOutputType | null
    _sum: DistrictSumAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  type GetDistrictGroupByPayload<T extends DistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistrictGroupByOutputType[P]>
            : GetScalarType<T[P], DistrictGroupByOutputType[P]>
        }
      >
    >


  export type DistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    customers?: boolean | District$customersArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
  }

  export type DistrictOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name", ExtArgs["result"]["district"]>
  export type DistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | District$customersArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DistrictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DistrictIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "District"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
    }, ExtArgs["result"]["district"]>
    composites: {}
  }

  type DistrictGetPayload<S extends boolean | null | undefined | DistrictDefaultArgs> = $Result.GetResult<Prisma.$DistrictPayload, S>

  type DistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DistrictFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DistrictCountAggregateInputType | true
    }

  export interface DistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['District'], meta: { name: 'District' } }
    /**
     * Find zero or one District that matches the filter.
     * @param {DistrictFindUniqueArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistrictFindUniqueArgs>(args: SelectSubset<T, DistrictFindUniqueArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one District that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DistrictFindUniqueOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistrictFindUniqueOrThrowArgs>(args: SelectSubset<T, DistrictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first District that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistrictFindFirstArgs>(args?: SelectSubset<T, DistrictFindFirstArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first District that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistrictFindFirstOrThrowArgs>(args?: SelectSubset<T, DistrictFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Districts
     * const districts = await prisma.district.findMany()
     * 
     * // Get first 10 Districts
     * const districts = await prisma.district.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const districtWithIdOnly = await prisma.district.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistrictFindManyArgs>(args?: SelectSubset<T, DistrictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a District.
     * @param {DistrictCreateArgs} args - Arguments to create a District.
     * @example
     * // Create one District
     * const District = await prisma.district.create({
     *   data: {
     *     // ... data to create a District
     *   }
     * })
     * 
     */
    create<T extends DistrictCreateArgs>(args: SelectSubset<T, DistrictCreateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Districts.
     * @param {DistrictCreateManyArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistrictCreateManyArgs>(args?: SelectSubset<T, DistrictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Districts and returns the data saved in the database.
     * @param {DistrictCreateManyAndReturnArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Districts and only return the `id`
     * const districtWithIdOnly = await prisma.district.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistrictCreateManyAndReturnArgs>(args?: SelectSubset<T, DistrictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a District.
     * @param {DistrictDeleteArgs} args - Arguments to delete one District.
     * @example
     * // Delete one District
     * const District = await prisma.district.delete({
     *   where: {
     *     // ... filter to delete one District
     *   }
     * })
     * 
     */
    delete<T extends DistrictDeleteArgs>(args: SelectSubset<T, DistrictDeleteArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one District.
     * @param {DistrictUpdateArgs} args - Arguments to update one District.
     * @example
     * // Update one District
     * const district = await prisma.district.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistrictUpdateArgs>(args: SelectSubset<T, DistrictUpdateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Districts.
     * @param {DistrictDeleteManyArgs} args - Arguments to filter Districts to delete.
     * @example
     * // Delete a few Districts
     * const { count } = await prisma.district.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistrictDeleteManyArgs>(args?: SelectSubset<T, DistrictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Districts
     * const district = await prisma.district.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistrictUpdateManyArgs>(args: SelectSubset<T, DistrictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts and returns the data updated in the database.
     * @param {DistrictUpdateManyAndReturnArgs} args - Arguments to update many Districts.
     * @example
     * // Update many Districts
     * const district = await prisma.district.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Districts and only return the `id`
     * const districtWithIdOnly = await prisma.district.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DistrictUpdateManyAndReturnArgs>(args: SelectSubset<T, DistrictUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one District.
     * @param {DistrictUpsertArgs} args - Arguments to update or create a District.
     * @example
     * // Update or create a District
     * const district = await prisma.district.upsert({
     *   create: {
     *     // ... data to create a District
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the District we want to update
     *   }
     * })
     */
    upsert<T extends DistrictUpsertArgs>(args: SelectSubset<T, DistrictUpsertArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictCountArgs} args - Arguments to filter Districts to count.
     * @example
     * // Count the number of Districts
     * const count = await prisma.district.count({
     *   where: {
     *     // ... the filter for the Districts we want to count
     *   }
     * })
    **/
    count<T extends DistrictCountArgs>(
      args?: Subset<T, DistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistrictAggregateArgs>(args: Subset<T, DistrictAggregateArgs>): Prisma.PrismaPromise<GetDistrictAggregateType<T>>

    /**
     * Group by District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistrictGroupByArgs['orderBy'] }
        : { orderBy?: DistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the District model
   */
  readonly fields: DistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for District.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends District$customersArgs<ExtArgs> = {}>(args?: Subset<T, District$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the District model
   */
  interface DistrictFieldRefs {
    readonly id: FieldRef<"District", 'Int'>
    readonly code: FieldRef<"District", 'String'>
    readonly name: FieldRef<"District", 'String'>
  }
    

  // Custom InputTypes
  /**
   * District findUnique
   */
  export type DistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findUniqueOrThrow
   */
  export type DistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findFirst
   */
  export type DistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findFirstOrThrow
   */
  export type DistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findMany
   */
  export type DistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which Districts to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District create
   */
  export type DistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a District.
     */
    data: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
  }

  /**
   * District createMany
   */
  export type DistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * District createManyAndReturn
   */
  export type DistrictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * District update
   */
  export type DistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a District.
     */
    data: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
    /**
     * Choose, which District to update.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District updateMany
   */
  export type DistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Districts.
     */
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyInput>
    /**
     * Filter which Districts to update
     */
    where?: DistrictWhereInput
    /**
     * Limit how many Districts to update.
     */
    limit?: number
  }

  /**
   * District updateManyAndReturn
   */
  export type DistrictUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * The data used to update Districts.
     */
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyInput>
    /**
     * Filter which Districts to update
     */
    where?: DistrictWhereInput
    /**
     * Limit how many Districts to update.
     */
    limit?: number
  }

  /**
   * District upsert
   */
  export type DistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the District to update in case it exists.
     */
    where: DistrictWhereUniqueInput
    /**
     * In case the District found by the `where` argument doesn't exist, create a new District with this data.
     */
    create: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
    /**
     * In case the District was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
  }

  /**
   * District delete
   */
  export type DistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter which District to delete.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District deleteMany
   */
  export type DistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Districts to delete
     */
    where?: DistrictWhereInput
    /**
     * Limit how many Districts to delete.
     */
    limit?: number
  }

  /**
   * District.customers
   */
  export type District$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * District without action
   */
  export type DistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
  }


  /**
   * Model Manager
   */

  export type AggregateManager = {
    _count: ManagerCountAggregateOutputType | null
    _avg: ManagerAvgAggregateOutputType | null
    _sum: ManagerSumAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerAvgAggregateOutputType = {
    id: number | null
  }

  export type ManagerSumAggregateOutputType = {
    id: number | null
  }

  export type ManagerMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    phone: string | null
  }

  export type ManagerMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    phone: string | null
  }

  export type ManagerCountAggregateOutputType = {
    id: number
    code: number
    name: number
    phone: number
    _all: number
  }


  export type ManagerAvgAggregateInputType = {
    id?: true
  }

  export type ManagerSumAggregateInputType = {
    id?: true
  }

  export type ManagerMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    phone?: true
  }

  export type ManagerMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    phone?: true
  }

  export type ManagerCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    phone?: true
    _all?: true
  }

  export type ManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manager to aggregate.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    _count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }




  export type ManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithAggregationInput | ManagerOrderByWithAggregationInput[]
    by: ManagerScalarFieldEnum[] | ManagerScalarFieldEnum
    having?: ManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCountAggregateInputType | true
    _avg?: ManagerAvgAggregateInputType
    _sum?: ManagerSumAggregateInputType
    _min?: ManagerMinAggregateInputType
    _max?: ManagerMaxAggregateInputType
  }

  export type ManagerGroupByOutputType = {
    id: number
    code: string
    name: string
    phone: string | null
    _count: ManagerCountAggregateOutputType | null
    _avg: ManagerAvgAggregateOutputType | null
    _sum: ManagerSumAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  type GetManagerGroupByPayload<T extends ManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerGroupByOutputType[P]>
        }
      >
    >


  export type ManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    phone?: boolean
    customers?: boolean | Manager$customersArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    phone?: boolean
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    phone?: boolean
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    phone?: boolean
  }

  export type ManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "phone", ExtArgs["result"]["manager"]>
  export type ManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | Manager$customersArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Manager"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      phone: string | null
    }, ExtArgs["result"]["manager"]>
    composites: {}
  }

  type ManagerGetPayload<S extends boolean | null | undefined | ManagerDefaultArgs> = $Result.GetResult<Prisma.$ManagerPayload, S>

  type ManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManagerCountAggregateInputType | true
    }

  export interface ManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manager'], meta: { name: 'Manager' } }
    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManagerFindUniqueArgs>(args: SelectSubset<T, ManagerFindUniqueArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManagerFindUniqueOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, ManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManagerFindFirstArgs>(args?: SelectSubset<T, ManagerFindFirstArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, ManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerWithIdOnly = await prisma.manager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManagerFindManyArgs>(args?: SelectSubset<T, ManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
     */
    create<T extends ManagerCreateArgs>(args: SelectSubset<T, ManagerCreateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Managers.
     * @param {ManagerCreateManyArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManagerCreateManyArgs>(args?: SelectSubset<T, ManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Managers and returns the data saved in the database.
     * @param {ManagerCreateManyAndReturnArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Managers and only return the `id`
     * const managerWithIdOnly = await prisma.manager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, ManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
     */
    delete<T extends ManagerDeleteArgs>(args: SelectSubset<T, ManagerDeleteArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManagerUpdateArgs>(args: SelectSubset<T, ManagerUpdateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManagerDeleteManyArgs>(args?: SelectSubset<T, ManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManagerUpdateManyArgs>(args: SelectSubset<T, ManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers and returns the data updated in the database.
     * @param {ManagerUpdateManyAndReturnArgs} args - Arguments to update many Managers.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Managers and only return the `id`
     * const managerWithIdOnly = await prisma.manager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, ManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
     */
    upsert<T extends ManagerUpsertArgs>(args: SelectSubset<T, ManagerUpsertArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Prisma.PrismaPromise<GetManagerAggregateType<T>>

    /**
     * Group by Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerGroupByArgs['orderBy'] }
        : { orderBy?: ManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manager model
   */
  readonly fields: ManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends Manager$customersArgs<ExtArgs> = {}>(args?: Subset<T, Manager$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Manager model
   */
  interface ManagerFieldRefs {
    readonly id: FieldRef<"Manager", 'Int'>
    readonly code: FieldRef<"Manager", 'String'>
    readonly name: FieldRef<"Manager", 'String'>
    readonly phone: FieldRef<"Manager", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Manager findUnique
   */
  export type ManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findUniqueOrThrow
   */
  export type ManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findFirst
   */
  export type ManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findFirstOrThrow
   */
  export type ManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Managers to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager create
   */
  export type ManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manager.
     */
    data: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
  }

  /**
   * Manager createMany
   */
  export type ManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manager createManyAndReturn
   */
  export type ManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manager update
   */
  export type ManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manager.
     */
    data: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
    /**
     * Choose, which Manager to update.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to update.
     */
    limit?: number
  }

  /**
   * Manager updateManyAndReturn
   */
  export type ManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to update.
     */
    limit?: number
  }

  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manager to update in case it exists.
     */
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
     */
    create: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
  }

  /**
   * Manager delete
   */
  export type ManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter which Manager to delete.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Managers to delete
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to delete.
     */
    limit?: number
  }

  /**
   * Manager.customers
   */
  export type Manager$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Manager without action
   */
  export type ManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    coefficient: number | null
    lossNorm: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    coefficient: number | null
    lossNorm: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    altName: string | null
    priceListName: string | null
    category: string | null
    status: string | null
    coefficient: number | null
    lossNorm: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    altName: string | null
    priceListName: string | null
    category: string | null
    status: string | null
    coefficient: number | null
    lossNorm: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    code: number
    name: number
    altName: number
    priceListName: number
    category: number
    status: number
    coefficient: number
    lossNorm: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    coefficient?: true
    lossNorm?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    coefficient?: true
    lossNorm?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    altName?: true
    priceListName?: true
    category?: true
    status?: true
    coefficient?: true
    lossNorm?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    altName?: true
    priceListName?: true
    category?: true
    status?: true
    coefficient?: true
    lossNorm?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    altName?: true
    priceListName?: true
    category?: true
    status?: true
    coefficient?: true
    lossNorm?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    code: string
    name: string
    altName: string | null
    priceListName: string | null
    category: string | null
    status: string
    coefficient: number
    lossNorm: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    altName?: boolean
    priceListName?: boolean
    category?: boolean
    status?: boolean
    coefficient?: boolean
    lossNorm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    stock?: boolean | Product$stockArgs<ExtArgs>
    stockTransactions?: boolean | Product$stockTransactionsArgs<ExtArgs>
    suppliers?: boolean | Product$suppliersArgs<ExtArgs>
    summaryJournalEntries?: boolean | Product$summaryJournalEntriesArgs<ExtArgs>
    productionItems?: boolean | Product$productionItemsArgs<ExtArgs>
    purchasePriceItems?: boolean | Product$purchasePriceItemsArgs<ExtArgs>
    salesPriceItems?: boolean | Product$salesPriceItemsArgs<ExtArgs>
    productionMmls?: boolean | Product$productionMmlsArgs<ExtArgs>
    mmlNodes?: boolean | Product$mmlNodesArgs<ExtArgs>
    productionRuns?: boolean | Product$productionRunsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    altName?: boolean
    priceListName?: boolean
    category?: boolean
    status?: boolean
    coefficient?: boolean
    lossNorm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    altName?: boolean
    priceListName?: boolean
    category?: boolean
    status?: boolean
    coefficient?: boolean
    lossNorm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    altName?: boolean
    priceListName?: boolean
    category?: boolean
    status?: boolean
    coefficient?: boolean
    lossNorm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "altName" | "priceListName" | "category" | "status" | "coefficient" | "lossNorm" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    stock?: boolean | Product$stockArgs<ExtArgs>
    stockTransactions?: boolean | Product$stockTransactionsArgs<ExtArgs>
    suppliers?: boolean | Product$suppliersArgs<ExtArgs>
    summaryJournalEntries?: boolean | Product$summaryJournalEntriesArgs<ExtArgs>
    productionItems?: boolean | Product$productionItemsArgs<ExtArgs>
    purchasePriceItems?: boolean | Product$purchasePriceItemsArgs<ExtArgs>
    salesPriceItems?: boolean | Product$salesPriceItemsArgs<ExtArgs>
    productionMmls?: boolean | Product$productionMmlsArgs<ExtArgs>
    mmlNodes?: boolean | Product$mmlNodesArgs<ExtArgs>
    productionRuns?: boolean | Product$productionRunsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      stock: Prisma.$StockPayload<ExtArgs> | null
      stockTransactions: Prisma.$StockTransactionPayload<ExtArgs>[]
      suppliers: Prisma.$SupplierProductPayload<ExtArgs>[]
      summaryJournalEntries: Prisma.$SummaryOrderJournalPayload<ExtArgs>[]
      productionItems: Prisma.$ProductionItemPayload<ExtArgs>[]
      purchasePriceItems: Prisma.$PurchasePriceItemPayload<ExtArgs>[]
      salesPriceItems: Prisma.$SalesPriceItemPayload<ExtArgs>[]
      productionMmls: Prisma.$ProductionMmlPayload<ExtArgs>[]
      mmlNodes: Prisma.$ProductionMmlNodePayload<ExtArgs>[]
      productionRuns: Prisma.$ProductionRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      altName: string | null
      priceListName: string | null
      category: string | null
      status: string
      coefficient: number
      lossNorm: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stock<T extends Product$stockArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stockTransactions<T extends Product$stockTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suppliers<T extends Product$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Product$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    summaryJournalEntries<T extends Product$summaryJournalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$summaryJournalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionItems<T extends Product$productionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchasePriceItems<T extends Product$purchasePriceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchasePriceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesPriceItems<T extends Product$salesPriceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$salesPriceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionMmls<T extends Product$productionMmlsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productionMmlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mmlNodes<T extends Product$mmlNodesArgs<ExtArgs> = {}>(args?: Subset<T, Product$mmlNodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionRuns<T extends Product$productionRunsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productionRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly code: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly altName: FieldRef<"Product", 'String'>
    readonly priceListName: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly status: FieldRef<"Product", 'String'>
    readonly coefficient: FieldRef<"Product", 'Float'>
    readonly lossNorm: FieldRef<"Product", 'Float'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.stock
   */
  export type Product$stockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
  }

  /**
   * Product.stockTransactions
   */
  export type Product$stockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    where?: StockTransactionWhereInput
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    cursor?: StockTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * Product.suppliers
   */
  export type Product$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    where?: SupplierProductWhereInput
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    cursor?: SupplierProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * Product.summaryJournalEntries
   */
  export type Product$summaryJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    where?: SummaryOrderJournalWhereInput
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    cursor?: SummaryOrderJournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SummaryOrderJournalScalarFieldEnum | SummaryOrderJournalScalarFieldEnum[]
  }

  /**
   * Product.productionItems
   */
  export type Product$productionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    where?: ProductionItemWhereInput
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    cursor?: ProductionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionItemScalarFieldEnum | ProductionItemScalarFieldEnum[]
  }

  /**
   * Product.purchasePriceItems
   */
  export type Product$purchasePriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    where?: PurchasePriceItemWhereInput
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    cursor?: PurchasePriceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * Product.salesPriceItems
   */
  export type Product$salesPriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    where?: SalesPriceItemWhereInput
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    cursor?: SalesPriceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesPriceItemScalarFieldEnum | SalesPriceItemScalarFieldEnum[]
  }

  /**
   * Product.productionMmls
   */
  export type Product$productionMmlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    where?: ProductionMmlWhereInput
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    cursor?: ProductionMmlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionMmlScalarFieldEnum | ProductionMmlScalarFieldEnum[]
  }

  /**
   * Product.mmlNodes
   */
  export type Product$mmlNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    where?: ProductionMmlNodeWhereInput
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    cursor?: ProductionMmlNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * Product.productionRuns
   */
  export type Product$productionRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    where?: ProductionRunWhereInput
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    cursor?: ProductionRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    legalName: string | null
    districtId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    legalName: string | null
    districtId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    code: number
    name: number
    legalName: number
    districtId: number
    managerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    districtId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    districtId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    districtId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    code: string
    name: string
    legalName: string | null
    districtId: string | null
    managerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    districtId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    summaryJournalEntries?: boolean | Customer$summaryJournalEntriesArgs<ExtArgs>
    salesPriceLists?: boolean | Customer$salesPriceListsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    districtId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    districtId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    districtId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "legalName" | "districtId" | "managerId" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    summaryJournalEntries?: boolean | Customer$summaryJournalEntriesArgs<ExtArgs>
    salesPriceLists?: boolean | Customer$salesPriceListsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      district: Prisma.$DistrictPayload<ExtArgs> | null
      manager: Prisma.$ManagerPayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
      summaryJournalEntries: Prisma.$SummaryOrderJournalPayload<ExtArgs>[]
      salesPriceLists: Prisma.$SalesPriceListPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      legalName: string | null
      districtId: string | null
      managerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    district<T extends Customer$districtArgs<ExtArgs> = {}>(args?: Subset<T, Customer$districtArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    manager<T extends Customer$managerArgs<ExtArgs> = {}>(args?: Subset<T, Customer$managerArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    summaryJournalEntries<T extends Customer$summaryJournalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$summaryJournalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesPriceLists<T extends Customer$salesPriceListsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesPriceListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly code: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly legalName: FieldRef<"Customer", 'String'>
    readonly districtId: FieldRef<"Customer", 'String'>
    readonly managerId: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.district
   */
  export type Customer$districtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    where?: DistrictWhereInput
  }

  /**
   * Customer.manager
   */
  export type Customer$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.summaryJournalEntries
   */
  export type Customer$summaryJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    where?: SummaryOrderJournalWhereInput
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    cursor?: SummaryOrderJournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SummaryOrderJournalScalarFieldEnum | SummaryOrderJournalScalarFieldEnum[]
  }

  /**
   * Customer.salesPriceLists
   */
  export type Customer$salesPriceListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    where?: SalesPriceListWhereInput
    orderBy?: SalesPriceListOrderByWithRelationInput | SalesPriceListOrderByWithRelationInput[]
    cursor?: SalesPriceListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesPriceListScalarFieldEnum | SalesPriceListScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
    primaryMmlId: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
    primaryMmlId: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    legalName: string | null
    altName: string | null
    phone: string | null
    telegram: string | null
    isActive: boolean | null
    primaryMmlId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    legalName: string | null
    altName: string | null
    phone: string | null
    telegram: string | null
    isActive: boolean | null
    primaryMmlId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    code: number
    name: number
    legalName: number
    altName: number
    phone: number
    telegram: number
    isActive: number
    primaryMmlId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
    primaryMmlId?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
    primaryMmlId?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    altName?: true
    phone?: true
    telegram?: true
    isActive?: true
    primaryMmlId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    altName?: true
    phone?: true
    telegram?: true
    isActive?: true
    primaryMmlId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    altName?: true
    phone?: true
    telegram?: true
    isActive?: true
    primaryMmlId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    code: string
    name: string
    legalName: string | null
    altName: string | null
    phone: string | null
    telegram: string | null
    isActive: boolean
    primaryMmlId: number | null
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    altName?: boolean
    phone?: boolean
    telegram?: boolean
    isActive?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
    products?: boolean | Supplier$productsArgs<ExtArgs>
    purchasePriceListSuppliers?: boolean | Supplier$purchasePriceListSuppliersArgs<ExtArgs>
    purchasePriceItems?: boolean | Supplier$purchasePriceItemsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    altName?: boolean
    phone?: boolean
    telegram?: boolean
    isActive?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    altName?: boolean
    phone?: boolean
    telegram?: boolean
    isActive?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    altName?: boolean
    phone?: boolean
    telegram?: boolean
    isActive?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "legalName" | "altName" | "phone" | "telegram" | "isActive" | "primaryMmlId" | "createdAt" | "updatedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
    products?: boolean | Supplier$productsArgs<ExtArgs>
    purchasePriceListSuppliers?: boolean | Supplier$purchasePriceListSuppliersArgs<ExtArgs>
    purchasePriceItems?: boolean | Supplier$purchasePriceItemsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
  }
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      primaryMml: Prisma.$ProductionMmlPayload<ExtArgs> | null
      products: Prisma.$SupplierProductPayload<ExtArgs>[]
      purchasePriceListSuppliers: Prisma.$PurchasePriceListSupplierPayload<ExtArgs>[]
      purchasePriceItems: Prisma.$PurchasePriceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      legalName: string | null
      altName: string | null
      phone: string | null
      telegram: string | null
      isActive: boolean
      primaryMmlId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    primaryMml<T extends Supplier$primaryMmlArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$primaryMmlArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends Supplier$productsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchasePriceListSuppliers<T extends Supplier$purchasePriceListSuppliersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchasePriceListSuppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchasePriceItems<T extends Supplier$purchasePriceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchasePriceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'Int'>
    readonly code: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly legalName: FieldRef<"Supplier", 'String'>
    readonly altName: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly telegram: FieldRef<"Supplier", 'String'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly primaryMmlId: FieldRef<"Supplier", 'Int'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.primaryMml
   */
  export type Supplier$primaryMmlArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    where?: ProductionMmlWhereInput
  }

  /**
   * Supplier.products
   */
  export type Supplier$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    where?: SupplierProductWhereInput
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    cursor?: SupplierProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * Supplier.purchasePriceListSuppliers
   */
  export type Supplier$purchasePriceListSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    where?: PurchasePriceListSupplierWhereInput
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * Supplier.purchasePriceItems
   */
  export type Supplier$purchasePriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    where?: PurchasePriceItemWhereInput
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    cursor?: PurchasePriceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model SupplierProduct
   */

  export type AggregateSupplierProduct = {
    _count: SupplierProductCountAggregateOutputType | null
    _avg: SupplierProductAvgAggregateOutputType | null
    _sum: SupplierProductSumAggregateOutputType | null
    _min: SupplierProductMinAggregateOutputType | null
    _max: SupplierProductMaxAggregateOutputType | null
  }

  export type SupplierProductAvgAggregateOutputType = {
    supplierId: number | null
    productId: number | null
  }

  export type SupplierProductSumAggregateOutputType = {
    supplierId: number | null
    productId: number | null
  }

  export type SupplierProductMinAggregateOutputType = {
    supplierId: number | null
    productId: number | null
  }

  export type SupplierProductMaxAggregateOutputType = {
    supplierId: number | null
    productId: number | null
  }

  export type SupplierProductCountAggregateOutputType = {
    supplierId: number
    productId: number
    _all: number
  }


  export type SupplierProductAvgAggregateInputType = {
    supplierId?: true
    productId?: true
  }

  export type SupplierProductSumAggregateInputType = {
    supplierId?: true
    productId?: true
  }

  export type SupplierProductMinAggregateInputType = {
    supplierId?: true
    productId?: true
  }

  export type SupplierProductMaxAggregateInputType = {
    supplierId?: true
    productId?: true
  }

  export type SupplierProductCountAggregateInputType = {
    supplierId?: true
    productId?: true
    _all?: true
  }

  export type SupplierProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierProduct to aggregate.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierProducts
    **/
    _count?: true | SupplierProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierProductMaxAggregateInputType
  }

  export type GetSupplierProductAggregateType<T extends SupplierProductAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierProduct[P]>
      : GetScalarType<T[P], AggregateSupplierProduct[P]>
  }




  export type SupplierProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierProductWhereInput
    orderBy?: SupplierProductOrderByWithAggregationInput | SupplierProductOrderByWithAggregationInput[]
    by: SupplierProductScalarFieldEnum[] | SupplierProductScalarFieldEnum
    having?: SupplierProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierProductCountAggregateInputType | true
    _avg?: SupplierProductAvgAggregateInputType
    _sum?: SupplierProductSumAggregateInputType
    _min?: SupplierProductMinAggregateInputType
    _max?: SupplierProductMaxAggregateInputType
  }

  export type SupplierProductGroupByOutputType = {
    supplierId: number
    productId: number
    _count: SupplierProductCountAggregateOutputType | null
    _avg: SupplierProductAvgAggregateOutputType | null
    _sum: SupplierProductSumAggregateOutputType | null
    _min: SupplierProductMinAggregateOutputType | null
    _max: SupplierProductMaxAggregateOutputType | null
  }

  type GetSupplierProductGroupByPayload<T extends SupplierProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierProductGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierProductGroupByOutputType[P]>
        }
      >
    >


  export type SupplierProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplierId?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierProduct"]>

  export type SupplierProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplierId?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierProduct"]>

  export type SupplierProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplierId?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierProduct"]>

  export type SupplierProductSelectScalar = {
    supplierId?: boolean
    productId?: boolean
  }

  export type SupplierProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"supplierId" | "productId", ExtArgs["result"]["supplierProduct"]>
  export type SupplierProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $SupplierProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierProduct"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      supplierId: number
      productId: number
    }, ExtArgs["result"]["supplierProduct"]>
    composites: {}
  }

  type SupplierProductGetPayload<S extends boolean | null | undefined | SupplierProductDefaultArgs> = $Result.GetResult<Prisma.$SupplierProductPayload, S>

  type SupplierProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierProductCountAggregateInputType | true
    }

  export interface SupplierProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierProduct'], meta: { name: 'SupplierProduct' } }
    /**
     * Find zero or one SupplierProduct that matches the filter.
     * @param {SupplierProductFindUniqueArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierProductFindUniqueArgs>(args: SelectSubset<T, SupplierProductFindUniqueArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierProductFindUniqueOrThrowArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierProductFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductFindFirstArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierProductFindFirstArgs>(args?: SelectSubset<T, SupplierProductFindFirstArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductFindFirstOrThrowArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierProductFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierProducts
     * const supplierProducts = await prisma.supplierProduct.findMany()
     * 
     * // Get first 10 SupplierProducts
     * const supplierProducts = await prisma.supplierProduct.findMany({ take: 10 })
     * 
     * // Only select the `supplierId`
     * const supplierProductWithSupplierIdOnly = await prisma.supplierProduct.findMany({ select: { supplierId: true } })
     * 
     */
    findMany<T extends SupplierProductFindManyArgs>(args?: SelectSubset<T, SupplierProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierProduct.
     * @param {SupplierProductCreateArgs} args - Arguments to create a SupplierProduct.
     * @example
     * // Create one SupplierProduct
     * const SupplierProduct = await prisma.supplierProduct.create({
     *   data: {
     *     // ... data to create a SupplierProduct
     *   }
     * })
     * 
     */
    create<T extends SupplierProductCreateArgs>(args: SelectSubset<T, SupplierProductCreateArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierProducts.
     * @param {SupplierProductCreateManyArgs} args - Arguments to create many SupplierProducts.
     * @example
     * // Create many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierProductCreateManyArgs>(args?: SelectSubset<T, SupplierProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierProducts and returns the data saved in the database.
     * @param {SupplierProductCreateManyAndReturnArgs} args - Arguments to create many SupplierProducts.
     * @example
     * // Create many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierProducts and only return the `supplierId`
     * const supplierProductWithSupplierIdOnly = await prisma.supplierProduct.createManyAndReturn({
     *   select: { supplierId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierProductCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierProduct.
     * @param {SupplierProductDeleteArgs} args - Arguments to delete one SupplierProduct.
     * @example
     * // Delete one SupplierProduct
     * const SupplierProduct = await prisma.supplierProduct.delete({
     *   where: {
     *     // ... filter to delete one SupplierProduct
     *   }
     * })
     * 
     */
    delete<T extends SupplierProductDeleteArgs>(args: SelectSubset<T, SupplierProductDeleteArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierProduct.
     * @param {SupplierProductUpdateArgs} args - Arguments to update one SupplierProduct.
     * @example
     * // Update one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierProductUpdateArgs>(args: SelectSubset<T, SupplierProductUpdateArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierProducts.
     * @param {SupplierProductDeleteManyArgs} args - Arguments to filter SupplierProducts to delete.
     * @example
     * // Delete a few SupplierProducts
     * const { count } = await prisma.supplierProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierProductDeleteManyArgs>(args?: SelectSubset<T, SupplierProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierProductUpdateManyArgs>(args: SelectSubset<T, SupplierProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierProducts and returns the data updated in the database.
     * @param {SupplierProductUpdateManyAndReturnArgs} args - Arguments to update many SupplierProducts.
     * @example
     * // Update many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierProducts and only return the `supplierId`
     * const supplierProductWithSupplierIdOnly = await prisma.supplierProduct.updateManyAndReturn({
     *   select: { supplierId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierProductUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierProduct.
     * @param {SupplierProductUpsertArgs} args - Arguments to update or create a SupplierProduct.
     * @example
     * // Update or create a SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.upsert({
     *   create: {
     *     // ... data to create a SupplierProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierProduct we want to update
     *   }
     * })
     */
    upsert<T extends SupplierProductUpsertArgs>(args: SelectSubset<T, SupplierProductUpsertArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductCountArgs} args - Arguments to filter SupplierProducts to count.
     * @example
     * // Count the number of SupplierProducts
     * const count = await prisma.supplierProduct.count({
     *   where: {
     *     // ... the filter for the SupplierProducts we want to count
     *   }
     * })
    **/
    count<T extends SupplierProductCountArgs>(
      args?: Subset<T, SupplierProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierProductAggregateArgs>(args: Subset<T, SupplierProductAggregateArgs>): Prisma.PrismaPromise<GetSupplierProductAggregateType<T>>

    /**
     * Group by SupplierProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierProductGroupByArgs['orderBy'] }
        : { orderBy?: SupplierProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierProduct model
   */
  readonly fields: SupplierProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierProduct model
   */
  interface SupplierProductFieldRefs {
    readonly supplierId: FieldRef<"SupplierProduct", 'Int'>
    readonly productId: FieldRef<"SupplierProduct", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SupplierProduct findUnique
   */
  export type SupplierProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct findUniqueOrThrow
   */
  export type SupplierProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct findFirst
   */
  export type SupplierProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierProducts.
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierProducts.
     */
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * SupplierProduct findFirstOrThrow
   */
  export type SupplierProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierProducts.
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierProducts.
     */
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * SupplierProduct findMany
   */
  export type SupplierProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProducts to fetch.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierProducts.
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * SupplierProduct create
   */
  export type SupplierProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierProduct.
     */
    data: XOR<SupplierProductCreateInput, SupplierProductUncheckedCreateInput>
  }

  /**
   * SupplierProduct createMany
   */
  export type SupplierProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierProducts.
     */
    data: SupplierProductCreateManyInput | SupplierProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierProduct createManyAndReturn
   */
  export type SupplierProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierProducts.
     */
    data: SupplierProductCreateManyInput | SupplierProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierProduct update
   */
  export type SupplierProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierProduct.
     */
    data: XOR<SupplierProductUpdateInput, SupplierProductUncheckedUpdateInput>
    /**
     * Choose, which SupplierProduct to update.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct updateMany
   */
  export type SupplierProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierProducts.
     */
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyInput>
    /**
     * Filter which SupplierProducts to update
     */
    where?: SupplierProductWhereInput
    /**
     * Limit how many SupplierProducts to update.
     */
    limit?: number
  }

  /**
   * SupplierProduct updateManyAndReturn
   */
  export type SupplierProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * The data used to update SupplierProducts.
     */
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyInput>
    /**
     * Filter which SupplierProducts to update
     */
    where?: SupplierProductWhereInput
    /**
     * Limit how many SupplierProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierProduct upsert
   */
  export type SupplierProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierProduct to update in case it exists.
     */
    where: SupplierProductWhereUniqueInput
    /**
     * In case the SupplierProduct found by the `where` argument doesn't exist, create a new SupplierProduct with this data.
     */
    create: XOR<SupplierProductCreateInput, SupplierProductUncheckedCreateInput>
    /**
     * In case the SupplierProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierProductUpdateInput, SupplierProductUncheckedUpdateInput>
  }

  /**
   * SupplierProduct delete
   */
  export type SupplierProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter which SupplierProduct to delete.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct deleteMany
   */
  export type SupplierProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierProducts to delete
     */
    where?: SupplierProductWhereInput
    /**
     * Limit how many SupplierProducts to delete.
     */
    limit?: number
  }

  /**
   * SupplierProduct without action
   */
  export type SupplierProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    expeditorId: number | null
    totalAmount: Decimal | null
    totalWeight: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    expeditorId: number | null
    totalAmount: Decimal | null
    totalWeight: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    idn: string | null
    date: Date | null
    status: string | null
    paymentType: string | null
    customerId: number | null
    expeditorId: number | null
    totalAmount: Decimal | null
    totalWeight: number | null
    isDisabled: boolean | null
    deliveryAddress: string | null
    assignedAt: Date | null
    deliveryStatus: string | null
    completedAt: Date | null
    signatureUrl: string | null
    signedInvoiceUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    idn: string | null
    date: Date | null
    status: string | null
    paymentType: string | null
    customerId: number | null
    expeditorId: number | null
    totalAmount: Decimal | null
    totalWeight: number | null
    isDisabled: boolean | null
    deliveryAddress: string | null
    assignedAt: Date | null
    deliveryStatus: string | null
    completedAt: Date | null
    signatureUrl: string | null
    signedInvoiceUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    idn: number
    date: number
    status: number
    paymentType: number
    customerId: number
    expeditorId: number
    totalAmount: number
    totalWeight: number
    isDisabled: number
    deliveryAddress: number
    assignedAt: number
    deliveryStatus: number
    completedAt: number
    signatureUrl: number
    signedInvoiceUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    customerId?: true
    expeditorId?: true
    totalAmount?: true
    totalWeight?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    customerId?: true
    expeditorId?: true
    totalAmount?: true
    totalWeight?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    idn?: true
    date?: true
    status?: true
    paymentType?: true
    customerId?: true
    expeditorId?: true
    totalAmount?: true
    totalWeight?: true
    isDisabled?: true
    deliveryAddress?: true
    assignedAt?: true
    deliveryStatus?: true
    completedAt?: true
    signatureUrl?: true
    signedInvoiceUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    idn?: true
    date?: true
    status?: true
    paymentType?: true
    customerId?: true
    expeditorId?: true
    totalAmount?: true
    totalWeight?: true
    isDisabled?: true
    deliveryAddress?: true
    assignedAt?: true
    deliveryStatus?: true
    completedAt?: true
    signatureUrl?: true
    signedInvoiceUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    idn?: true
    date?: true
    status?: true
    paymentType?: true
    customerId?: true
    expeditorId?: true
    totalAmount?: true
    totalWeight?: true
    isDisabled?: true
    deliveryAddress?: true
    assignedAt?: true
    deliveryStatus?: true
    completedAt?: true
    signatureUrl?: true
    signedInvoiceUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    idn: string | null
    date: Date
    status: string
    paymentType: string | null
    customerId: number
    expeditorId: number | null
    totalAmount: Decimal
    totalWeight: number
    isDisabled: boolean
    deliveryAddress: string | null
    assignedAt: Date | null
    deliveryStatus: string
    completedAt: Date | null
    signatureUrl: string | null
    signedInvoiceUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    date?: boolean
    status?: boolean
    paymentType?: boolean
    customerId?: boolean
    expeditorId?: boolean
    totalAmount?: boolean
    totalWeight?: boolean
    isDisabled?: boolean
    deliveryAddress?: boolean
    assignedAt?: boolean
    deliveryStatus?: boolean
    completedAt?: boolean
    signatureUrl?: boolean
    signedInvoiceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    stockTransactions?: boolean | Order$stockTransactionsArgs<ExtArgs>
    attachments?: boolean | Order$attachmentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    date?: boolean
    status?: boolean
    paymentType?: boolean
    customerId?: boolean
    expeditorId?: boolean
    totalAmount?: boolean
    totalWeight?: boolean
    isDisabled?: boolean
    deliveryAddress?: boolean
    assignedAt?: boolean
    deliveryStatus?: boolean
    completedAt?: boolean
    signatureUrl?: boolean
    signedInvoiceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    date?: boolean
    status?: boolean
    paymentType?: boolean
    customerId?: boolean
    expeditorId?: boolean
    totalAmount?: boolean
    totalWeight?: boolean
    isDisabled?: boolean
    deliveryAddress?: boolean
    assignedAt?: boolean
    deliveryStatus?: boolean
    completedAt?: boolean
    signatureUrl?: boolean
    signedInvoiceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    idn?: boolean
    date?: boolean
    status?: boolean
    paymentType?: boolean
    customerId?: boolean
    expeditorId?: boolean
    totalAmount?: boolean
    totalWeight?: boolean
    isDisabled?: boolean
    deliveryAddress?: boolean
    assignedAt?: boolean
    deliveryStatus?: boolean
    completedAt?: boolean
    signatureUrl?: boolean
    signedInvoiceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idn" | "date" | "status" | "paymentType" | "customerId" | "expeditorId" | "totalAmount" | "totalWeight" | "isDisabled" | "deliveryAddress" | "assignedAt" | "deliveryStatus" | "completedAt" | "signatureUrl" | "signedInvoiceUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    stockTransactions?: boolean | Order$stockTransactionsArgs<ExtArgs>
    attachments?: boolean | Order$attachmentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      expeditor: Prisma.$ExpeditorPayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      stockTransactions: Prisma.$StockTransactionPayload<ExtArgs>[]
      attachments: Prisma.$OrderAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idn: string | null
      date: Date
      status: string
      paymentType: string | null
      customerId: number
      expeditorId: number | null
      totalAmount: Prisma.Decimal
      totalWeight: number
      isDisabled: boolean
      deliveryAddress: string | null
      assignedAt: Date | null
      deliveryStatus: string
      completedAt: Date | null
      signatureUrl: string | null
      signedInvoiceUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    expeditor<T extends Order$expeditorArgs<ExtArgs> = {}>(args?: Subset<T, Order$expeditorArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockTransactions<T extends Order$stockTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Order$stockTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Order$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly idn: FieldRef<"Order", 'String'>
    readonly date: FieldRef<"Order", 'DateTime'>
    readonly status: FieldRef<"Order", 'String'>
    readonly paymentType: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'Int'>
    readonly expeditorId: FieldRef<"Order", 'Int'>
    readonly totalAmount: FieldRef<"Order", 'Decimal'>
    readonly totalWeight: FieldRef<"Order", 'Float'>
    readonly isDisabled: FieldRef<"Order", 'Boolean'>
    readonly deliveryAddress: FieldRef<"Order", 'String'>
    readonly assignedAt: FieldRef<"Order", 'DateTime'>
    readonly deliveryStatus: FieldRef<"Order", 'String'>
    readonly completedAt: FieldRef<"Order", 'DateTime'>
    readonly signatureUrl: FieldRef<"Order", 'String'>
    readonly signedInvoiceUrl: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.expeditor
   */
  export type Order$expeditorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    where?: ExpeditorWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.stockTransactions
   */
  export type Order$stockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    where?: StockTransactionWhereInput
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    cursor?: StockTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * Order.attachments
   */
  export type Order$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    where?: OrderAttachmentWhereInput
    orderBy?: OrderAttachmentOrderByWithRelationInput | OrderAttachmentOrderByWithRelationInput[]
    cursor?: OrderAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderAttachmentScalarFieldEnum | OrderAttachmentScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderAttachment
   */

  export type AggregateOrderAttachment = {
    _count: OrderAttachmentCountAggregateOutputType | null
    _avg: OrderAttachmentAvgAggregateOutputType | null
    _sum: OrderAttachmentSumAggregateOutputType | null
    _min: OrderAttachmentMinAggregateOutputType | null
    _max: OrderAttachmentMaxAggregateOutputType | null
  }

  export type OrderAttachmentAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type OrderAttachmentSumAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type OrderAttachmentMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    type: string | null
    filename: string | null
    url: string | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type OrderAttachmentMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    type: string | null
    filename: string | null
    url: string | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type OrderAttachmentCountAggregateOutputType = {
    id: number
    orderId: number
    type: number
    filename: number
    url: number
    mimeType: number
    createdAt: number
    _all: number
  }


  export type OrderAttachmentAvgAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type OrderAttachmentSumAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type OrderAttachmentMinAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    filename?: true
    url?: true
    mimeType?: true
    createdAt?: true
  }

  export type OrderAttachmentMaxAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    filename?: true
    url?: true
    mimeType?: true
    createdAt?: true
  }

  export type OrderAttachmentCountAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    filename?: true
    url?: true
    mimeType?: true
    createdAt?: true
    _all?: true
  }

  export type OrderAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderAttachment to aggregate.
     */
    where?: OrderAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAttachments to fetch.
     */
    orderBy?: OrderAttachmentOrderByWithRelationInput | OrderAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderAttachments
    **/
    _count?: true | OrderAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderAttachmentMaxAggregateInputType
  }

  export type GetOrderAttachmentAggregateType<T extends OrderAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderAttachment[P]>
      : GetScalarType<T[P], AggregateOrderAttachment[P]>
  }




  export type OrderAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderAttachmentWhereInput
    orderBy?: OrderAttachmentOrderByWithAggregationInput | OrderAttachmentOrderByWithAggregationInput[]
    by: OrderAttachmentScalarFieldEnum[] | OrderAttachmentScalarFieldEnum
    having?: OrderAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderAttachmentCountAggregateInputType | true
    _avg?: OrderAttachmentAvgAggregateInputType
    _sum?: OrderAttachmentSumAggregateInputType
    _min?: OrderAttachmentMinAggregateInputType
    _max?: OrderAttachmentMaxAggregateInputType
  }

  export type OrderAttachmentGroupByOutputType = {
    id: number
    orderId: number
    type: string
    filename: string
    url: string
    mimeType: string | null
    createdAt: Date
    _count: OrderAttachmentCountAggregateOutputType | null
    _avg: OrderAttachmentAvgAggregateOutputType | null
    _sum: OrderAttachmentSumAggregateOutputType | null
    _min: OrderAttachmentMinAggregateOutputType | null
    _max: OrderAttachmentMaxAggregateOutputType | null
  }

  type GetOrderAttachmentGroupByPayload<T extends OrderAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], OrderAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type OrderAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderAttachment"]>

  export type OrderAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderAttachment"]>

  export type OrderAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderAttachment"]>

  export type OrderAttachmentSelectScalar = {
    id?: boolean
    orderId?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
  }

  export type OrderAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "type" | "filename" | "url" | "mimeType" | "createdAt", ExtArgs["result"]["orderAttachment"]>
  export type OrderAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $OrderAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderAttachment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      type: string
      filename: string
      url: string
      mimeType: string | null
      createdAt: Date
    }, ExtArgs["result"]["orderAttachment"]>
    composites: {}
  }

  type OrderAttachmentGetPayload<S extends boolean | null | undefined | OrderAttachmentDefaultArgs> = $Result.GetResult<Prisma.$OrderAttachmentPayload, S>

  type OrderAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderAttachmentCountAggregateInputType | true
    }

  export interface OrderAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderAttachment'], meta: { name: 'OrderAttachment' } }
    /**
     * Find zero or one OrderAttachment that matches the filter.
     * @param {OrderAttachmentFindUniqueArgs} args - Arguments to find a OrderAttachment
     * @example
     * // Get one OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderAttachmentFindUniqueArgs>(args: SelectSubset<T, OrderAttachmentFindUniqueArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderAttachmentFindUniqueOrThrowArgs} args - Arguments to find a OrderAttachment
     * @example
     * // Get one OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentFindFirstArgs} args - Arguments to find a OrderAttachment
     * @example
     * // Get one OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderAttachmentFindFirstArgs>(args?: SelectSubset<T, OrderAttachmentFindFirstArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentFindFirstOrThrowArgs} args - Arguments to find a OrderAttachment
     * @example
     * // Get one OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderAttachments
     * const orderAttachments = await prisma.orderAttachment.findMany()
     * 
     * // Get first 10 OrderAttachments
     * const orderAttachments = await prisma.orderAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderAttachmentWithIdOnly = await prisma.orderAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderAttachmentFindManyArgs>(args?: SelectSubset<T, OrderAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderAttachment.
     * @param {OrderAttachmentCreateArgs} args - Arguments to create a OrderAttachment.
     * @example
     * // Create one OrderAttachment
     * const OrderAttachment = await prisma.orderAttachment.create({
     *   data: {
     *     // ... data to create a OrderAttachment
     *   }
     * })
     * 
     */
    create<T extends OrderAttachmentCreateArgs>(args: SelectSubset<T, OrderAttachmentCreateArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderAttachments.
     * @param {OrderAttachmentCreateManyArgs} args - Arguments to create many OrderAttachments.
     * @example
     * // Create many OrderAttachments
     * const orderAttachment = await prisma.orderAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderAttachmentCreateManyArgs>(args?: SelectSubset<T, OrderAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderAttachments and returns the data saved in the database.
     * @param {OrderAttachmentCreateManyAndReturnArgs} args - Arguments to create many OrderAttachments.
     * @example
     * // Create many OrderAttachments
     * const orderAttachment = await prisma.orderAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderAttachments and only return the `id`
     * const orderAttachmentWithIdOnly = await prisma.orderAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderAttachment.
     * @param {OrderAttachmentDeleteArgs} args - Arguments to delete one OrderAttachment.
     * @example
     * // Delete one OrderAttachment
     * const OrderAttachment = await prisma.orderAttachment.delete({
     *   where: {
     *     // ... filter to delete one OrderAttachment
     *   }
     * })
     * 
     */
    delete<T extends OrderAttachmentDeleteArgs>(args: SelectSubset<T, OrderAttachmentDeleteArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderAttachment.
     * @param {OrderAttachmentUpdateArgs} args - Arguments to update one OrderAttachment.
     * @example
     * // Update one OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderAttachmentUpdateArgs>(args: SelectSubset<T, OrderAttachmentUpdateArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderAttachments.
     * @param {OrderAttachmentDeleteManyArgs} args - Arguments to filter OrderAttachments to delete.
     * @example
     * // Delete a few OrderAttachments
     * const { count } = await prisma.orderAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderAttachmentDeleteManyArgs>(args?: SelectSubset<T, OrderAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderAttachments
     * const orderAttachment = await prisma.orderAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderAttachmentUpdateManyArgs>(args: SelectSubset<T, OrderAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderAttachments and returns the data updated in the database.
     * @param {OrderAttachmentUpdateManyAndReturnArgs} args - Arguments to update many OrderAttachments.
     * @example
     * // Update many OrderAttachments
     * const orderAttachment = await prisma.orderAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderAttachments and only return the `id`
     * const orderAttachmentWithIdOnly = await prisma.orderAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderAttachment.
     * @param {OrderAttachmentUpsertArgs} args - Arguments to update or create a OrderAttachment.
     * @example
     * // Update or create a OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.upsert({
     *   create: {
     *     // ... data to create a OrderAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderAttachment we want to update
     *   }
     * })
     */
    upsert<T extends OrderAttachmentUpsertArgs>(args: SelectSubset<T, OrderAttachmentUpsertArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentCountArgs} args - Arguments to filter OrderAttachments to count.
     * @example
     * // Count the number of OrderAttachments
     * const count = await prisma.orderAttachment.count({
     *   where: {
     *     // ... the filter for the OrderAttachments we want to count
     *   }
     * })
    **/
    count<T extends OrderAttachmentCountArgs>(
      args?: Subset<T, OrderAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAttachmentAggregateArgs>(args: Subset<T, OrderAttachmentAggregateArgs>): Prisma.PrismaPromise<GetOrderAttachmentAggregateType<T>>

    /**
     * Group by OrderAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: OrderAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderAttachment model
   */
  readonly fields: OrderAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderAttachment model
   */
  interface OrderAttachmentFieldRefs {
    readonly id: FieldRef<"OrderAttachment", 'Int'>
    readonly orderId: FieldRef<"OrderAttachment", 'Int'>
    readonly type: FieldRef<"OrderAttachment", 'String'>
    readonly filename: FieldRef<"OrderAttachment", 'String'>
    readonly url: FieldRef<"OrderAttachment", 'String'>
    readonly mimeType: FieldRef<"OrderAttachment", 'String'>
    readonly createdAt: FieldRef<"OrderAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderAttachment findUnique
   */
  export type OrderAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAttachment to fetch.
     */
    where: OrderAttachmentWhereUniqueInput
  }

  /**
   * OrderAttachment findUniqueOrThrow
   */
  export type OrderAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAttachment to fetch.
     */
    where: OrderAttachmentWhereUniqueInput
  }

  /**
   * OrderAttachment findFirst
   */
  export type OrderAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAttachment to fetch.
     */
    where?: OrderAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAttachments to fetch.
     */
    orderBy?: OrderAttachmentOrderByWithRelationInput | OrderAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderAttachments.
     */
    cursor?: OrderAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderAttachments.
     */
    distinct?: OrderAttachmentScalarFieldEnum | OrderAttachmentScalarFieldEnum[]
  }

  /**
   * OrderAttachment findFirstOrThrow
   */
  export type OrderAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAttachment to fetch.
     */
    where?: OrderAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAttachments to fetch.
     */
    orderBy?: OrderAttachmentOrderByWithRelationInput | OrderAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderAttachments.
     */
    cursor?: OrderAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderAttachments.
     */
    distinct?: OrderAttachmentScalarFieldEnum | OrderAttachmentScalarFieldEnum[]
  }

  /**
   * OrderAttachment findMany
   */
  export type OrderAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAttachments to fetch.
     */
    where?: OrderAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAttachments to fetch.
     */
    orderBy?: OrderAttachmentOrderByWithRelationInput | OrderAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderAttachments.
     */
    cursor?: OrderAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAttachments.
     */
    skip?: number
    distinct?: OrderAttachmentScalarFieldEnum | OrderAttachmentScalarFieldEnum[]
  }

  /**
   * OrderAttachment create
   */
  export type OrderAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderAttachment.
     */
    data: XOR<OrderAttachmentCreateInput, OrderAttachmentUncheckedCreateInput>
  }

  /**
   * OrderAttachment createMany
   */
  export type OrderAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderAttachments.
     */
    data: OrderAttachmentCreateManyInput | OrderAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderAttachment createManyAndReturn
   */
  export type OrderAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many OrderAttachments.
     */
    data: OrderAttachmentCreateManyInput | OrderAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderAttachment update
   */
  export type OrderAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderAttachment.
     */
    data: XOR<OrderAttachmentUpdateInput, OrderAttachmentUncheckedUpdateInput>
    /**
     * Choose, which OrderAttachment to update.
     */
    where: OrderAttachmentWhereUniqueInput
  }

  /**
   * OrderAttachment updateMany
   */
  export type OrderAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderAttachments.
     */
    data: XOR<OrderAttachmentUpdateManyMutationInput, OrderAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which OrderAttachments to update
     */
    where?: OrderAttachmentWhereInput
    /**
     * Limit how many OrderAttachments to update.
     */
    limit?: number
  }

  /**
   * OrderAttachment updateManyAndReturn
   */
  export type OrderAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update OrderAttachments.
     */
    data: XOR<OrderAttachmentUpdateManyMutationInput, OrderAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which OrderAttachments to update
     */
    where?: OrderAttachmentWhereInput
    /**
     * Limit how many OrderAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderAttachment upsert
   */
  export type OrderAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderAttachment to update in case it exists.
     */
    where: OrderAttachmentWhereUniqueInput
    /**
     * In case the OrderAttachment found by the `where` argument doesn't exist, create a new OrderAttachment with this data.
     */
    create: XOR<OrderAttachmentCreateInput, OrderAttachmentUncheckedCreateInput>
    /**
     * In case the OrderAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderAttachmentUpdateInput, OrderAttachmentUncheckedUpdateInput>
  }

  /**
   * OrderAttachment delete
   */
  export type OrderAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter which OrderAttachment to delete.
     */
    where: OrderAttachmentWhereUniqueInput
  }

  /**
   * OrderAttachment deleteMany
   */
  export type OrderAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderAttachments to delete
     */
    where?: OrderAttachmentWhereInput
    /**
     * Limit how many OrderAttachments to delete.
     */
    limit?: number
  }

  /**
   * OrderAttachment without action
   */
  export type OrderAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
    amount: Decimal | null
    shippedQty: number | null
    distributionCoef: number | null
    sumWithRevaluation: Decimal | null
    weightToDistribute: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
    amount: Decimal | null
    shippedQty: number | null
    distributionCoef: number | null
    sumWithRevaluation: Decimal | null
    weightToDistribute: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
    amount: Decimal | null
    shippedQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
    distributionCoef: number | null
    sumWithRevaluation: Decimal | null
    weightToDistribute: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
    amount: Decimal | null
    shippedQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
    distributionCoef: number | null
    sumWithRevaluation: Decimal | null
    weightToDistribute: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    price: number
    amount: number
    shippedQty: number
    createdAt: number
    updatedAt: number
    distributionCoef: number
    sumWithRevaluation: number
    weightToDistribute: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    amount?: true
    shippedQty?: true
    distributionCoef?: true
    sumWithRevaluation?: true
    weightToDistribute?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    amount?: true
    shippedQty?: true
    distributionCoef?: true
    sumWithRevaluation?: true
    weightToDistribute?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    amount?: true
    shippedQty?: true
    createdAt?: true
    updatedAt?: true
    distributionCoef?: true
    sumWithRevaluation?: true
    weightToDistribute?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    amount?: true
    shippedQty?: true
    createdAt?: true
    updatedAt?: true
    distributionCoef?: true
    sumWithRevaluation?: true
    weightToDistribute?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    amount?: true
    shippedQty?: true
    createdAt?: true
    updatedAt?: true
    distributionCoef?: true
    sumWithRevaluation?: true
    weightToDistribute?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    price: Decimal
    amount: Decimal
    shippedQty: number
    createdAt: Date
    updatedAt: Date
    distributionCoef: number | null
    sumWithRevaluation: Decimal | null
    weightToDistribute: number | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    amount?: boolean
    shippedQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributionCoef?: boolean
    sumWithRevaluation?: boolean
    weightToDistribute?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    amount?: boolean
    shippedQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributionCoef?: boolean
    sumWithRevaluation?: boolean
    weightToDistribute?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    amount?: boolean
    shippedQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributionCoef?: boolean
    sumWithRevaluation?: boolean
    weightToDistribute?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    amount?: boolean
    shippedQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributionCoef?: boolean
    sumWithRevaluation?: boolean
    weightToDistribute?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantity" | "price" | "amount" | "shippedQty" | "createdAt" | "updatedAt" | "distributionCoef" | "sumWithRevaluation" | "weightToDistribute", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      productId: number
      quantity: number
      price: Prisma.Decimal
      amount: Prisma.Decimal
      shippedQty: number
      createdAt: Date
      updatedAt: Date
      distributionCoef: number | null
      sumWithRevaluation: Prisma.Decimal | null
      weightToDistribute: number | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly productId: FieldRef<"OrderItem", 'Int'>
    readonly quantity: FieldRef<"OrderItem", 'Float'>
    readonly price: FieldRef<"OrderItem", 'Decimal'>
    readonly amount: FieldRef<"OrderItem", 'Decimal'>
    readonly shippedQty: FieldRef<"OrderItem", 'Float'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly distributionCoef: FieldRef<"OrderItem", 'Float'>
    readonly sumWithRevaluation: FieldRef<"OrderItem", 'Decimal'>
    readonly weightToDistribute: FieldRef<"OrderItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Expeditor
   */

  export type AggregateExpeditor = {
    _count: ExpeditorCountAggregateOutputType | null
    _avg: ExpeditorAvgAggregateOutputType | null
    _sum: ExpeditorSumAggregateOutputType | null
    _min: ExpeditorMinAggregateOutputType | null
    _max: ExpeditorMaxAggregateOutputType | null
  }

  export type ExpeditorAvgAggregateOutputType = {
    id: number | null
  }

  export type ExpeditorSumAggregateOutputType = {
    id: number | null
  }

  export type ExpeditorMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpeditorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpeditorCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpeditorAvgAggregateInputType = {
    id?: true
  }

  export type ExpeditorSumAggregateInputType = {
    id?: true
  }

  export type ExpeditorMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpeditorMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpeditorCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpeditorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expeditor to aggregate.
     */
    where?: ExpeditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expeditors to fetch.
     */
    orderBy?: ExpeditorOrderByWithRelationInput | ExpeditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpeditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expeditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expeditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expeditors
    **/
    _count?: true | ExpeditorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpeditorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpeditorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpeditorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpeditorMaxAggregateInputType
  }

  export type GetExpeditorAggregateType<T extends ExpeditorAggregateArgs> = {
        [P in keyof T & keyof AggregateExpeditor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpeditor[P]>
      : GetScalarType<T[P], AggregateExpeditor[P]>
  }




  export type ExpeditorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpeditorWhereInput
    orderBy?: ExpeditorOrderByWithAggregationInput | ExpeditorOrderByWithAggregationInput[]
    by: ExpeditorScalarFieldEnum[] | ExpeditorScalarFieldEnum
    having?: ExpeditorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpeditorCountAggregateInputType | true
    _avg?: ExpeditorAvgAggregateInputType
    _sum?: ExpeditorSumAggregateInputType
    _min?: ExpeditorMinAggregateInputType
    _max?: ExpeditorMaxAggregateInputType
  }

  export type ExpeditorGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExpeditorCountAggregateOutputType | null
    _avg: ExpeditorAvgAggregateOutputType | null
    _sum: ExpeditorSumAggregateOutputType | null
    _min: ExpeditorMinAggregateOutputType | null
    _max: ExpeditorMaxAggregateOutputType | null
  }

  type GetExpeditorGroupByPayload<T extends ExpeditorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpeditorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpeditorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpeditorGroupByOutputType[P]>
            : GetScalarType<T[P], ExpeditorGroupByOutputType[P]>
        }
      >
    >


  export type ExpeditorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | Expeditor$ordersArgs<ExtArgs>
    _count?: boolean | ExpeditorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expeditor"]>

  export type ExpeditorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expeditor"]>

  export type ExpeditorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expeditor"]>

  export type ExpeditorSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpeditorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["expeditor"]>
  export type ExpeditorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Expeditor$ordersArgs<ExtArgs>
    _count?: boolean | ExpeditorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpeditorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ExpeditorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExpeditorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expeditor"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expeditor"]>
    composites: {}
  }

  type ExpeditorGetPayload<S extends boolean | null | undefined | ExpeditorDefaultArgs> = $Result.GetResult<Prisma.$ExpeditorPayload, S>

  type ExpeditorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpeditorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpeditorCountAggregateInputType | true
    }

  export interface ExpeditorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expeditor'], meta: { name: 'Expeditor' } }
    /**
     * Find zero or one Expeditor that matches the filter.
     * @param {ExpeditorFindUniqueArgs} args - Arguments to find a Expeditor
     * @example
     * // Get one Expeditor
     * const expeditor = await prisma.expeditor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpeditorFindUniqueArgs>(args: SelectSubset<T, ExpeditorFindUniqueArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expeditor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpeditorFindUniqueOrThrowArgs} args - Arguments to find a Expeditor
     * @example
     * // Get one Expeditor
     * const expeditor = await prisma.expeditor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpeditorFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpeditorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expeditor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorFindFirstArgs} args - Arguments to find a Expeditor
     * @example
     * // Get one Expeditor
     * const expeditor = await prisma.expeditor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpeditorFindFirstArgs>(args?: SelectSubset<T, ExpeditorFindFirstArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expeditor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorFindFirstOrThrowArgs} args - Arguments to find a Expeditor
     * @example
     * // Get one Expeditor
     * const expeditor = await prisma.expeditor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpeditorFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpeditorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expeditors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expeditors
     * const expeditors = await prisma.expeditor.findMany()
     * 
     * // Get first 10 Expeditors
     * const expeditors = await prisma.expeditor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expeditorWithIdOnly = await prisma.expeditor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpeditorFindManyArgs>(args?: SelectSubset<T, ExpeditorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expeditor.
     * @param {ExpeditorCreateArgs} args - Arguments to create a Expeditor.
     * @example
     * // Create one Expeditor
     * const Expeditor = await prisma.expeditor.create({
     *   data: {
     *     // ... data to create a Expeditor
     *   }
     * })
     * 
     */
    create<T extends ExpeditorCreateArgs>(args: SelectSubset<T, ExpeditorCreateArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expeditors.
     * @param {ExpeditorCreateManyArgs} args - Arguments to create many Expeditors.
     * @example
     * // Create many Expeditors
     * const expeditor = await prisma.expeditor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpeditorCreateManyArgs>(args?: SelectSubset<T, ExpeditorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expeditors and returns the data saved in the database.
     * @param {ExpeditorCreateManyAndReturnArgs} args - Arguments to create many Expeditors.
     * @example
     * // Create many Expeditors
     * const expeditor = await prisma.expeditor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expeditors and only return the `id`
     * const expeditorWithIdOnly = await prisma.expeditor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpeditorCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpeditorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expeditor.
     * @param {ExpeditorDeleteArgs} args - Arguments to delete one Expeditor.
     * @example
     * // Delete one Expeditor
     * const Expeditor = await prisma.expeditor.delete({
     *   where: {
     *     // ... filter to delete one Expeditor
     *   }
     * })
     * 
     */
    delete<T extends ExpeditorDeleteArgs>(args: SelectSubset<T, ExpeditorDeleteArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expeditor.
     * @param {ExpeditorUpdateArgs} args - Arguments to update one Expeditor.
     * @example
     * // Update one Expeditor
     * const expeditor = await prisma.expeditor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpeditorUpdateArgs>(args: SelectSubset<T, ExpeditorUpdateArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expeditors.
     * @param {ExpeditorDeleteManyArgs} args - Arguments to filter Expeditors to delete.
     * @example
     * // Delete a few Expeditors
     * const { count } = await prisma.expeditor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpeditorDeleteManyArgs>(args?: SelectSubset<T, ExpeditorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expeditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expeditors
     * const expeditor = await prisma.expeditor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpeditorUpdateManyArgs>(args: SelectSubset<T, ExpeditorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expeditors and returns the data updated in the database.
     * @param {ExpeditorUpdateManyAndReturnArgs} args - Arguments to update many Expeditors.
     * @example
     * // Update many Expeditors
     * const expeditor = await prisma.expeditor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expeditors and only return the `id`
     * const expeditorWithIdOnly = await prisma.expeditor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpeditorUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpeditorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expeditor.
     * @param {ExpeditorUpsertArgs} args - Arguments to update or create a Expeditor.
     * @example
     * // Update or create a Expeditor
     * const expeditor = await prisma.expeditor.upsert({
     *   create: {
     *     // ... data to create a Expeditor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expeditor we want to update
     *   }
     * })
     */
    upsert<T extends ExpeditorUpsertArgs>(args: SelectSubset<T, ExpeditorUpsertArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expeditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorCountArgs} args - Arguments to filter Expeditors to count.
     * @example
     * // Count the number of Expeditors
     * const count = await prisma.expeditor.count({
     *   where: {
     *     // ... the filter for the Expeditors we want to count
     *   }
     * })
    **/
    count<T extends ExpeditorCountArgs>(
      args?: Subset<T, ExpeditorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpeditorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expeditor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpeditorAggregateArgs>(args: Subset<T, ExpeditorAggregateArgs>): Prisma.PrismaPromise<GetExpeditorAggregateType<T>>

    /**
     * Group by Expeditor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpeditorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpeditorGroupByArgs['orderBy'] }
        : { orderBy?: ExpeditorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpeditorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpeditorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expeditor model
   */
  readonly fields: ExpeditorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expeditor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpeditorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends Expeditor$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Expeditor$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expeditor model
   */
  interface ExpeditorFieldRefs {
    readonly id: FieldRef<"Expeditor", 'Int'>
    readonly name: FieldRef<"Expeditor", 'String'>
    readonly phone: FieldRef<"Expeditor", 'String'>
    readonly isActive: FieldRef<"Expeditor", 'Boolean'>
    readonly createdAt: FieldRef<"Expeditor", 'DateTime'>
    readonly updatedAt: FieldRef<"Expeditor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expeditor findUnique
   */
  export type ExpeditorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter, which Expeditor to fetch.
     */
    where: ExpeditorWhereUniqueInput
  }

  /**
   * Expeditor findUniqueOrThrow
   */
  export type ExpeditorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter, which Expeditor to fetch.
     */
    where: ExpeditorWhereUniqueInput
  }

  /**
   * Expeditor findFirst
   */
  export type ExpeditorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter, which Expeditor to fetch.
     */
    where?: ExpeditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expeditors to fetch.
     */
    orderBy?: ExpeditorOrderByWithRelationInput | ExpeditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expeditors.
     */
    cursor?: ExpeditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expeditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expeditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expeditors.
     */
    distinct?: ExpeditorScalarFieldEnum | ExpeditorScalarFieldEnum[]
  }

  /**
   * Expeditor findFirstOrThrow
   */
  export type ExpeditorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter, which Expeditor to fetch.
     */
    where?: ExpeditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expeditors to fetch.
     */
    orderBy?: ExpeditorOrderByWithRelationInput | ExpeditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expeditors.
     */
    cursor?: ExpeditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expeditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expeditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expeditors.
     */
    distinct?: ExpeditorScalarFieldEnum | ExpeditorScalarFieldEnum[]
  }

  /**
   * Expeditor findMany
   */
  export type ExpeditorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter, which Expeditors to fetch.
     */
    where?: ExpeditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expeditors to fetch.
     */
    orderBy?: ExpeditorOrderByWithRelationInput | ExpeditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expeditors.
     */
    cursor?: ExpeditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expeditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expeditors.
     */
    skip?: number
    distinct?: ExpeditorScalarFieldEnum | ExpeditorScalarFieldEnum[]
  }

  /**
   * Expeditor create
   */
  export type ExpeditorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * The data needed to create a Expeditor.
     */
    data: XOR<ExpeditorCreateInput, ExpeditorUncheckedCreateInput>
  }

  /**
   * Expeditor createMany
   */
  export type ExpeditorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expeditors.
     */
    data: ExpeditorCreateManyInput | ExpeditorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expeditor createManyAndReturn
   */
  export type ExpeditorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * The data used to create many Expeditors.
     */
    data: ExpeditorCreateManyInput | ExpeditorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expeditor update
   */
  export type ExpeditorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * The data needed to update a Expeditor.
     */
    data: XOR<ExpeditorUpdateInput, ExpeditorUncheckedUpdateInput>
    /**
     * Choose, which Expeditor to update.
     */
    where: ExpeditorWhereUniqueInput
  }

  /**
   * Expeditor updateMany
   */
  export type ExpeditorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expeditors.
     */
    data: XOR<ExpeditorUpdateManyMutationInput, ExpeditorUncheckedUpdateManyInput>
    /**
     * Filter which Expeditors to update
     */
    where?: ExpeditorWhereInput
    /**
     * Limit how many Expeditors to update.
     */
    limit?: number
  }

  /**
   * Expeditor updateManyAndReturn
   */
  export type ExpeditorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * The data used to update Expeditors.
     */
    data: XOR<ExpeditorUpdateManyMutationInput, ExpeditorUncheckedUpdateManyInput>
    /**
     * Filter which Expeditors to update
     */
    where?: ExpeditorWhereInput
    /**
     * Limit how many Expeditors to update.
     */
    limit?: number
  }

  /**
   * Expeditor upsert
   */
  export type ExpeditorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * The filter to search for the Expeditor to update in case it exists.
     */
    where: ExpeditorWhereUniqueInput
    /**
     * In case the Expeditor found by the `where` argument doesn't exist, create a new Expeditor with this data.
     */
    create: XOR<ExpeditorCreateInput, ExpeditorUncheckedCreateInput>
    /**
     * In case the Expeditor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpeditorUpdateInput, ExpeditorUncheckedUpdateInput>
  }

  /**
   * Expeditor delete
   */
  export type ExpeditorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter which Expeditor to delete.
     */
    where: ExpeditorWhereUniqueInput
  }

  /**
   * Expeditor deleteMany
   */
  export type ExpeditorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expeditors to delete
     */
    where?: ExpeditorWhereInput
    /**
     * Limit how many Expeditors to delete.
     */
    limit?: number
  }

  /**
   * Expeditor.orders
   */
  export type Expeditor$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Expeditor without action
   */
  export type ExpeditorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
  }


  /**
   * Model Stock
   */

  export type AggregateStock = {
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  export type StockAvgAggregateOutputType = {
    productId: number | null
    quantity: number | null
  }

  export type StockSumAggregateOutputType = {
    productId: number | null
    quantity: number | null
  }

  export type StockMinAggregateOutputType = {
    productId: number | null
    quantity: number | null
    updatedAt: Date | null
  }

  export type StockMaxAggregateOutputType = {
    productId: number | null
    quantity: number | null
    updatedAt: Date | null
  }

  export type StockCountAggregateOutputType = {
    productId: number
    quantity: number
    updatedAt: number
    _all: number
  }


  export type StockAvgAggregateInputType = {
    productId?: true
    quantity?: true
  }

  export type StockSumAggregateInputType = {
    productId?: true
    quantity?: true
  }

  export type StockMinAggregateInputType = {
    productId?: true
    quantity?: true
    updatedAt?: true
  }

  export type StockMaxAggregateInputType = {
    productId?: true
    quantity?: true
    updatedAt?: true
  }

  export type StockCountAggregateInputType = {
    productId?: true
    quantity?: true
    updatedAt?: true
    _all?: true
  }

  export type StockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stock to aggregate.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMaxAggregateInputType
  }

  export type GetStockAggregateType<T extends StockAggregateArgs> = {
        [P in keyof T & keyof AggregateStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock[P]>
      : GetScalarType<T[P], AggregateStock[P]>
  }




  export type StockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
    orderBy?: StockOrderByWithAggregationInput | StockOrderByWithAggregationInput[]
    by: StockScalarFieldEnum[] | StockScalarFieldEnum
    having?: StockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCountAggregateInputType | true
    _avg?: StockAvgAggregateInputType
    _sum?: StockSumAggregateInputType
    _min?: StockMinAggregateInputType
    _max?: StockMaxAggregateInputType
  }

  export type StockGroupByOutputType = {
    productId: number
    quantity: number
    updatedAt: Date
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  type GetStockGroupByPayload<T extends StockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockGroupByOutputType[P]>
            : GetScalarType<T[P], StockGroupByOutputType[P]>
        }
      >
    >


  export type StockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectScalar = {
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
  }

  export type StockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"productId" | "quantity" | "updatedAt", ExtArgs["result"]["stock"]>
  export type StockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $StockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stock"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      productId: number
      quantity: number
      updatedAt: Date
    }, ExtArgs["result"]["stock"]>
    composites: {}
  }

  type StockGetPayload<S extends boolean | null | undefined | StockDefaultArgs> = $Result.GetResult<Prisma.$StockPayload, S>

  type StockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockCountAggregateInputType | true
    }

  export interface StockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stock'], meta: { name: 'Stock' } }
    /**
     * Find zero or one Stock that matches the filter.
     * @param {StockFindUniqueArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockFindUniqueArgs>(args: SelectSubset<T, StockFindUniqueArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockFindUniqueOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockFindUniqueOrThrowArgs>(args: SelectSubset<T, StockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockFindFirstArgs>(args?: SelectSubset<T, StockFindFirstArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockFindFirstOrThrowArgs>(args?: SelectSubset<T, StockFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stock.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stock.findMany({ take: 10 })
     * 
     * // Only select the `productId`
     * const stockWithProductIdOnly = await prisma.stock.findMany({ select: { productId: true } })
     * 
     */
    findMany<T extends StockFindManyArgs>(args?: SelectSubset<T, StockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stock.
     * @param {StockCreateArgs} args - Arguments to create a Stock.
     * @example
     * // Create one Stock
     * const Stock = await prisma.stock.create({
     *   data: {
     *     // ... data to create a Stock
     *   }
     * })
     * 
     */
    create<T extends StockCreateArgs>(args: SelectSubset<T, StockCreateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stocks.
     * @param {StockCreateManyArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockCreateManyArgs>(args?: SelectSubset<T, StockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stocks and returns the data saved in the database.
     * @param {StockCreateManyAndReturnArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stocks and only return the `productId`
     * const stockWithProductIdOnly = await prisma.stock.createManyAndReturn({
     *   select: { productId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockCreateManyAndReturnArgs>(args?: SelectSubset<T, StockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stock.
     * @param {StockDeleteArgs} args - Arguments to delete one Stock.
     * @example
     * // Delete one Stock
     * const Stock = await prisma.stock.delete({
     *   where: {
     *     // ... filter to delete one Stock
     *   }
     * })
     * 
     */
    delete<T extends StockDeleteArgs>(args: SelectSubset<T, StockDeleteArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stock.
     * @param {StockUpdateArgs} args - Arguments to update one Stock.
     * @example
     * // Update one Stock
     * const stock = await prisma.stock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockUpdateArgs>(args: SelectSubset<T, StockUpdateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stocks.
     * @param {StockDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockDeleteManyArgs>(args?: SelectSubset<T, StockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockUpdateManyArgs>(args: SelectSubset<T, StockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks and returns the data updated in the database.
     * @param {StockUpdateManyAndReturnArgs} args - Arguments to update many Stocks.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stocks and only return the `productId`
     * const stockWithProductIdOnly = await prisma.stock.updateManyAndReturn({
     *   select: { productId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockUpdateManyAndReturnArgs>(args: SelectSubset<T, StockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stock.
     * @param {StockUpsertArgs} args - Arguments to update or create a Stock.
     * @example
     * // Update or create a Stock
     * const stock = await prisma.stock.upsert({
     *   create: {
     *     // ... data to create a Stock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock we want to update
     *   }
     * })
     */
    upsert<T extends StockUpsertArgs>(args: SelectSubset<T, StockUpsertArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stock.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StockCountArgs>(
      args?: Subset<T, StockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAggregateArgs>(args: Subset<T, StockAggregateArgs>): Prisma.PrismaPromise<GetStockAggregateType<T>>

    /**
     * Group by Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockGroupByArgs['orderBy'] }
        : { orderBy?: StockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stock model
   */
  readonly fields: StockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stock model
   */
  interface StockFieldRefs {
    readonly productId: FieldRef<"Stock", 'Int'>
    readonly quantity: FieldRef<"Stock", 'Float'>
    readonly updatedAt: FieldRef<"Stock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stock findUnique
   */
  export type StockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findUniqueOrThrow
   */
  export type StockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findFirst
   */
  export type StockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findFirstOrThrow
   */
  export type StockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findMany
   */
  export type StockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock create
   */
  export type StockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to create a Stock.
     */
    data: XOR<StockCreateInput, StockUncheckedCreateInput>
  }

  /**
   * Stock createMany
   */
  export type StockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stock createManyAndReturn
   */
  export type StockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stock update
   */
  export type StockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to update a Stock.
     */
    data: XOR<StockUpdateInput, StockUncheckedUpdateInput>
    /**
     * Choose, which Stock to update.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock updateMany
   */
  export type StockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
  }

  /**
   * Stock updateManyAndReturn
   */
  export type StockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stock upsert
   */
  export type StockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The filter to search for the Stock to update in case it exists.
     */
    where: StockWhereUniqueInput
    /**
     * In case the Stock found by the `where` argument doesn't exist, create a new Stock with this data.
     */
    create: XOR<StockCreateInput, StockUncheckedCreateInput>
    /**
     * In case the Stock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockUpdateInput, StockUncheckedUpdateInput>
  }

  /**
   * Stock delete
   */
  export type StockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter which Stock to delete.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock deleteMany
   */
  export type StockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to delete
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to delete.
     */
    limit?: number
  }

  /**
   * Stock without action
   */
  export type StockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
  }


  /**
   * Model StockTransaction
   */

  export type AggregateStockTransaction = {
    _count: StockTransactionCountAggregateOutputType | null
    _avg: StockTransactionAvgAggregateOutputType | null
    _sum: StockTransactionSumAggregateOutputType | null
    _min: StockTransactionMinAggregateOutputType | null
    _max: StockTransactionMaxAggregateOutputType | null
  }

  export type StockTransactionAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    orderId: number | null
  }

  export type StockTransactionSumAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    orderId: number | null
  }

  export type StockTransactionMinAggregateOutputType = {
    id: number | null
    productId: number | null
    type: string | null
    quantity: number | null
    orderId: number | null
    note: string | null
    createdAt: Date | null
  }

  export type StockTransactionMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    type: string | null
    quantity: number | null
    orderId: number | null
    note: string | null
    createdAt: Date | null
  }

  export type StockTransactionCountAggregateOutputType = {
    id: number
    productId: number
    type: number
    quantity: number
    orderId: number
    note: number
    createdAt: number
    _all: number
  }


  export type StockTransactionAvgAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    orderId?: true
  }

  export type StockTransactionSumAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    orderId?: true
  }

  export type StockTransactionMinAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    quantity?: true
    orderId?: true
    note?: true
    createdAt?: true
  }

  export type StockTransactionMaxAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    quantity?: true
    orderId?: true
    note?: true
    createdAt?: true
  }

  export type StockTransactionCountAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    quantity?: true
    orderId?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type StockTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransaction to aggregate.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockTransactions
    **/
    _count?: true | StockTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockTransactionMaxAggregateInputType
  }

  export type GetStockTransactionAggregateType<T extends StockTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateStockTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockTransaction[P]>
      : GetScalarType<T[P], AggregateStockTransaction[P]>
  }




  export type StockTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransactionWhereInput
    orderBy?: StockTransactionOrderByWithAggregationInput | StockTransactionOrderByWithAggregationInput[]
    by: StockTransactionScalarFieldEnum[] | StockTransactionScalarFieldEnum
    having?: StockTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockTransactionCountAggregateInputType | true
    _avg?: StockTransactionAvgAggregateInputType
    _sum?: StockTransactionSumAggregateInputType
    _min?: StockTransactionMinAggregateInputType
    _max?: StockTransactionMaxAggregateInputType
  }

  export type StockTransactionGroupByOutputType = {
    id: number
    productId: number
    type: string
    quantity: number
    orderId: number | null
    note: string | null
    createdAt: Date
    _count: StockTransactionCountAggregateOutputType | null
    _avg: StockTransactionAvgAggregateOutputType | null
    _sum: StockTransactionSumAggregateOutputType | null
    _min: StockTransactionMinAggregateOutputType | null
    _max: StockTransactionMaxAggregateOutputType | null
  }

  type GetStockTransactionGroupByPayload<T extends StockTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], StockTransactionGroupByOutputType[P]>
        }
      >
    >


  export type StockTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransaction"]>

  export type StockTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransaction"]>

  export type StockTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransaction"]>

  export type StockTransactionSelectScalar = {
    id?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type StockTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "type" | "quantity" | "orderId" | "note" | "createdAt", ExtArgs["result"]["stockTransaction"]>
  export type StockTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $StockTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockTransaction"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      type: string
      quantity: number
      orderId: number | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["stockTransaction"]>
    composites: {}
  }

  type StockTransactionGetPayload<S extends boolean | null | undefined | StockTransactionDefaultArgs> = $Result.GetResult<Prisma.$StockTransactionPayload, S>

  type StockTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockTransactionCountAggregateInputType | true
    }

  export interface StockTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockTransaction'], meta: { name: 'StockTransaction' } }
    /**
     * Find zero or one StockTransaction that matches the filter.
     * @param {StockTransactionFindUniqueArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockTransactionFindUniqueArgs>(args: SelectSubset<T, StockTransactionFindUniqueArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockTransactionFindUniqueOrThrowArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, StockTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionFindFirstArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockTransactionFindFirstArgs>(args?: SelectSubset<T, StockTransactionFindFirstArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionFindFirstOrThrowArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, StockTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockTransactions
     * const stockTransactions = await prisma.stockTransaction.findMany()
     * 
     * // Get first 10 StockTransactions
     * const stockTransactions = await prisma.stockTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockTransactionWithIdOnly = await prisma.stockTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockTransactionFindManyArgs>(args?: SelectSubset<T, StockTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockTransaction.
     * @param {StockTransactionCreateArgs} args - Arguments to create a StockTransaction.
     * @example
     * // Create one StockTransaction
     * const StockTransaction = await prisma.stockTransaction.create({
     *   data: {
     *     // ... data to create a StockTransaction
     *   }
     * })
     * 
     */
    create<T extends StockTransactionCreateArgs>(args: SelectSubset<T, StockTransactionCreateArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockTransactions.
     * @param {StockTransactionCreateManyArgs} args - Arguments to create many StockTransactions.
     * @example
     * // Create many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockTransactionCreateManyArgs>(args?: SelectSubset<T, StockTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockTransactions and returns the data saved in the database.
     * @param {StockTransactionCreateManyAndReturnArgs} args - Arguments to create many StockTransactions.
     * @example
     * // Create many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockTransactions and only return the `id`
     * const stockTransactionWithIdOnly = await prisma.stockTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, StockTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockTransaction.
     * @param {StockTransactionDeleteArgs} args - Arguments to delete one StockTransaction.
     * @example
     * // Delete one StockTransaction
     * const StockTransaction = await prisma.stockTransaction.delete({
     *   where: {
     *     // ... filter to delete one StockTransaction
     *   }
     * })
     * 
     */
    delete<T extends StockTransactionDeleteArgs>(args: SelectSubset<T, StockTransactionDeleteArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockTransaction.
     * @param {StockTransactionUpdateArgs} args - Arguments to update one StockTransaction.
     * @example
     * // Update one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockTransactionUpdateArgs>(args: SelectSubset<T, StockTransactionUpdateArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockTransactions.
     * @param {StockTransactionDeleteManyArgs} args - Arguments to filter StockTransactions to delete.
     * @example
     * // Delete a few StockTransactions
     * const { count } = await prisma.stockTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockTransactionDeleteManyArgs>(args?: SelectSubset<T, StockTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockTransactionUpdateManyArgs>(args: SelectSubset<T, StockTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransactions and returns the data updated in the database.
     * @param {StockTransactionUpdateManyAndReturnArgs} args - Arguments to update many StockTransactions.
     * @example
     * // Update many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockTransactions and only return the `id`
     * const stockTransactionWithIdOnly = await prisma.stockTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, StockTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockTransaction.
     * @param {StockTransactionUpsertArgs} args - Arguments to update or create a StockTransaction.
     * @example
     * // Update or create a StockTransaction
     * const stockTransaction = await prisma.stockTransaction.upsert({
     *   create: {
     *     // ... data to create a StockTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockTransaction we want to update
     *   }
     * })
     */
    upsert<T extends StockTransactionUpsertArgs>(args: SelectSubset<T, StockTransactionUpsertArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionCountArgs} args - Arguments to filter StockTransactions to count.
     * @example
     * // Count the number of StockTransactions
     * const count = await prisma.stockTransaction.count({
     *   where: {
     *     // ... the filter for the StockTransactions we want to count
     *   }
     * })
    **/
    count<T extends StockTransactionCountArgs>(
      args?: Subset<T, StockTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockTransactionAggregateArgs>(args: Subset<T, StockTransactionAggregateArgs>): Prisma.PrismaPromise<GetStockTransactionAggregateType<T>>

    /**
     * Group by StockTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockTransactionGroupByArgs['orderBy'] }
        : { orderBy?: StockTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockTransaction model
   */
  readonly fields: StockTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends StockTransaction$orderArgs<ExtArgs> = {}>(args?: Subset<T, StockTransaction$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockTransaction model
   */
  interface StockTransactionFieldRefs {
    readonly id: FieldRef<"StockTransaction", 'Int'>
    readonly productId: FieldRef<"StockTransaction", 'Int'>
    readonly type: FieldRef<"StockTransaction", 'String'>
    readonly quantity: FieldRef<"StockTransaction", 'Float'>
    readonly orderId: FieldRef<"StockTransaction", 'Int'>
    readonly note: FieldRef<"StockTransaction", 'String'>
    readonly createdAt: FieldRef<"StockTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockTransaction findUnique
   */
  export type StockTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction findUniqueOrThrow
   */
  export type StockTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction findFirst
   */
  export type StockTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransactions.
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransactions.
     */
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * StockTransaction findFirstOrThrow
   */
  export type StockTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransactions.
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransactions.
     */
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * StockTransaction findMany
   */
  export type StockTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransactions to fetch.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockTransactions.
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * StockTransaction create
   */
  export type StockTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a StockTransaction.
     */
    data: XOR<StockTransactionCreateInput, StockTransactionUncheckedCreateInput>
  }

  /**
   * StockTransaction createMany
   */
  export type StockTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockTransactions.
     */
    data: StockTransactionCreateManyInput | StockTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockTransaction createManyAndReturn
   */
  export type StockTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many StockTransactions.
     */
    data: StockTransactionCreateManyInput | StockTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransaction update
   */
  export type StockTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a StockTransaction.
     */
    data: XOR<StockTransactionUpdateInput, StockTransactionUncheckedUpdateInput>
    /**
     * Choose, which StockTransaction to update.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction updateMany
   */
  export type StockTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockTransactions.
     */
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyInput>
    /**
     * Filter which StockTransactions to update
     */
    where?: StockTransactionWhereInput
    /**
     * Limit how many StockTransactions to update.
     */
    limit?: number
  }

  /**
   * StockTransaction updateManyAndReturn
   */
  export type StockTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * The data used to update StockTransactions.
     */
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyInput>
    /**
     * Filter which StockTransactions to update
     */
    where?: StockTransactionWhereInput
    /**
     * Limit how many StockTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransaction upsert
   */
  export type StockTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the StockTransaction to update in case it exists.
     */
    where: StockTransactionWhereUniqueInput
    /**
     * In case the StockTransaction found by the `where` argument doesn't exist, create a new StockTransaction with this data.
     */
    create: XOR<StockTransactionCreateInput, StockTransactionUncheckedCreateInput>
    /**
     * In case the StockTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockTransactionUpdateInput, StockTransactionUncheckedUpdateInput>
  }

  /**
   * StockTransaction delete
   */
  export type StockTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter which StockTransaction to delete.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction deleteMany
   */
  export type StockTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransactions to delete
     */
    where?: StockTransactionWhereInput
    /**
     * Limit how many StockTransactions to delete.
     */
    limit?: number
  }

  /**
   * StockTransaction.order
   */
  export type StockTransaction$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * StockTransaction without action
   */
  export type StockTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
  }


  /**
   * Model SummaryOrderJournal
   */

  export type AggregateSummaryOrderJournal = {
    _count: SummaryOrderJournalCountAggregateOutputType | null
    _avg: SummaryOrderJournalAvgAggregateOutputType | null
    _sum: SummaryOrderJournalSumAggregateOutputType | null
    _min: SummaryOrderJournalMinAggregateOutputType | null
    _max: SummaryOrderJournalMaxAggregateOutputType | null
  }

  export type SummaryOrderJournalAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    productId: number | null
    price: Decimal | null
    shippedQty: number | null
    orderQty: number | null
    sumWithRevaluation: Decimal | null
    distributionCoef: number | null
    weightToDistribute: number | null
  }

  export type SummaryOrderJournalSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    productId: number | null
    price: Decimal | null
    shippedQty: number | null
    orderQty: number | null
    sumWithRevaluation: Decimal | null
    distributionCoef: number | null
    weightToDistribute: number | null
  }

  export type SummaryOrderJournalMinAggregateOutputType = {
    id: number | null
    idn: string | null
    shipDate: Date | null
    paymentType: string | null
    customerId: number | null
    customerName: string | null
    productId: number | null
    productCode: string | null
    productFullName: string | null
    category: string | null
    shortNameMorning: string | null
    priceType: string | null
    price: Decimal | null
    shippedQty: number | null
    orderQty: number | null
    sumWithRevaluation: Decimal | null
    distributionCoef: number | null
    weightToDistribute: number | null
    managerId: string | null
    managerName: string | null
    district: string | null
    pointAddress: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SummaryOrderJournalMaxAggregateOutputType = {
    id: number | null
    idn: string | null
    shipDate: Date | null
    paymentType: string | null
    customerId: number | null
    customerName: string | null
    productId: number | null
    productCode: string | null
    productFullName: string | null
    category: string | null
    shortNameMorning: string | null
    priceType: string | null
    price: Decimal | null
    shippedQty: number | null
    orderQty: number | null
    sumWithRevaluation: Decimal | null
    distributionCoef: number | null
    weightToDistribute: number | null
    managerId: string | null
    managerName: string | null
    district: string | null
    pointAddress: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SummaryOrderJournalCountAggregateOutputType = {
    id: number
    idn: number
    shipDate: number
    paymentType: number
    customerId: number
    customerName: number
    productId: number
    productCode: number
    productFullName: number
    category: number
    shortNameMorning: number
    priceType: number
    price: number
    shippedQty: number
    orderQty: number
    sumWithRevaluation: number
    distributionCoef: number
    weightToDistribute: number
    managerId: number
    managerName: number
    district: number
    pointAddress: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SummaryOrderJournalAvgAggregateInputType = {
    id?: true
    customerId?: true
    productId?: true
    price?: true
    shippedQty?: true
    orderQty?: true
    sumWithRevaluation?: true
    distributionCoef?: true
    weightToDistribute?: true
  }

  export type SummaryOrderJournalSumAggregateInputType = {
    id?: true
    customerId?: true
    productId?: true
    price?: true
    shippedQty?: true
    orderQty?: true
    sumWithRevaluation?: true
    distributionCoef?: true
    weightToDistribute?: true
  }

  export type SummaryOrderJournalMinAggregateInputType = {
    id?: true
    idn?: true
    shipDate?: true
    paymentType?: true
    customerId?: true
    customerName?: true
    productId?: true
    productCode?: true
    productFullName?: true
    category?: true
    shortNameMorning?: true
    priceType?: true
    price?: true
    shippedQty?: true
    orderQty?: true
    sumWithRevaluation?: true
    distributionCoef?: true
    weightToDistribute?: true
    managerId?: true
    managerName?: true
    district?: true
    pointAddress?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SummaryOrderJournalMaxAggregateInputType = {
    id?: true
    idn?: true
    shipDate?: true
    paymentType?: true
    customerId?: true
    customerName?: true
    productId?: true
    productCode?: true
    productFullName?: true
    category?: true
    shortNameMorning?: true
    priceType?: true
    price?: true
    shippedQty?: true
    orderQty?: true
    sumWithRevaluation?: true
    distributionCoef?: true
    weightToDistribute?: true
    managerId?: true
    managerName?: true
    district?: true
    pointAddress?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SummaryOrderJournalCountAggregateInputType = {
    id?: true
    idn?: true
    shipDate?: true
    paymentType?: true
    customerId?: true
    customerName?: true
    productId?: true
    productCode?: true
    productFullName?: true
    category?: true
    shortNameMorning?: true
    priceType?: true
    price?: true
    shippedQty?: true
    orderQty?: true
    sumWithRevaluation?: true
    distributionCoef?: true
    weightToDistribute?: true
    managerId?: true
    managerName?: true
    district?: true
    pointAddress?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SummaryOrderJournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummaryOrderJournal to aggregate.
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderJournals to fetch.
     */
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SummaryOrderJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SummaryOrderJournals
    **/
    _count?: true | SummaryOrderJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SummaryOrderJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SummaryOrderJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SummaryOrderJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SummaryOrderJournalMaxAggregateInputType
  }

  export type GetSummaryOrderJournalAggregateType<T extends SummaryOrderJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateSummaryOrderJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSummaryOrderJournal[P]>
      : GetScalarType<T[P], AggregateSummaryOrderJournal[P]>
  }




  export type SummaryOrderJournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummaryOrderJournalWhereInput
    orderBy?: SummaryOrderJournalOrderByWithAggregationInput | SummaryOrderJournalOrderByWithAggregationInput[]
    by: SummaryOrderJournalScalarFieldEnum[] | SummaryOrderJournalScalarFieldEnum
    having?: SummaryOrderJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SummaryOrderJournalCountAggregateInputType | true
    _avg?: SummaryOrderJournalAvgAggregateInputType
    _sum?: SummaryOrderJournalSumAggregateInputType
    _min?: SummaryOrderJournalMinAggregateInputType
    _max?: SummaryOrderJournalMaxAggregateInputType
  }

  export type SummaryOrderJournalGroupByOutputType = {
    id: number
    idn: string
    shipDate: Date
    paymentType: string | null
    customerId: number | null
    customerName: string
    productId: number | null
    productCode: string | null
    productFullName: string
    category: string | null
    shortNameMorning: string | null
    priceType: string | null
    price: Decimal
    shippedQty: number
    orderQty: number
    sumWithRevaluation: Decimal | null
    distributionCoef: number | null
    weightToDistribute: number | null
    managerId: string | null
    managerName: string | null
    district: string | null
    pointAddress: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SummaryOrderJournalCountAggregateOutputType | null
    _avg: SummaryOrderJournalAvgAggregateOutputType | null
    _sum: SummaryOrderJournalSumAggregateOutputType | null
    _min: SummaryOrderJournalMinAggregateOutputType | null
    _max: SummaryOrderJournalMaxAggregateOutputType | null
  }

  type GetSummaryOrderJournalGroupByPayload<T extends SummaryOrderJournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SummaryOrderJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SummaryOrderJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SummaryOrderJournalGroupByOutputType[P]>
            : GetScalarType<T[P], SummaryOrderJournalGroupByOutputType[P]>
        }
      >
    >


  export type SummaryOrderJournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    shipDate?: boolean
    paymentType?: boolean
    customerId?: boolean
    customerName?: boolean
    productId?: boolean
    productCode?: boolean
    productFullName?: boolean
    category?: boolean
    shortNameMorning?: boolean
    priceType?: boolean
    price?: boolean
    shippedQty?: boolean
    orderQty?: boolean
    sumWithRevaluation?: boolean
    distributionCoef?: boolean
    weightToDistribute?: boolean
    managerId?: boolean
    managerName?: boolean
    district?: boolean
    pointAddress?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
  }, ExtArgs["result"]["summaryOrderJournal"]>

  export type SummaryOrderJournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    shipDate?: boolean
    paymentType?: boolean
    customerId?: boolean
    customerName?: boolean
    productId?: boolean
    productCode?: boolean
    productFullName?: boolean
    category?: boolean
    shortNameMorning?: boolean
    priceType?: boolean
    price?: boolean
    shippedQty?: boolean
    orderQty?: boolean
    sumWithRevaluation?: boolean
    distributionCoef?: boolean
    weightToDistribute?: boolean
    managerId?: boolean
    managerName?: boolean
    district?: boolean
    pointAddress?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
  }, ExtArgs["result"]["summaryOrderJournal"]>

  export type SummaryOrderJournalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    shipDate?: boolean
    paymentType?: boolean
    customerId?: boolean
    customerName?: boolean
    productId?: boolean
    productCode?: boolean
    productFullName?: boolean
    category?: boolean
    shortNameMorning?: boolean
    priceType?: boolean
    price?: boolean
    shippedQty?: boolean
    orderQty?: boolean
    sumWithRevaluation?: boolean
    distributionCoef?: boolean
    weightToDistribute?: boolean
    managerId?: boolean
    managerName?: boolean
    district?: boolean
    pointAddress?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
  }, ExtArgs["result"]["summaryOrderJournal"]>

  export type SummaryOrderJournalSelectScalar = {
    id?: boolean
    idn?: boolean
    shipDate?: boolean
    paymentType?: boolean
    customerId?: boolean
    customerName?: boolean
    productId?: boolean
    productCode?: boolean
    productFullName?: boolean
    category?: boolean
    shortNameMorning?: boolean
    priceType?: boolean
    price?: boolean
    shippedQty?: boolean
    orderQty?: boolean
    sumWithRevaluation?: boolean
    distributionCoef?: boolean
    weightToDistribute?: boolean
    managerId?: boolean
    managerName?: boolean
    district?: boolean
    pointAddress?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SummaryOrderJournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idn" | "shipDate" | "paymentType" | "customerId" | "customerName" | "productId" | "productCode" | "productFullName" | "category" | "shortNameMorning" | "priceType" | "price" | "shippedQty" | "orderQty" | "sumWithRevaluation" | "distributionCoef" | "weightToDistribute" | "managerId" | "managerName" | "district" | "pointAddress" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["summaryOrderJournal"]>
  export type SummaryOrderJournalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
  }
  export type SummaryOrderJournalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
  }
  export type SummaryOrderJournalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
  }

  export type $SummaryOrderJournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SummaryOrderJournal"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idn: string
      shipDate: Date
      paymentType: string | null
      customerId: number | null
      customerName: string
      productId: number | null
      productCode: string | null
      productFullName: string
      category: string | null
      shortNameMorning: string | null
      priceType: string | null
      price: Prisma.Decimal
      shippedQty: number
      orderQty: number
      sumWithRevaluation: Prisma.Decimal | null
      distributionCoef: number | null
      weightToDistribute: number | null
      managerId: string | null
      managerName: string | null
      district: string | null
      pointAddress: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["summaryOrderJournal"]>
    composites: {}
  }

  type SummaryOrderJournalGetPayload<S extends boolean | null | undefined | SummaryOrderJournalDefaultArgs> = $Result.GetResult<Prisma.$SummaryOrderJournalPayload, S>

  type SummaryOrderJournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SummaryOrderJournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SummaryOrderJournalCountAggregateInputType | true
    }

  export interface SummaryOrderJournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SummaryOrderJournal'], meta: { name: 'SummaryOrderJournal' } }
    /**
     * Find zero or one SummaryOrderJournal that matches the filter.
     * @param {SummaryOrderJournalFindUniqueArgs} args - Arguments to find a SummaryOrderJournal
     * @example
     * // Get one SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SummaryOrderJournalFindUniqueArgs>(args: SelectSubset<T, SummaryOrderJournalFindUniqueArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SummaryOrderJournal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SummaryOrderJournalFindUniqueOrThrowArgs} args - Arguments to find a SummaryOrderJournal
     * @example
     * // Get one SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SummaryOrderJournalFindUniqueOrThrowArgs>(args: SelectSubset<T, SummaryOrderJournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummaryOrderJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalFindFirstArgs} args - Arguments to find a SummaryOrderJournal
     * @example
     * // Get one SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SummaryOrderJournalFindFirstArgs>(args?: SelectSubset<T, SummaryOrderJournalFindFirstArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummaryOrderJournal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalFindFirstOrThrowArgs} args - Arguments to find a SummaryOrderJournal
     * @example
     * // Get one SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SummaryOrderJournalFindFirstOrThrowArgs>(args?: SelectSubset<T, SummaryOrderJournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SummaryOrderJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SummaryOrderJournals
     * const summaryOrderJournals = await prisma.summaryOrderJournal.findMany()
     * 
     * // Get first 10 SummaryOrderJournals
     * const summaryOrderJournals = await prisma.summaryOrderJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const summaryOrderJournalWithIdOnly = await prisma.summaryOrderJournal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SummaryOrderJournalFindManyArgs>(args?: SelectSubset<T, SummaryOrderJournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SummaryOrderJournal.
     * @param {SummaryOrderJournalCreateArgs} args - Arguments to create a SummaryOrderJournal.
     * @example
     * // Create one SummaryOrderJournal
     * const SummaryOrderJournal = await prisma.summaryOrderJournal.create({
     *   data: {
     *     // ... data to create a SummaryOrderJournal
     *   }
     * })
     * 
     */
    create<T extends SummaryOrderJournalCreateArgs>(args: SelectSubset<T, SummaryOrderJournalCreateArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SummaryOrderJournals.
     * @param {SummaryOrderJournalCreateManyArgs} args - Arguments to create many SummaryOrderJournals.
     * @example
     * // Create many SummaryOrderJournals
     * const summaryOrderJournal = await prisma.summaryOrderJournal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SummaryOrderJournalCreateManyArgs>(args?: SelectSubset<T, SummaryOrderJournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SummaryOrderJournals and returns the data saved in the database.
     * @param {SummaryOrderJournalCreateManyAndReturnArgs} args - Arguments to create many SummaryOrderJournals.
     * @example
     * // Create many SummaryOrderJournals
     * const summaryOrderJournal = await prisma.summaryOrderJournal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SummaryOrderJournals and only return the `id`
     * const summaryOrderJournalWithIdOnly = await prisma.summaryOrderJournal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SummaryOrderJournalCreateManyAndReturnArgs>(args?: SelectSubset<T, SummaryOrderJournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SummaryOrderJournal.
     * @param {SummaryOrderJournalDeleteArgs} args - Arguments to delete one SummaryOrderJournal.
     * @example
     * // Delete one SummaryOrderJournal
     * const SummaryOrderJournal = await prisma.summaryOrderJournal.delete({
     *   where: {
     *     // ... filter to delete one SummaryOrderJournal
     *   }
     * })
     * 
     */
    delete<T extends SummaryOrderJournalDeleteArgs>(args: SelectSubset<T, SummaryOrderJournalDeleteArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SummaryOrderJournal.
     * @param {SummaryOrderJournalUpdateArgs} args - Arguments to update one SummaryOrderJournal.
     * @example
     * // Update one SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SummaryOrderJournalUpdateArgs>(args: SelectSubset<T, SummaryOrderJournalUpdateArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SummaryOrderJournals.
     * @param {SummaryOrderJournalDeleteManyArgs} args - Arguments to filter SummaryOrderJournals to delete.
     * @example
     * // Delete a few SummaryOrderJournals
     * const { count } = await prisma.summaryOrderJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SummaryOrderJournalDeleteManyArgs>(args?: SelectSubset<T, SummaryOrderJournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummaryOrderJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SummaryOrderJournals
     * const summaryOrderJournal = await prisma.summaryOrderJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SummaryOrderJournalUpdateManyArgs>(args: SelectSubset<T, SummaryOrderJournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummaryOrderJournals and returns the data updated in the database.
     * @param {SummaryOrderJournalUpdateManyAndReturnArgs} args - Arguments to update many SummaryOrderJournals.
     * @example
     * // Update many SummaryOrderJournals
     * const summaryOrderJournal = await prisma.summaryOrderJournal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SummaryOrderJournals and only return the `id`
     * const summaryOrderJournalWithIdOnly = await prisma.summaryOrderJournal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SummaryOrderJournalUpdateManyAndReturnArgs>(args: SelectSubset<T, SummaryOrderJournalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SummaryOrderJournal.
     * @param {SummaryOrderJournalUpsertArgs} args - Arguments to update or create a SummaryOrderJournal.
     * @example
     * // Update or create a SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.upsert({
     *   create: {
     *     // ... data to create a SummaryOrderJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SummaryOrderJournal we want to update
     *   }
     * })
     */
    upsert<T extends SummaryOrderJournalUpsertArgs>(args: SelectSubset<T, SummaryOrderJournalUpsertArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SummaryOrderJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalCountArgs} args - Arguments to filter SummaryOrderJournals to count.
     * @example
     * // Count the number of SummaryOrderJournals
     * const count = await prisma.summaryOrderJournal.count({
     *   where: {
     *     // ... the filter for the SummaryOrderJournals we want to count
     *   }
     * })
    **/
    count<T extends SummaryOrderJournalCountArgs>(
      args?: Subset<T, SummaryOrderJournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SummaryOrderJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SummaryOrderJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SummaryOrderJournalAggregateArgs>(args: Subset<T, SummaryOrderJournalAggregateArgs>): Prisma.PrismaPromise<GetSummaryOrderJournalAggregateType<T>>

    /**
     * Group by SummaryOrderJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SummaryOrderJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SummaryOrderJournalGroupByArgs['orderBy'] }
        : { orderBy?: SummaryOrderJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SummaryOrderJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSummaryOrderJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SummaryOrderJournal model
   */
  readonly fields: SummaryOrderJournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SummaryOrderJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SummaryOrderJournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends SummaryOrderJournal$customerArgs<ExtArgs> = {}>(args?: Subset<T, SummaryOrderJournal$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends SummaryOrderJournal$productArgs<ExtArgs> = {}>(args?: Subset<T, SummaryOrderJournal$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SummaryOrderJournal model
   */
  interface SummaryOrderJournalFieldRefs {
    readonly id: FieldRef<"SummaryOrderJournal", 'Int'>
    readonly idn: FieldRef<"SummaryOrderJournal", 'String'>
    readonly shipDate: FieldRef<"SummaryOrderJournal", 'DateTime'>
    readonly paymentType: FieldRef<"SummaryOrderJournal", 'String'>
    readonly customerId: FieldRef<"SummaryOrderJournal", 'Int'>
    readonly customerName: FieldRef<"SummaryOrderJournal", 'String'>
    readonly productId: FieldRef<"SummaryOrderJournal", 'Int'>
    readonly productCode: FieldRef<"SummaryOrderJournal", 'String'>
    readonly productFullName: FieldRef<"SummaryOrderJournal", 'String'>
    readonly category: FieldRef<"SummaryOrderJournal", 'String'>
    readonly shortNameMorning: FieldRef<"SummaryOrderJournal", 'String'>
    readonly priceType: FieldRef<"SummaryOrderJournal", 'String'>
    readonly price: FieldRef<"SummaryOrderJournal", 'Decimal'>
    readonly shippedQty: FieldRef<"SummaryOrderJournal", 'Float'>
    readonly orderQty: FieldRef<"SummaryOrderJournal", 'Float'>
    readonly sumWithRevaluation: FieldRef<"SummaryOrderJournal", 'Decimal'>
    readonly distributionCoef: FieldRef<"SummaryOrderJournal", 'Float'>
    readonly weightToDistribute: FieldRef<"SummaryOrderJournal", 'Float'>
    readonly managerId: FieldRef<"SummaryOrderJournal", 'String'>
    readonly managerName: FieldRef<"SummaryOrderJournal", 'String'>
    readonly district: FieldRef<"SummaryOrderJournal", 'String'>
    readonly pointAddress: FieldRef<"SummaryOrderJournal", 'String'>
    readonly status: FieldRef<"SummaryOrderJournal", 'String'>
    readonly createdAt: FieldRef<"SummaryOrderJournal", 'DateTime'>
    readonly updatedAt: FieldRef<"SummaryOrderJournal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SummaryOrderJournal findUnique
   */
  export type SummaryOrderJournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderJournal to fetch.
     */
    where: SummaryOrderJournalWhereUniqueInput
  }

  /**
   * SummaryOrderJournal findUniqueOrThrow
   */
  export type SummaryOrderJournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderJournal to fetch.
     */
    where: SummaryOrderJournalWhereUniqueInput
  }

  /**
   * SummaryOrderJournal findFirst
   */
  export type SummaryOrderJournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderJournal to fetch.
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderJournals to fetch.
     */
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummaryOrderJournals.
     */
    cursor?: SummaryOrderJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummaryOrderJournals.
     */
    distinct?: SummaryOrderJournalScalarFieldEnum | SummaryOrderJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrderJournal findFirstOrThrow
   */
  export type SummaryOrderJournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderJournal to fetch.
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderJournals to fetch.
     */
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummaryOrderJournals.
     */
    cursor?: SummaryOrderJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummaryOrderJournals.
     */
    distinct?: SummaryOrderJournalScalarFieldEnum | SummaryOrderJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrderJournal findMany
   */
  export type SummaryOrderJournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderJournals to fetch.
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderJournals to fetch.
     */
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SummaryOrderJournals.
     */
    cursor?: SummaryOrderJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderJournals.
     */
    skip?: number
    distinct?: SummaryOrderJournalScalarFieldEnum | SummaryOrderJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrderJournal create
   */
  export type SummaryOrderJournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * The data needed to create a SummaryOrderJournal.
     */
    data: XOR<SummaryOrderJournalCreateInput, SummaryOrderJournalUncheckedCreateInput>
  }

  /**
   * SummaryOrderJournal createMany
   */
  export type SummaryOrderJournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SummaryOrderJournals.
     */
    data: SummaryOrderJournalCreateManyInput | SummaryOrderJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SummaryOrderJournal createManyAndReturn
   */
  export type SummaryOrderJournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * The data used to create many SummaryOrderJournals.
     */
    data: SummaryOrderJournalCreateManyInput | SummaryOrderJournalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SummaryOrderJournal update
   */
  export type SummaryOrderJournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * The data needed to update a SummaryOrderJournal.
     */
    data: XOR<SummaryOrderJournalUpdateInput, SummaryOrderJournalUncheckedUpdateInput>
    /**
     * Choose, which SummaryOrderJournal to update.
     */
    where: SummaryOrderJournalWhereUniqueInput
  }

  /**
   * SummaryOrderJournal updateMany
   */
  export type SummaryOrderJournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SummaryOrderJournals.
     */
    data: XOR<SummaryOrderJournalUpdateManyMutationInput, SummaryOrderJournalUncheckedUpdateManyInput>
    /**
     * Filter which SummaryOrderJournals to update
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * Limit how many SummaryOrderJournals to update.
     */
    limit?: number
  }

  /**
   * SummaryOrderJournal updateManyAndReturn
   */
  export type SummaryOrderJournalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * The data used to update SummaryOrderJournals.
     */
    data: XOR<SummaryOrderJournalUpdateManyMutationInput, SummaryOrderJournalUncheckedUpdateManyInput>
    /**
     * Filter which SummaryOrderJournals to update
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * Limit how many SummaryOrderJournals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SummaryOrderJournal upsert
   */
  export type SummaryOrderJournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * The filter to search for the SummaryOrderJournal to update in case it exists.
     */
    where: SummaryOrderJournalWhereUniqueInput
    /**
     * In case the SummaryOrderJournal found by the `where` argument doesn't exist, create a new SummaryOrderJournal with this data.
     */
    create: XOR<SummaryOrderJournalCreateInput, SummaryOrderJournalUncheckedCreateInput>
    /**
     * In case the SummaryOrderJournal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SummaryOrderJournalUpdateInput, SummaryOrderJournalUncheckedUpdateInput>
  }

  /**
   * SummaryOrderJournal delete
   */
  export type SummaryOrderJournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter which SummaryOrderJournal to delete.
     */
    where: SummaryOrderJournalWhereUniqueInput
  }

  /**
   * SummaryOrderJournal deleteMany
   */
  export type SummaryOrderJournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummaryOrderJournals to delete
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * Limit how many SummaryOrderJournals to delete.
     */
    limit?: number
  }

  /**
   * SummaryOrderJournal.customer
   */
  export type SummaryOrderJournal$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * SummaryOrderJournal.product
   */
  export type SummaryOrderJournal$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * SummaryOrderJournal without action
   */
  export type SummaryOrderJournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
  }


  /**
   * Model SummaryOrdersJournal
   */

  export type AggregateSummaryOrdersJournal = {
    _count: SummaryOrdersJournalCountAggregateOutputType | null
    _avg: SummaryOrdersJournalAvgAggregateOutputType | null
    _sum: SummaryOrdersJournalSumAggregateOutputType | null
    _min: SummaryOrdersJournalMinAggregateOutputType | null
    _max: SummaryOrdersJournalMaxAggregateOutputType | null
  }

  export type SummaryOrdersJournalAvgAggregateOutputType = {
    id: number | null
  }

  export type SummaryOrdersJournalSumAggregateOutputType = {
    id: number | null
  }

  export type SummaryOrdersJournalMinAggregateOutputType = {
    id: number | null
    summaryDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    isHidden: boolean | null
  }

  export type SummaryOrdersJournalMaxAggregateOutputType = {
    id: number | null
    summaryDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    isHidden: boolean | null
  }

  export type SummaryOrdersJournalCountAggregateOutputType = {
    id: number
    summaryDate: number
    createdAt: number
    createdBy: number
    isHidden: number
    data: number
    _all: number
  }


  export type SummaryOrdersJournalAvgAggregateInputType = {
    id?: true
  }

  export type SummaryOrdersJournalSumAggregateInputType = {
    id?: true
  }

  export type SummaryOrdersJournalMinAggregateInputType = {
    id?: true
    summaryDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
  }

  export type SummaryOrdersJournalMaxAggregateInputType = {
    id?: true
    summaryDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
  }

  export type SummaryOrdersJournalCountAggregateInputType = {
    id?: true
    summaryDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
    data?: true
    _all?: true
  }

  export type SummaryOrdersJournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummaryOrdersJournal to aggregate.
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrdersJournals to fetch.
     */
    orderBy?: SummaryOrdersJournalOrderByWithRelationInput | SummaryOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SummaryOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SummaryOrdersJournals
    **/
    _count?: true | SummaryOrdersJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SummaryOrdersJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SummaryOrdersJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SummaryOrdersJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SummaryOrdersJournalMaxAggregateInputType
  }

  export type GetSummaryOrdersJournalAggregateType<T extends SummaryOrdersJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateSummaryOrdersJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSummaryOrdersJournal[P]>
      : GetScalarType<T[P], AggregateSummaryOrdersJournal[P]>
  }




  export type SummaryOrdersJournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummaryOrdersJournalWhereInput
    orderBy?: SummaryOrdersJournalOrderByWithAggregationInput | SummaryOrdersJournalOrderByWithAggregationInput[]
    by: SummaryOrdersJournalScalarFieldEnum[] | SummaryOrdersJournalScalarFieldEnum
    having?: SummaryOrdersJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SummaryOrdersJournalCountAggregateInputType | true
    _avg?: SummaryOrdersJournalAvgAggregateInputType
    _sum?: SummaryOrdersJournalSumAggregateInputType
    _min?: SummaryOrdersJournalMinAggregateInputType
    _max?: SummaryOrdersJournalMaxAggregateInputType
  }

  export type SummaryOrdersJournalGroupByOutputType = {
    id: number
    summaryDate: Date
    createdAt: Date
    createdBy: string
    isHidden: boolean
    data: JsonValue
    _count: SummaryOrdersJournalCountAggregateOutputType | null
    _avg: SummaryOrdersJournalAvgAggregateOutputType | null
    _sum: SummaryOrdersJournalSumAggregateOutputType | null
    _min: SummaryOrdersJournalMinAggregateOutputType | null
    _max: SummaryOrdersJournalMaxAggregateOutputType | null
  }

  type GetSummaryOrdersJournalGroupByPayload<T extends SummaryOrdersJournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SummaryOrdersJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SummaryOrdersJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SummaryOrdersJournalGroupByOutputType[P]>
            : GetScalarType<T[P], SummaryOrdersJournalGroupByOutputType[P]>
        }
      >
    >


  export type SummaryOrdersJournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    summaryDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    data?: boolean
  }, ExtArgs["result"]["summaryOrdersJournal"]>

  export type SummaryOrdersJournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    summaryDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    data?: boolean
  }, ExtArgs["result"]["summaryOrdersJournal"]>

  export type SummaryOrdersJournalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    summaryDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    data?: boolean
  }, ExtArgs["result"]["summaryOrdersJournal"]>

  export type SummaryOrdersJournalSelectScalar = {
    id?: boolean
    summaryDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    data?: boolean
  }

  export type SummaryOrdersJournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "summaryDate" | "createdAt" | "createdBy" | "isHidden" | "data", ExtArgs["result"]["summaryOrdersJournal"]>

  export type $SummaryOrdersJournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SummaryOrdersJournal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      summaryDate: Date
      createdAt: Date
      createdBy: string
      isHidden: boolean
      data: Prisma.JsonValue
    }, ExtArgs["result"]["summaryOrdersJournal"]>
    composites: {}
  }

  type SummaryOrdersJournalGetPayload<S extends boolean | null | undefined | SummaryOrdersJournalDefaultArgs> = $Result.GetResult<Prisma.$SummaryOrdersJournalPayload, S>

  type SummaryOrdersJournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SummaryOrdersJournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SummaryOrdersJournalCountAggregateInputType | true
    }

  export interface SummaryOrdersJournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SummaryOrdersJournal'], meta: { name: 'SummaryOrdersJournal' } }
    /**
     * Find zero or one SummaryOrdersJournal that matches the filter.
     * @param {SummaryOrdersJournalFindUniqueArgs} args - Arguments to find a SummaryOrdersJournal
     * @example
     * // Get one SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SummaryOrdersJournalFindUniqueArgs>(args: SelectSubset<T, SummaryOrdersJournalFindUniqueArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SummaryOrdersJournal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SummaryOrdersJournalFindUniqueOrThrowArgs} args - Arguments to find a SummaryOrdersJournal
     * @example
     * // Get one SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SummaryOrdersJournalFindUniqueOrThrowArgs>(args: SelectSubset<T, SummaryOrdersJournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummaryOrdersJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalFindFirstArgs} args - Arguments to find a SummaryOrdersJournal
     * @example
     * // Get one SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SummaryOrdersJournalFindFirstArgs>(args?: SelectSubset<T, SummaryOrdersJournalFindFirstArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummaryOrdersJournal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalFindFirstOrThrowArgs} args - Arguments to find a SummaryOrdersJournal
     * @example
     * // Get one SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SummaryOrdersJournalFindFirstOrThrowArgs>(args?: SelectSubset<T, SummaryOrdersJournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SummaryOrdersJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SummaryOrdersJournals
     * const summaryOrdersJournals = await prisma.summaryOrdersJournal.findMany()
     * 
     * // Get first 10 SummaryOrdersJournals
     * const summaryOrdersJournals = await prisma.summaryOrdersJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const summaryOrdersJournalWithIdOnly = await prisma.summaryOrdersJournal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SummaryOrdersJournalFindManyArgs>(args?: SelectSubset<T, SummaryOrdersJournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SummaryOrdersJournal.
     * @param {SummaryOrdersJournalCreateArgs} args - Arguments to create a SummaryOrdersJournal.
     * @example
     * // Create one SummaryOrdersJournal
     * const SummaryOrdersJournal = await prisma.summaryOrdersJournal.create({
     *   data: {
     *     // ... data to create a SummaryOrdersJournal
     *   }
     * })
     * 
     */
    create<T extends SummaryOrdersJournalCreateArgs>(args: SelectSubset<T, SummaryOrdersJournalCreateArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SummaryOrdersJournals.
     * @param {SummaryOrdersJournalCreateManyArgs} args - Arguments to create many SummaryOrdersJournals.
     * @example
     * // Create many SummaryOrdersJournals
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SummaryOrdersJournalCreateManyArgs>(args?: SelectSubset<T, SummaryOrdersJournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SummaryOrdersJournals and returns the data saved in the database.
     * @param {SummaryOrdersJournalCreateManyAndReturnArgs} args - Arguments to create many SummaryOrdersJournals.
     * @example
     * // Create many SummaryOrdersJournals
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SummaryOrdersJournals and only return the `id`
     * const summaryOrdersJournalWithIdOnly = await prisma.summaryOrdersJournal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SummaryOrdersJournalCreateManyAndReturnArgs>(args?: SelectSubset<T, SummaryOrdersJournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SummaryOrdersJournal.
     * @param {SummaryOrdersJournalDeleteArgs} args - Arguments to delete one SummaryOrdersJournal.
     * @example
     * // Delete one SummaryOrdersJournal
     * const SummaryOrdersJournal = await prisma.summaryOrdersJournal.delete({
     *   where: {
     *     // ... filter to delete one SummaryOrdersJournal
     *   }
     * })
     * 
     */
    delete<T extends SummaryOrdersJournalDeleteArgs>(args: SelectSubset<T, SummaryOrdersJournalDeleteArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SummaryOrdersJournal.
     * @param {SummaryOrdersJournalUpdateArgs} args - Arguments to update one SummaryOrdersJournal.
     * @example
     * // Update one SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SummaryOrdersJournalUpdateArgs>(args: SelectSubset<T, SummaryOrdersJournalUpdateArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SummaryOrdersJournals.
     * @param {SummaryOrdersJournalDeleteManyArgs} args - Arguments to filter SummaryOrdersJournals to delete.
     * @example
     * // Delete a few SummaryOrdersJournals
     * const { count } = await prisma.summaryOrdersJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SummaryOrdersJournalDeleteManyArgs>(args?: SelectSubset<T, SummaryOrdersJournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummaryOrdersJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SummaryOrdersJournals
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SummaryOrdersJournalUpdateManyArgs>(args: SelectSubset<T, SummaryOrdersJournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummaryOrdersJournals and returns the data updated in the database.
     * @param {SummaryOrdersJournalUpdateManyAndReturnArgs} args - Arguments to update many SummaryOrdersJournals.
     * @example
     * // Update many SummaryOrdersJournals
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SummaryOrdersJournals and only return the `id`
     * const summaryOrdersJournalWithIdOnly = await prisma.summaryOrdersJournal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SummaryOrdersJournalUpdateManyAndReturnArgs>(args: SelectSubset<T, SummaryOrdersJournalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SummaryOrdersJournal.
     * @param {SummaryOrdersJournalUpsertArgs} args - Arguments to update or create a SummaryOrdersJournal.
     * @example
     * // Update or create a SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.upsert({
     *   create: {
     *     // ... data to create a SummaryOrdersJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SummaryOrdersJournal we want to update
     *   }
     * })
     */
    upsert<T extends SummaryOrdersJournalUpsertArgs>(args: SelectSubset<T, SummaryOrdersJournalUpsertArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SummaryOrdersJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalCountArgs} args - Arguments to filter SummaryOrdersJournals to count.
     * @example
     * // Count the number of SummaryOrdersJournals
     * const count = await prisma.summaryOrdersJournal.count({
     *   where: {
     *     // ... the filter for the SummaryOrdersJournals we want to count
     *   }
     * })
    **/
    count<T extends SummaryOrdersJournalCountArgs>(
      args?: Subset<T, SummaryOrdersJournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SummaryOrdersJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SummaryOrdersJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SummaryOrdersJournalAggregateArgs>(args: Subset<T, SummaryOrdersJournalAggregateArgs>): Prisma.PrismaPromise<GetSummaryOrdersJournalAggregateType<T>>

    /**
     * Group by SummaryOrdersJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SummaryOrdersJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SummaryOrdersJournalGroupByArgs['orderBy'] }
        : { orderBy?: SummaryOrdersJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SummaryOrdersJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSummaryOrdersJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SummaryOrdersJournal model
   */
  readonly fields: SummaryOrdersJournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SummaryOrdersJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SummaryOrdersJournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SummaryOrdersJournal model
   */
  interface SummaryOrdersJournalFieldRefs {
    readonly id: FieldRef<"SummaryOrdersJournal", 'Int'>
    readonly summaryDate: FieldRef<"SummaryOrdersJournal", 'DateTime'>
    readonly createdAt: FieldRef<"SummaryOrdersJournal", 'DateTime'>
    readonly createdBy: FieldRef<"SummaryOrdersJournal", 'String'>
    readonly isHidden: FieldRef<"SummaryOrdersJournal", 'Boolean'>
    readonly data: FieldRef<"SummaryOrdersJournal", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SummaryOrdersJournal findUnique
   */
  export type SummaryOrdersJournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which SummaryOrdersJournal to fetch.
     */
    where: SummaryOrdersJournalWhereUniqueInput
  }

  /**
   * SummaryOrdersJournal findUniqueOrThrow
   */
  export type SummaryOrdersJournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which SummaryOrdersJournal to fetch.
     */
    where: SummaryOrdersJournalWhereUniqueInput
  }

  /**
   * SummaryOrdersJournal findFirst
   */
  export type SummaryOrdersJournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which SummaryOrdersJournal to fetch.
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrdersJournals to fetch.
     */
    orderBy?: SummaryOrdersJournalOrderByWithRelationInput | SummaryOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummaryOrdersJournals.
     */
    cursor?: SummaryOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummaryOrdersJournals.
     */
    distinct?: SummaryOrdersJournalScalarFieldEnum | SummaryOrdersJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrdersJournal findFirstOrThrow
   */
  export type SummaryOrdersJournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which SummaryOrdersJournal to fetch.
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrdersJournals to fetch.
     */
    orderBy?: SummaryOrdersJournalOrderByWithRelationInput | SummaryOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummaryOrdersJournals.
     */
    cursor?: SummaryOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummaryOrdersJournals.
     */
    distinct?: SummaryOrdersJournalScalarFieldEnum | SummaryOrdersJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrdersJournal findMany
   */
  export type SummaryOrdersJournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which SummaryOrdersJournals to fetch.
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrdersJournals to fetch.
     */
    orderBy?: SummaryOrdersJournalOrderByWithRelationInput | SummaryOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SummaryOrdersJournals.
     */
    cursor?: SummaryOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrdersJournals.
     */
    skip?: number
    distinct?: SummaryOrdersJournalScalarFieldEnum | SummaryOrdersJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrdersJournal create
   */
  export type SummaryOrdersJournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * The data needed to create a SummaryOrdersJournal.
     */
    data: XOR<SummaryOrdersJournalCreateInput, SummaryOrdersJournalUncheckedCreateInput>
  }

  /**
   * SummaryOrdersJournal createMany
   */
  export type SummaryOrdersJournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SummaryOrdersJournals.
     */
    data: SummaryOrdersJournalCreateManyInput | SummaryOrdersJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SummaryOrdersJournal createManyAndReturn
   */
  export type SummaryOrdersJournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * The data used to create many SummaryOrdersJournals.
     */
    data: SummaryOrdersJournalCreateManyInput | SummaryOrdersJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SummaryOrdersJournal update
   */
  export type SummaryOrdersJournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * The data needed to update a SummaryOrdersJournal.
     */
    data: XOR<SummaryOrdersJournalUpdateInput, SummaryOrdersJournalUncheckedUpdateInput>
    /**
     * Choose, which SummaryOrdersJournal to update.
     */
    where: SummaryOrdersJournalWhereUniqueInput
  }

  /**
   * SummaryOrdersJournal updateMany
   */
  export type SummaryOrdersJournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SummaryOrdersJournals.
     */
    data: XOR<SummaryOrdersJournalUpdateManyMutationInput, SummaryOrdersJournalUncheckedUpdateManyInput>
    /**
     * Filter which SummaryOrdersJournals to update
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * Limit how many SummaryOrdersJournals to update.
     */
    limit?: number
  }

  /**
   * SummaryOrdersJournal updateManyAndReturn
   */
  export type SummaryOrdersJournalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * The data used to update SummaryOrdersJournals.
     */
    data: XOR<SummaryOrdersJournalUpdateManyMutationInput, SummaryOrdersJournalUncheckedUpdateManyInput>
    /**
     * Filter which SummaryOrdersJournals to update
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * Limit how many SummaryOrdersJournals to update.
     */
    limit?: number
  }

  /**
   * SummaryOrdersJournal upsert
   */
  export type SummaryOrdersJournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * The filter to search for the SummaryOrdersJournal to update in case it exists.
     */
    where: SummaryOrdersJournalWhereUniqueInput
    /**
     * In case the SummaryOrdersJournal found by the `where` argument doesn't exist, create a new SummaryOrdersJournal with this data.
     */
    create: XOR<SummaryOrdersJournalCreateInput, SummaryOrdersJournalUncheckedCreateInput>
    /**
     * In case the SummaryOrdersJournal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SummaryOrdersJournalUpdateInput, SummaryOrdersJournalUncheckedUpdateInput>
  }

  /**
   * SummaryOrdersJournal delete
   */
  export type SummaryOrdersJournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter which SummaryOrdersJournal to delete.
     */
    where: SummaryOrdersJournalWhereUniqueInput
  }

  /**
   * SummaryOrdersJournal deleteMany
   */
  export type SummaryOrdersJournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummaryOrdersJournals to delete
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * Limit how many SummaryOrdersJournals to delete.
     */
    limit?: number
  }

  /**
   * SummaryOrdersJournal without action
   */
  export type SummaryOrdersJournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
  }


  /**
   * Model AssemblyOrdersJournal
   */

  export type AggregateAssemblyOrdersJournal = {
    _count: AssemblyOrdersJournalCountAggregateOutputType | null
    _avg: AssemblyOrdersJournalAvgAggregateOutputType | null
    _sum: AssemblyOrdersJournalSumAggregateOutputType | null
    _min: AssemblyOrdersJournalMinAggregateOutputType | null
    _max: AssemblyOrdersJournalMaxAggregateOutputType | null
  }

  export type AssemblyOrdersJournalAvgAggregateOutputType = {
    id: number | null
    sourceSummaryId: number | null
  }

  export type AssemblyOrdersJournalSumAggregateOutputType = {
    id: number | null
    sourceSummaryId: number | null
  }

  export type AssemblyOrdersJournalMinAggregateOutputType = {
    id: number | null
    assemblyDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    isHidden: boolean | null
    sourceSummaryId: number | null
  }

  export type AssemblyOrdersJournalMaxAggregateOutputType = {
    id: number | null
    assemblyDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    isHidden: boolean | null
    sourceSummaryId: number | null
  }

  export type AssemblyOrdersJournalCountAggregateOutputType = {
    id: number
    assemblyDate: number
    createdAt: number
    createdBy: number
    isHidden: number
    sourceSummaryId: number
    data: number
    _all: number
  }


  export type AssemblyOrdersJournalAvgAggregateInputType = {
    id?: true
    sourceSummaryId?: true
  }

  export type AssemblyOrdersJournalSumAggregateInputType = {
    id?: true
    sourceSummaryId?: true
  }

  export type AssemblyOrdersJournalMinAggregateInputType = {
    id?: true
    assemblyDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
    sourceSummaryId?: true
  }

  export type AssemblyOrdersJournalMaxAggregateInputType = {
    id?: true
    assemblyDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
    sourceSummaryId?: true
  }

  export type AssemblyOrdersJournalCountAggregateInputType = {
    id?: true
    assemblyDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
    sourceSummaryId?: true
    data?: true
    _all?: true
  }

  export type AssemblyOrdersJournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssemblyOrdersJournal to aggregate.
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssemblyOrdersJournals to fetch.
     */
    orderBy?: AssemblyOrdersJournalOrderByWithRelationInput | AssemblyOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssemblyOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssemblyOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssemblyOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssemblyOrdersJournals
    **/
    _count?: true | AssemblyOrdersJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssemblyOrdersJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssemblyOrdersJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssemblyOrdersJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssemblyOrdersJournalMaxAggregateInputType
  }

  export type GetAssemblyOrdersJournalAggregateType<T extends AssemblyOrdersJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateAssemblyOrdersJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssemblyOrdersJournal[P]>
      : GetScalarType<T[P], AggregateAssemblyOrdersJournal[P]>
  }




  export type AssemblyOrdersJournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssemblyOrdersJournalWhereInput
    orderBy?: AssemblyOrdersJournalOrderByWithAggregationInput | AssemblyOrdersJournalOrderByWithAggregationInput[]
    by: AssemblyOrdersJournalScalarFieldEnum[] | AssemblyOrdersJournalScalarFieldEnum
    having?: AssemblyOrdersJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssemblyOrdersJournalCountAggregateInputType | true
    _avg?: AssemblyOrdersJournalAvgAggregateInputType
    _sum?: AssemblyOrdersJournalSumAggregateInputType
    _min?: AssemblyOrdersJournalMinAggregateInputType
    _max?: AssemblyOrdersJournalMaxAggregateInputType
  }

  export type AssemblyOrdersJournalGroupByOutputType = {
    id: number
    assemblyDate: Date
    createdAt: Date
    createdBy: string
    isHidden: boolean
    sourceSummaryId: number | null
    data: JsonValue
    _count: AssemblyOrdersJournalCountAggregateOutputType | null
    _avg: AssemblyOrdersJournalAvgAggregateOutputType | null
    _sum: AssemblyOrdersJournalSumAggregateOutputType | null
    _min: AssemblyOrdersJournalMinAggregateOutputType | null
    _max: AssemblyOrdersJournalMaxAggregateOutputType | null
  }

  type GetAssemblyOrdersJournalGroupByPayload<T extends AssemblyOrdersJournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssemblyOrdersJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssemblyOrdersJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssemblyOrdersJournalGroupByOutputType[P]>
            : GetScalarType<T[P], AssemblyOrdersJournalGroupByOutputType[P]>
        }
      >
    >


  export type AssemblyOrdersJournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assemblyDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    sourceSummaryId?: boolean
    data?: boolean
  }, ExtArgs["result"]["assemblyOrdersJournal"]>

  export type AssemblyOrdersJournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assemblyDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    sourceSummaryId?: boolean
    data?: boolean
  }, ExtArgs["result"]["assemblyOrdersJournal"]>

  export type AssemblyOrdersJournalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assemblyDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    sourceSummaryId?: boolean
    data?: boolean
  }, ExtArgs["result"]["assemblyOrdersJournal"]>

  export type AssemblyOrdersJournalSelectScalar = {
    id?: boolean
    assemblyDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    sourceSummaryId?: boolean
    data?: boolean
  }

  export type AssemblyOrdersJournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assemblyDate" | "createdAt" | "createdBy" | "isHidden" | "sourceSummaryId" | "data", ExtArgs["result"]["assemblyOrdersJournal"]>

  export type $AssemblyOrdersJournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssemblyOrdersJournal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assemblyDate: Date
      createdAt: Date
      createdBy: string
      isHidden: boolean
      sourceSummaryId: number | null
      data: Prisma.JsonValue
    }, ExtArgs["result"]["assemblyOrdersJournal"]>
    composites: {}
  }

  type AssemblyOrdersJournalGetPayload<S extends boolean | null | undefined | AssemblyOrdersJournalDefaultArgs> = $Result.GetResult<Prisma.$AssemblyOrdersJournalPayload, S>

  type AssemblyOrdersJournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssemblyOrdersJournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssemblyOrdersJournalCountAggregateInputType | true
    }

  export interface AssemblyOrdersJournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssemblyOrdersJournal'], meta: { name: 'AssemblyOrdersJournal' } }
    /**
     * Find zero or one AssemblyOrdersJournal that matches the filter.
     * @param {AssemblyOrdersJournalFindUniqueArgs} args - Arguments to find a AssemblyOrdersJournal
     * @example
     * // Get one AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssemblyOrdersJournalFindUniqueArgs>(args: SelectSubset<T, AssemblyOrdersJournalFindUniqueArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssemblyOrdersJournal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssemblyOrdersJournalFindUniqueOrThrowArgs} args - Arguments to find a AssemblyOrdersJournal
     * @example
     * // Get one AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssemblyOrdersJournalFindUniqueOrThrowArgs>(args: SelectSubset<T, AssemblyOrdersJournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssemblyOrdersJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalFindFirstArgs} args - Arguments to find a AssemblyOrdersJournal
     * @example
     * // Get one AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssemblyOrdersJournalFindFirstArgs>(args?: SelectSubset<T, AssemblyOrdersJournalFindFirstArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssemblyOrdersJournal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalFindFirstOrThrowArgs} args - Arguments to find a AssemblyOrdersJournal
     * @example
     * // Get one AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssemblyOrdersJournalFindFirstOrThrowArgs>(args?: SelectSubset<T, AssemblyOrdersJournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssemblyOrdersJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssemblyOrdersJournals
     * const assemblyOrdersJournals = await prisma.assemblyOrdersJournal.findMany()
     * 
     * // Get first 10 AssemblyOrdersJournals
     * const assemblyOrdersJournals = await prisma.assemblyOrdersJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assemblyOrdersJournalWithIdOnly = await prisma.assemblyOrdersJournal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssemblyOrdersJournalFindManyArgs>(args?: SelectSubset<T, AssemblyOrdersJournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssemblyOrdersJournal.
     * @param {AssemblyOrdersJournalCreateArgs} args - Arguments to create a AssemblyOrdersJournal.
     * @example
     * // Create one AssemblyOrdersJournal
     * const AssemblyOrdersJournal = await prisma.assemblyOrdersJournal.create({
     *   data: {
     *     // ... data to create a AssemblyOrdersJournal
     *   }
     * })
     * 
     */
    create<T extends AssemblyOrdersJournalCreateArgs>(args: SelectSubset<T, AssemblyOrdersJournalCreateArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssemblyOrdersJournals.
     * @param {AssemblyOrdersJournalCreateManyArgs} args - Arguments to create many AssemblyOrdersJournals.
     * @example
     * // Create many AssemblyOrdersJournals
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssemblyOrdersJournalCreateManyArgs>(args?: SelectSubset<T, AssemblyOrdersJournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssemblyOrdersJournals and returns the data saved in the database.
     * @param {AssemblyOrdersJournalCreateManyAndReturnArgs} args - Arguments to create many AssemblyOrdersJournals.
     * @example
     * // Create many AssemblyOrdersJournals
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssemblyOrdersJournals and only return the `id`
     * const assemblyOrdersJournalWithIdOnly = await prisma.assemblyOrdersJournal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssemblyOrdersJournalCreateManyAndReturnArgs>(args?: SelectSubset<T, AssemblyOrdersJournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssemblyOrdersJournal.
     * @param {AssemblyOrdersJournalDeleteArgs} args - Arguments to delete one AssemblyOrdersJournal.
     * @example
     * // Delete one AssemblyOrdersJournal
     * const AssemblyOrdersJournal = await prisma.assemblyOrdersJournal.delete({
     *   where: {
     *     // ... filter to delete one AssemblyOrdersJournal
     *   }
     * })
     * 
     */
    delete<T extends AssemblyOrdersJournalDeleteArgs>(args: SelectSubset<T, AssemblyOrdersJournalDeleteArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssemblyOrdersJournal.
     * @param {AssemblyOrdersJournalUpdateArgs} args - Arguments to update one AssemblyOrdersJournal.
     * @example
     * // Update one AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssemblyOrdersJournalUpdateArgs>(args: SelectSubset<T, AssemblyOrdersJournalUpdateArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssemblyOrdersJournals.
     * @param {AssemblyOrdersJournalDeleteManyArgs} args - Arguments to filter AssemblyOrdersJournals to delete.
     * @example
     * // Delete a few AssemblyOrdersJournals
     * const { count } = await prisma.assemblyOrdersJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssemblyOrdersJournalDeleteManyArgs>(args?: SelectSubset<T, AssemblyOrdersJournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssemblyOrdersJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssemblyOrdersJournals
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssemblyOrdersJournalUpdateManyArgs>(args: SelectSubset<T, AssemblyOrdersJournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssemblyOrdersJournals and returns the data updated in the database.
     * @param {AssemblyOrdersJournalUpdateManyAndReturnArgs} args - Arguments to update many AssemblyOrdersJournals.
     * @example
     * // Update many AssemblyOrdersJournals
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssemblyOrdersJournals and only return the `id`
     * const assemblyOrdersJournalWithIdOnly = await prisma.assemblyOrdersJournal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssemblyOrdersJournalUpdateManyAndReturnArgs>(args: SelectSubset<T, AssemblyOrdersJournalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssemblyOrdersJournal.
     * @param {AssemblyOrdersJournalUpsertArgs} args - Arguments to update or create a AssemblyOrdersJournal.
     * @example
     * // Update or create a AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.upsert({
     *   create: {
     *     // ... data to create a AssemblyOrdersJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssemblyOrdersJournal we want to update
     *   }
     * })
     */
    upsert<T extends AssemblyOrdersJournalUpsertArgs>(args: SelectSubset<T, AssemblyOrdersJournalUpsertArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssemblyOrdersJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalCountArgs} args - Arguments to filter AssemblyOrdersJournals to count.
     * @example
     * // Count the number of AssemblyOrdersJournals
     * const count = await prisma.assemblyOrdersJournal.count({
     *   where: {
     *     // ... the filter for the AssemblyOrdersJournals we want to count
     *   }
     * })
    **/
    count<T extends AssemblyOrdersJournalCountArgs>(
      args?: Subset<T, AssemblyOrdersJournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssemblyOrdersJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssemblyOrdersJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssemblyOrdersJournalAggregateArgs>(args: Subset<T, AssemblyOrdersJournalAggregateArgs>): Prisma.PrismaPromise<GetAssemblyOrdersJournalAggregateType<T>>

    /**
     * Group by AssemblyOrdersJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssemblyOrdersJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssemblyOrdersJournalGroupByArgs['orderBy'] }
        : { orderBy?: AssemblyOrdersJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssemblyOrdersJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssemblyOrdersJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssemblyOrdersJournal model
   */
  readonly fields: AssemblyOrdersJournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssemblyOrdersJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssemblyOrdersJournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssemblyOrdersJournal model
   */
  interface AssemblyOrdersJournalFieldRefs {
    readonly id: FieldRef<"AssemblyOrdersJournal", 'Int'>
    readonly assemblyDate: FieldRef<"AssemblyOrdersJournal", 'DateTime'>
    readonly createdAt: FieldRef<"AssemblyOrdersJournal", 'DateTime'>
    readonly createdBy: FieldRef<"AssemblyOrdersJournal", 'String'>
    readonly isHidden: FieldRef<"AssemblyOrdersJournal", 'Boolean'>
    readonly sourceSummaryId: FieldRef<"AssemblyOrdersJournal", 'Int'>
    readonly data: FieldRef<"AssemblyOrdersJournal", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AssemblyOrdersJournal findUnique
   */
  export type AssemblyOrdersJournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which AssemblyOrdersJournal to fetch.
     */
    where: AssemblyOrdersJournalWhereUniqueInput
  }

  /**
   * AssemblyOrdersJournal findUniqueOrThrow
   */
  export type AssemblyOrdersJournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which AssemblyOrdersJournal to fetch.
     */
    where: AssemblyOrdersJournalWhereUniqueInput
  }

  /**
   * AssemblyOrdersJournal findFirst
   */
  export type AssemblyOrdersJournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which AssemblyOrdersJournal to fetch.
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssemblyOrdersJournals to fetch.
     */
    orderBy?: AssemblyOrdersJournalOrderByWithRelationInput | AssemblyOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssemblyOrdersJournals.
     */
    cursor?: AssemblyOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssemblyOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssemblyOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssemblyOrdersJournals.
     */
    distinct?: AssemblyOrdersJournalScalarFieldEnum | AssemblyOrdersJournalScalarFieldEnum[]
  }

  /**
   * AssemblyOrdersJournal findFirstOrThrow
   */
  export type AssemblyOrdersJournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which AssemblyOrdersJournal to fetch.
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssemblyOrdersJournals to fetch.
     */
    orderBy?: AssemblyOrdersJournalOrderByWithRelationInput | AssemblyOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssemblyOrdersJournals.
     */
    cursor?: AssemblyOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssemblyOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssemblyOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssemblyOrdersJournals.
     */
    distinct?: AssemblyOrdersJournalScalarFieldEnum | AssemblyOrdersJournalScalarFieldEnum[]
  }

  /**
   * AssemblyOrdersJournal findMany
   */
  export type AssemblyOrdersJournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which AssemblyOrdersJournals to fetch.
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssemblyOrdersJournals to fetch.
     */
    orderBy?: AssemblyOrdersJournalOrderByWithRelationInput | AssemblyOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssemblyOrdersJournals.
     */
    cursor?: AssemblyOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssemblyOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssemblyOrdersJournals.
     */
    skip?: number
    distinct?: AssemblyOrdersJournalScalarFieldEnum | AssemblyOrdersJournalScalarFieldEnum[]
  }

  /**
   * AssemblyOrdersJournal create
   */
  export type AssemblyOrdersJournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * The data needed to create a AssemblyOrdersJournal.
     */
    data: XOR<AssemblyOrdersJournalCreateInput, AssemblyOrdersJournalUncheckedCreateInput>
  }

  /**
   * AssemblyOrdersJournal createMany
   */
  export type AssemblyOrdersJournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssemblyOrdersJournals.
     */
    data: AssemblyOrdersJournalCreateManyInput | AssemblyOrdersJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssemblyOrdersJournal createManyAndReturn
   */
  export type AssemblyOrdersJournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * The data used to create many AssemblyOrdersJournals.
     */
    data: AssemblyOrdersJournalCreateManyInput | AssemblyOrdersJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssemblyOrdersJournal update
   */
  export type AssemblyOrdersJournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * The data needed to update a AssemblyOrdersJournal.
     */
    data: XOR<AssemblyOrdersJournalUpdateInput, AssemblyOrdersJournalUncheckedUpdateInput>
    /**
     * Choose, which AssemblyOrdersJournal to update.
     */
    where: AssemblyOrdersJournalWhereUniqueInput
  }

  /**
   * AssemblyOrdersJournal updateMany
   */
  export type AssemblyOrdersJournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssemblyOrdersJournals.
     */
    data: XOR<AssemblyOrdersJournalUpdateManyMutationInput, AssemblyOrdersJournalUncheckedUpdateManyInput>
    /**
     * Filter which AssemblyOrdersJournals to update
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * Limit how many AssemblyOrdersJournals to update.
     */
    limit?: number
  }

  /**
   * AssemblyOrdersJournal updateManyAndReturn
   */
  export type AssemblyOrdersJournalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * The data used to update AssemblyOrdersJournals.
     */
    data: XOR<AssemblyOrdersJournalUpdateManyMutationInput, AssemblyOrdersJournalUncheckedUpdateManyInput>
    /**
     * Filter which AssemblyOrdersJournals to update
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * Limit how many AssemblyOrdersJournals to update.
     */
    limit?: number
  }

  /**
   * AssemblyOrdersJournal upsert
   */
  export type AssemblyOrdersJournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * The filter to search for the AssemblyOrdersJournal to update in case it exists.
     */
    where: AssemblyOrdersJournalWhereUniqueInput
    /**
     * In case the AssemblyOrdersJournal found by the `where` argument doesn't exist, create a new AssemblyOrdersJournal with this data.
     */
    create: XOR<AssemblyOrdersJournalCreateInput, AssemblyOrdersJournalUncheckedCreateInput>
    /**
     * In case the AssemblyOrdersJournal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssemblyOrdersJournalUpdateInput, AssemblyOrdersJournalUncheckedUpdateInput>
  }

  /**
   * AssemblyOrdersJournal delete
   */
  export type AssemblyOrdersJournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter which AssemblyOrdersJournal to delete.
     */
    where: AssemblyOrdersJournalWhereUniqueInput
  }

  /**
   * AssemblyOrdersJournal deleteMany
   */
  export type AssemblyOrdersJournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssemblyOrdersJournals to delete
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * Limit how many AssemblyOrdersJournals to delete.
     */
    limit?: number
  }

  /**
   * AssemblyOrdersJournal without action
   */
  export type AssemblyOrdersJournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
  }


  /**
   * Model ProductionStaff
   */

  export type AggregateProductionStaff = {
    _count: ProductionStaffCountAggregateOutputType | null
    _avg: ProductionStaffAvgAggregateOutputType | null
    _sum: ProductionStaffSumAggregateOutputType | null
    _min: ProductionStaffMinAggregateOutputType | null
    _max: ProductionStaffMaxAggregateOutputType | null
  }

  export type ProductionStaffAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProductionStaffSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProductionStaffMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    phone: string | null
    userId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionStaffMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    phone: string | null
    userId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionStaffCountAggregateOutputType = {
    id: number
    fullName: number
    phone: number
    userId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionStaffAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProductionStaffSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProductionStaffMinAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionStaffMaxAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionStaffCountAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionStaff to aggregate.
     */
    where?: ProductionStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionStaffs to fetch.
     */
    orderBy?: ProductionStaffOrderByWithRelationInput | ProductionStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionStaffs
    **/
    _count?: true | ProductionStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionStaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionStaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionStaffMaxAggregateInputType
  }

  export type GetProductionStaffAggregateType<T extends ProductionStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionStaff[P]>
      : GetScalarType<T[P], AggregateProductionStaff[P]>
  }




  export type ProductionStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionStaffWhereInput
    orderBy?: ProductionStaffOrderByWithAggregationInput | ProductionStaffOrderByWithAggregationInput[]
    by: ProductionStaffScalarFieldEnum[] | ProductionStaffScalarFieldEnum
    having?: ProductionStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionStaffCountAggregateInputType | true
    _avg?: ProductionStaffAvgAggregateInputType
    _sum?: ProductionStaffSumAggregateInputType
    _min?: ProductionStaffMinAggregateInputType
    _max?: ProductionStaffMaxAggregateInputType
  }

  export type ProductionStaffGroupByOutputType = {
    id: number
    fullName: string
    phone: string | null
    userId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductionStaffCountAggregateOutputType | null
    _avg: ProductionStaffAvgAggregateOutputType | null
    _sum: ProductionStaffSumAggregateOutputType | null
    _min: ProductionStaffMinAggregateOutputType | null
    _max: ProductionStaffMaxAggregateOutputType | null
  }

  type GetProductionStaffGroupByPayload<T extends ProductionStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionStaffGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionStaffGroupByOutputType[P]>
        }
      >
    >


  export type ProductionStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    phone?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    journals?: boolean | ProductionStaff$journalsArgs<ExtArgs>
    _count?: boolean | ProductionStaffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionStaff"]>

  export type ProductionStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    phone?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionStaff"]>

  export type ProductionStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    phone?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionStaff"]>

  export type ProductionStaffSelectScalar = {
    id?: boolean
    fullName?: boolean
    phone?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "phone" | "userId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["productionStaff"]>
  export type ProductionStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    journals?: boolean | ProductionStaff$journalsArgs<ExtArgs>
    _count?: boolean | ProductionStaffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductionStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductionStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionStaff"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      journals: Prisma.$ProductionJournalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      phone: string | null
      userId: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionStaff"]>
    composites: {}
  }

  type ProductionStaffGetPayload<S extends boolean | null | undefined | ProductionStaffDefaultArgs> = $Result.GetResult<Prisma.$ProductionStaffPayload, S>

  type ProductionStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionStaffCountAggregateInputType | true
    }

  export interface ProductionStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionStaff'], meta: { name: 'ProductionStaff' } }
    /**
     * Find zero or one ProductionStaff that matches the filter.
     * @param {ProductionStaffFindUniqueArgs} args - Arguments to find a ProductionStaff
     * @example
     * // Get one ProductionStaff
     * const productionStaff = await prisma.productionStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionStaffFindUniqueArgs>(args: SelectSubset<T, ProductionStaffFindUniqueArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionStaffFindUniqueOrThrowArgs} args - Arguments to find a ProductionStaff
     * @example
     * // Get one ProductionStaff
     * const productionStaff = await prisma.productionStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffFindFirstArgs} args - Arguments to find a ProductionStaff
     * @example
     * // Get one ProductionStaff
     * const productionStaff = await prisma.productionStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionStaffFindFirstArgs>(args?: SelectSubset<T, ProductionStaffFindFirstArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffFindFirstOrThrowArgs} args - Arguments to find a ProductionStaff
     * @example
     * // Get one ProductionStaff
     * const productionStaff = await prisma.productionStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionStaffs
     * const productionStaffs = await prisma.productionStaff.findMany()
     * 
     * // Get first 10 ProductionStaffs
     * const productionStaffs = await prisma.productionStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionStaffWithIdOnly = await prisma.productionStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionStaffFindManyArgs>(args?: SelectSubset<T, ProductionStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionStaff.
     * @param {ProductionStaffCreateArgs} args - Arguments to create a ProductionStaff.
     * @example
     * // Create one ProductionStaff
     * const ProductionStaff = await prisma.productionStaff.create({
     *   data: {
     *     // ... data to create a ProductionStaff
     *   }
     * })
     * 
     */
    create<T extends ProductionStaffCreateArgs>(args: SelectSubset<T, ProductionStaffCreateArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionStaffs.
     * @param {ProductionStaffCreateManyArgs} args - Arguments to create many ProductionStaffs.
     * @example
     * // Create many ProductionStaffs
     * const productionStaff = await prisma.productionStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionStaffCreateManyArgs>(args?: SelectSubset<T, ProductionStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionStaffs and returns the data saved in the database.
     * @param {ProductionStaffCreateManyAndReturnArgs} args - Arguments to create many ProductionStaffs.
     * @example
     * // Create many ProductionStaffs
     * const productionStaff = await prisma.productionStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionStaffs and only return the `id`
     * const productionStaffWithIdOnly = await prisma.productionStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionStaff.
     * @param {ProductionStaffDeleteArgs} args - Arguments to delete one ProductionStaff.
     * @example
     * // Delete one ProductionStaff
     * const ProductionStaff = await prisma.productionStaff.delete({
     *   where: {
     *     // ... filter to delete one ProductionStaff
     *   }
     * })
     * 
     */
    delete<T extends ProductionStaffDeleteArgs>(args: SelectSubset<T, ProductionStaffDeleteArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionStaff.
     * @param {ProductionStaffUpdateArgs} args - Arguments to update one ProductionStaff.
     * @example
     * // Update one ProductionStaff
     * const productionStaff = await prisma.productionStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionStaffUpdateArgs>(args: SelectSubset<T, ProductionStaffUpdateArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionStaffs.
     * @param {ProductionStaffDeleteManyArgs} args - Arguments to filter ProductionStaffs to delete.
     * @example
     * // Delete a few ProductionStaffs
     * const { count } = await prisma.productionStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionStaffDeleteManyArgs>(args?: SelectSubset<T, ProductionStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionStaffs
     * const productionStaff = await prisma.productionStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionStaffUpdateManyArgs>(args: SelectSubset<T, ProductionStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionStaffs and returns the data updated in the database.
     * @param {ProductionStaffUpdateManyAndReturnArgs} args - Arguments to update many ProductionStaffs.
     * @example
     * // Update many ProductionStaffs
     * const productionStaff = await prisma.productionStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionStaffs and only return the `id`
     * const productionStaffWithIdOnly = await prisma.productionStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionStaff.
     * @param {ProductionStaffUpsertArgs} args - Arguments to update or create a ProductionStaff.
     * @example
     * // Update or create a ProductionStaff
     * const productionStaff = await prisma.productionStaff.upsert({
     *   create: {
     *     // ... data to create a ProductionStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionStaff we want to update
     *   }
     * })
     */
    upsert<T extends ProductionStaffUpsertArgs>(args: SelectSubset<T, ProductionStaffUpsertArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffCountArgs} args - Arguments to filter ProductionStaffs to count.
     * @example
     * // Count the number of ProductionStaffs
     * const count = await prisma.productionStaff.count({
     *   where: {
     *     // ... the filter for the ProductionStaffs we want to count
     *   }
     * })
    **/
    count<T extends ProductionStaffCountArgs>(
      args?: Subset<T, ProductionStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionStaffAggregateArgs>(args: Subset<T, ProductionStaffAggregateArgs>): Prisma.PrismaPromise<GetProductionStaffAggregateType<T>>

    /**
     * Group by ProductionStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionStaffGroupByArgs['orderBy'] }
        : { orderBy?: ProductionStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionStaff model
   */
  readonly fields: ProductionStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    journals<T extends ProductionStaff$journalsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionStaff$journalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionStaff model
   */
  interface ProductionStaffFieldRefs {
    readonly id: FieldRef<"ProductionStaff", 'Int'>
    readonly fullName: FieldRef<"ProductionStaff", 'String'>
    readonly phone: FieldRef<"ProductionStaff", 'String'>
    readonly userId: FieldRef<"ProductionStaff", 'Int'>
    readonly isActive: FieldRef<"ProductionStaff", 'Boolean'>
    readonly createdAt: FieldRef<"ProductionStaff", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionStaff findUnique
   */
  export type ProductionStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProductionStaff to fetch.
     */
    where: ProductionStaffWhereUniqueInput
  }

  /**
   * ProductionStaff findUniqueOrThrow
   */
  export type ProductionStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProductionStaff to fetch.
     */
    where: ProductionStaffWhereUniqueInput
  }

  /**
   * ProductionStaff findFirst
   */
  export type ProductionStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProductionStaff to fetch.
     */
    where?: ProductionStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionStaffs to fetch.
     */
    orderBy?: ProductionStaffOrderByWithRelationInput | ProductionStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionStaffs.
     */
    cursor?: ProductionStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionStaffs.
     */
    distinct?: ProductionStaffScalarFieldEnum | ProductionStaffScalarFieldEnum[]
  }

  /**
   * ProductionStaff findFirstOrThrow
   */
  export type ProductionStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProductionStaff to fetch.
     */
    where?: ProductionStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionStaffs to fetch.
     */
    orderBy?: ProductionStaffOrderByWithRelationInput | ProductionStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionStaffs.
     */
    cursor?: ProductionStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionStaffs.
     */
    distinct?: ProductionStaffScalarFieldEnum | ProductionStaffScalarFieldEnum[]
  }

  /**
   * ProductionStaff findMany
   */
  export type ProductionStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProductionStaffs to fetch.
     */
    where?: ProductionStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionStaffs to fetch.
     */
    orderBy?: ProductionStaffOrderByWithRelationInput | ProductionStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionStaffs.
     */
    cursor?: ProductionStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionStaffs.
     */
    skip?: number
    distinct?: ProductionStaffScalarFieldEnum | ProductionStaffScalarFieldEnum[]
  }

  /**
   * ProductionStaff create
   */
  export type ProductionStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionStaff.
     */
    data: XOR<ProductionStaffCreateInput, ProductionStaffUncheckedCreateInput>
  }

  /**
   * ProductionStaff createMany
   */
  export type ProductionStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionStaffs.
     */
    data: ProductionStaffCreateManyInput | ProductionStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionStaff createManyAndReturn
   */
  export type ProductionStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionStaffs.
     */
    data: ProductionStaffCreateManyInput | ProductionStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionStaff update
   */
  export type ProductionStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionStaff.
     */
    data: XOR<ProductionStaffUpdateInput, ProductionStaffUncheckedUpdateInput>
    /**
     * Choose, which ProductionStaff to update.
     */
    where: ProductionStaffWhereUniqueInput
  }

  /**
   * ProductionStaff updateMany
   */
  export type ProductionStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionStaffs.
     */
    data: XOR<ProductionStaffUpdateManyMutationInput, ProductionStaffUncheckedUpdateManyInput>
    /**
     * Filter which ProductionStaffs to update
     */
    where?: ProductionStaffWhereInput
    /**
     * Limit how many ProductionStaffs to update.
     */
    limit?: number
  }

  /**
   * ProductionStaff updateManyAndReturn
   */
  export type ProductionStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * The data used to update ProductionStaffs.
     */
    data: XOR<ProductionStaffUpdateManyMutationInput, ProductionStaffUncheckedUpdateManyInput>
    /**
     * Filter which ProductionStaffs to update
     */
    where?: ProductionStaffWhereInput
    /**
     * Limit how many ProductionStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionStaff upsert
   */
  export type ProductionStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionStaff to update in case it exists.
     */
    where: ProductionStaffWhereUniqueInput
    /**
     * In case the ProductionStaff found by the `where` argument doesn't exist, create a new ProductionStaff with this data.
     */
    create: XOR<ProductionStaffCreateInput, ProductionStaffUncheckedCreateInput>
    /**
     * In case the ProductionStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionStaffUpdateInput, ProductionStaffUncheckedUpdateInput>
  }

  /**
   * ProductionStaff delete
   */
  export type ProductionStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter which ProductionStaff to delete.
     */
    where: ProductionStaffWhereUniqueInput
  }

  /**
   * ProductionStaff deleteMany
   */
  export type ProductionStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionStaffs to delete
     */
    where?: ProductionStaffWhereInput
    /**
     * Limit how many ProductionStaffs to delete.
     */
    limit?: number
  }

  /**
   * ProductionStaff.journals
   */
  export type ProductionStaff$journalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    where?: ProductionJournalWhereInput
    orderBy?: ProductionJournalOrderByWithRelationInput | ProductionJournalOrderByWithRelationInput[]
    cursor?: ProductionJournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionJournalScalarFieldEnum | ProductionJournalScalarFieldEnum[]
  }

  /**
   * ProductionStaff without action
   */
  export type ProductionStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
  }


  /**
   * Model ProductionJournal
   */

  export type AggregateProductionJournal = {
    _count: ProductionJournalCountAggregateOutputType | null
    _avg: ProductionJournalAvgAggregateOutputType | null
    _sum: ProductionJournalSumAggregateOutputType | null
    _min: ProductionJournalMinAggregateOutputType | null
    _max: ProductionJournalMaxAggregateOutputType | null
  }

  export type ProductionJournalAvgAggregateOutputType = {
    id: number | null
    staffId: number | null
  }

  export type ProductionJournalSumAggregateOutputType = {
    id: number | null
    staffId: number | null
  }

  export type ProductionJournalMinAggregateOutputType = {
    id: number | null
    productionDate: Date | null
    staffId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ProductionJournalMaxAggregateOutputType = {
    id: number | null
    productionDate: Date | null
    staffId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ProductionJournalCountAggregateOutputType = {
    id: number
    productionDate: number
    staffId: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type ProductionJournalAvgAggregateInputType = {
    id?: true
    staffId?: true
  }

  export type ProductionJournalSumAggregateInputType = {
    id?: true
    staffId?: true
  }

  export type ProductionJournalMinAggregateInputType = {
    id?: true
    productionDate?: true
    staffId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ProductionJournalMaxAggregateInputType = {
    id?: true
    productionDate?: true
    staffId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ProductionJournalCountAggregateInputType = {
    id?: true
    productionDate?: true
    staffId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type ProductionJournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionJournal to aggregate.
     */
    where?: ProductionJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionJournals to fetch.
     */
    orderBy?: ProductionJournalOrderByWithRelationInput | ProductionJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionJournals
    **/
    _count?: true | ProductionJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionJournalMaxAggregateInputType
  }

  export type GetProductionJournalAggregateType<T extends ProductionJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionJournal[P]>
      : GetScalarType<T[P], AggregateProductionJournal[P]>
  }




  export type ProductionJournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionJournalWhereInput
    orderBy?: ProductionJournalOrderByWithAggregationInput | ProductionJournalOrderByWithAggregationInput[]
    by: ProductionJournalScalarFieldEnum[] | ProductionJournalScalarFieldEnum
    having?: ProductionJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionJournalCountAggregateInputType | true
    _avg?: ProductionJournalAvgAggregateInputType
    _sum?: ProductionJournalSumAggregateInputType
    _min?: ProductionJournalMinAggregateInputType
    _max?: ProductionJournalMaxAggregateInputType
  }

  export type ProductionJournalGroupByOutputType = {
    id: number
    productionDate: Date
    staffId: number
    status: string
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    _count: ProductionJournalCountAggregateOutputType | null
    _avg: ProductionJournalAvgAggregateOutputType | null
    _sum: ProductionJournalSumAggregateOutputType | null
    _min: ProductionJournalMinAggregateOutputType | null
    _max: ProductionJournalMaxAggregateOutputType | null
  }

  type GetProductionJournalGroupByPayload<T extends ProductionJournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionJournalGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionJournalGroupByOutputType[P]>
        }
      >
    >


  export type ProductionJournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDate?: boolean
    staffId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
    items?: boolean | ProductionJournal$itemsArgs<ExtArgs>
    _count?: boolean | ProductionJournalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionJournal"]>

  export type ProductionJournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDate?: boolean
    staffId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionJournal"]>

  export type ProductionJournalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDate?: boolean
    staffId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionJournal"]>

  export type ProductionJournalSelectScalar = {
    id?: boolean
    productionDate?: boolean
    staffId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type ProductionJournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionDate" | "staffId" | "status" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["productionJournal"]>
  export type ProductionJournalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
    items?: boolean | ProductionJournal$itemsArgs<ExtArgs>
    _count?: boolean | ProductionJournalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionJournalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
  }
  export type ProductionJournalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
  }

  export type $ProductionJournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionJournal"
    objects: {
      staff: Prisma.$ProductionStaffPayload<ExtArgs>
      items: Prisma.$ProductionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionDate: Date
      staffId: number
      status: string
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
    }, ExtArgs["result"]["productionJournal"]>
    composites: {}
  }

  type ProductionJournalGetPayload<S extends boolean | null | undefined | ProductionJournalDefaultArgs> = $Result.GetResult<Prisma.$ProductionJournalPayload, S>

  type ProductionJournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionJournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionJournalCountAggregateInputType | true
    }

  export interface ProductionJournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionJournal'], meta: { name: 'ProductionJournal' } }
    /**
     * Find zero or one ProductionJournal that matches the filter.
     * @param {ProductionJournalFindUniqueArgs} args - Arguments to find a ProductionJournal
     * @example
     * // Get one ProductionJournal
     * const productionJournal = await prisma.productionJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionJournalFindUniqueArgs>(args: SelectSubset<T, ProductionJournalFindUniqueArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionJournal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionJournalFindUniqueOrThrowArgs} args - Arguments to find a ProductionJournal
     * @example
     * // Get one ProductionJournal
     * const productionJournal = await prisma.productionJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionJournalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionJournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalFindFirstArgs} args - Arguments to find a ProductionJournal
     * @example
     * // Get one ProductionJournal
     * const productionJournal = await prisma.productionJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionJournalFindFirstArgs>(args?: SelectSubset<T, ProductionJournalFindFirstArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionJournal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalFindFirstOrThrowArgs} args - Arguments to find a ProductionJournal
     * @example
     * // Get one ProductionJournal
     * const productionJournal = await prisma.productionJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionJournalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionJournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionJournals
     * const productionJournals = await prisma.productionJournal.findMany()
     * 
     * // Get first 10 ProductionJournals
     * const productionJournals = await prisma.productionJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionJournalWithIdOnly = await prisma.productionJournal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionJournalFindManyArgs>(args?: SelectSubset<T, ProductionJournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionJournal.
     * @param {ProductionJournalCreateArgs} args - Arguments to create a ProductionJournal.
     * @example
     * // Create one ProductionJournal
     * const ProductionJournal = await prisma.productionJournal.create({
     *   data: {
     *     // ... data to create a ProductionJournal
     *   }
     * })
     * 
     */
    create<T extends ProductionJournalCreateArgs>(args: SelectSubset<T, ProductionJournalCreateArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionJournals.
     * @param {ProductionJournalCreateManyArgs} args - Arguments to create many ProductionJournals.
     * @example
     * // Create many ProductionJournals
     * const productionJournal = await prisma.productionJournal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionJournalCreateManyArgs>(args?: SelectSubset<T, ProductionJournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionJournals and returns the data saved in the database.
     * @param {ProductionJournalCreateManyAndReturnArgs} args - Arguments to create many ProductionJournals.
     * @example
     * // Create many ProductionJournals
     * const productionJournal = await prisma.productionJournal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionJournals and only return the `id`
     * const productionJournalWithIdOnly = await prisma.productionJournal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionJournalCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionJournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionJournal.
     * @param {ProductionJournalDeleteArgs} args - Arguments to delete one ProductionJournal.
     * @example
     * // Delete one ProductionJournal
     * const ProductionJournal = await prisma.productionJournal.delete({
     *   where: {
     *     // ... filter to delete one ProductionJournal
     *   }
     * })
     * 
     */
    delete<T extends ProductionJournalDeleteArgs>(args: SelectSubset<T, ProductionJournalDeleteArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionJournal.
     * @param {ProductionJournalUpdateArgs} args - Arguments to update one ProductionJournal.
     * @example
     * // Update one ProductionJournal
     * const productionJournal = await prisma.productionJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionJournalUpdateArgs>(args: SelectSubset<T, ProductionJournalUpdateArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionJournals.
     * @param {ProductionJournalDeleteManyArgs} args - Arguments to filter ProductionJournals to delete.
     * @example
     * // Delete a few ProductionJournals
     * const { count } = await prisma.productionJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionJournalDeleteManyArgs>(args?: SelectSubset<T, ProductionJournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionJournals
     * const productionJournal = await prisma.productionJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionJournalUpdateManyArgs>(args: SelectSubset<T, ProductionJournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionJournals and returns the data updated in the database.
     * @param {ProductionJournalUpdateManyAndReturnArgs} args - Arguments to update many ProductionJournals.
     * @example
     * // Update many ProductionJournals
     * const productionJournal = await prisma.productionJournal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionJournals and only return the `id`
     * const productionJournalWithIdOnly = await prisma.productionJournal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionJournalUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionJournalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionJournal.
     * @param {ProductionJournalUpsertArgs} args - Arguments to update or create a ProductionJournal.
     * @example
     * // Update or create a ProductionJournal
     * const productionJournal = await prisma.productionJournal.upsert({
     *   create: {
     *     // ... data to create a ProductionJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionJournal we want to update
     *   }
     * })
     */
    upsert<T extends ProductionJournalUpsertArgs>(args: SelectSubset<T, ProductionJournalUpsertArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalCountArgs} args - Arguments to filter ProductionJournals to count.
     * @example
     * // Count the number of ProductionJournals
     * const count = await prisma.productionJournal.count({
     *   where: {
     *     // ... the filter for the ProductionJournals we want to count
     *   }
     * })
    **/
    count<T extends ProductionJournalCountArgs>(
      args?: Subset<T, ProductionJournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionJournalAggregateArgs>(args: Subset<T, ProductionJournalAggregateArgs>): Prisma.PrismaPromise<GetProductionJournalAggregateType<T>>

    /**
     * Group by ProductionJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionJournalGroupByArgs['orderBy'] }
        : { orderBy?: ProductionJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionJournal model
   */
  readonly fields: ProductionJournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionJournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends ProductionStaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionStaffDefaultArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends ProductionJournal$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionJournal$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionJournal model
   */
  interface ProductionJournalFieldRefs {
    readonly id: FieldRef<"ProductionJournal", 'Int'>
    readonly productionDate: FieldRef<"ProductionJournal", 'DateTime'>
    readonly staffId: FieldRef<"ProductionJournal", 'Int'>
    readonly status: FieldRef<"ProductionJournal", 'String'>
    readonly createdAt: FieldRef<"ProductionJournal", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionJournal", 'DateTime'>
    readonly createdBy: FieldRef<"ProductionJournal", 'String'>
    readonly updatedBy: FieldRef<"ProductionJournal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductionJournal findUnique
   */
  export type ProductionJournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter, which ProductionJournal to fetch.
     */
    where: ProductionJournalWhereUniqueInput
  }

  /**
   * ProductionJournal findUniqueOrThrow
   */
  export type ProductionJournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter, which ProductionJournal to fetch.
     */
    where: ProductionJournalWhereUniqueInput
  }

  /**
   * ProductionJournal findFirst
   */
  export type ProductionJournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter, which ProductionJournal to fetch.
     */
    where?: ProductionJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionJournals to fetch.
     */
    orderBy?: ProductionJournalOrderByWithRelationInput | ProductionJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionJournals.
     */
    cursor?: ProductionJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionJournals.
     */
    distinct?: ProductionJournalScalarFieldEnum | ProductionJournalScalarFieldEnum[]
  }

  /**
   * ProductionJournal findFirstOrThrow
   */
  export type ProductionJournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter, which ProductionJournal to fetch.
     */
    where?: ProductionJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionJournals to fetch.
     */
    orderBy?: ProductionJournalOrderByWithRelationInput | ProductionJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionJournals.
     */
    cursor?: ProductionJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionJournals.
     */
    distinct?: ProductionJournalScalarFieldEnum | ProductionJournalScalarFieldEnum[]
  }

  /**
   * ProductionJournal findMany
   */
  export type ProductionJournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter, which ProductionJournals to fetch.
     */
    where?: ProductionJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionJournals to fetch.
     */
    orderBy?: ProductionJournalOrderByWithRelationInput | ProductionJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionJournals.
     */
    cursor?: ProductionJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionJournals.
     */
    skip?: number
    distinct?: ProductionJournalScalarFieldEnum | ProductionJournalScalarFieldEnum[]
  }

  /**
   * ProductionJournal create
   */
  export type ProductionJournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionJournal.
     */
    data: XOR<ProductionJournalCreateInput, ProductionJournalUncheckedCreateInput>
  }

  /**
   * ProductionJournal createMany
   */
  export type ProductionJournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionJournals.
     */
    data: ProductionJournalCreateManyInput | ProductionJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionJournal createManyAndReturn
   */
  export type ProductionJournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionJournals.
     */
    data: ProductionJournalCreateManyInput | ProductionJournalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionJournal update
   */
  export type ProductionJournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionJournal.
     */
    data: XOR<ProductionJournalUpdateInput, ProductionJournalUncheckedUpdateInput>
    /**
     * Choose, which ProductionJournal to update.
     */
    where: ProductionJournalWhereUniqueInput
  }

  /**
   * ProductionJournal updateMany
   */
  export type ProductionJournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionJournals.
     */
    data: XOR<ProductionJournalUpdateManyMutationInput, ProductionJournalUncheckedUpdateManyInput>
    /**
     * Filter which ProductionJournals to update
     */
    where?: ProductionJournalWhereInput
    /**
     * Limit how many ProductionJournals to update.
     */
    limit?: number
  }

  /**
   * ProductionJournal updateManyAndReturn
   */
  export type ProductionJournalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * The data used to update ProductionJournals.
     */
    data: XOR<ProductionJournalUpdateManyMutationInput, ProductionJournalUncheckedUpdateManyInput>
    /**
     * Filter which ProductionJournals to update
     */
    where?: ProductionJournalWhereInput
    /**
     * Limit how many ProductionJournals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionJournal upsert
   */
  export type ProductionJournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionJournal to update in case it exists.
     */
    where: ProductionJournalWhereUniqueInput
    /**
     * In case the ProductionJournal found by the `where` argument doesn't exist, create a new ProductionJournal with this data.
     */
    create: XOR<ProductionJournalCreateInput, ProductionJournalUncheckedCreateInput>
    /**
     * In case the ProductionJournal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionJournalUpdateInput, ProductionJournalUncheckedUpdateInput>
  }

  /**
   * ProductionJournal delete
   */
  export type ProductionJournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter which ProductionJournal to delete.
     */
    where: ProductionJournalWhereUniqueInput
  }

  /**
   * ProductionJournal deleteMany
   */
  export type ProductionJournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionJournals to delete
     */
    where?: ProductionJournalWhereInput
    /**
     * Limit how many ProductionJournals to delete.
     */
    limit?: number
  }

  /**
   * ProductionJournal.items
   */
  export type ProductionJournal$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    where?: ProductionItemWhereInput
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    cursor?: ProductionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionItemScalarFieldEnum | ProductionItemScalarFieldEnum[]
  }

  /**
   * ProductionJournal without action
   */
  export type ProductionJournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
  }


  /**
   * Model ProductionItem
   */

  export type AggregateProductionItem = {
    _count: ProductionItemCountAggregateOutputType | null
    _avg: ProductionItemAvgAggregateOutputType | null
    _sum: ProductionItemSumAggregateOutputType | null
    _min: ProductionItemMinAggregateOutputType | null
    _max: ProductionItemMaxAggregateOutputType | null
  }

  export type ProductionItemAvgAggregateOutputType = {
    id: number | null
    journalId: number | null
    productId: number | null
    sortOrder: number | null
  }

  export type ProductionItemSumAggregateOutputType = {
    id: number | null
    journalId: number | null
    productId: number | null
    sortOrder: number | null
  }

  export type ProductionItemMinAggregateOutputType = {
    id: number | null
    journalId: number | null
    productId: number | null
    productName: string | null
    state: string | null
    sortOrder: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ProductionItemMaxAggregateOutputType = {
    id: number | null
    journalId: number | null
    productId: number | null
    productName: string | null
    state: string | null
    sortOrder: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ProductionItemCountAggregateOutputType = {
    id: number
    journalId: number
    productId: number
    productName: number
    state: number
    sortOrder: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type ProductionItemAvgAggregateInputType = {
    id?: true
    journalId?: true
    productId?: true
    sortOrder?: true
  }

  export type ProductionItemSumAggregateInputType = {
    id?: true
    journalId?: true
    productId?: true
    sortOrder?: true
  }

  export type ProductionItemMinAggregateInputType = {
    id?: true
    journalId?: true
    productId?: true
    productName?: true
    state?: true
    sortOrder?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ProductionItemMaxAggregateInputType = {
    id?: true
    journalId?: true
    productId?: true
    productName?: true
    state?: true
    sortOrder?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ProductionItemCountAggregateInputType = {
    id?: true
    journalId?: true
    productId?: true
    productName?: true
    state?: true
    sortOrder?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type ProductionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionItem to aggregate.
     */
    where?: ProductionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItems to fetch.
     */
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionItems
    **/
    _count?: true | ProductionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionItemMaxAggregateInputType
  }

  export type GetProductionItemAggregateType<T extends ProductionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionItem[P]>
      : GetScalarType<T[P], AggregateProductionItem[P]>
  }




  export type ProductionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionItemWhereInput
    orderBy?: ProductionItemOrderByWithAggregationInput | ProductionItemOrderByWithAggregationInput[]
    by: ProductionItemScalarFieldEnum[] | ProductionItemScalarFieldEnum
    having?: ProductionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionItemCountAggregateInputType | true
    _avg?: ProductionItemAvgAggregateInputType
    _sum?: ProductionItemSumAggregateInputType
    _min?: ProductionItemMinAggregateInputType
    _max?: ProductionItemMaxAggregateInputType
  }

  export type ProductionItemGroupByOutputType = {
    id: number
    journalId: number
    productId: number | null
    productName: string | null
    state: string
    sortOrder: number
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    _count: ProductionItemCountAggregateOutputType | null
    _avg: ProductionItemAvgAggregateOutputType | null
    _sum: ProductionItemSumAggregateOutputType | null
    _min: ProductionItemMinAggregateOutputType | null
    _max: ProductionItemMaxAggregateOutputType | null
  }

  type GetProductionItemGroupByPayload<T extends ProductionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionItemGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionItemGroupByOutputType[P]>
        }
      >
    >


  export type ProductionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    productId?: boolean
    productName?: boolean
    state?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
    values?: boolean | ProductionItem$valuesArgs<ExtArgs>
    _count?: boolean | ProductionItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionItem"]>

  export type ProductionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    productId?: boolean
    productName?: boolean
    state?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["productionItem"]>

  export type ProductionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    productId?: boolean
    productName?: boolean
    state?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["productionItem"]>

  export type ProductionItemSelectScalar = {
    id?: boolean
    journalId?: boolean
    productId?: boolean
    productName?: boolean
    state?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type ProductionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalId" | "productId" | "productName" | "state" | "sortOrder" | "isDeleted" | "deletedAt" | "deletedBy" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["productionItem"]>
  export type ProductionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
    values?: boolean | ProductionItem$valuesArgs<ExtArgs>
    _count?: boolean | ProductionItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
  }
  export type ProductionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
  }

  export type $ProductionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionItem"
    objects: {
      journal: Prisma.$ProductionJournalPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
      values: Prisma.$ProductionItemValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      journalId: number
      productId: number | null
      productName: string | null
      state: string
      sortOrder: number
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
    }, ExtArgs["result"]["productionItem"]>
    composites: {}
  }

  type ProductionItemGetPayload<S extends boolean | null | undefined | ProductionItemDefaultArgs> = $Result.GetResult<Prisma.$ProductionItemPayload, S>

  type ProductionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionItemCountAggregateInputType | true
    }

  export interface ProductionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionItem'], meta: { name: 'ProductionItem' } }
    /**
     * Find zero or one ProductionItem that matches the filter.
     * @param {ProductionItemFindUniqueArgs} args - Arguments to find a ProductionItem
     * @example
     * // Get one ProductionItem
     * const productionItem = await prisma.productionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionItemFindUniqueArgs>(args: SelectSubset<T, ProductionItemFindUniqueArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionItemFindUniqueOrThrowArgs} args - Arguments to find a ProductionItem
     * @example
     * // Get one ProductionItem
     * const productionItem = await prisma.productionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemFindFirstArgs} args - Arguments to find a ProductionItem
     * @example
     * // Get one ProductionItem
     * const productionItem = await prisma.productionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionItemFindFirstArgs>(args?: SelectSubset<T, ProductionItemFindFirstArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemFindFirstOrThrowArgs} args - Arguments to find a ProductionItem
     * @example
     * // Get one ProductionItem
     * const productionItem = await prisma.productionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionItems
     * const productionItems = await prisma.productionItem.findMany()
     * 
     * // Get first 10 ProductionItems
     * const productionItems = await prisma.productionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionItemWithIdOnly = await prisma.productionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionItemFindManyArgs>(args?: SelectSubset<T, ProductionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionItem.
     * @param {ProductionItemCreateArgs} args - Arguments to create a ProductionItem.
     * @example
     * // Create one ProductionItem
     * const ProductionItem = await prisma.productionItem.create({
     *   data: {
     *     // ... data to create a ProductionItem
     *   }
     * })
     * 
     */
    create<T extends ProductionItemCreateArgs>(args: SelectSubset<T, ProductionItemCreateArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionItems.
     * @param {ProductionItemCreateManyArgs} args - Arguments to create many ProductionItems.
     * @example
     * // Create many ProductionItems
     * const productionItem = await prisma.productionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionItemCreateManyArgs>(args?: SelectSubset<T, ProductionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionItems and returns the data saved in the database.
     * @param {ProductionItemCreateManyAndReturnArgs} args - Arguments to create many ProductionItems.
     * @example
     * // Create many ProductionItems
     * const productionItem = await prisma.productionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionItems and only return the `id`
     * const productionItemWithIdOnly = await prisma.productionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionItem.
     * @param {ProductionItemDeleteArgs} args - Arguments to delete one ProductionItem.
     * @example
     * // Delete one ProductionItem
     * const ProductionItem = await prisma.productionItem.delete({
     *   where: {
     *     // ... filter to delete one ProductionItem
     *   }
     * })
     * 
     */
    delete<T extends ProductionItemDeleteArgs>(args: SelectSubset<T, ProductionItemDeleteArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionItem.
     * @param {ProductionItemUpdateArgs} args - Arguments to update one ProductionItem.
     * @example
     * // Update one ProductionItem
     * const productionItem = await prisma.productionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionItemUpdateArgs>(args: SelectSubset<T, ProductionItemUpdateArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionItems.
     * @param {ProductionItemDeleteManyArgs} args - Arguments to filter ProductionItems to delete.
     * @example
     * // Delete a few ProductionItems
     * const { count } = await prisma.productionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionItemDeleteManyArgs>(args?: SelectSubset<T, ProductionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionItems
     * const productionItem = await prisma.productionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionItemUpdateManyArgs>(args: SelectSubset<T, ProductionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionItems and returns the data updated in the database.
     * @param {ProductionItemUpdateManyAndReturnArgs} args - Arguments to update many ProductionItems.
     * @example
     * // Update many ProductionItems
     * const productionItem = await prisma.productionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionItems and only return the `id`
     * const productionItemWithIdOnly = await prisma.productionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionItem.
     * @param {ProductionItemUpsertArgs} args - Arguments to update or create a ProductionItem.
     * @example
     * // Update or create a ProductionItem
     * const productionItem = await prisma.productionItem.upsert({
     *   create: {
     *     // ... data to create a ProductionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionItem we want to update
     *   }
     * })
     */
    upsert<T extends ProductionItemUpsertArgs>(args: SelectSubset<T, ProductionItemUpsertArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemCountArgs} args - Arguments to filter ProductionItems to count.
     * @example
     * // Count the number of ProductionItems
     * const count = await prisma.productionItem.count({
     *   where: {
     *     // ... the filter for the ProductionItems we want to count
     *   }
     * })
    **/
    count<T extends ProductionItemCountArgs>(
      args?: Subset<T, ProductionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionItemAggregateArgs>(args: Subset<T, ProductionItemAggregateArgs>): Prisma.PrismaPromise<GetProductionItemAggregateType<T>>

    /**
     * Group by ProductionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionItemGroupByArgs['orderBy'] }
        : { orderBy?: ProductionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionItem model
   */
  readonly fields: ProductionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journal<T extends ProductionJournalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionJournalDefaultArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductionItem$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductionItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    values<T extends ProductionItem$valuesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionItem$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionItem model
   */
  interface ProductionItemFieldRefs {
    readonly id: FieldRef<"ProductionItem", 'Int'>
    readonly journalId: FieldRef<"ProductionItem", 'Int'>
    readonly productId: FieldRef<"ProductionItem", 'Int'>
    readonly productName: FieldRef<"ProductionItem", 'String'>
    readonly state: FieldRef<"ProductionItem", 'String'>
    readonly sortOrder: FieldRef<"ProductionItem", 'Int'>
    readonly isDeleted: FieldRef<"ProductionItem", 'Boolean'>
    readonly deletedAt: FieldRef<"ProductionItem", 'DateTime'>
    readonly deletedBy: FieldRef<"ProductionItem", 'String'>
    readonly createdAt: FieldRef<"ProductionItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionItem", 'DateTime'>
    readonly createdBy: FieldRef<"ProductionItem", 'String'>
    readonly updatedBy: FieldRef<"ProductionItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductionItem findUnique
   */
  export type ProductionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItem to fetch.
     */
    where: ProductionItemWhereUniqueInput
  }

  /**
   * ProductionItem findUniqueOrThrow
   */
  export type ProductionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItem to fetch.
     */
    where: ProductionItemWhereUniqueInput
  }

  /**
   * ProductionItem findFirst
   */
  export type ProductionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItem to fetch.
     */
    where?: ProductionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItems to fetch.
     */
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionItems.
     */
    cursor?: ProductionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionItems.
     */
    distinct?: ProductionItemScalarFieldEnum | ProductionItemScalarFieldEnum[]
  }

  /**
   * ProductionItem findFirstOrThrow
   */
  export type ProductionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItem to fetch.
     */
    where?: ProductionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItems to fetch.
     */
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionItems.
     */
    cursor?: ProductionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionItems.
     */
    distinct?: ProductionItemScalarFieldEnum | ProductionItemScalarFieldEnum[]
  }

  /**
   * ProductionItem findMany
   */
  export type ProductionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItems to fetch.
     */
    where?: ProductionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItems to fetch.
     */
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionItems.
     */
    cursor?: ProductionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItems.
     */
    skip?: number
    distinct?: ProductionItemScalarFieldEnum | ProductionItemScalarFieldEnum[]
  }

  /**
   * ProductionItem create
   */
  export type ProductionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionItem.
     */
    data: XOR<ProductionItemCreateInput, ProductionItemUncheckedCreateInput>
  }

  /**
   * ProductionItem createMany
   */
  export type ProductionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionItems.
     */
    data: ProductionItemCreateManyInput | ProductionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionItem createManyAndReturn
   */
  export type ProductionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionItems.
     */
    data: ProductionItemCreateManyInput | ProductionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionItem update
   */
  export type ProductionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionItem.
     */
    data: XOR<ProductionItemUpdateInput, ProductionItemUncheckedUpdateInput>
    /**
     * Choose, which ProductionItem to update.
     */
    where: ProductionItemWhereUniqueInput
  }

  /**
   * ProductionItem updateMany
   */
  export type ProductionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionItems.
     */
    data: XOR<ProductionItemUpdateManyMutationInput, ProductionItemUncheckedUpdateManyInput>
    /**
     * Filter which ProductionItems to update
     */
    where?: ProductionItemWhereInput
    /**
     * Limit how many ProductionItems to update.
     */
    limit?: number
  }

  /**
   * ProductionItem updateManyAndReturn
   */
  export type ProductionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * The data used to update ProductionItems.
     */
    data: XOR<ProductionItemUpdateManyMutationInput, ProductionItemUncheckedUpdateManyInput>
    /**
     * Filter which ProductionItems to update
     */
    where?: ProductionItemWhereInput
    /**
     * Limit how many ProductionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionItem upsert
   */
  export type ProductionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionItem to update in case it exists.
     */
    where: ProductionItemWhereUniqueInput
    /**
     * In case the ProductionItem found by the `where` argument doesn't exist, create a new ProductionItem with this data.
     */
    create: XOR<ProductionItemCreateInput, ProductionItemUncheckedCreateInput>
    /**
     * In case the ProductionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionItemUpdateInput, ProductionItemUncheckedUpdateInput>
  }

  /**
   * ProductionItem delete
   */
  export type ProductionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter which ProductionItem to delete.
     */
    where: ProductionItemWhereUniqueInput
  }

  /**
   * ProductionItem deleteMany
   */
  export type ProductionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionItems to delete
     */
    where?: ProductionItemWhereInput
    /**
     * Limit how many ProductionItems to delete.
     */
    limit?: number
  }

  /**
   * ProductionItem.product
   */
  export type ProductionItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * ProductionItem.values
   */
  export type ProductionItem$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    where?: ProductionItemValueWhereInput
    orderBy?: ProductionItemValueOrderByWithRelationInput | ProductionItemValueOrderByWithRelationInput[]
    cursor?: ProductionItemValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionItemValueScalarFieldEnum | ProductionItemValueScalarFieldEnum[]
  }

  /**
   * ProductionItem without action
   */
  export type ProductionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
  }


  /**
   * Model ProductionItemValue
   */

  export type AggregateProductionItemValue = {
    _count: ProductionItemValueCountAggregateOutputType | null
    _avg: ProductionItemValueAvgAggregateOutputType | null
    _sum: ProductionItemValueSumAggregateOutputType | null
    _min: ProductionItemValueMinAggregateOutputType | null
    _max: ProductionItemValueMaxAggregateOutputType | null
  }

  export type ProductionItemValueAvgAggregateOutputType = {
    id: number | null
    productionItemId: number | null
  }

  export type ProductionItemValueSumAggregateOutputType = {
    id: number | null
    productionItemId: number | null
  }

  export type ProductionItemValueMinAggregateOutputType = {
    id: number | null
    productionItemId: number | null
    fieldKey: string | null
    fieldValue: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ProductionItemValueMaxAggregateOutputType = {
    id: number | null
    productionItemId: number | null
    fieldKey: string | null
    fieldValue: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ProductionItemValueCountAggregateOutputType = {
    id: number
    productionItemId: number
    fieldKey: number
    fieldValue: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ProductionItemValueAvgAggregateInputType = {
    id?: true
    productionItemId?: true
  }

  export type ProductionItemValueSumAggregateInputType = {
    id?: true
    productionItemId?: true
  }

  export type ProductionItemValueMinAggregateInputType = {
    id?: true
    productionItemId?: true
    fieldKey?: true
    fieldValue?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProductionItemValueMaxAggregateInputType = {
    id?: true
    productionItemId?: true
    fieldKey?: true
    fieldValue?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProductionItemValueCountAggregateInputType = {
    id?: true
    productionItemId?: true
    fieldKey?: true
    fieldValue?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ProductionItemValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionItemValue to aggregate.
     */
    where?: ProductionItemValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItemValues to fetch.
     */
    orderBy?: ProductionItemValueOrderByWithRelationInput | ProductionItemValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionItemValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItemValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItemValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionItemValues
    **/
    _count?: true | ProductionItemValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionItemValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionItemValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionItemValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionItemValueMaxAggregateInputType
  }

  export type GetProductionItemValueAggregateType<T extends ProductionItemValueAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionItemValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionItemValue[P]>
      : GetScalarType<T[P], AggregateProductionItemValue[P]>
  }




  export type ProductionItemValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionItemValueWhereInput
    orderBy?: ProductionItemValueOrderByWithAggregationInput | ProductionItemValueOrderByWithAggregationInput[]
    by: ProductionItemValueScalarFieldEnum[] | ProductionItemValueScalarFieldEnum
    having?: ProductionItemValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionItemValueCountAggregateInputType | true
    _avg?: ProductionItemValueAvgAggregateInputType
    _sum?: ProductionItemValueSumAggregateInputType
    _min?: ProductionItemValueMinAggregateInputType
    _max?: ProductionItemValueMaxAggregateInputType
  }

  export type ProductionItemValueGroupByOutputType = {
    id: number
    productionItemId: number
    fieldKey: string
    fieldValue: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: ProductionItemValueCountAggregateOutputType | null
    _avg: ProductionItemValueAvgAggregateOutputType | null
    _sum: ProductionItemValueSumAggregateOutputType | null
    _min: ProductionItemValueMinAggregateOutputType | null
    _max: ProductionItemValueMaxAggregateOutputType | null
  }

  type GetProductionItemValueGroupByPayload<T extends ProductionItemValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionItemValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionItemValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionItemValueGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionItemValueGroupByOutputType[P]>
        }
      >
    >


  export type ProductionItemValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionItemId?: boolean
    fieldKey?: boolean
    fieldValue?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionItemValue"]>

  export type ProductionItemValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionItemId?: boolean
    fieldKey?: boolean
    fieldValue?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionItemValue"]>

  export type ProductionItemValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionItemId?: boolean
    fieldKey?: boolean
    fieldValue?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionItemValue"]>

  export type ProductionItemValueSelectScalar = {
    id?: boolean
    productionItemId?: boolean
    fieldKey?: boolean
    fieldValue?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ProductionItemValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionItemId" | "fieldKey" | "fieldValue" | "updatedAt" | "updatedBy", ExtArgs["result"]["productionItemValue"]>
  export type ProductionItemValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }
  export type ProductionItemValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }
  export type ProductionItemValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }

  export type $ProductionItemValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionItemValue"
    objects: {
      productionItem: Prisma.$ProductionItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionItemId: number
      fieldKey: string
      fieldValue: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["productionItemValue"]>
    composites: {}
  }

  type ProductionItemValueGetPayload<S extends boolean | null | undefined | ProductionItemValueDefaultArgs> = $Result.GetResult<Prisma.$ProductionItemValuePayload, S>

  type ProductionItemValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionItemValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionItemValueCountAggregateInputType | true
    }

  export interface ProductionItemValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionItemValue'], meta: { name: 'ProductionItemValue' } }
    /**
     * Find zero or one ProductionItemValue that matches the filter.
     * @param {ProductionItemValueFindUniqueArgs} args - Arguments to find a ProductionItemValue
     * @example
     * // Get one ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionItemValueFindUniqueArgs>(args: SelectSubset<T, ProductionItemValueFindUniqueArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionItemValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionItemValueFindUniqueOrThrowArgs} args - Arguments to find a ProductionItemValue
     * @example
     * // Get one ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionItemValueFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionItemValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionItemValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueFindFirstArgs} args - Arguments to find a ProductionItemValue
     * @example
     * // Get one ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionItemValueFindFirstArgs>(args?: SelectSubset<T, ProductionItemValueFindFirstArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionItemValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueFindFirstOrThrowArgs} args - Arguments to find a ProductionItemValue
     * @example
     * // Get one ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionItemValueFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionItemValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionItemValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionItemValues
     * const productionItemValues = await prisma.productionItemValue.findMany()
     * 
     * // Get first 10 ProductionItemValues
     * const productionItemValues = await prisma.productionItemValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionItemValueWithIdOnly = await prisma.productionItemValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionItemValueFindManyArgs>(args?: SelectSubset<T, ProductionItemValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionItemValue.
     * @param {ProductionItemValueCreateArgs} args - Arguments to create a ProductionItemValue.
     * @example
     * // Create one ProductionItemValue
     * const ProductionItemValue = await prisma.productionItemValue.create({
     *   data: {
     *     // ... data to create a ProductionItemValue
     *   }
     * })
     * 
     */
    create<T extends ProductionItemValueCreateArgs>(args: SelectSubset<T, ProductionItemValueCreateArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionItemValues.
     * @param {ProductionItemValueCreateManyArgs} args - Arguments to create many ProductionItemValues.
     * @example
     * // Create many ProductionItemValues
     * const productionItemValue = await prisma.productionItemValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionItemValueCreateManyArgs>(args?: SelectSubset<T, ProductionItemValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionItemValues and returns the data saved in the database.
     * @param {ProductionItemValueCreateManyAndReturnArgs} args - Arguments to create many ProductionItemValues.
     * @example
     * // Create many ProductionItemValues
     * const productionItemValue = await prisma.productionItemValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionItemValues and only return the `id`
     * const productionItemValueWithIdOnly = await prisma.productionItemValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionItemValueCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionItemValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionItemValue.
     * @param {ProductionItemValueDeleteArgs} args - Arguments to delete one ProductionItemValue.
     * @example
     * // Delete one ProductionItemValue
     * const ProductionItemValue = await prisma.productionItemValue.delete({
     *   where: {
     *     // ... filter to delete one ProductionItemValue
     *   }
     * })
     * 
     */
    delete<T extends ProductionItemValueDeleteArgs>(args: SelectSubset<T, ProductionItemValueDeleteArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionItemValue.
     * @param {ProductionItemValueUpdateArgs} args - Arguments to update one ProductionItemValue.
     * @example
     * // Update one ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionItemValueUpdateArgs>(args: SelectSubset<T, ProductionItemValueUpdateArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionItemValues.
     * @param {ProductionItemValueDeleteManyArgs} args - Arguments to filter ProductionItemValues to delete.
     * @example
     * // Delete a few ProductionItemValues
     * const { count } = await prisma.productionItemValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionItemValueDeleteManyArgs>(args?: SelectSubset<T, ProductionItemValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionItemValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionItemValues
     * const productionItemValue = await prisma.productionItemValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionItemValueUpdateManyArgs>(args: SelectSubset<T, ProductionItemValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionItemValues and returns the data updated in the database.
     * @param {ProductionItemValueUpdateManyAndReturnArgs} args - Arguments to update many ProductionItemValues.
     * @example
     * // Update many ProductionItemValues
     * const productionItemValue = await prisma.productionItemValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionItemValues and only return the `id`
     * const productionItemValueWithIdOnly = await prisma.productionItemValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionItemValueUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionItemValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionItemValue.
     * @param {ProductionItemValueUpsertArgs} args - Arguments to update or create a ProductionItemValue.
     * @example
     * // Update or create a ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.upsert({
     *   create: {
     *     // ... data to create a ProductionItemValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionItemValue we want to update
     *   }
     * })
     */
    upsert<T extends ProductionItemValueUpsertArgs>(args: SelectSubset<T, ProductionItemValueUpsertArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionItemValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueCountArgs} args - Arguments to filter ProductionItemValues to count.
     * @example
     * // Count the number of ProductionItemValues
     * const count = await prisma.productionItemValue.count({
     *   where: {
     *     // ... the filter for the ProductionItemValues we want to count
     *   }
     * })
    **/
    count<T extends ProductionItemValueCountArgs>(
      args?: Subset<T, ProductionItemValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionItemValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionItemValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionItemValueAggregateArgs>(args: Subset<T, ProductionItemValueAggregateArgs>): Prisma.PrismaPromise<GetProductionItemValueAggregateType<T>>

    /**
     * Group by ProductionItemValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionItemValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionItemValueGroupByArgs['orderBy'] }
        : { orderBy?: ProductionItemValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionItemValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionItemValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionItemValue model
   */
  readonly fields: ProductionItemValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionItemValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionItemValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionItem<T extends ProductionItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionItemDefaultArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionItemValue model
   */
  interface ProductionItemValueFieldRefs {
    readonly id: FieldRef<"ProductionItemValue", 'Int'>
    readonly productionItemId: FieldRef<"ProductionItemValue", 'Int'>
    readonly fieldKey: FieldRef<"ProductionItemValue", 'String'>
    readonly fieldValue: FieldRef<"ProductionItemValue", 'String'>
    readonly updatedAt: FieldRef<"ProductionItemValue", 'DateTime'>
    readonly updatedBy: FieldRef<"ProductionItemValue", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductionItemValue findUnique
   */
  export type ProductionItemValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItemValue to fetch.
     */
    where: ProductionItemValueWhereUniqueInput
  }

  /**
   * ProductionItemValue findUniqueOrThrow
   */
  export type ProductionItemValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItemValue to fetch.
     */
    where: ProductionItemValueWhereUniqueInput
  }

  /**
   * ProductionItemValue findFirst
   */
  export type ProductionItemValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItemValue to fetch.
     */
    where?: ProductionItemValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItemValues to fetch.
     */
    orderBy?: ProductionItemValueOrderByWithRelationInput | ProductionItemValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionItemValues.
     */
    cursor?: ProductionItemValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItemValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItemValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionItemValues.
     */
    distinct?: ProductionItemValueScalarFieldEnum | ProductionItemValueScalarFieldEnum[]
  }

  /**
   * ProductionItemValue findFirstOrThrow
   */
  export type ProductionItemValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItemValue to fetch.
     */
    where?: ProductionItemValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItemValues to fetch.
     */
    orderBy?: ProductionItemValueOrderByWithRelationInput | ProductionItemValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionItemValues.
     */
    cursor?: ProductionItemValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItemValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItemValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionItemValues.
     */
    distinct?: ProductionItemValueScalarFieldEnum | ProductionItemValueScalarFieldEnum[]
  }

  /**
   * ProductionItemValue findMany
   */
  export type ProductionItemValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItemValues to fetch.
     */
    where?: ProductionItemValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItemValues to fetch.
     */
    orderBy?: ProductionItemValueOrderByWithRelationInput | ProductionItemValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionItemValues.
     */
    cursor?: ProductionItemValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItemValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItemValues.
     */
    skip?: number
    distinct?: ProductionItemValueScalarFieldEnum | ProductionItemValueScalarFieldEnum[]
  }

  /**
   * ProductionItemValue create
   */
  export type ProductionItemValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionItemValue.
     */
    data: XOR<ProductionItemValueCreateInput, ProductionItemValueUncheckedCreateInput>
  }

  /**
   * ProductionItemValue createMany
   */
  export type ProductionItemValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionItemValues.
     */
    data: ProductionItemValueCreateManyInput | ProductionItemValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionItemValue createManyAndReturn
   */
  export type ProductionItemValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionItemValues.
     */
    data: ProductionItemValueCreateManyInput | ProductionItemValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionItemValue update
   */
  export type ProductionItemValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionItemValue.
     */
    data: XOR<ProductionItemValueUpdateInput, ProductionItemValueUncheckedUpdateInput>
    /**
     * Choose, which ProductionItemValue to update.
     */
    where: ProductionItemValueWhereUniqueInput
  }

  /**
   * ProductionItemValue updateMany
   */
  export type ProductionItemValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionItemValues.
     */
    data: XOR<ProductionItemValueUpdateManyMutationInput, ProductionItemValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductionItemValues to update
     */
    where?: ProductionItemValueWhereInput
    /**
     * Limit how many ProductionItemValues to update.
     */
    limit?: number
  }

  /**
   * ProductionItemValue updateManyAndReturn
   */
  export type ProductionItemValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * The data used to update ProductionItemValues.
     */
    data: XOR<ProductionItemValueUpdateManyMutationInput, ProductionItemValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductionItemValues to update
     */
    where?: ProductionItemValueWhereInput
    /**
     * Limit how many ProductionItemValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionItemValue upsert
   */
  export type ProductionItemValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionItemValue to update in case it exists.
     */
    where: ProductionItemValueWhereUniqueInput
    /**
     * In case the ProductionItemValue found by the `where` argument doesn't exist, create a new ProductionItemValue with this data.
     */
    create: XOR<ProductionItemValueCreateInput, ProductionItemValueUncheckedCreateInput>
    /**
     * In case the ProductionItemValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionItemValueUpdateInput, ProductionItemValueUncheckedUpdateInput>
  }

  /**
   * ProductionItemValue delete
   */
  export type ProductionItemValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter which ProductionItemValue to delete.
     */
    where: ProductionItemValueWhereUniqueInput
  }

  /**
   * ProductionItemValue deleteMany
   */
  export type ProductionItemValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionItemValues to delete
     */
    where?: ProductionItemValueWhereInput
    /**
     * Limit how many ProductionItemValues to delete.
     */
    limit?: number
  }

  /**
   * ProductionItemValue without action
   */
  export type ProductionItemValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
  }


  /**
   * Model PurchasePriceList
   */

  export type AggregatePurchasePriceList = {
    _count: PurchasePriceListCountAggregateOutputType | null
    _avg: PurchasePriceListAvgAggregateOutputType | null
    _sum: PurchasePriceListSumAggregateOutputType | null
    _min: PurchasePriceListMinAggregateOutputType | null
    _max: PurchasePriceListMaxAggregateOutputType | null
  }

  export type PurchasePriceListAvgAggregateOutputType = {
    id: number | null
  }

  export type PurchasePriceListSumAggregateOutputType = {
    id: number | null
  }

  export type PurchasePriceListMinAggregateOutputType = {
    id: number | null
    date: Date | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type PurchasePriceListMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type PurchasePriceListCountAggregateOutputType = {
    id: number
    date: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type PurchasePriceListAvgAggregateInputType = {
    id?: true
  }

  export type PurchasePriceListSumAggregateInputType = {
    id?: true
  }

  export type PurchasePriceListMinAggregateInputType = {
    id?: true
    date?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type PurchasePriceListMaxAggregateInputType = {
    id?: true
    date?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type PurchasePriceListCountAggregateInputType = {
    id?: true
    date?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type PurchasePriceListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceList to aggregate.
     */
    where?: PurchasePriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceLists to fetch.
     */
    orderBy?: PurchasePriceListOrderByWithRelationInput | PurchasePriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasePriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasePriceLists
    **/
    _count?: true | PurchasePriceListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasePriceListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasePriceListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasePriceListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasePriceListMaxAggregateInputType
  }

  export type GetPurchasePriceListAggregateType<T extends PurchasePriceListAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasePriceList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasePriceList[P]>
      : GetScalarType<T[P], AggregatePurchasePriceList[P]>
  }




  export type PurchasePriceListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceListWhereInput
    orderBy?: PurchasePriceListOrderByWithAggregationInput | PurchasePriceListOrderByWithAggregationInput[]
    by: PurchasePriceListScalarFieldEnum[] | PurchasePriceListScalarFieldEnum
    having?: PurchasePriceListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasePriceListCountAggregateInputType | true
    _avg?: PurchasePriceListAvgAggregateInputType
    _sum?: PurchasePriceListSumAggregateInputType
    _min?: PurchasePriceListMinAggregateInputType
    _max?: PurchasePriceListMaxAggregateInputType
  }

  export type PurchasePriceListGroupByOutputType = {
    id: number
    date: Date
    name: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    _count: PurchasePriceListCountAggregateOutputType | null
    _avg: PurchasePriceListAvgAggregateOutputType | null
    _sum: PurchasePriceListSumAggregateOutputType | null
    _min: PurchasePriceListMinAggregateOutputType | null
    _max: PurchasePriceListMaxAggregateOutputType | null
  }

  type GetPurchasePriceListGroupByPayload<T extends PurchasePriceListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasePriceListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasePriceListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasePriceListGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasePriceListGroupByOutputType[P]>
        }
      >
    >


  export type PurchasePriceListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    suppliers?: boolean | PurchasePriceList$suppliersArgs<ExtArgs>
    items?: boolean | PurchasePriceList$itemsArgs<ExtArgs>
    _count?: boolean | PurchasePriceListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceList"]>

  export type PurchasePriceListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["purchasePriceList"]>

  export type PurchasePriceListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["purchasePriceList"]>

  export type PurchasePriceListSelectScalar = {
    id?: boolean
    date?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type PurchasePriceListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "name" | "isActive" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["purchasePriceList"]>
  export type PurchasePriceListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suppliers?: boolean | PurchasePriceList$suppliersArgs<ExtArgs>
    items?: boolean | PurchasePriceList$itemsArgs<ExtArgs>
    _count?: boolean | PurchasePriceListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchasePriceListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PurchasePriceListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PurchasePriceListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasePriceList"
    objects: {
      suppliers: Prisma.$PurchasePriceListSupplierPayload<ExtArgs>[]
      items: Prisma.$PurchasePriceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      name: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
    }, ExtArgs["result"]["purchasePriceList"]>
    composites: {}
  }

  type PurchasePriceListGetPayload<S extends boolean | null | undefined | PurchasePriceListDefaultArgs> = $Result.GetResult<Prisma.$PurchasePriceListPayload, S>

  type PurchasePriceListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchasePriceListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchasePriceListCountAggregateInputType | true
    }

  export interface PurchasePriceListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasePriceList'], meta: { name: 'PurchasePriceList' } }
    /**
     * Find zero or one PurchasePriceList that matches the filter.
     * @param {PurchasePriceListFindUniqueArgs} args - Arguments to find a PurchasePriceList
     * @example
     * // Get one PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasePriceListFindUniqueArgs>(args: SelectSubset<T, PurchasePriceListFindUniqueArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchasePriceList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchasePriceListFindUniqueOrThrowArgs} args - Arguments to find a PurchasePriceList
     * @example
     * // Get one PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasePriceListFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasePriceListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListFindFirstArgs} args - Arguments to find a PurchasePriceList
     * @example
     * // Get one PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasePriceListFindFirstArgs>(args?: SelectSubset<T, PurchasePriceListFindFirstArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListFindFirstOrThrowArgs} args - Arguments to find a PurchasePriceList
     * @example
     * // Get one PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasePriceListFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasePriceListFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchasePriceLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasePriceLists
     * const purchasePriceLists = await prisma.purchasePriceList.findMany()
     * 
     * // Get first 10 PurchasePriceLists
     * const purchasePriceLists = await prisma.purchasePriceList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasePriceListWithIdOnly = await prisma.purchasePriceList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasePriceListFindManyArgs>(args?: SelectSubset<T, PurchasePriceListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchasePriceList.
     * @param {PurchasePriceListCreateArgs} args - Arguments to create a PurchasePriceList.
     * @example
     * // Create one PurchasePriceList
     * const PurchasePriceList = await prisma.purchasePriceList.create({
     *   data: {
     *     // ... data to create a PurchasePriceList
     *   }
     * })
     * 
     */
    create<T extends PurchasePriceListCreateArgs>(args: SelectSubset<T, PurchasePriceListCreateArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchasePriceLists.
     * @param {PurchasePriceListCreateManyArgs} args - Arguments to create many PurchasePriceLists.
     * @example
     * // Create many PurchasePriceLists
     * const purchasePriceList = await prisma.purchasePriceList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasePriceListCreateManyArgs>(args?: SelectSubset<T, PurchasePriceListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasePriceLists and returns the data saved in the database.
     * @param {PurchasePriceListCreateManyAndReturnArgs} args - Arguments to create many PurchasePriceLists.
     * @example
     * // Create many PurchasePriceLists
     * const purchasePriceList = await prisma.purchasePriceList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasePriceLists and only return the `id`
     * const purchasePriceListWithIdOnly = await prisma.purchasePriceList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasePriceListCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasePriceListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchasePriceList.
     * @param {PurchasePriceListDeleteArgs} args - Arguments to delete one PurchasePriceList.
     * @example
     * // Delete one PurchasePriceList
     * const PurchasePriceList = await prisma.purchasePriceList.delete({
     *   where: {
     *     // ... filter to delete one PurchasePriceList
     *   }
     * })
     * 
     */
    delete<T extends PurchasePriceListDeleteArgs>(args: SelectSubset<T, PurchasePriceListDeleteArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchasePriceList.
     * @param {PurchasePriceListUpdateArgs} args - Arguments to update one PurchasePriceList.
     * @example
     * // Update one PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasePriceListUpdateArgs>(args: SelectSubset<T, PurchasePriceListUpdateArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchasePriceLists.
     * @param {PurchasePriceListDeleteManyArgs} args - Arguments to filter PurchasePriceLists to delete.
     * @example
     * // Delete a few PurchasePriceLists
     * const { count } = await prisma.purchasePriceList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasePriceListDeleteManyArgs>(args?: SelectSubset<T, PurchasePriceListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasePriceLists
     * const purchasePriceList = await prisma.purchasePriceList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasePriceListUpdateManyArgs>(args: SelectSubset<T, PurchasePriceListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceLists and returns the data updated in the database.
     * @param {PurchasePriceListUpdateManyAndReturnArgs} args - Arguments to update many PurchasePriceLists.
     * @example
     * // Update many PurchasePriceLists
     * const purchasePriceList = await prisma.purchasePriceList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchasePriceLists and only return the `id`
     * const purchasePriceListWithIdOnly = await prisma.purchasePriceList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchasePriceListUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchasePriceListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchasePriceList.
     * @param {PurchasePriceListUpsertArgs} args - Arguments to update or create a PurchasePriceList.
     * @example
     * // Update or create a PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.upsert({
     *   create: {
     *     // ... data to create a PurchasePriceList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasePriceList we want to update
     *   }
     * })
     */
    upsert<T extends PurchasePriceListUpsertArgs>(args: SelectSubset<T, PurchasePriceListUpsertArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchasePriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListCountArgs} args - Arguments to filter PurchasePriceLists to count.
     * @example
     * // Count the number of PurchasePriceLists
     * const count = await prisma.purchasePriceList.count({
     *   where: {
     *     // ... the filter for the PurchasePriceLists we want to count
     *   }
     * })
    **/
    count<T extends PurchasePriceListCountArgs>(
      args?: Subset<T, PurchasePriceListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasePriceListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasePriceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasePriceListAggregateArgs>(args: Subset<T, PurchasePriceListAggregateArgs>): Prisma.PrismaPromise<GetPurchasePriceListAggregateType<T>>

    /**
     * Group by PurchasePriceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasePriceListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasePriceListGroupByArgs['orderBy'] }
        : { orderBy?: PurchasePriceListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasePriceListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasePriceListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasePriceList model
   */
  readonly fields: PurchasePriceListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasePriceList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasePriceListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    suppliers<T extends PurchasePriceList$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, PurchasePriceList$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends PurchasePriceList$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchasePriceList$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasePriceList model
   */
  interface PurchasePriceListFieldRefs {
    readonly id: FieldRef<"PurchasePriceList", 'Int'>
    readonly date: FieldRef<"PurchasePriceList", 'DateTime'>
    readonly name: FieldRef<"PurchasePriceList", 'String'>
    readonly isActive: FieldRef<"PurchasePriceList", 'Boolean'>
    readonly createdAt: FieldRef<"PurchasePriceList", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchasePriceList", 'DateTime'>
    readonly createdBy: FieldRef<"PurchasePriceList", 'String'>
    readonly updatedBy: FieldRef<"PurchasePriceList", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchasePriceList findUnique
   */
  export type PurchasePriceListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceList to fetch.
     */
    where: PurchasePriceListWhereUniqueInput
  }

  /**
   * PurchasePriceList findUniqueOrThrow
   */
  export type PurchasePriceListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceList to fetch.
     */
    where: PurchasePriceListWhereUniqueInput
  }

  /**
   * PurchasePriceList findFirst
   */
  export type PurchasePriceListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceList to fetch.
     */
    where?: PurchasePriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceLists to fetch.
     */
    orderBy?: PurchasePriceListOrderByWithRelationInput | PurchasePriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceLists.
     */
    cursor?: PurchasePriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceLists.
     */
    distinct?: PurchasePriceListScalarFieldEnum | PurchasePriceListScalarFieldEnum[]
  }

  /**
   * PurchasePriceList findFirstOrThrow
   */
  export type PurchasePriceListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceList to fetch.
     */
    where?: PurchasePriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceLists to fetch.
     */
    orderBy?: PurchasePriceListOrderByWithRelationInput | PurchasePriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceLists.
     */
    cursor?: PurchasePriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceLists.
     */
    distinct?: PurchasePriceListScalarFieldEnum | PurchasePriceListScalarFieldEnum[]
  }

  /**
   * PurchasePriceList findMany
   */
  export type PurchasePriceListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceLists to fetch.
     */
    where?: PurchasePriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceLists to fetch.
     */
    orderBy?: PurchasePriceListOrderByWithRelationInput | PurchasePriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasePriceLists.
     */
    cursor?: PurchasePriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceLists.
     */
    skip?: number
    distinct?: PurchasePriceListScalarFieldEnum | PurchasePriceListScalarFieldEnum[]
  }

  /**
   * PurchasePriceList create
   */
  export type PurchasePriceListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasePriceList.
     */
    data: XOR<PurchasePriceListCreateInput, PurchasePriceListUncheckedCreateInput>
  }

  /**
   * PurchasePriceList createMany
   */
  export type PurchasePriceListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasePriceLists.
     */
    data: PurchasePriceListCreateManyInput | PurchasePriceListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasePriceList createManyAndReturn
   */
  export type PurchasePriceListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * The data used to create many PurchasePriceLists.
     */
    data: PurchasePriceListCreateManyInput | PurchasePriceListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasePriceList update
   */
  export type PurchasePriceListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasePriceList.
     */
    data: XOR<PurchasePriceListUpdateInput, PurchasePriceListUncheckedUpdateInput>
    /**
     * Choose, which PurchasePriceList to update.
     */
    where: PurchasePriceListWhereUniqueInput
  }

  /**
   * PurchasePriceList updateMany
   */
  export type PurchasePriceListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasePriceLists.
     */
    data: XOR<PurchasePriceListUpdateManyMutationInput, PurchasePriceListUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceLists to update
     */
    where?: PurchasePriceListWhereInput
    /**
     * Limit how many PurchasePriceLists to update.
     */
    limit?: number
  }

  /**
   * PurchasePriceList updateManyAndReturn
   */
  export type PurchasePriceListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * The data used to update PurchasePriceLists.
     */
    data: XOR<PurchasePriceListUpdateManyMutationInput, PurchasePriceListUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceLists to update
     */
    where?: PurchasePriceListWhereInput
    /**
     * Limit how many PurchasePriceLists to update.
     */
    limit?: number
  }

  /**
   * PurchasePriceList upsert
   */
  export type PurchasePriceListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasePriceList to update in case it exists.
     */
    where: PurchasePriceListWhereUniqueInput
    /**
     * In case the PurchasePriceList found by the `where` argument doesn't exist, create a new PurchasePriceList with this data.
     */
    create: XOR<PurchasePriceListCreateInput, PurchasePriceListUncheckedCreateInput>
    /**
     * In case the PurchasePriceList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasePriceListUpdateInput, PurchasePriceListUncheckedUpdateInput>
  }

  /**
   * PurchasePriceList delete
   */
  export type PurchasePriceListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter which PurchasePriceList to delete.
     */
    where: PurchasePriceListWhereUniqueInput
  }

  /**
   * PurchasePriceList deleteMany
   */
  export type PurchasePriceListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceLists to delete
     */
    where?: PurchasePriceListWhereInput
    /**
     * Limit how many PurchasePriceLists to delete.
     */
    limit?: number
  }

  /**
   * PurchasePriceList.suppliers
   */
  export type PurchasePriceList$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    where?: PurchasePriceListSupplierWhereInput
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * PurchasePriceList.items
   */
  export type PurchasePriceList$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    where?: PurchasePriceItemWhereInput
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    cursor?: PurchasePriceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * PurchasePriceList without action
   */
  export type PurchasePriceListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
  }


  /**
   * Model PurchasePriceListSupplier
   */

  export type AggregatePurchasePriceListSupplier = {
    _count: PurchasePriceListSupplierCountAggregateOutputType | null
    _avg: PurchasePriceListSupplierAvgAggregateOutputType | null
    _sum: PurchasePriceListSupplierSumAggregateOutputType | null
    _min: PurchasePriceListSupplierMinAggregateOutputType | null
    _max: PurchasePriceListSupplierMaxAggregateOutputType | null
  }

  export type PurchasePriceListSupplierAvgAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    primaryMmlId: number | null
  }

  export type PurchasePriceListSupplierSumAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    primaryMmlId: number | null
  }

  export type PurchasePriceListSupplierMinAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    primaryMmlId: number | null
    createdAt: Date | null
  }

  export type PurchasePriceListSupplierMaxAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    primaryMmlId: number | null
    createdAt: Date | null
  }

  export type PurchasePriceListSupplierCountAggregateOutputType = {
    id: number
    priceListId: number
    supplierId: number
    primaryMmlId: number
    createdAt: number
    _all: number
  }


  export type PurchasePriceListSupplierAvgAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    primaryMmlId?: true
  }

  export type PurchasePriceListSupplierSumAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    primaryMmlId?: true
  }

  export type PurchasePriceListSupplierMinAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    primaryMmlId?: true
    createdAt?: true
  }

  export type PurchasePriceListSupplierMaxAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    primaryMmlId?: true
    createdAt?: true
  }

  export type PurchasePriceListSupplierCountAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    primaryMmlId?: true
    createdAt?: true
    _all?: true
  }

  export type PurchasePriceListSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceListSupplier to aggregate.
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceListSuppliers to fetch.
     */
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceListSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceListSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasePriceListSuppliers
    **/
    _count?: true | PurchasePriceListSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasePriceListSupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasePriceListSupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasePriceListSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasePriceListSupplierMaxAggregateInputType
  }

  export type GetPurchasePriceListSupplierAggregateType<T extends PurchasePriceListSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasePriceListSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasePriceListSupplier[P]>
      : GetScalarType<T[P], AggregatePurchasePriceListSupplier[P]>
  }




  export type PurchasePriceListSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceListSupplierWhereInput
    orderBy?: PurchasePriceListSupplierOrderByWithAggregationInput | PurchasePriceListSupplierOrderByWithAggregationInput[]
    by: PurchasePriceListSupplierScalarFieldEnum[] | PurchasePriceListSupplierScalarFieldEnum
    having?: PurchasePriceListSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasePriceListSupplierCountAggregateInputType | true
    _avg?: PurchasePriceListSupplierAvgAggregateInputType
    _sum?: PurchasePriceListSupplierSumAggregateInputType
    _min?: PurchasePriceListSupplierMinAggregateInputType
    _max?: PurchasePriceListSupplierMaxAggregateInputType
  }

  export type PurchasePriceListSupplierGroupByOutputType = {
    id: number
    priceListId: number
    supplierId: number
    primaryMmlId: number | null
    createdAt: Date
    _count: PurchasePriceListSupplierCountAggregateOutputType | null
    _avg: PurchasePriceListSupplierAvgAggregateOutputType | null
    _sum: PurchasePriceListSupplierSumAggregateOutputType | null
    _min: PurchasePriceListSupplierMinAggregateOutputType | null
    _max: PurchasePriceListSupplierMaxAggregateOutputType | null
  }

  type GetPurchasePriceListSupplierGroupByPayload<T extends PurchasePriceListSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasePriceListSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasePriceListSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasePriceListSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasePriceListSupplierGroupByOutputType[P]>
        }
      >
    >


  export type PurchasePriceListSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceListSupplier"]>

  export type PurchasePriceListSupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceListSupplier"]>

  export type PurchasePriceListSupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceListSupplier"]>

  export type PurchasePriceListSupplierSelectScalar = {
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
  }

  export type PurchasePriceListSupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "priceListId" | "supplierId" | "primaryMmlId" | "createdAt", ExtArgs["result"]["purchasePriceListSupplier"]>
  export type PurchasePriceListSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }
  export type PurchasePriceListSupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }
  export type PurchasePriceListSupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }

  export type $PurchasePriceListSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasePriceListSupplier"
    objects: {
      priceList: Prisma.$PurchasePriceListPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      primaryMml: Prisma.$ProductionMmlPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      priceListId: number
      supplierId: number
      primaryMmlId: number | null
      createdAt: Date
    }, ExtArgs["result"]["purchasePriceListSupplier"]>
    composites: {}
  }

  type PurchasePriceListSupplierGetPayload<S extends boolean | null | undefined | PurchasePriceListSupplierDefaultArgs> = $Result.GetResult<Prisma.$PurchasePriceListSupplierPayload, S>

  type PurchasePriceListSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchasePriceListSupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchasePriceListSupplierCountAggregateInputType | true
    }

  export interface PurchasePriceListSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasePriceListSupplier'], meta: { name: 'PurchasePriceListSupplier' } }
    /**
     * Find zero or one PurchasePriceListSupplier that matches the filter.
     * @param {PurchasePriceListSupplierFindUniqueArgs} args - Arguments to find a PurchasePriceListSupplier
     * @example
     * // Get one PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasePriceListSupplierFindUniqueArgs>(args: SelectSubset<T, PurchasePriceListSupplierFindUniqueArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchasePriceListSupplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchasePriceListSupplierFindUniqueOrThrowArgs} args - Arguments to find a PurchasePriceListSupplier
     * @example
     * // Get one PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasePriceListSupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasePriceListSupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceListSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierFindFirstArgs} args - Arguments to find a PurchasePriceListSupplier
     * @example
     * // Get one PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasePriceListSupplierFindFirstArgs>(args?: SelectSubset<T, PurchasePriceListSupplierFindFirstArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceListSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierFindFirstOrThrowArgs} args - Arguments to find a PurchasePriceListSupplier
     * @example
     * // Get one PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasePriceListSupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasePriceListSupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchasePriceListSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasePriceListSuppliers
     * const purchasePriceListSuppliers = await prisma.purchasePriceListSupplier.findMany()
     * 
     * // Get first 10 PurchasePriceListSuppliers
     * const purchasePriceListSuppliers = await prisma.purchasePriceListSupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasePriceListSupplierWithIdOnly = await prisma.purchasePriceListSupplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasePriceListSupplierFindManyArgs>(args?: SelectSubset<T, PurchasePriceListSupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchasePriceListSupplier.
     * @param {PurchasePriceListSupplierCreateArgs} args - Arguments to create a PurchasePriceListSupplier.
     * @example
     * // Create one PurchasePriceListSupplier
     * const PurchasePriceListSupplier = await prisma.purchasePriceListSupplier.create({
     *   data: {
     *     // ... data to create a PurchasePriceListSupplier
     *   }
     * })
     * 
     */
    create<T extends PurchasePriceListSupplierCreateArgs>(args: SelectSubset<T, PurchasePriceListSupplierCreateArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchasePriceListSuppliers.
     * @param {PurchasePriceListSupplierCreateManyArgs} args - Arguments to create many PurchasePriceListSuppliers.
     * @example
     * // Create many PurchasePriceListSuppliers
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasePriceListSupplierCreateManyArgs>(args?: SelectSubset<T, PurchasePriceListSupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasePriceListSuppliers and returns the data saved in the database.
     * @param {PurchasePriceListSupplierCreateManyAndReturnArgs} args - Arguments to create many PurchasePriceListSuppliers.
     * @example
     * // Create many PurchasePriceListSuppliers
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasePriceListSuppliers and only return the `id`
     * const purchasePriceListSupplierWithIdOnly = await prisma.purchasePriceListSupplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasePriceListSupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasePriceListSupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchasePriceListSupplier.
     * @param {PurchasePriceListSupplierDeleteArgs} args - Arguments to delete one PurchasePriceListSupplier.
     * @example
     * // Delete one PurchasePriceListSupplier
     * const PurchasePriceListSupplier = await prisma.purchasePriceListSupplier.delete({
     *   where: {
     *     // ... filter to delete one PurchasePriceListSupplier
     *   }
     * })
     * 
     */
    delete<T extends PurchasePriceListSupplierDeleteArgs>(args: SelectSubset<T, PurchasePriceListSupplierDeleteArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchasePriceListSupplier.
     * @param {PurchasePriceListSupplierUpdateArgs} args - Arguments to update one PurchasePriceListSupplier.
     * @example
     * // Update one PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasePriceListSupplierUpdateArgs>(args: SelectSubset<T, PurchasePriceListSupplierUpdateArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchasePriceListSuppliers.
     * @param {PurchasePriceListSupplierDeleteManyArgs} args - Arguments to filter PurchasePriceListSuppliers to delete.
     * @example
     * // Delete a few PurchasePriceListSuppliers
     * const { count } = await prisma.purchasePriceListSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasePriceListSupplierDeleteManyArgs>(args?: SelectSubset<T, PurchasePriceListSupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceListSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasePriceListSuppliers
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasePriceListSupplierUpdateManyArgs>(args: SelectSubset<T, PurchasePriceListSupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceListSuppliers and returns the data updated in the database.
     * @param {PurchasePriceListSupplierUpdateManyAndReturnArgs} args - Arguments to update many PurchasePriceListSuppliers.
     * @example
     * // Update many PurchasePriceListSuppliers
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchasePriceListSuppliers and only return the `id`
     * const purchasePriceListSupplierWithIdOnly = await prisma.purchasePriceListSupplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchasePriceListSupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchasePriceListSupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchasePriceListSupplier.
     * @param {PurchasePriceListSupplierUpsertArgs} args - Arguments to update or create a PurchasePriceListSupplier.
     * @example
     * // Update or create a PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.upsert({
     *   create: {
     *     // ... data to create a PurchasePriceListSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasePriceListSupplier we want to update
     *   }
     * })
     */
    upsert<T extends PurchasePriceListSupplierUpsertArgs>(args: SelectSubset<T, PurchasePriceListSupplierUpsertArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchasePriceListSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierCountArgs} args - Arguments to filter PurchasePriceListSuppliers to count.
     * @example
     * // Count the number of PurchasePriceListSuppliers
     * const count = await prisma.purchasePriceListSupplier.count({
     *   where: {
     *     // ... the filter for the PurchasePriceListSuppliers we want to count
     *   }
     * })
    **/
    count<T extends PurchasePriceListSupplierCountArgs>(
      args?: Subset<T, PurchasePriceListSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasePriceListSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasePriceListSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasePriceListSupplierAggregateArgs>(args: Subset<T, PurchasePriceListSupplierAggregateArgs>): Prisma.PrismaPromise<GetPurchasePriceListSupplierAggregateType<T>>

    /**
     * Group by PurchasePriceListSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasePriceListSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasePriceListSupplierGroupByArgs['orderBy'] }
        : { orderBy?: PurchasePriceListSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasePriceListSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasePriceListSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasePriceListSupplier model
   */
  readonly fields: PurchasePriceListSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasePriceListSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasePriceListSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    priceList<T extends PurchasePriceListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchasePriceListDefaultArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    primaryMml<T extends PurchasePriceListSupplier$primaryMmlArgs<ExtArgs> = {}>(args?: Subset<T, PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasePriceListSupplier model
   */
  interface PurchasePriceListSupplierFieldRefs {
    readonly id: FieldRef<"PurchasePriceListSupplier", 'Int'>
    readonly priceListId: FieldRef<"PurchasePriceListSupplier", 'Int'>
    readonly supplierId: FieldRef<"PurchasePriceListSupplier", 'Int'>
    readonly primaryMmlId: FieldRef<"PurchasePriceListSupplier", 'Int'>
    readonly createdAt: FieldRef<"PurchasePriceListSupplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchasePriceListSupplier findUnique
   */
  export type PurchasePriceListSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceListSupplier to fetch.
     */
    where: PurchasePriceListSupplierWhereUniqueInput
  }

  /**
   * PurchasePriceListSupplier findUniqueOrThrow
   */
  export type PurchasePriceListSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceListSupplier to fetch.
     */
    where: PurchasePriceListSupplierWhereUniqueInput
  }

  /**
   * PurchasePriceListSupplier findFirst
   */
  export type PurchasePriceListSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceListSupplier to fetch.
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceListSuppliers to fetch.
     */
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceListSuppliers.
     */
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceListSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceListSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceListSuppliers.
     */
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * PurchasePriceListSupplier findFirstOrThrow
   */
  export type PurchasePriceListSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceListSupplier to fetch.
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceListSuppliers to fetch.
     */
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceListSuppliers.
     */
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceListSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceListSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceListSuppliers.
     */
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * PurchasePriceListSupplier findMany
   */
  export type PurchasePriceListSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceListSuppliers to fetch.
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceListSuppliers to fetch.
     */
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasePriceListSuppliers.
     */
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceListSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceListSuppliers.
     */
    skip?: number
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * PurchasePriceListSupplier create
   */
  export type PurchasePriceListSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasePriceListSupplier.
     */
    data: XOR<PurchasePriceListSupplierCreateInput, PurchasePriceListSupplierUncheckedCreateInput>
  }

  /**
   * PurchasePriceListSupplier createMany
   */
  export type PurchasePriceListSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasePriceListSuppliers.
     */
    data: PurchasePriceListSupplierCreateManyInput | PurchasePriceListSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasePriceListSupplier createManyAndReturn
   */
  export type PurchasePriceListSupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * The data used to create many PurchasePriceListSuppliers.
     */
    data: PurchasePriceListSupplierCreateManyInput | PurchasePriceListSupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasePriceListSupplier update
   */
  export type PurchasePriceListSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasePriceListSupplier.
     */
    data: XOR<PurchasePriceListSupplierUpdateInput, PurchasePriceListSupplierUncheckedUpdateInput>
    /**
     * Choose, which PurchasePriceListSupplier to update.
     */
    where: PurchasePriceListSupplierWhereUniqueInput
  }

  /**
   * PurchasePriceListSupplier updateMany
   */
  export type PurchasePriceListSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasePriceListSuppliers.
     */
    data: XOR<PurchasePriceListSupplierUpdateManyMutationInput, PurchasePriceListSupplierUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceListSuppliers to update
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * Limit how many PurchasePriceListSuppliers to update.
     */
    limit?: number
  }

  /**
   * PurchasePriceListSupplier updateManyAndReturn
   */
  export type PurchasePriceListSupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * The data used to update PurchasePriceListSuppliers.
     */
    data: XOR<PurchasePriceListSupplierUpdateManyMutationInput, PurchasePriceListSupplierUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceListSuppliers to update
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * Limit how many PurchasePriceListSuppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasePriceListSupplier upsert
   */
  export type PurchasePriceListSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasePriceListSupplier to update in case it exists.
     */
    where: PurchasePriceListSupplierWhereUniqueInput
    /**
     * In case the PurchasePriceListSupplier found by the `where` argument doesn't exist, create a new PurchasePriceListSupplier with this data.
     */
    create: XOR<PurchasePriceListSupplierCreateInput, PurchasePriceListSupplierUncheckedCreateInput>
    /**
     * In case the PurchasePriceListSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasePriceListSupplierUpdateInput, PurchasePriceListSupplierUncheckedUpdateInput>
  }

  /**
   * PurchasePriceListSupplier delete
   */
  export type PurchasePriceListSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter which PurchasePriceListSupplier to delete.
     */
    where: PurchasePriceListSupplierWhereUniqueInput
  }

  /**
   * PurchasePriceListSupplier deleteMany
   */
  export type PurchasePriceListSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceListSuppliers to delete
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * Limit how many PurchasePriceListSuppliers to delete.
     */
    limit?: number
  }

  /**
   * PurchasePriceListSupplier.primaryMml
   */
  export type PurchasePriceListSupplier$primaryMmlArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    where?: ProductionMmlWhereInput
  }

  /**
   * PurchasePriceListSupplier without action
   */
  export type PurchasePriceListSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
  }


  /**
   * Model PurchasePriceItem
   */

  export type AggregatePurchasePriceItem = {
    _count: PurchasePriceItemCountAggregateOutputType | null
    _avg: PurchasePriceItemAvgAggregateOutputType | null
    _sum: PurchasePriceItemSumAggregateOutputType | null
    _min: PurchasePriceItemMinAggregateOutputType | null
    _max: PurchasePriceItemMaxAggregateOutputType | null
  }

  export type PurchasePriceItemAvgAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    productId: number | null
    purchasePrice: Decimal | null
  }

  export type PurchasePriceItemSumAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    productId: number | null
    purchasePrice: Decimal | null
  }

  export type PurchasePriceItemMinAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    productId: number | null
    purchasePrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasePriceItemMaxAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    productId: number | null
    purchasePrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasePriceItemCountAggregateOutputType = {
    id: number
    priceListId: number
    supplierId: number
    productId: number
    purchasePrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchasePriceItemAvgAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    productId?: true
    purchasePrice?: true
  }

  export type PurchasePriceItemSumAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    productId?: true
    purchasePrice?: true
  }

  export type PurchasePriceItemMinAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    productId?: true
    purchasePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasePriceItemMaxAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    productId?: true
    purchasePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasePriceItemCountAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    productId?: true
    purchasePrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchasePriceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceItem to aggregate.
     */
    where?: PurchasePriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceItems to fetch.
     */
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasePriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasePriceItems
    **/
    _count?: true | PurchasePriceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasePriceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasePriceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasePriceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasePriceItemMaxAggregateInputType
  }

  export type GetPurchasePriceItemAggregateType<T extends PurchasePriceItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasePriceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasePriceItem[P]>
      : GetScalarType<T[P], AggregatePurchasePriceItem[P]>
  }




  export type PurchasePriceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceItemWhereInput
    orderBy?: PurchasePriceItemOrderByWithAggregationInput | PurchasePriceItemOrderByWithAggregationInput[]
    by: PurchasePriceItemScalarFieldEnum[] | PurchasePriceItemScalarFieldEnum
    having?: PurchasePriceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasePriceItemCountAggregateInputType | true
    _avg?: PurchasePriceItemAvgAggregateInputType
    _sum?: PurchasePriceItemSumAggregateInputType
    _min?: PurchasePriceItemMinAggregateInputType
    _max?: PurchasePriceItemMaxAggregateInputType
  }

  export type PurchasePriceItemGroupByOutputType = {
    id: number
    priceListId: number
    supplierId: number
    productId: number
    purchasePrice: Decimal
    createdAt: Date
    updatedAt: Date
    _count: PurchasePriceItemCountAggregateOutputType | null
    _avg: PurchasePriceItemAvgAggregateOutputType | null
    _sum: PurchasePriceItemSumAggregateOutputType | null
    _min: PurchasePriceItemMinAggregateOutputType | null
    _max: PurchasePriceItemMaxAggregateOutputType | null
  }

  type GetPurchasePriceItemGroupByPayload<T extends PurchasePriceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasePriceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasePriceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasePriceItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasePriceItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchasePriceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    productId?: boolean
    purchasePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceItem"]>

  export type PurchasePriceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    productId?: boolean
    purchasePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceItem"]>

  export type PurchasePriceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    productId?: boolean
    purchasePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceItem"]>

  export type PurchasePriceItemSelectScalar = {
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    productId?: boolean
    purchasePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchasePriceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "priceListId" | "supplierId" | "productId" | "purchasePrice" | "createdAt" | "updatedAt", ExtArgs["result"]["purchasePriceItem"]>
  export type PurchasePriceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchasePriceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchasePriceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PurchasePriceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasePriceItem"
    objects: {
      priceList: Prisma.$PurchasePriceListPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      priceListId: number
      supplierId: number
      productId: number
      purchasePrice: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchasePriceItem"]>
    composites: {}
  }

  type PurchasePriceItemGetPayload<S extends boolean | null | undefined | PurchasePriceItemDefaultArgs> = $Result.GetResult<Prisma.$PurchasePriceItemPayload, S>

  type PurchasePriceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchasePriceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchasePriceItemCountAggregateInputType | true
    }

  export interface PurchasePriceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasePriceItem'], meta: { name: 'PurchasePriceItem' } }
    /**
     * Find zero or one PurchasePriceItem that matches the filter.
     * @param {PurchasePriceItemFindUniqueArgs} args - Arguments to find a PurchasePriceItem
     * @example
     * // Get one PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasePriceItemFindUniqueArgs>(args: SelectSubset<T, PurchasePriceItemFindUniqueArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchasePriceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchasePriceItemFindUniqueOrThrowArgs} args - Arguments to find a PurchasePriceItem
     * @example
     * // Get one PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasePriceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasePriceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemFindFirstArgs} args - Arguments to find a PurchasePriceItem
     * @example
     * // Get one PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasePriceItemFindFirstArgs>(args?: SelectSubset<T, PurchasePriceItemFindFirstArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemFindFirstOrThrowArgs} args - Arguments to find a PurchasePriceItem
     * @example
     * // Get one PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasePriceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasePriceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchasePriceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasePriceItems
     * const purchasePriceItems = await prisma.purchasePriceItem.findMany()
     * 
     * // Get first 10 PurchasePriceItems
     * const purchasePriceItems = await prisma.purchasePriceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasePriceItemWithIdOnly = await prisma.purchasePriceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasePriceItemFindManyArgs>(args?: SelectSubset<T, PurchasePriceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchasePriceItem.
     * @param {PurchasePriceItemCreateArgs} args - Arguments to create a PurchasePriceItem.
     * @example
     * // Create one PurchasePriceItem
     * const PurchasePriceItem = await prisma.purchasePriceItem.create({
     *   data: {
     *     // ... data to create a PurchasePriceItem
     *   }
     * })
     * 
     */
    create<T extends PurchasePriceItemCreateArgs>(args: SelectSubset<T, PurchasePriceItemCreateArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchasePriceItems.
     * @param {PurchasePriceItemCreateManyArgs} args - Arguments to create many PurchasePriceItems.
     * @example
     * // Create many PurchasePriceItems
     * const purchasePriceItem = await prisma.purchasePriceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasePriceItemCreateManyArgs>(args?: SelectSubset<T, PurchasePriceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasePriceItems and returns the data saved in the database.
     * @param {PurchasePriceItemCreateManyAndReturnArgs} args - Arguments to create many PurchasePriceItems.
     * @example
     * // Create many PurchasePriceItems
     * const purchasePriceItem = await prisma.purchasePriceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasePriceItems and only return the `id`
     * const purchasePriceItemWithIdOnly = await prisma.purchasePriceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasePriceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasePriceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchasePriceItem.
     * @param {PurchasePriceItemDeleteArgs} args - Arguments to delete one PurchasePriceItem.
     * @example
     * // Delete one PurchasePriceItem
     * const PurchasePriceItem = await prisma.purchasePriceItem.delete({
     *   where: {
     *     // ... filter to delete one PurchasePriceItem
     *   }
     * })
     * 
     */
    delete<T extends PurchasePriceItemDeleteArgs>(args: SelectSubset<T, PurchasePriceItemDeleteArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchasePriceItem.
     * @param {PurchasePriceItemUpdateArgs} args - Arguments to update one PurchasePriceItem.
     * @example
     * // Update one PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasePriceItemUpdateArgs>(args: SelectSubset<T, PurchasePriceItemUpdateArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchasePriceItems.
     * @param {PurchasePriceItemDeleteManyArgs} args - Arguments to filter PurchasePriceItems to delete.
     * @example
     * // Delete a few PurchasePriceItems
     * const { count } = await prisma.purchasePriceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasePriceItemDeleteManyArgs>(args?: SelectSubset<T, PurchasePriceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasePriceItems
     * const purchasePriceItem = await prisma.purchasePriceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasePriceItemUpdateManyArgs>(args: SelectSubset<T, PurchasePriceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceItems and returns the data updated in the database.
     * @param {PurchasePriceItemUpdateManyAndReturnArgs} args - Arguments to update many PurchasePriceItems.
     * @example
     * // Update many PurchasePriceItems
     * const purchasePriceItem = await prisma.purchasePriceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchasePriceItems and only return the `id`
     * const purchasePriceItemWithIdOnly = await prisma.purchasePriceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchasePriceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchasePriceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchasePriceItem.
     * @param {PurchasePriceItemUpsertArgs} args - Arguments to update or create a PurchasePriceItem.
     * @example
     * // Update or create a PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.upsert({
     *   create: {
     *     // ... data to create a PurchasePriceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasePriceItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchasePriceItemUpsertArgs>(args: SelectSubset<T, PurchasePriceItemUpsertArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchasePriceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemCountArgs} args - Arguments to filter PurchasePriceItems to count.
     * @example
     * // Count the number of PurchasePriceItems
     * const count = await prisma.purchasePriceItem.count({
     *   where: {
     *     // ... the filter for the PurchasePriceItems we want to count
     *   }
     * })
    **/
    count<T extends PurchasePriceItemCountArgs>(
      args?: Subset<T, PurchasePriceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasePriceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasePriceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasePriceItemAggregateArgs>(args: Subset<T, PurchasePriceItemAggregateArgs>): Prisma.PrismaPromise<GetPurchasePriceItemAggregateType<T>>

    /**
     * Group by PurchasePriceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasePriceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasePriceItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchasePriceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasePriceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasePriceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasePriceItem model
   */
  readonly fields: PurchasePriceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasePriceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasePriceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    priceList<T extends PurchasePriceListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchasePriceListDefaultArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasePriceItem model
   */
  interface PurchasePriceItemFieldRefs {
    readonly id: FieldRef<"PurchasePriceItem", 'Int'>
    readonly priceListId: FieldRef<"PurchasePriceItem", 'Int'>
    readonly supplierId: FieldRef<"PurchasePriceItem", 'Int'>
    readonly productId: FieldRef<"PurchasePriceItem", 'Int'>
    readonly purchasePrice: FieldRef<"PurchasePriceItem", 'Decimal'>
    readonly createdAt: FieldRef<"PurchasePriceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchasePriceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchasePriceItem findUnique
   */
  export type PurchasePriceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceItem to fetch.
     */
    where: PurchasePriceItemWhereUniqueInput
  }

  /**
   * PurchasePriceItem findUniqueOrThrow
   */
  export type PurchasePriceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceItem to fetch.
     */
    where: PurchasePriceItemWhereUniqueInput
  }

  /**
   * PurchasePriceItem findFirst
   */
  export type PurchasePriceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceItem to fetch.
     */
    where?: PurchasePriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceItems to fetch.
     */
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceItems.
     */
    cursor?: PurchasePriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceItems.
     */
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * PurchasePriceItem findFirstOrThrow
   */
  export type PurchasePriceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceItem to fetch.
     */
    where?: PurchasePriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceItems to fetch.
     */
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceItems.
     */
    cursor?: PurchasePriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceItems.
     */
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * PurchasePriceItem findMany
   */
  export type PurchasePriceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceItems to fetch.
     */
    where?: PurchasePriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceItems to fetch.
     */
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasePriceItems.
     */
    cursor?: PurchasePriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceItems.
     */
    skip?: number
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * PurchasePriceItem create
   */
  export type PurchasePriceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasePriceItem.
     */
    data: XOR<PurchasePriceItemCreateInput, PurchasePriceItemUncheckedCreateInput>
  }

  /**
   * PurchasePriceItem createMany
   */
  export type PurchasePriceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasePriceItems.
     */
    data: PurchasePriceItemCreateManyInput | PurchasePriceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasePriceItem createManyAndReturn
   */
  export type PurchasePriceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchasePriceItems.
     */
    data: PurchasePriceItemCreateManyInput | PurchasePriceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasePriceItem update
   */
  export type PurchasePriceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasePriceItem.
     */
    data: XOR<PurchasePriceItemUpdateInput, PurchasePriceItemUncheckedUpdateInput>
    /**
     * Choose, which PurchasePriceItem to update.
     */
    where: PurchasePriceItemWhereUniqueInput
  }

  /**
   * PurchasePriceItem updateMany
   */
  export type PurchasePriceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasePriceItems.
     */
    data: XOR<PurchasePriceItemUpdateManyMutationInput, PurchasePriceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceItems to update
     */
    where?: PurchasePriceItemWhereInput
    /**
     * Limit how many PurchasePriceItems to update.
     */
    limit?: number
  }

  /**
   * PurchasePriceItem updateManyAndReturn
   */
  export type PurchasePriceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchasePriceItems.
     */
    data: XOR<PurchasePriceItemUpdateManyMutationInput, PurchasePriceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceItems to update
     */
    where?: PurchasePriceItemWhereInput
    /**
     * Limit how many PurchasePriceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasePriceItem upsert
   */
  export type PurchasePriceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasePriceItem to update in case it exists.
     */
    where: PurchasePriceItemWhereUniqueInput
    /**
     * In case the PurchasePriceItem found by the `where` argument doesn't exist, create a new PurchasePriceItem with this data.
     */
    create: XOR<PurchasePriceItemCreateInput, PurchasePriceItemUncheckedCreateInput>
    /**
     * In case the PurchasePriceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasePriceItemUpdateInput, PurchasePriceItemUncheckedUpdateInput>
  }

  /**
   * PurchasePriceItem delete
   */
  export type PurchasePriceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter which PurchasePriceItem to delete.
     */
    where: PurchasePriceItemWhereUniqueInput
  }

  /**
   * PurchasePriceItem deleteMany
   */
  export type PurchasePriceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceItems to delete
     */
    where?: PurchasePriceItemWhereInput
    /**
     * Limit how many PurchasePriceItems to delete.
     */
    limit?: number
  }

  /**
   * PurchasePriceItem without action
   */
  export type PurchasePriceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
  }


  /**
   * Model SalesPriceList
   */

  export type AggregateSalesPriceList = {
    _count: SalesPriceListCountAggregateOutputType | null
    _avg: SalesPriceListAvgAggregateOutputType | null
    _sum: SalesPriceListSumAggregateOutputType | null
    _min: SalesPriceListMinAggregateOutputType | null
    _max: SalesPriceListMaxAggregateOutputType | null
  }

  export type SalesPriceListAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type SalesPriceListSumAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type SalesPriceListMinAggregateOutputType = {
    id: number | null
    listType: string | null
    customerId: number | null
    title: string | null
    effectiveDate: Date | null
    status: string | null
    isCurrent: boolean | null
    isHidden: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type SalesPriceListMaxAggregateOutputType = {
    id: number | null
    listType: string | null
    customerId: number | null
    title: string | null
    effectiveDate: Date | null
    status: string | null
    isCurrent: boolean | null
    isHidden: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type SalesPriceListCountAggregateOutputType = {
    id: number
    listType: number
    customerId: number
    title: number
    effectiveDate: number
    status: number
    isCurrent: number
    isHidden: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type SalesPriceListAvgAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type SalesPriceListSumAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type SalesPriceListMinAggregateInputType = {
    id?: true
    listType?: true
    customerId?: true
    title?: true
    effectiveDate?: true
    status?: true
    isCurrent?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SalesPriceListMaxAggregateInputType = {
    id?: true
    listType?: true
    customerId?: true
    title?: true
    effectiveDate?: true
    status?: true
    isCurrent?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SalesPriceListCountAggregateInputType = {
    id?: true
    listType?: true
    customerId?: true
    title?: true
    effectiveDate?: true
    status?: true
    isCurrent?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type SalesPriceListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesPriceList to aggregate.
     */
    where?: SalesPriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceLists to fetch.
     */
    orderBy?: SalesPriceListOrderByWithRelationInput | SalesPriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesPriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesPriceLists
    **/
    _count?: true | SalesPriceListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesPriceListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesPriceListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesPriceListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesPriceListMaxAggregateInputType
  }

  export type GetSalesPriceListAggregateType<T extends SalesPriceListAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesPriceList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesPriceList[P]>
      : GetScalarType<T[P], AggregateSalesPriceList[P]>
  }




  export type SalesPriceListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesPriceListWhereInput
    orderBy?: SalesPriceListOrderByWithAggregationInput | SalesPriceListOrderByWithAggregationInput[]
    by: SalesPriceListScalarFieldEnum[] | SalesPriceListScalarFieldEnum
    having?: SalesPriceListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesPriceListCountAggregateInputType | true
    _avg?: SalesPriceListAvgAggregateInputType
    _sum?: SalesPriceListSumAggregateInputType
    _min?: SalesPriceListMinAggregateInputType
    _max?: SalesPriceListMaxAggregateInputType
  }

  export type SalesPriceListGroupByOutputType = {
    id: number
    listType: string
    customerId: number | null
    title: string | null
    effectiveDate: Date
    status: string
    isCurrent: boolean
    isHidden: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    _count: SalesPriceListCountAggregateOutputType | null
    _avg: SalesPriceListAvgAggregateOutputType | null
    _sum: SalesPriceListSumAggregateOutputType | null
    _min: SalesPriceListMinAggregateOutputType | null
    _max: SalesPriceListMaxAggregateOutputType | null
  }

  type GetSalesPriceListGroupByPayload<T extends SalesPriceListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesPriceListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesPriceListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesPriceListGroupByOutputType[P]>
            : GetScalarType<T[P], SalesPriceListGroupByOutputType[P]>
        }
      >
    >


  export type SalesPriceListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    customerId?: boolean
    title?: boolean
    effectiveDate?: boolean
    status?: boolean
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
    items?: boolean | SalesPriceList$itemsArgs<ExtArgs>
    _count?: boolean | SalesPriceListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceList"]>

  export type SalesPriceListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    customerId?: boolean
    title?: boolean
    effectiveDate?: boolean
    status?: boolean
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceList"]>

  export type SalesPriceListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    customerId?: boolean
    title?: boolean
    effectiveDate?: boolean
    status?: boolean
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceList"]>

  export type SalesPriceListSelectScalar = {
    id?: boolean
    listType?: boolean
    customerId?: boolean
    title?: boolean
    effectiveDate?: boolean
    status?: boolean
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type SalesPriceListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listType" | "customerId" | "title" | "effectiveDate" | "status" | "isCurrent" | "isHidden" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["salesPriceList"]>
  export type SalesPriceListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
    items?: boolean | SalesPriceList$itemsArgs<ExtArgs>
    _count?: boolean | SalesPriceListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesPriceListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
  }
  export type SalesPriceListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
  }

  export type $SalesPriceListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesPriceList"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      items: Prisma.$SalesPriceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      listType: string
      customerId: number | null
      title: string | null
      effectiveDate: Date
      status: string
      isCurrent: boolean
      isHidden: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
    }, ExtArgs["result"]["salesPriceList"]>
    composites: {}
  }

  type SalesPriceListGetPayload<S extends boolean | null | undefined | SalesPriceListDefaultArgs> = $Result.GetResult<Prisma.$SalesPriceListPayload, S>

  type SalesPriceListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesPriceListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesPriceListCountAggregateInputType | true
    }

  export interface SalesPriceListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesPriceList'], meta: { name: 'SalesPriceList' } }
    /**
     * Find zero or one SalesPriceList that matches the filter.
     * @param {SalesPriceListFindUniqueArgs} args - Arguments to find a SalesPriceList
     * @example
     * // Get one SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesPriceListFindUniqueArgs>(args: SelectSubset<T, SalesPriceListFindUniqueArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesPriceList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesPriceListFindUniqueOrThrowArgs} args - Arguments to find a SalesPriceList
     * @example
     * // Get one SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesPriceListFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesPriceListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesPriceList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListFindFirstArgs} args - Arguments to find a SalesPriceList
     * @example
     * // Get one SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesPriceListFindFirstArgs>(args?: SelectSubset<T, SalesPriceListFindFirstArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesPriceList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListFindFirstOrThrowArgs} args - Arguments to find a SalesPriceList
     * @example
     * // Get one SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesPriceListFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesPriceListFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesPriceLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesPriceLists
     * const salesPriceLists = await prisma.salesPriceList.findMany()
     * 
     * // Get first 10 SalesPriceLists
     * const salesPriceLists = await prisma.salesPriceList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesPriceListWithIdOnly = await prisma.salesPriceList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesPriceListFindManyArgs>(args?: SelectSubset<T, SalesPriceListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesPriceList.
     * @param {SalesPriceListCreateArgs} args - Arguments to create a SalesPriceList.
     * @example
     * // Create one SalesPriceList
     * const SalesPriceList = await prisma.salesPriceList.create({
     *   data: {
     *     // ... data to create a SalesPriceList
     *   }
     * })
     * 
     */
    create<T extends SalesPriceListCreateArgs>(args: SelectSubset<T, SalesPriceListCreateArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesPriceLists.
     * @param {SalesPriceListCreateManyArgs} args - Arguments to create many SalesPriceLists.
     * @example
     * // Create many SalesPriceLists
     * const salesPriceList = await prisma.salesPriceList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesPriceListCreateManyArgs>(args?: SelectSubset<T, SalesPriceListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesPriceLists and returns the data saved in the database.
     * @param {SalesPriceListCreateManyAndReturnArgs} args - Arguments to create many SalesPriceLists.
     * @example
     * // Create many SalesPriceLists
     * const salesPriceList = await prisma.salesPriceList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesPriceLists and only return the `id`
     * const salesPriceListWithIdOnly = await prisma.salesPriceList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesPriceListCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesPriceListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesPriceList.
     * @param {SalesPriceListDeleteArgs} args - Arguments to delete one SalesPriceList.
     * @example
     * // Delete one SalesPriceList
     * const SalesPriceList = await prisma.salesPriceList.delete({
     *   where: {
     *     // ... filter to delete one SalesPriceList
     *   }
     * })
     * 
     */
    delete<T extends SalesPriceListDeleteArgs>(args: SelectSubset<T, SalesPriceListDeleteArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesPriceList.
     * @param {SalesPriceListUpdateArgs} args - Arguments to update one SalesPriceList.
     * @example
     * // Update one SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesPriceListUpdateArgs>(args: SelectSubset<T, SalesPriceListUpdateArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesPriceLists.
     * @param {SalesPriceListDeleteManyArgs} args - Arguments to filter SalesPriceLists to delete.
     * @example
     * // Delete a few SalesPriceLists
     * const { count } = await prisma.salesPriceList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesPriceListDeleteManyArgs>(args?: SelectSubset<T, SalesPriceListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesPriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesPriceLists
     * const salesPriceList = await prisma.salesPriceList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesPriceListUpdateManyArgs>(args: SelectSubset<T, SalesPriceListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesPriceLists and returns the data updated in the database.
     * @param {SalesPriceListUpdateManyAndReturnArgs} args - Arguments to update many SalesPriceLists.
     * @example
     * // Update many SalesPriceLists
     * const salesPriceList = await prisma.salesPriceList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesPriceLists and only return the `id`
     * const salesPriceListWithIdOnly = await prisma.salesPriceList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesPriceListUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesPriceListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesPriceList.
     * @param {SalesPriceListUpsertArgs} args - Arguments to update or create a SalesPriceList.
     * @example
     * // Update or create a SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.upsert({
     *   create: {
     *     // ... data to create a SalesPriceList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesPriceList we want to update
     *   }
     * })
     */
    upsert<T extends SalesPriceListUpsertArgs>(args: SelectSubset<T, SalesPriceListUpsertArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesPriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListCountArgs} args - Arguments to filter SalesPriceLists to count.
     * @example
     * // Count the number of SalesPriceLists
     * const count = await prisma.salesPriceList.count({
     *   where: {
     *     // ... the filter for the SalesPriceLists we want to count
     *   }
     * })
    **/
    count<T extends SalesPriceListCountArgs>(
      args?: Subset<T, SalesPriceListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesPriceListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesPriceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesPriceListAggregateArgs>(args: Subset<T, SalesPriceListAggregateArgs>): Prisma.PrismaPromise<GetSalesPriceListAggregateType<T>>

    /**
     * Group by SalesPriceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesPriceListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesPriceListGroupByArgs['orderBy'] }
        : { orderBy?: SalesPriceListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesPriceListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesPriceListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesPriceList model
   */
  readonly fields: SalesPriceListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesPriceList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesPriceListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends SalesPriceList$customerArgs<ExtArgs> = {}>(args?: Subset<T, SalesPriceList$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends SalesPriceList$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SalesPriceList$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesPriceList model
   */
  interface SalesPriceListFieldRefs {
    readonly id: FieldRef<"SalesPriceList", 'Int'>
    readonly listType: FieldRef<"SalesPriceList", 'String'>
    readonly customerId: FieldRef<"SalesPriceList", 'Int'>
    readonly title: FieldRef<"SalesPriceList", 'String'>
    readonly effectiveDate: FieldRef<"SalesPriceList", 'DateTime'>
    readonly status: FieldRef<"SalesPriceList", 'String'>
    readonly isCurrent: FieldRef<"SalesPriceList", 'Boolean'>
    readonly isHidden: FieldRef<"SalesPriceList", 'Boolean'>
    readonly createdAt: FieldRef<"SalesPriceList", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesPriceList", 'DateTime'>
    readonly createdBy: FieldRef<"SalesPriceList", 'String'>
    readonly updatedBy: FieldRef<"SalesPriceList", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SalesPriceList findUnique
   */
  export type SalesPriceListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceList to fetch.
     */
    where: SalesPriceListWhereUniqueInput
  }

  /**
   * SalesPriceList findUniqueOrThrow
   */
  export type SalesPriceListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceList to fetch.
     */
    where: SalesPriceListWhereUniqueInput
  }

  /**
   * SalesPriceList findFirst
   */
  export type SalesPriceListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceList to fetch.
     */
    where?: SalesPriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceLists to fetch.
     */
    orderBy?: SalesPriceListOrderByWithRelationInput | SalesPriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesPriceLists.
     */
    cursor?: SalesPriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesPriceLists.
     */
    distinct?: SalesPriceListScalarFieldEnum | SalesPriceListScalarFieldEnum[]
  }

  /**
   * SalesPriceList findFirstOrThrow
   */
  export type SalesPriceListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceList to fetch.
     */
    where?: SalesPriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceLists to fetch.
     */
    orderBy?: SalesPriceListOrderByWithRelationInput | SalesPriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesPriceLists.
     */
    cursor?: SalesPriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesPriceLists.
     */
    distinct?: SalesPriceListScalarFieldEnum | SalesPriceListScalarFieldEnum[]
  }

  /**
   * SalesPriceList findMany
   */
  export type SalesPriceListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceLists to fetch.
     */
    where?: SalesPriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceLists to fetch.
     */
    orderBy?: SalesPriceListOrderByWithRelationInput | SalesPriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesPriceLists.
     */
    cursor?: SalesPriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceLists.
     */
    skip?: number
    distinct?: SalesPriceListScalarFieldEnum | SalesPriceListScalarFieldEnum[]
  }

  /**
   * SalesPriceList create
   */
  export type SalesPriceListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesPriceList.
     */
    data: XOR<SalesPriceListCreateInput, SalesPriceListUncheckedCreateInput>
  }

  /**
   * SalesPriceList createMany
   */
  export type SalesPriceListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesPriceLists.
     */
    data: SalesPriceListCreateManyInput | SalesPriceListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesPriceList createManyAndReturn
   */
  export type SalesPriceListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * The data used to create many SalesPriceLists.
     */
    data: SalesPriceListCreateManyInput | SalesPriceListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesPriceList update
   */
  export type SalesPriceListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesPriceList.
     */
    data: XOR<SalesPriceListUpdateInput, SalesPriceListUncheckedUpdateInput>
    /**
     * Choose, which SalesPriceList to update.
     */
    where: SalesPriceListWhereUniqueInput
  }

  /**
   * SalesPriceList updateMany
   */
  export type SalesPriceListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesPriceLists.
     */
    data: XOR<SalesPriceListUpdateManyMutationInput, SalesPriceListUncheckedUpdateManyInput>
    /**
     * Filter which SalesPriceLists to update
     */
    where?: SalesPriceListWhereInput
    /**
     * Limit how many SalesPriceLists to update.
     */
    limit?: number
  }

  /**
   * SalesPriceList updateManyAndReturn
   */
  export type SalesPriceListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * The data used to update SalesPriceLists.
     */
    data: XOR<SalesPriceListUpdateManyMutationInput, SalesPriceListUncheckedUpdateManyInput>
    /**
     * Filter which SalesPriceLists to update
     */
    where?: SalesPriceListWhereInput
    /**
     * Limit how many SalesPriceLists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesPriceList upsert
   */
  export type SalesPriceListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesPriceList to update in case it exists.
     */
    where: SalesPriceListWhereUniqueInput
    /**
     * In case the SalesPriceList found by the `where` argument doesn't exist, create a new SalesPriceList with this data.
     */
    create: XOR<SalesPriceListCreateInput, SalesPriceListUncheckedCreateInput>
    /**
     * In case the SalesPriceList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesPriceListUpdateInput, SalesPriceListUncheckedUpdateInput>
  }

  /**
   * SalesPriceList delete
   */
  export type SalesPriceListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter which SalesPriceList to delete.
     */
    where: SalesPriceListWhereUniqueInput
  }

  /**
   * SalesPriceList deleteMany
   */
  export type SalesPriceListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesPriceLists to delete
     */
    where?: SalesPriceListWhereInput
    /**
     * Limit how many SalesPriceLists to delete.
     */
    limit?: number
  }

  /**
   * SalesPriceList.customer
   */
  export type SalesPriceList$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * SalesPriceList.items
   */
  export type SalesPriceList$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    where?: SalesPriceItemWhereInput
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    cursor?: SalesPriceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesPriceItemScalarFieldEnum | SalesPriceItemScalarFieldEnum[]
  }

  /**
   * SalesPriceList without action
   */
  export type SalesPriceListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
  }


  /**
   * Model SalesPriceItem
   */

  export type AggregateSalesPriceItem = {
    _count: SalesPriceItemCountAggregateOutputType | null
    _avg: SalesPriceItemAvgAggregateOutputType | null
    _sum: SalesPriceItemSumAggregateOutputType | null
    _min: SalesPriceItemMinAggregateOutputType | null
    _max: SalesPriceItemMaxAggregateOutputType | null
  }

  export type SalesPriceItemAvgAggregateOutputType = {
    id: number | null
    priceListId: number | null
    productId: number | null
    salePrice: Decimal | null
  }

  export type SalesPriceItemSumAggregateOutputType = {
    id: number | null
    priceListId: number | null
    productId: number | null
    salePrice: Decimal | null
  }

  export type SalesPriceItemMinAggregateOutputType = {
    id: number | null
    priceListId: number | null
    productId: number | null
    salePrice: Decimal | null
    rowDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SalesPriceItemMaxAggregateOutputType = {
    id: number | null
    priceListId: number | null
    productId: number | null
    salePrice: Decimal | null
    rowDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SalesPriceItemCountAggregateOutputType = {
    id: number
    priceListId: number
    productId: number
    salePrice: number
    rowDate: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SalesPriceItemAvgAggregateInputType = {
    id?: true
    priceListId?: true
    productId?: true
    salePrice?: true
  }

  export type SalesPriceItemSumAggregateInputType = {
    id?: true
    priceListId?: true
    productId?: true
    salePrice?: true
  }

  export type SalesPriceItemMinAggregateInputType = {
    id?: true
    priceListId?: true
    productId?: true
    salePrice?: true
    rowDate?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SalesPriceItemMaxAggregateInputType = {
    id?: true
    priceListId?: true
    productId?: true
    salePrice?: true
    rowDate?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SalesPriceItemCountAggregateInputType = {
    id?: true
    priceListId?: true
    productId?: true
    salePrice?: true
    rowDate?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SalesPriceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesPriceItem to aggregate.
     */
    where?: SalesPriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceItems to fetch.
     */
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesPriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesPriceItems
    **/
    _count?: true | SalesPriceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesPriceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesPriceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesPriceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesPriceItemMaxAggregateInputType
  }

  export type GetSalesPriceItemAggregateType<T extends SalesPriceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesPriceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesPriceItem[P]>
      : GetScalarType<T[P], AggregateSalesPriceItem[P]>
  }




  export type SalesPriceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesPriceItemWhereInput
    orderBy?: SalesPriceItemOrderByWithAggregationInput | SalesPriceItemOrderByWithAggregationInput[]
    by: SalesPriceItemScalarFieldEnum[] | SalesPriceItemScalarFieldEnum
    having?: SalesPriceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesPriceItemCountAggregateInputType | true
    _avg?: SalesPriceItemAvgAggregateInputType
    _sum?: SalesPriceItemSumAggregateInputType
    _min?: SalesPriceItemMinAggregateInputType
    _max?: SalesPriceItemMaxAggregateInputType
  }

  export type SalesPriceItemGroupByOutputType = {
    id: number
    priceListId: number
    productId: number
    salePrice: Decimal
    rowDate: Date
    createdAt: Date
    updatedAt: Date
    updatedBy: string | null
    _count: SalesPriceItemCountAggregateOutputType | null
    _avg: SalesPriceItemAvgAggregateOutputType | null
    _sum: SalesPriceItemSumAggregateOutputType | null
    _min: SalesPriceItemMinAggregateOutputType | null
    _max: SalesPriceItemMaxAggregateOutputType | null
  }

  type GetSalesPriceItemGroupByPayload<T extends SalesPriceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesPriceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesPriceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesPriceItemGroupByOutputType[P]>
            : GetScalarType<T[P], SalesPriceItemGroupByOutputType[P]>
        }
      >
    >


  export type SalesPriceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    productId?: boolean
    salePrice?: boolean
    rowDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceItem"]>

  export type SalesPriceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    productId?: boolean
    salePrice?: boolean
    rowDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceItem"]>

  export type SalesPriceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    productId?: boolean
    salePrice?: boolean
    rowDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceItem"]>

  export type SalesPriceItemSelectScalar = {
    id?: boolean
    priceListId?: boolean
    productId?: boolean
    salePrice?: boolean
    rowDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type SalesPriceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "priceListId" | "productId" | "salePrice" | "rowDate" | "createdAt" | "updatedAt" | "updatedBy", ExtArgs["result"]["salesPriceItem"]>
  export type SalesPriceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SalesPriceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SalesPriceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $SalesPriceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesPriceItem"
    objects: {
      priceList: Prisma.$SalesPriceListPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      priceListId: number
      productId: number
      salePrice: Prisma.Decimal
      rowDate: Date
      createdAt: Date
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["salesPriceItem"]>
    composites: {}
  }

  type SalesPriceItemGetPayload<S extends boolean | null | undefined | SalesPriceItemDefaultArgs> = $Result.GetResult<Prisma.$SalesPriceItemPayload, S>

  type SalesPriceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesPriceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesPriceItemCountAggregateInputType | true
    }

  export interface SalesPriceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesPriceItem'], meta: { name: 'SalesPriceItem' } }
    /**
     * Find zero or one SalesPriceItem that matches the filter.
     * @param {SalesPriceItemFindUniqueArgs} args - Arguments to find a SalesPriceItem
     * @example
     * // Get one SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesPriceItemFindUniqueArgs>(args: SelectSubset<T, SalesPriceItemFindUniqueArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesPriceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesPriceItemFindUniqueOrThrowArgs} args - Arguments to find a SalesPriceItem
     * @example
     * // Get one SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesPriceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesPriceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesPriceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemFindFirstArgs} args - Arguments to find a SalesPriceItem
     * @example
     * // Get one SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesPriceItemFindFirstArgs>(args?: SelectSubset<T, SalesPriceItemFindFirstArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesPriceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemFindFirstOrThrowArgs} args - Arguments to find a SalesPriceItem
     * @example
     * // Get one SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesPriceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesPriceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesPriceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesPriceItems
     * const salesPriceItems = await prisma.salesPriceItem.findMany()
     * 
     * // Get first 10 SalesPriceItems
     * const salesPriceItems = await prisma.salesPriceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesPriceItemWithIdOnly = await prisma.salesPriceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesPriceItemFindManyArgs>(args?: SelectSubset<T, SalesPriceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesPriceItem.
     * @param {SalesPriceItemCreateArgs} args - Arguments to create a SalesPriceItem.
     * @example
     * // Create one SalesPriceItem
     * const SalesPriceItem = await prisma.salesPriceItem.create({
     *   data: {
     *     // ... data to create a SalesPriceItem
     *   }
     * })
     * 
     */
    create<T extends SalesPriceItemCreateArgs>(args: SelectSubset<T, SalesPriceItemCreateArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesPriceItems.
     * @param {SalesPriceItemCreateManyArgs} args - Arguments to create many SalesPriceItems.
     * @example
     * // Create many SalesPriceItems
     * const salesPriceItem = await prisma.salesPriceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesPriceItemCreateManyArgs>(args?: SelectSubset<T, SalesPriceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesPriceItems and returns the data saved in the database.
     * @param {SalesPriceItemCreateManyAndReturnArgs} args - Arguments to create many SalesPriceItems.
     * @example
     * // Create many SalesPriceItems
     * const salesPriceItem = await prisma.salesPriceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesPriceItems and only return the `id`
     * const salesPriceItemWithIdOnly = await prisma.salesPriceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesPriceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesPriceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesPriceItem.
     * @param {SalesPriceItemDeleteArgs} args - Arguments to delete one SalesPriceItem.
     * @example
     * // Delete one SalesPriceItem
     * const SalesPriceItem = await prisma.salesPriceItem.delete({
     *   where: {
     *     // ... filter to delete one SalesPriceItem
     *   }
     * })
     * 
     */
    delete<T extends SalesPriceItemDeleteArgs>(args: SelectSubset<T, SalesPriceItemDeleteArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesPriceItem.
     * @param {SalesPriceItemUpdateArgs} args - Arguments to update one SalesPriceItem.
     * @example
     * // Update one SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesPriceItemUpdateArgs>(args: SelectSubset<T, SalesPriceItemUpdateArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesPriceItems.
     * @param {SalesPriceItemDeleteManyArgs} args - Arguments to filter SalesPriceItems to delete.
     * @example
     * // Delete a few SalesPriceItems
     * const { count } = await prisma.salesPriceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesPriceItemDeleteManyArgs>(args?: SelectSubset<T, SalesPriceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesPriceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesPriceItems
     * const salesPriceItem = await prisma.salesPriceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesPriceItemUpdateManyArgs>(args: SelectSubset<T, SalesPriceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesPriceItems and returns the data updated in the database.
     * @param {SalesPriceItemUpdateManyAndReturnArgs} args - Arguments to update many SalesPriceItems.
     * @example
     * // Update many SalesPriceItems
     * const salesPriceItem = await prisma.salesPriceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesPriceItems and only return the `id`
     * const salesPriceItemWithIdOnly = await prisma.salesPriceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesPriceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesPriceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesPriceItem.
     * @param {SalesPriceItemUpsertArgs} args - Arguments to update or create a SalesPriceItem.
     * @example
     * // Update or create a SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.upsert({
     *   create: {
     *     // ... data to create a SalesPriceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesPriceItem we want to update
     *   }
     * })
     */
    upsert<T extends SalesPriceItemUpsertArgs>(args: SelectSubset<T, SalesPriceItemUpsertArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesPriceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemCountArgs} args - Arguments to filter SalesPriceItems to count.
     * @example
     * // Count the number of SalesPriceItems
     * const count = await prisma.salesPriceItem.count({
     *   where: {
     *     // ... the filter for the SalesPriceItems we want to count
     *   }
     * })
    **/
    count<T extends SalesPriceItemCountArgs>(
      args?: Subset<T, SalesPriceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesPriceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesPriceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesPriceItemAggregateArgs>(args: Subset<T, SalesPriceItemAggregateArgs>): Prisma.PrismaPromise<GetSalesPriceItemAggregateType<T>>

    /**
     * Group by SalesPriceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesPriceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesPriceItemGroupByArgs['orderBy'] }
        : { orderBy?: SalesPriceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesPriceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesPriceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesPriceItem model
   */
  readonly fields: SalesPriceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesPriceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesPriceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    priceList<T extends SalesPriceListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesPriceListDefaultArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesPriceItem model
   */
  interface SalesPriceItemFieldRefs {
    readonly id: FieldRef<"SalesPriceItem", 'Int'>
    readonly priceListId: FieldRef<"SalesPriceItem", 'Int'>
    readonly productId: FieldRef<"SalesPriceItem", 'Int'>
    readonly salePrice: FieldRef<"SalesPriceItem", 'Decimal'>
    readonly rowDate: FieldRef<"SalesPriceItem", 'DateTime'>
    readonly createdAt: FieldRef<"SalesPriceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesPriceItem", 'DateTime'>
    readonly updatedBy: FieldRef<"SalesPriceItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SalesPriceItem findUnique
   */
  export type SalesPriceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceItem to fetch.
     */
    where: SalesPriceItemWhereUniqueInput
  }

  /**
   * SalesPriceItem findUniqueOrThrow
   */
  export type SalesPriceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceItem to fetch.
     */
    where: SalesPriceItemWhereUniqueInput
  }

  /**
   * SalesPriceItem findFirst
   */
  export type SalesPriceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceItem to fetch.
     */
    where?: SalesPriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceItems to fetch.
     */
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesPriceItems.
     */
    cursor?: SalesPriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesPriceItems.
     */
    distinct?: SalesPriceItemScalarFieldEnum | SalesPriceItemScalarFieldEnum[]
  }

  /**
   * SalesPriceItem findFirstOrThrow
   */
  export type SalesPriceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceItem to fetch.
     */
    where?: SalesPriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceItems to fetch.
     */
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesPriceItems.
     */
    cursor?: SalesPriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesPriceItems.
     */
    distinct?: SalesPriceItemScalarFieldEnum | SalesPriceItemScalarFieldEnum[]
  }

  /**
   * SalesPriceItem findMany
   */
  export type SalesPriceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceItems to fetch.
     */
    where?: SalesPriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceItems to fetch.
     */
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesPriceItems.
     */
    cursor?: SalesPriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceItems.
     */
    skip?: number
    distinct?: SalesPriceItemScalarFieldEnum | SalesPriceItemScalarFieldEnum[]
  }

  /**
   * SalesPriceItem create
   */
  export type SalesPriceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesPriceItem.
     */
    data: XOR<SalesPriceItemCreateInput, SalesPriceItemUncheckedCreateInput>
  }

  /**
   * SalesPriceItem createMany
   */
  export type SalesPriceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesPriceItems.
     */
    data: SalesPriceItemCreateManyInput | SalesPriceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesPriceItem createManyAndReturn
   */
  export type SalesPriceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * The data used to create many SalesPriceItems.
     */
    data: SalesPriceItemCreateManyInput | SalesPriceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesPriceItem update
   */
  export type SalesPriceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesPriceItem.
     */
    data: XOR<SalesPriceItemUpdateInput, SalesPriceItemUncheckedUpdateInput>
    /**
     * Choose, which SalesPriceItem to update.
     */
    where: SalesPriceItemWhereUniqueInput
  }

  /**
   * SalesPriceItem updateMany
   */
  export type SalesPriceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesPriceItems.
     */
    data: XOR<SalesPriceItemUpdateManyMutationInput, SalesPriceItemUncheckedUpdateManyInput>
    /**
     * Filter which SalesPriceItems to update
     */
    where?: SalesPriceItemWhereInput
    /**
     * Limit how many SalesPriceItems to update.
     */
    limit?: number
  }

  /**
   * SalesPriceItem updateManyAndReturn
   */
  export type SalesPriceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * The data used to update SalesPriceItems.
     */
    data: XOR<SalesPriceItemUpdateManyMutationInput, SalesPriceItemUncheckedUpdateManyInput>
    /**
     * Filter which SalesPriceItems to update
     */
    where?: SalesPriceItemWhereInput
    /**
     * Limit how many SalesPriceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesPriceItem upsert
   */
  export type SalesPriceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesPriceItem to update in case it exists.
     */
    where: SalesPriceItemWhereUniqueInput
    /**
     * In case the SalesPriceItem found by the `where` argument doesn't exist, create a new SalesPriceItem with this data.
     */
    create: XOR<SalesPriceItemCreateInput, SalesPriceItemUncheckedCreateInput>
    /**
     * In case the SalesPriceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesPriceItemUpdateInput, SalesPriceItemUncheckedUpdateInput>
  }

  /**
   * SalesPriceItem delete
   */
  export type SalesPriceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter which SalesPriceItem to delete.
     */
    where: SalesPriceItemWhereUniqueInput
  }

  /**
   * SalesPriceItem deleteMany
   */
  export type SalesPriceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesPriceItems to delete
     */
    where?: SalesPriceItemWhereInput
    /**
     * Limit how many SalesPriceItems to delete.
     */
    limit?: number
  }

  /**
   * SalesPriceItem without action
   */
  export type SalesPriceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
  }


  /**
   * Model ProductionMml
   */

  export type AggregateProductionMml = {
    _count: ProductionMmlCountAggregateOutputType | null
    _avg: ProductionMmlAvgAggregateOutputType | null
    _sum: ProductionMmlSumAggregateOutputType | null
    _min: ProductionMmlMinAggregateOutputType | null
    _max: ProductionMmlMaxAggregateOutputType | null
  }

  export type ProductionMmlAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    createdBy: number | null
  }

  export type ProductionMmlSumAggregateOutputType = {
    id: number | null
    productId: number | null
    createdBy: number | null
  }

  export type ProductionMmlMinAggregateOutputType = {
    id: number | null
    productId: number | null
    createdBy: number | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionMmlMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    createdBy: number | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionMmlCountAggregateOutputType = {
    id: number
    productId: number
    createdBy: number
    isLocked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionMmlAvgAggregateInputType = {
    id?: true
    productId?: true
    createdBy?: true
  }

  export type ProductionMmlSumAggregateInputType = {
    id?: true
    productId?: true
    createdBy?: true
  }

  export type ProductionMmlMinAggregateInputType = {
    id?: true
    productId?: true
    createdBy?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionMmlMaxAggregateInputType = {
    id?: true
    productId?: true
    createdBy?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionMmlCountAggregateInputType = {
    id?: true
    productId?: true
    createdBy?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionMmlAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionMml to aggregate.
     */
    where?: ProductionMmlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmls to fetch.
     */
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionMmlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionMmls
    **/
    _count?: true | ProductionMmlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionMmlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionMmlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionMmlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionMmlMaxAggregateInputType
  }

  export type GetProductionMmlAggregateType<T extends ProductionMmlAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionMml]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionMml[P]>
      : GetScalarType<T[P], AggregateProductionMml[P]>
  }




  export type ProductionMmlGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlWhereInput
    orderBy?: ProductionMmlOrderByWithAggregationInput | ProductionMmlOrderByWithAggregationInput[]
    by: ProductionMmlScalarFieldEnum[] | ProductionMmlScalarFieldEnum
    having?: ProductionMmlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionMmlCountAggregateInputType | true
    _avg?: ProductionMmlAvgAggregateInputType
    _sum?: ProductionMmlSumAggregateInputType
    _min?: ProductionMmlMinAggregateInputType
    _max?: ProductionMmlMaxAggregateInputType
  }

  export type ProductionMmlGroupByOutputType = {
    id: number
    productId: number
    createdBy: number
    isLocked: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductionMmlCountAggregateOutputType | null
    _avg: ProductionMmlAvgAggregateOutputType | null
    _sum: ProductionMmlSumAggregateOutputType | null
    _min: ProductionMmlMinAggregateOutputType | null
    _max: ProductionMmlMaxAggregateOutputType | null
  }

  type GetProductionMmlGroupByPayload<T extends ProductionMmlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionMmlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionMmlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionMmlGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionMmlGroupByOutputType[P]>
        }
      >
    >


  export type ProductionMmlSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    createdBy?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    nodes?: boolean | ProductionMml$nodesArgs<ExtArgs>
    runs?: boolean | ProductionMml$runsArgs<ExtArgs>
    suppliersWithPrimaryMml?: boolean | ProductionMml$suppliersWithPrimaryMmlArgs<ExtArgs>
    priceListSuppliers?: boolean | ProductionMml$priceListSuppliersArgs<ExtArgs>
    _count?: boolean | ProductionMmlCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMml"]>

  export type ProductionMmlSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    createdBy?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMml"]>

  export type ProductionMmlSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    createdBy?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMml"]>

  export type ProductionMmlSelectScalar = {
    id?: boolean
    productId?: boolean
    createdBy?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionMmlOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "createdBy" | "isLocked" | "createdAt" | "updatedAt", ExtArgs["result"]["productionMml"]>
  export type ProductionMmlInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    nodes?: boolean | ProductionMml$nodesArgs<ExtArgs>
    runs?: boolean | ProductionMml$runsArgs<ExtArgs>
    suppliersWithPrimaryMml?: boolean | ProductionMml$suppliersWithPrimaryMmlArgs<ExtArgs>
    priceListSuppliers?: boolean | ProductionMml$priceListSuppliersArgs<ExtArgs>
    _count?: boolean | ProductionMmlCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionMmlIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductionMmlIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductionMmlPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionMml"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      nodes: Prisma.$ProductionMmlNodePayload<ExtArgs>[]
      runs: Prisma.$ProductionRunPayload<ExtArgs>[]
      suppliersWithPrimaryMml: Prisma.$SupplierPayload<ExtArgs>[]
      priceListSuppliers: Prisma.$PurchasePriceListSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      createdBy: number
      isLocked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionMml"]>
    composites: {}
  }

  type ProductionMmlGetPayload<S extends boolean | null | undefined | ProductionMmlDefaultArgs> = $Result.GetResult<Prisma.$ProductionMmlPayload, S>

  type ProductionMmlCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionMmlFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionMmlCountAggregateInputType | true
    }

  export interface ProductionMmlDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionMml'], meta: { name: 'ProductionMml' } }
    /**
     * Find zero or one ProductionMml that matches the filter.
     * @param {ProductionMmlFindUniqueArgs} args - Arguments to find a ProductionMml
     * @example
     * // Get one ProductionMml
     * const productionMml = await prisma.productionMml.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionMmlFindUniqueArgs>(args: SelectSubset<T, ProductionMmlFindUniqueArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionMml that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionMmlFindUniqueOrThrowArgs} args - Arguments to find a ProductionMml
     * @example
     * // Get one ProductionMml
     * const productionMml = await prisma.productionMml.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionMmlFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionMmlFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionMml that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlFindFirstArgs} args - Arguments to find a ProductionMml
     * @example
     * // Get one ProductionMml
     * const productionMml = await prisma.productionMml.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionMmlFindFirstArgs>(args?: SelectSubset<T, ProductionMmlFindFirstArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionMml that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlFindFirstOrThrowArgs} args - Arguments to find a ProductionMml
     * @example
     * // Get one ProductionMml
     * const productionMml = await prisma.productionMml.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionMmlFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionMmlFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionMmls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionMmls
     * const productionMmls = await prisma.productionMml.findMany()
     * 
     * // Get first 10 ProductionMmls
     * const productionMmls = await prisma.productionMml.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionMmlWithIdOnly = await prisma.productionMml.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionMmlFindManyArgs>(args?: SelectSubset<T, ProductionMmlFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionMml.
     * @param {ProductionMmlCreateArgs} args - Arguments to create a ProductionMml.
     * @example
     * // Create one ProductionMml
     * const ProductionMml = await prisma.productionMml.create({
     *   data: {
     *     // ... data to create a ProductionMml
     *   }
     * })
     * 
     */
    create<T extends ProductionMmlCreateArgs>(args: SelectSubset<T, ProductionMmlCreateArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionMmls.
     * @param {ProductionMmlCreateManyArgs} args - Arguments to create many ProductionMmls.
     * @example
     * // Create many ProductionMmls
     * const productionMml = await prisma.productionMml.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionMmlCreateManyArgs>(args?: SelectSubset<T, ProductionMmlCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionMmls and returns the data saved in the database.
     * @param {ProductionMmlCreateManyAndReturnArgs} args - Arguments to create many ProductionMmls.
     * @example
     * // Create many ProductionMmls
     * const productionMml = await prisma.productionMml.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionMmls and only return the `id`
     * const productionMmlWithIdOnly = await prisma.productionMml.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionMmlCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionMmlCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionMml.
     * @param {ProductionMmlDeleteArgs} args - Arguments to delete one ProductionMml.
     * @example
     * // Delete one ProductionMml
     * const ProductionMml = await prisma.productionMml.delete({
     *   where: {
     *     // ... filter to delete one ProductionMml
     *   }
     * })
     * 
     */
    delete<T extends ProductionMmlDeleteArgs>(args: SelectSubset<T, ProductionMmlDeleteArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionMml.
     * @param {ProductionMmlUpdateArgs} args - Arguments to update one ProductionMml.
     * @example
     * // Update one ProductionMml
     * const productionMml = await prisma.productionMml.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionMmlUpdateArgs>(args: SelectSubset<T, ProductionMmlUpdateArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionMmls.
     * @param {ProductionMmlDeleteManyArgs} args - Arguments to filter ProductionMmls to delete.
     * @example
     * // Delete a few ProductionMmls
     * const { count } = await prisma.productionMml.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionMmlDeleteManyArgs>(args?: SelectSubset<T, ProductionMmlDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionMmls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionMmls
     * const productionMml = await prisma.productionMml.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionMmlUpdateManyArgs>(args: SelectSubset<T, ProductionMmlUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionMmls and returns the data updated in the database.
     * @param {ProductionMmlUpdateManyAndReturnArgs} args - Arguments to update many ProductionMmls.
     * @example
     * // Update many ProductionMmls
     * const productionMml = await prisma.productionMml.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionMmls and only return the `id`
     * const productionMmlWithIdOnly = await prisma.productionMml.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionMmlUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionMmlUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionMml.
     * @param {ProductionMmlUpsertArgs} args - Arguments to update or create a ProductionMml.
     * @example
     * // Update or create a ProductionMml
     * const productionMml = await prisma.productionMml.upsert({
     *   create: {
     *     // ... data to create a ProductionMml
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionMml we want to update
     *   }
     * })
     */
    upsert<T extends ProductionMmlUpsertArgs>(args: SelectSubset<T, ProductionMmlUpsertArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionMmls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlCountArgs} args - Arguments to filter ProductionMmls to count.
     * @example
     * // Count the number of ProductionMmls
     * const count = await prisma.productionMml.count({
     *   where: {
     *     // ... the filter for the ProductionMmls we want to count
     *   }
     * })
    **/
    count<T extends ProductionMmlCountArgs>(
      args?: Subset<T, ProductionMmlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionMmlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionMml.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionMmlAggregateArgs>(args: Subset<T, ProductionMmlAggregateArgs>): Prisma.PrismaPromise<GetProductionMmlAggregateType<T>>

    /**
     * Group by ProductionMml.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionMmlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionMmlGroupByArgs['orderBy'] }
        : { orderBy?: ProductionMmlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionMmlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionMmlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionMml model
   */
  readonly fields: ProductionMmlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionMml.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionMmlClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nodes<T extends ProductionMml$nodesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMml$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runs<T extends ProductionMml$runsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMml$runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suppliersWithPrimaryMml<T extends ProductionMml$suppliersWithPrimaryMmlArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMml$suppliersWithPrimaryMmlArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceListSuppliers<T extends ProductionMml$priceListSuppliersArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMml$priceListSuppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionMml model
   */
  interface ProductionMmlFieldRefs {
    readonly id: FieldRef<"ProductionMml", 'Int'>
    readonly productId: FieldRef<"ProductionMml", 'Int'>
    readonly createdBy: FieldRef<"ProductionMml", 'Int'>
    readonly isLocked: FieldRef<"ProductionMml", 'Boolean'>
    readonly createdAt: FieldRef<"ProductionMml", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionMml", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionMml findUnique
   */
  export type ProductionMmlFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMml to fetch.
     */
    where: ProductionMmlWhereUniqueInput
  }

  /**
   * ProductionMml findUniqueOrThrow
   */
  export type ProductionMmlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMml to fetch.
     */
    where: ProductionMmlWhereUniqueInput
  }

  /**
   * ProductionMml findFirst
   */
  export type ProductionMmlFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMml to fetch.
     */
    where?: ProductionMmlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmls to fetch.
     */
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionMmls.
     */
    cursor?: ProductionMmlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionMmls.
     */
    distinct?: ProductionMmlScalarFieldEnum | ProductionMmlScalarFieldEnum[]
  }

  /**
   * ProductionMml findFirstOrThrow
   */
  export type ProductionMmlFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMml to fetch.
     */
    where?: ProductionMmlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmls to fetch.
     */
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionMmls.
     */
    cursor?: ProductionMmlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionMmls.
     */
    distinct?: ProductionMmlScalarFieldEnum | ProductionMmlScalarFieldEnum[]
  }

  /**
   * ProductionMml findMany
   */
  export type ProductionMmlFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmls to fetch.
     */
    where?: ProductionMmlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmls to fetch.
     */
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionMmls.
     */
    cursor?: ProductionMmlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmls.
     */
    skip?: number
    distinct?: ProductionMmlScalarFieldEnum | ProductionMmlScalarFieldEnum[]
  }

  /**
   * ProductionMml create
   */
  export type ProductionMmlCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionMml.
     */
    data: XOR<ProductionMmlCreateInput, ProductionMmlUncheckedCreateInput>
  }

  /**
   * ProductionMml createMany
   */
  export type ProductionMmlCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionMmls.
     */
    data: ProductionMmlCreateManyInput | ProductionMmlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionMml createManyAndReturn
   */
  export type ProductionMmlCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionMmls.
     */
    data: ProductionMmlCreateManyInput | ProductionMmlCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionMml update
   */
  export type ProductionMmlUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionMml.
     */
    data: XOR<ProductionMmlUpdateInput, ProductionMmlUncheckedUpdateInput>
    /**
     * Choose, which ProductionMml to update.
     */
    where: ProductionMmlWhereUniqueInput
  }

  /**
   * ProductionMml updateMany
   */
  export type ProductionMmlUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionMmls.
     */
    data: XOR<ProductionMmlUpdateManyMutationInput, ProductionMmlUncheckedUpdateManyInput>
    /**
     * Filter which ProductionMmls to update
     */
    where?: ProductionMmlWhereInput
    /**
     * Limit how many ProductionMmls to update.
     */
    limit?: number
  }

  /**
   * ProductionMml updateManyAndReturn
   */
  export type ProductionMmlUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * The data used to update ProductionMmls.
     */
    data: XOR<ProductionMmlUpdateManyMutationInput, ProductionMmlUncheckedUpdateManyInput>
    /**
     * Filter which ProductionMmls to update
     */
    where?: ProductionMmlWhereInput
    /**
     * Limit how many ProductionMmls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionMml upsert
   */
  export type ProductionMmlUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionMml to update in case it exists.
     */
    where: ProductionMmlWhereUniqueInput
    /**
     * In case the ProductionMml found by the `where` argument doesn't exist, create a new ProductionMml with this data.
     */
    create: XOR<ProductionMmlCreateInput, ProductionMmlUncheckedCreateInput>
    /**
     * In case the ProductionMml was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionMmlUpdateInput, ProductionMmlUncheckedUpdateInput>
  }

  /**
   * ProductionMml delete
   */
  export type ProductionMmlDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter which ProductionMml to delete.
     */
    where: ProductionMmlWhereUniqueInput
  }

  /**
   * ProductionMml deleteMany
   */
  export type ProductionMmlDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionMmls to delete
     */
    where?: ProductionMmlWhereInput
    /**
     * Limit how many ProductionMmls to delete.
     */
    limit?: number
  }

  /**
   * ProductionMml.nodes
   */
  export type ProductionMml$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    where?: ProductionMmlNodeWhereInput
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    cursor?: ProductionMmlNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * ProductionMml.runs
   */
  export type ProductionMml$runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    where?: ProductionRunWhereInput
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    cursor?: ProductionRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * ProductionMml.suppliersWithPrimaryMml
   */
  export type ProductionMml$suppliersWithPrimaryMmlArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * ProductionMml.priceListSuppliers
   */
  export type ProductionMml$priceListSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    where?: PurchasePriceListSupplierWhereInput
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * ProductionMml without action
   */
  export type ProductionMmlDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
  }


  /**
   * Model ProductionMmlNode
   */

  export type AggregateProductionMmlNode = {
    _count: ProductionMmlNodeCountAggregateOutputType | null
    _avg: ProductionMmlNodeAvgAggregateOutputType | null
    _sum: ProductionMmlNodeSumAggregateOutputType | null
    _min: ProductionMmlNodeMinAggregateOutputType | null
    _max: ProductionMmlNodeMaxAggregateOutputType | null
  }

  export type ProductionMmlNodeAvgAggregateOutputType = {
    id: number | null
    mmlId: number | null
    parentNodeId: number | null
    productId: number | null
    sortOrder: number | null
  }

  export type ProductionMmlNodeSumAggregateOutputType = {
    id: number | null
    mmlId: number | null
    parentNodeId: number | null
    productId: number | null
    sortOrder: number | null
  }

  export type ProductionMmlNodeMinAggregateOutputType = {
    id: number | null
    mmlId: number | null
    parentNodeId: number | null
    productId: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionMmlNodeMaxAggregateOutputType = {
    id: number | null
    mmlId: number | null
    parentNodeId: number | null
    productId: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionMmlNodeCountAggregateOutputType = {
    id: number
    mmlId: number
    parentNodeId: number
    productId: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionMmlNodeAvgAggregateInputType = {
    id?: true
    mmlId?: true
    parentNodeId?: true
    productId?: true
    sortOrder?: true
  }

  export type ProductionMmlNodeSumAggregateInputType = {
    id?: true
    mmlId?: true
    parentNodeId?: true
    productId?: true
    sortOrder?: true
  }

  export type ProductionMmlNodeMinAggregateInputType = {
    id?: true
    mmlId?: true
    parentNodeId?: true
    productId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionMmlNodeMaxAggregateInputType = {
    id?: true
    mmlId?: true
    parentNodeId?: true
    productId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionMmlNodeCountAggregateInputType = {
    id?: true
    mmlId?: true
    parentNodeId?: true
    productId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionMmlNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionMmlNode to aggregate.
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmlNodes to fetch.
     */
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionMmlNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmlNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmlNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionMmlNodes
    **/
    _count?: true | ProductionMmlNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionMmlNodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionMmlNodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionMmlNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionMmlNodeMaxAggregateInputType
  }

  export type GetProductionMmlNodeAggregateType<T extends ProductionMmlNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionMmlNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionMmlNode[P]>
      : GetScalarType<T[P], AggregateProductionMmlNode[P]>
  }




  export type ProductionMmlNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlNodeWhereInput
    orderBy?: ProductionMmlNodeOrderByWithAggregationInput | ProductionMmlNodeOrderByWithAggregationInput[]
    by: ProductionMmlNodeScalarFieldEnum[] | ProductionMmlNodeScalarFieldEnum
    having?: ProductionMmlNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionMmlNodeCountAggregateInputType | true
    _avg?: ProductionMmlNodeAvgAggregateInputType
    _sum?: ProductionMmlNodeSumAggregateInputType
    _min?: ProductionMmlNodeMinAggregateInputType
    _max?: ProductionMmlNodeMaxAggregateInputType
  }

  export type ProductionMmlNodeGroupByOutputType = {
    id: number
    mmlId: number
    parentNodeId: number | null
    productId: number
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ProductionMmlNodeCountAggregateOutputType | null
    _avg: ProductionMmlNodeAvgAggregateOutputType | null
    _sum: ProductionMmlNodeSumAggregateOutputType | null
    _min: ProductionMmlNodeMinAggregateOutputType | null
    _max: ProductionMmlNodeMaxAggregateOutputType | null
  }

  type GetProductionMmlNodeGroupByPayload<T extends ProductionMmlNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionMmlNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionMmlNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionMmlNodeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionMmlNodeGroupByOutputType[P]>
        }
      >
    >


  export type ProductionMmlNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mmlId?: boolean
    parentNodeId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    children?: boolean | ProductionMmlNode$childrenArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    runValues?: boolean | ProductionMmlNode$runValuesArgs<ExtArgs>
    _count?: boolean | ProductionMmlNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMmlNode"]>

  export type ProductionMmlNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mmlId?: boolean
    parentNodeId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMmlNode"]>

  export type ProductionMmlNodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mmlId?: boolean
    parentNodeId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMmlNode"]>

  export type ProductionMmlNodeSelectScalar = {
    id?: boolean
    mmlId?: boolean
    parentNodeId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionMmlNodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mmlId" | "parentNodeId" | "productId" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["productionMmlNode"]>
  export type ProductionMmlNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    children?: boolean | ProductionMmlNode$childrenArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    runValues?: boolean | ProductionMmlNode$runValuesArgs<ExtArgs>
    _count?: boolean | ProductionMmlNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionMmlNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductionMmlNodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductionMmlNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionMmlNode"
    objects: {
      mml: Prisma.$ProductionMmlPayload<ExtArgs>
      parentNode: Prisma.$ProductionMmlNodePayload<ExtArgs> | null
      children: Prisma.$ProductionMmlNodePayload<ExtArgs>[]
      product: Prisma.$ProductPayload<ExtArgs>
      runValues: Prisma.$ProductionRunValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mmlId: number
      parentNodeId: number | null
      productId: number
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionMmlNode"]>
    composites: {}
  }

  type ProductionMmlNodeGetPayload<S extends boolean | null | undefined | ProductionMmlNodeDefaultArgs> = $Result.GetResult<Prisma.$ProductionMmlNodePayload, S>

  type ProductionMmlNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionMmlNodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionMmlNodeCountAggregateInputType | true
    }

  export interface ProductionMmlNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionMmlNode'], meta: { name: 'ProductionMmlNode' } }
    /**
     * Find zero or one ProductionMmlNode that matches the filter.
     * @param {ProductionMmlNodeFindUniqueArgs} args - Arguments to find a ProductionMmlNode
     * @example
     * // Get one ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionMmlNodeFindUniqueArgs>(args: SelectSubset<T, ProductionMmlNodeFindUniqueArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionMmlNode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionMmlNodeFindUniqueOrThrowArgs} args - Arguments to find a ProductionMmlNode
     * @example
     * // Get one ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionMmlNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionMmlNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionMmlNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeFindFirstArgs} args - Arguments to find a ProductionMmlNode
     * @example
     * // Get one ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionMmlNodeFindFirstArgs>(args?: SelectSubset<T, ProductionMmlNodeFindFirstArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionMmlNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeFindFirstOrThrowArgs} args - Arguments to find a ProductionMmlNode
     * @example
     * // Get one ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionMmlNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionMmlNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionMmlNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionMmlNodes
     * const productionMmlNodes = await prisma.productionMmlNode.findMany()
     * 
     * // Get first 10 ProductionMmlNodes
     * const productionMmlNodes = await prisma.productionMmlNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionMmlNodeWithIdOnly = await prisma.productionMmlNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionMmlNodeFindManyArgs>(args?: SelectSubset<T, ProductionMmlNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionMmlNode.
     * @param {ProductionMmlNodeCreateArgs} args - Arguments to create a ProductionMmlNode.
     * @example
     * // Create one ProductionMmlNode
     * const ProductionMmlNode = await prisma.productionMmlNode.create({
     *   data: {
     *     // ... data to create a ProductionMmlNode
     *   }
     * })
     * 
     */
    create<T extends ProductionMmlNodeCreateArgs>(args: SelectSubset<T, ProductionMmlNodeCreateArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionMmlNodes.
     * @param {ProductionMmlNodeCreateManyArgs} args - Arguments to create many ProductionMmlNodes.
     * @example
     * // Create many ProductionMmlNodes
     * const productionMmlNode = await prisma.productionMmlNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionMmlNodeCreateManyArgs>(args?: SelectSubset<T, ProductionMmlNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionMmlNodes and returns the data saved in the database.
     * @param {ProductionMmlNodeCreateManyAndReturnArgs} args - Arguments to create many ProductionMmlNodes.
     * @example
     * // Create many ProductionMmlNodes
     * const productionMmlNode = await prisma.productionMmlNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionMmlNodes and only return the `id`
     * const productionMmlNodeWithIdOnly = await prisma.productionMmlNode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionMmlNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionMmlNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionMmlNode.
     * @param {ProductionMmlNodeDeleteArgs} args - Arguments to delete one ProductionMmlNode.
     * @example
     * // Delete one ProductionMmlNode
     * const ProductionMmlNode = await prisma.productionMmlNode.delete({
     *   where: {
     *     // ... filter to delete one ProductionMmlNode
     *   }
     * })
     * 
     */
    delete<T extends ProductionMmlNodeDeleteArgs>(args: SelectSubset<T, ProductionMmlNodeDeleteArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionMmlNode.
     * @param {ProductionMmlNodeUpdateArgs} args - Arguments to update one ProductionMmlNode.
     * @example
     * // Update one ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionMmlNodeUpdateArgs>(args: SelectSubset<T, ProductionMmlNodeUpdateArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionMmlNodes.
     * @param {ProductionMmlNodeDeleteManyArgs} args - Arguments to filter ProductionMmlNodes to delete.
     * @example
     * // Delete a few ProductionMmlNodes
     * const { count } = await prisma.productionMmlNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionMmlNodeDeleteManyArgs>(args?: SelectSubset<T, ProductionMmlNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionMmlNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionMmlNodes
     * const productionMmlNode = await prisma.productionMmlNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionMmlNodeUpdateManyArgs>(args: SelectSubset<T, ProductionMmlNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionMmlNodes and returns the data updated in the database.
     * @param {ProductionMmlNodeUpdateManyAndReturnArgs} args - Arguments to update many ProductionMmlNodes.
     * @example
     * // Update many ProductionMmlNodes
     * const productionMmlNode = await prisma.productionMmlNode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionMmlNodes and only return the `id`
     * const productionMmlNodeWithIdOnly = await prisma.productionMmlNode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionMmlNodeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionMmlNodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionMmlNode.
     * @param {ProductionMmlNodeUpsertArgs} args - Arguments to update or create a ProductionMmlNode.
     * @example
     * // Update or create a ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.upsert({
     *   create: {
     *     // ... data to create a ProductionMmlNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionMmlNode we want to update
     *   }
     * })
     */
    upsert<T extends ProductionMmlNodeUpsertArgs>(args: SelectSubset<T, ProductionMmlNodeUpsertArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionMmlNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeCountArgs} args - Arguments to filter ProductionMmlNodes to count.
     * @example
     * // Count the number of ProductionMmlNodes
     * const count = await prisma.productionMmlNode.count({
     *   where: {
     *     // ... the filter for the ProductionMmlNodes we want to count
     *   }
     * })
    **/
    count<T extends ProductionMmlNodeCountArgs>(
      args?: Subset<T, ProductionMmlNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionMmlNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionMmlNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionMmlNodeAggregateArgs>(args: Subset<T, ProductionMmlNodeAggregateArgs>): Prisma.PrismaPromise<GetProductionMmlNodeAggregateType<T>>

    /**
     * Group by ProductionMmlNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionMmlNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionMmlNodeGroupByArgs['orderBy'] }
        : { orderBy?: ProductionMmlNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionMmlNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionMmlNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionMmlNode model
   */
  readonly fields: ProductionMmlNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionMmlNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionMmlNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mml<T extends ProductionMmlDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlDefaultArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentNode<T extends ProductionMmlNode$parentNodeArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlNode$parentNodeArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends ProductionMmlNode$childrenArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlNode$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    runValues<T extends ProductionMmlNode$runValuesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlNode$runValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionMmlNode model
   */
  interface ProductionMmlNodeFieldRefs {
    readonly id: FieldRef<"ProductionMmlNode", 'Int'>
    readonly mmlId: FieldRef<"ProductionMmlNode", 'Int'>
    readonly parentNodeId: FieldRef<"ProductionMmlNode", 'Int'>
    readonly productId: FieldRef<"ProductionMmlNode", 'Int'>
    readonly sortOrder: FieldRef<"ProductionMmlNode", 'Int'>
    readonly createdAt: FieldRef<"ProductionMmlNode", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionMmlNode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionMmlNode findUnique
   */
  export type ProductionMmlNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmlNode to fetch.
     */
    where: ProductionMmlNodeWhereUniqueInput
  }

  /**
   * ProductionMmlNode findUniqueOrThrow
   */
  export type ProductionMmlNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmlNode to fetch.
     */
    where: ProductionMmlNodeWhereUniqueInput
  }

  /**
   * ProductionMmlNode findFirst
   */
  export type ProductionMmlNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmlNode to fetch.
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmlNodes to fetch.
     */
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionMmlNodes.
     */
    cursor?: ProductionMmlNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmlNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmlNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionMmlNodes.
     */
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * ProductionMmlNode findFirstOrThrow
   */
  export type ProductionMmlNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmlNode to fetch.
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmlNodes to fetch.
     */
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionMmlNodes.
     */
    cursor?: ProductionMmlNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmlNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmlNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionMmlNodes.
     */
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * ProductionMmlNode findMany
   */
  export type ProductionMmlNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmlNodes to fetch.
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmlNodes to fetch.
     */
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionMmlNodes.
     */
    cursor?: ProductionMmlNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmlNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmlNodes.
     */
    skip?: number
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * ProductionMmlNode create
   */
  export type ProductionMmlNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionMmlNode.
     */
    data: XOR<ProductionMmlNodeCreateInput, ProductionMmlNodeUncheckedCreateInput>
  }

  /**
   * ProductionMmlNode createMany
   */
  export type ProductionMmlNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionMmlNodes.
     */
    data: ProductionMmlNodeCreateManyInput | ProductionMmlNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionMmlNode createManyAndReturn
   */
  export type ProductionMmlNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionMmlNodes.
     */
    data: ProductionMmlNodeCreateManyInput | ProductionMmlNodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionMmlNode update
   */
  export type ProductionMmlNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionMmlNode.
     */
    data: XOR<ProductionMmlNodeUpdateInput, ProductionMmlNodeUncheckedUpdateInput>
    /**
     * Choose, which ProductionMmlNode to update.
     */
    where: ProductionMmlNodeWhereUniqueInput
  }

  /**
   * ProductionMmlNode updateMany
   */
  export type ProductionMmlNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionMmlNodes.
     */
    data: XOR<ProductionMmlNodeUpdateManyMutationInput, ProductionMmlNodeUncheckedUpdateManyInput>
    /**
     * Filter which ProductionMmlNodes to update
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * Limit how many ProductionMmlNodes to update.
     */
    limit?: number
  }

  /**
   * ProductionMmlNode updateManyAndReturn
   */
  export type ProductionMmlNodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * The data used to update ProductionMmlNodes.
     */
    data: XOR<ProductionMmlNodeUpdateManyMutationInput, ProductionMmlNodeUncheckedUpdateManyInput>
    /**
     * Filter which ProductionMmlNodes to update
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * Limit how many ProductionMmlNodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionMmlNode upsert
   */
  export type ProductionMmlNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionMmlNode to update in case it exists.
     */
    where: ProductionMmlNodeWhereUniqueInput
    /**
     * In case the ProductionMmlNode found by the `where` argument doesn't exist, create a new ProductionMmlNode with this data.
     */
    create: XOR<ProductionMmlNodeCreateInput, ProductionMmlNodeUncheckedCreateInput>
    /**
     * In case the ProductionMmlNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionMmlNodeUpdateInput, ProductionMmlNodeUncheckedUpdateInput>
  }

  /**
   * ProductionMmlNode delete
   */
  export type ProductionMmlNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter which ProductionMmlNode to delete.
     */
    where: ProductionMmlNodeWhereUniqueInput
  }

  /**
   * ProductionMmlNode deleteMany
   */
  export type ProductionMmlNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionMmlNodes to delete
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * Limit how many ProductionMmlNodes to delete.
     */
    limit?: number
  }

  /**
   * ProductionMmlNode.parentNode
   */
  export type ProductionMmlNode$parentNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    where?: ProductionMmlNodeWhereInput
  }

  /**
   * ProductionMmlNode.children
   */
  export type ProductionMmlNode$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    where?: ProductionMmlNodeWhereInput
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    cursor?: ProductionMmlNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * ProductionMmlNode.runValues
   */
  export type ProductionMmlNode$runValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    where?: ProductionRunValueWhereInput
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    cursor?: ProductionRunValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRunValueScalarFieldEnum | ProductionRunValueScalarFieldEnum[]
  }

  /**
   * ProductionMmlNode without action
   */
  export type ProductionMmlNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
  }


  /**
   * Model ProductionRun
   */

  export type AggregateProductionRun = {
    _count: ProductionRunCountAggregateOutputType | null
    _avg: ProductionRunAvgAggregateOutputType | null
    _sum: ProductionRunSumAggregateOutputType | null
    _min: ProductionRunMinAggregateOutputType | null
    _max: ProductionRunMaxAggregateOutputType | null
  }

  export type ProductionRunAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    mmlId: number | null
    userId: number | null
  }

  export type ProductionRunSumAggregateOutputType = {
    id: number | null
    productId: number | null
    mmlId: number | null
    userId: number | null
  }

  export type ProductionRunMinAggregateOutputType = {
    id: number | null
    productId: number | null
    mmlId: number | null
    userId: number | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionRunMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    mmlId: number | null
    userId: number | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionRunCountAggregateOutputType = {
    id: number
    productId: number
    mmlId: number
    userId: number
    isLocked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionRunAvgAggregateInputType = {
    id?: true
    productId?: true
    mmlId?: true
    userId?: true
  }

  export type ProductionRunSumAggregateInputType = {
    id?: true
    productId?: true
    mmlId?: true
    userId?: true
  }

  export type ProductionRunMinAggregateInputType = {
    id?: true
    productId?: true
    mmlId?: true
    userId?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionRunMaxAggregateInputType = {
    id?: true
    productId?: true
    mmlId?: true
    userId?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionRunCountAggregateInputType = {
    id?: true
    productId?: true
    mmlId?: true
    userId?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionRun to aggregate.
     */
    where?: ProductionRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRuns to fetch.
     */
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionRuns
    **/
    _count?: true | ProductionRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionRunMaxAggregateInputType
  }

  export type GetProductionRunAggregateType<T extends ProductionRunAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionRun[P]>
      : GetScalarType<T[P], AggregateProductionRun[P]>
  }




  export type ProductionRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunWhereInput
    orderBy?: ProductionRunOrderByWithAggregationInput | ProductionRunOrderByWithAggregationInput[]
    by: ProductionRunScalarFieldEnum[] | ProductionRunScalarFieldEnum
    having?: ProductionRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionRunCountAggregateInputType | true
    _avg?: ProductionRunAvgAggregateInputType
    _sum?: ProductionRunSumAggregateInputType
    _min?: ProductionRunMinAggregateInputType
    _max?: ProductionRunMaxAggregateInputType
  }

  export type ProductionRunGroupByOutputType = {
    id: number
    productId: number
    mmlId: number
    userId: number
    isLocked: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductionRunCountAggregateOutputType | null
    _avg: ProductionRunAvgAggregateOutputType | null
    _sum: ProductionRunSumAggregateOutputType | null
    _min: ProductionRunMinAggregateOutputType | null
    _max: ProductionRunMaxAggregateOutputType | null
  }

  type GetProductionRunGroupByPayload<T extends ProductionRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionRunGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionRunGroupByOutputType[P]>
        }
      >
    >


  export type ProductionRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    mmlId?: boolean
    userId?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    values?: boolean | ProductionRun$valuesArgs<ExtArgs>
    _count?: boolean | ProductionRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionRun"]>

  export type ProductionRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    mmlId?: boolean
    userId?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionRun"]>

  export type ProductionRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    mmlId?: boolean
    userId?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionRun"]>

  export type ProductionRunSelectScalar = {
    id?: boolean
    productId?: boolean
    mmlId?: boolean
    userId?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "mmlId" | "userId" | "isLocked" | "createdAt" | "updatedAt", ExtArgs["result"]["productionRun"]>
  export type ProductionRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    values?: boolean | ProductionRun$valuesArgs<ExtArgs>
    _count?: boolean | ProductionRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductionRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductionRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionRun"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      mml: Prisma.$ProductionMmlPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      values: Prisma.$ProductionRunValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      mmlId: number
      userId: number
      isLocked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionRun"]>
    composites: {}
  }

  type ProductionRunGetPayload<S extends boolean | null | undefined | ProductionRunDefaultArgs> = $Result.GetResult<Prisma.$ProductionRunPayload, S>

  type ProductionRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionRunCountAggregateInputType | true
    }

  export interface ProductionRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionRun'], meta: { name: 'ProductionRun' } }
    /**
     * Find zero or one ProductionRun that matches the filter.
     * @param {ProductionRunFindUniqueArgs} args - Arguments to find a ProductionRun
     * @example
     * // Get one ProductionRun
     * const productionRun = await prisma.productionRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionRunFindUniqueArgs>(args: SelectSubset<T, ProductionRunFindUniqueArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionRunFindUniqueOrThrowArgs} args - Arguments to find a ProductionRun
     * @example
     * // Get one ProductionRun
     * const productionRun = await prisma.productionRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionRunFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunFindFirstArgs} args - Arguments to find a ProductionRun
     * @example
     * // Get one ProductionRun
     * const productionRun = await prisma.productionRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionRunFindFirstArgs>(args?: SelectSubset<T, ProductionRunFindFirstArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunFindFirstOrThrowArgs} args - Arguments to find a ProductionRun
     * @example
     * // Get one ProductionRun
     * const productionRun = await prisma.productionRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionRunFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionRuns
     * const productionRuns = await prisma.productionRun.findMany()
     * 
     * // Get first 10 ProductionRuns
     * const productionRuns = await prisma.productionRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionRunWithIdOnly = await prisma.productionRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionRunFindManyArgs>(args?: SelectSubset<T, ProductionRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionRun.
     * @param {ProductionRunCreateArgs} args - Arguments to create a ProductionRun.
     * @example
     * // Create one ProductionRun
     * const ProductionRun = await prisma.productionRun.create({
     *   data: {
     *     // ... data to create a ProductionRun
     *   }
     * })
     * 
     */
    create<T extends ProductionRunCreateArgs>(args: SelectSubset<T, ProductionRunCreateArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionRuns.
     * @param {ProductionRunCreateManyArgs} args - Arguments to create many ProductionRuns.
     * @example
     * // Create many ProductionRuns
     * const productionRun = await prisma.productionRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionRunCreateManyArgs>(args?: SelectSubset<T, ProductionRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionRuns and returns the data saved in the database.
     * @param {ProductionRunCreateManyAndReturnArgs} args - Arguments to create many ProductionRuns.
     * @example
     * // Create many ProductionRuns
     * const productionRun = await prisma.productionRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionRuns and only return the `id`
     * const productionRunWithIdOnly = await prisma.productionRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionRunCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionRun.
     * @param {ProductionRunDeleteArgs} args - Arguments to delete one ProductionRun.
     * @example
     * // Delete one ProductionRun
     * const ProductionRun = await prisma.productionRun.delete({
     *   where: {
     *     // ... filter to delete one ProductionRun
     *   }
     * })
     * 
     */
    delete<T extends ProductionRunDeleteArgs>(args: SelectSubset<T, ProductionRunDeleteArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionRun.
     * @param {ProductionRunUpdateArgs} args - Arguments to update one ProductionRun.
     * @example
     * // Update one ProductionRun
     * const productionRun = await prisma.productionRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionRunUpdateArgs>(args: SelectSubset<T, ProductionRunUpdateArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionRuns.
     * @param {ProductionRunDeleteManyArgs} args - Arguments to filter ProductionRuns to delete.
     * @example
     * // Delete a few ProductionRuns
     * const { count } = await prisma.productionRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionRunDeleteManyArgs>(args?: SelectSubset<T, ProductionRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionRuns
     * const productionRun = await prisma.productionRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionRunUpdateManyArgs>(args: SelectSubset<T, ProductionRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionRuns and returns the data updated in the database.
     * @param {ProductionRunUpdateManyAndReturnArgs} args - Arguments to update many ProductionRuns.
     * @example
     * // Update many ProductionRuns
     * const productionRun = await prisma.productionRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionRuns and only return the `id`
     * const productionRunWithIdOnly = await prisma.productionRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionRunUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionRun.
     * @param {ProductionRunUpsertArgs} args - Arguments to update or create a ProductionRun.
     * @example
     * // Update or create a ProductionRun
     * const productionRun = await prisma.productionRun.upsert({
     *   create: {
     *     // ... data to create a ProductionRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionRun we want to update
     *   }
     * })
     */
    upsert<T extends ProductionRunUpsertArgs>(args: SelectSubset<T, ProductionRunUpsertArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunCountArgs} args - Arguments to filter ProductionRuns to count.
     * @example
     * // Count the number of ProductionRuns
     * const count = await prisma.productionRun.count({
     *   where: {
     *     // ... the filter for the ProductionRuns we want to count
     *   }
     * })
    **/
    count<T extends ProductionRunCountArgs>(
      args?: Subset<T, ProductionRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionRunAggregateArgs>(args: Subset<T, ProductionRunAggregateArgs>): Prisma.PrismaPromise<GetProductionRunAggregateType<T>>

    /**
     * Group by ProductionRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionRunGroupByArgs['orderBy'] }
        : { orderBy?: ProductionRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionRun model
   */
  readonly fields: ProductionRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mml<T extends ProductionMmlDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlDefaultArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    values<T extends ProductionRun$valuesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionRun$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionRun model
   */
  interface ProductionRunFieldRefs {
    readonly id: FieldRef<"ProductionRun", 'Int'>
    readonly productId: FieldRef<"ProductionRun", 'Int'>
    readonly mmlId: FieldRef<"ProductionRun", 'Int'>
    readonly userId: FieldRef<"ProductionRun", 'Int'>
    readonly isLocked: FieldRef<"ProductionRun", 'Boolean'>
    readonly createdAt: FieldRef<"ProductionRun", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionRun findUnique
   */
  export type ProductionRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRun to fetch.
     */
    where: ProductionRunWhereUniqueInput
  }

  /**
   * ProductionRun findUniqueOrThrow
   */
  export type ProductionRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRun to fetch.
     */
    where: ProductionRunWhereUniqueInput
  }

  /**
   * ProductionRun findFirst
   */
  export type ProductionRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRun to fetch.
     */
    where?: ProductionRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRuns to fetch.
     */
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionRuns.
     */
    cursor?: ProductionRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionRuns.
     */
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * ProductionRun findFirstOrThrow
   */
  export type ProductionRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRun to fetch.
     */
    where?: ProductionRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRuns to fetch.
     */
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionRuns.
     */
    cursor?: ProductionRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionRuns.
     */
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * ProductionRun findMany
   */
  export type ProductionRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRuns to fetch.
     */
    where?: ProductionRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRuns to fetch.
     */
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionRuns.
     */
    cursor?: ProductionRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRuns.
     */
    skip?: number
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * ProductionRun create
   */
  export type ProductionRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionRun.
     */
    data: XOR<ProductionRunCreateInput, ProductionRunUncheckedCreateInput>
  }

  /**
   * ProductionRun createMany
   */
  export type ProductionRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionRuns.
     */
    data: ProductionRunCreateManyInput | ProductionRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionRun createManyAndReturn
   */
  export type ProductionRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionRuns.
     */
    data: ProductionRunCreateManyInput | ProductionRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionRun update
   */
  export type ProductionRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionRun.
     */
    data: XOR<ProductionRunUpdateInput, ProductionRunUncheckedUpdateInput>
    /**
     * Choose, which ProductionRun to update.
     */
    where: ProductionRunWhereUniqueInput
  }

  /**
   * ProductionRun updateMany
   */
  export type ProductionRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionRuns.
     */
    data: XOR<ProductionRunUpdateManyMutationInput, ProductionRunUncheckedUpdateManyInput>
    /**
     * Filter which ProductionRuns to update
     */
    where?: ProductionRunWhereInput
    /**
     * Limit how many ProductionRuns to update.
     */
    limit?: number
  }

  /**
   * ProductionRun updateManyAndReturn
   */
  export type ProductionRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * The data used to update ProductionRuns.
     */
    data: XOR<ProductionRunUpdateManyMutationInput, ProductionRunUncheckedUpdateManyInput>
    /**
     * Filter which ProductionRuns to update
     */
    where?: ProductionRunWhereInput
    /**
     * Limit how many ProductionRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionRun upsert
   */
  export type ProductionRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionRun to update in case it exists.
     */
    where: ProductionRunWhereUniqueInput
    /**
     * In case the ProductionRun found by the `where` argument doesn't exist, create a new ProductionRun with this data.
     */
    create: XOR<ProductionRunCreateInput, ProductionRunUncheckedCreateInput>
    /**
     * In case the ProductionRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionRunUpdateInput, ProductionRunUncheckedUpdateInput>
  }

  /**
   * ProductionRun delete
   */
  export type ProductionRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter which ProductionRun to delete.
     */
    where: ProductionRunWhereUniqueInput
  }

  /**
   * ProductionRun deleteMany
   */
  export type ProductionRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionRuns to delete
     */
    where?: ProductionRunWhereInput
    /**
     * Limit how many ProductionRuns to delete.
     */
    limit?: number
  }

  /**
   * ProductionRun.values
   */
  export type ProductionRun$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    where?: ProductionRunValueWhereInput
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    cursor?: ProductionRunValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRunValueScalarFieldEnum | ProductionRunValueScalarFieldEnum[]
  }

  /**
   * ProductionRun without action
   */
  export type ProductionRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
  }


  /**
   * Model ProductionRunValue
   */

  export type AggregateProductionRunValue = {
    _count: ProductionRunValueCountAggregateOutputType | null
    _avg: ProductionRunValueAvgAggregateOutputType | null
    _sum: ProductionRunValueSumAggregateOutputType | null
    _min: ProductionRunValueMinAggregateOutputType | null
    _max: ProductionRunValueMaxAggregateOutputType | null
  }

  export type ProductionRunValueAvgAggregateOutputType = {
    id: number | null
    productionRunId: number | null
    mmlNodeId: number | null
    value: Decimal | null
  }

  export type ProductionRunValueSumAggregateOutputType = {
    id: number | null
    productionRunId: number | null
    mmlNodeId: number | null
    value: Decimal | null
  }

  export type ProductionRunValueMinAggregateOutputType = {
    id: number | null
    productionRunId: number | null
    mmlNodeId: number | null
    value: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionRunValueMaxAggregateOutputType = {
    id: number | null
    productionRunId: number | null
    mmlNodeId: number | null
    value: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionRunValueCountAggregateOutputType = {
    id: number
    productionRunId: number
    mmlNodeId: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionRunValueAvgAggregateInputType = {
    id?: true
    productionRunId?: true
    mmlNodeId?: true
    value?: true
  }

  export type ProductionRunValueSumAggregateInputType = {
    id?: true
    productionRunId?: true
    mmlNodeId?: true
    value?: true
  }

  export type ProductionRunValueMinAggregateInputType = {
    id?: true
    productionRunId?: true
    mmlNodeId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionRunValueMaxAggregateInputType = {
    id?: true
    productionRunId?: true
    mmlNodeId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionRunValueCountAggregateInputType = {
    id?: true
    productionRunId?: true
    mmlNodeId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionRunValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionRunValue to aggregate.
     */
    where?: ProductionRunValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRunValues to fetch.
     */
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionRunValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRunValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRunValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionRunValues
    **/
    _count?: true | ProductionRunValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionRunValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionRunValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionRunValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionRunValueMaxAggregateInputType
  }

  export type GetProductionRunValueAggregateType<T extends ProductionRunValueAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionRunValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionRunValue[P]>
      : GetScalarType<T[P], AggregateProductionRunValue[P]>
  }




  export type ProductionRunValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunValueWhereInput
    orderBy?: ProductionRunValueOrderByWithAggregationInput | ProductionRunValueOrderByWithAggregationInput[]
    by: ProductionRunValueScalarFieldEnum[] | ProductionRunValueScalarFieldEnum
    having?: ProductionRunValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionRunValueCountAggregateInputType | true
    _avg?: ProductionRunValueAvgAggregateInputType
    _sum?: ProductionRunValueSumAggregateInputType
    _min?: ProductionRunValueMinAggregateInputType
    _max?: ProductionRunValueMaxAggregateInputType
  }

  export type ProductionRunValueGroupByOutputType = {
    id: number
    productionRunId: number
    mmlNodeId: number
    value: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: ProductionRunValueCountAggregateOutputType | null
    _avg: ProductionRunValueAvgAggregateOutputType | null
    _sum: ProductionRunValueSumAggregateOutputType | null
    _min: ProductionRunValueMinAggregateOutputType | null
    _max: ProductionRunValueMaxAggregateOutputType | null
  }

  type GetProductionRunValueGroupByPayload<T extends ProductionRunValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionRunValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionRunValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionRunValueGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionRunValueGroupByOutputType[P]>
        }
      >
    >


  export type ProductionRunValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionRunId?: boolean
    mmlNodeId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionRunValue"]>

  export type ProductionRunValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionRunId?: boolean
    mmlNodeId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionRunValue"]>

  export type ProductionRunValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionRunId?: boolean
    mmlNodeId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionRunValue"]>

  export type ProductionRunValueSelectScalar = {
    id?: boolean
    productionRunId?: boolean
    mmlNodeId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionRunValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionRunId" | "mmlNodeId" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["productionRunValue"]>
  export type ProductionRunValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
  }
  export type ProductionRunValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
  }
  export type ProductionRunValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
  }

  export type $ProductionRunValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionRunValue"
    objects: {
      run: Prisma.$ProductionRunPayload<ExtArgs>
      node: Prisma.$ProductionMmlNodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionRunId: number
      mmlNodeId: number
      value: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionRunValue"]>
    composites: {}
  }

  type ProductionRunValueGetPayload<S extends boolean | null | undefined | ProductionRunValueDefaultArgs> = $Result.GetResult<Prisma.$ProductionRunValuePayload, S>

  type ProductionRunValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionRunValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionRunValueCountAggregateInputType | true
    }

  export interface ProductionRunValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionRunValue'], meta: { name: 'ProductionRunValue' } }
    /**
     * Find zero or one ProductionRunValue that matches the filter.
     * @param {ProductionRunValueFindUniqueArgs} args - Arguments to find a ProductionRunValue
     * @example
     * // Get one ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionRunValueFindUniqueArgs>(args: SelectSubset<T, ProductionRunValueFindUniqueArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionRunValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionRunValueFindUniqueOrThrowArgs} args - Arguments to find a ProductionRunValue
     * @example
     * // Get one ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionRunValueFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionRunValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionRunValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueFindFirstArgs} args - Arguments to find a ProductionRunValue
     * @example
     * // Get one ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionRunValueFindFirstArgs>(args?: SelectSubset<T, ProductionRunValueFindFirstArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionRunValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueFindFirstOrThrowArgs} args - Arguments to find a ProductionRunValue
     * @example
     * // Get one ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionRunValueFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionRunValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionRunValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionRunValues
     * const productionRunValues = await prisma.productionRunValue.findMany()
     * 
     * // Get first 10 ProductionRunValues
     * const productionRunValues = await prisma.productionRunValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionRunValueWithIdOnly = await prisma.productionRunValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionRunValueFindManyArgs>(args?: SelectSubset<T, ProductionRunValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionRunValue.
     * @param {ProductionRunValueCreateArgs} args - Arguments to create a ProductionRunValue.
     * @example
     * // Create one ProductionRunValue
     * const ProductionRunValue = await prisma.productionRunValue.create({
     *   data: {
     *     // ... data to create a ProductionRunValue
     *   }
     * })
     * 
     */
    create<T extends ProductionRunValueCreateArgs>(args: SelectSubset<T, ProductionRunValueCreateArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionRunValues.
     * @param {ProductionRunValueCreateManyArgs} args - Arguments to create many ProductionRunValues.
     * @example
     * // Create many ProductionRunValues
     * const productionRunValue = await prisma.productionRunValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionRunValueCreateManyArgs>(args?: SelectSubset<T, ProductionRunValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionRunValues and returns the data saved in the database.
     * @param {ProductionRunValueCreateManyAndReturnArgs} args - Arguments to create many ProductionRunValues.
     * @example
     * // Create many ProductionRunValues
     * const productionRunValue = await prisma.productionRunValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionRunValues and only return the `id`
     * const productionRunValueWithIdOnly = await prisma.productionRunValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionRunValueCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionRunValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionRunValue.
     * @param {ProductionRunValueDeleteArgs} args - Arguments to delete one ProductionRunValue.
     * @example
     * // Delete one ProductionRunValue
     * const ProductionRunValue = await prisma.productionRunValue.delete({
     *   where: {
     *     // ... filter to delete one ProductionRunValue
     *   }
     * })
     * 
     */
    delete<T extends ProductionRunValueDeleteArgs>(args: SelectSubset<T, ProductionRunValueDeleteArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionRunValue.
     * @param {ProductionRunValueUpdateArgs} args - Arguments to update one ProductionRunValue.
     * @example
     * // Update one ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionRunValueUpdateArgs>(args: SelectSubset<T, ProductionRunValueUpdateArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionRunValues.
     * @param {ProductionRunValueDeleteManyArgs} args - Arguments to filter ProductionRunValues to delete.
     * @example
     * // Delete a few ProductionRunValues
     * const { count } = await prisma.productionRunValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionRunValueDeleteManyArgs>(args?: SelectSubset<T, ProductionRunValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionRunValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionRunValues
     * const productionRunValue = await prisma.productionRunValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionRunValueUpdateManyArgs>(args: SelectSubset<T, ProductionRunValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionRunValues and returns the data updated in the database.
     * @param {ProductionRunValueUpdateManyAndReturnArgs} args - Arguments to update many ProductionRunValues.
     * @example
     * // Update many ProductionRunValues
     * const productionRunValue = await prisma.productionRunValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionRunValues and only return the `id`
     * const productionRunValueWithIdOnly = await prisma.productionRunValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionRunValueUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionRunValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionRunValue.
     * @param {ProductionRunValueUpsertArgs} args - Arguments to update or create a ProductionRunValue.
     * @example
     * // Update or create a ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.upsert({
     *   create: {
     *     // ... data to create a ProductionRunValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionRunValue we want to update
     *   }
     * })
     */
    upsert<T extends ProductionRunValueUpsertArgs>(args: SelectSubset<T, ProductionRunValueUpsertArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionRunValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueCountArgs} args - Arguments to filter ProductionRunValues to count.
     * @example
     * // Count the number of ProductionRunValues
     * const count = await prisma.productionRunValue.count({
     *   where: {
     *     // ... the filter for the ProductionRunValues we want to count
     *   }
     * })
    **/
    count<T extends ProductionRunValueCountArgs>(
      args?: Subset<T, ProductionRunValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionRunValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionRunValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionRunValueAggregateArgs>(args: Subset<T, ProductionRunValueAggregateArgs>): Prisma.PrismaPromise<GetProductionRunValueAggregateType<T>>

    /**
     * Group by ProductionRunValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionRunValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionRunValueGroupByArgs['orderBy'] }
        : { orderBy?: ProductionRunValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionRunValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionRunValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionRunValue model
   */
  readonly fields: ProductionRunValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionRunValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionRunValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    run<T extends ProductionRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionRunDefaultArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    node<T extends ProductionMmlNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlNodeDefaultArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionRunValue model
   */
  interface ProductionRunValueFieldRefs {
    readonly id: FieldRef<"ProductionRunValue", 'Int'>
    readonly productionRunId: FieldRef<"ProductionRunValue", 'Int'>
    readonly mmlNodeId: FieldRef<"ProductionRunValue", 'Int'>
    readonly value: FieldRef<"ProductionRunValue", 'Decimal'>
    readonly createdAt: FieldRef<"ProductionRunValue", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionRunValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionRunValue findUnique
   */
  export type ProductionRunValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRunValue to fetch.
     */
    where: ProductionRunValueWhereUniqueInput
  }

  /**
   * ProductionRunValue findUniqueOrThrow
   */
  export type ProductionRunValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRunValue to fetch.
     */
    where: ProductionRunValueWhereUniqueInput
  }

  /**
   * ProductionRunValue findFirst
   */
  export type ProductionRunValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRunValue to fetch.
     */
    where?: ProductionRunValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRunValues to fetch.
     */
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionRunValues.
     */
    cursor?: ProductionRunValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRunValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRunValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionRunValues.
     */
    distinct?: ProductionRunValueScalarFieldEnum | ProductionRunValueScalarFieldEnum[]
  }

  /**
   * ProductionRunValue findFirstOrThrow
   */
  export type ProductionRunValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRunValue to fetch.
     */
    where?: ProductionRunValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRunValues to fetch.
     */
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionRunValues.
     */
    cursor?: ProductionRunValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRunValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRunValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionRunValues.
     */
    distinct?: ProductionRunValueScalarFieldEnum | ProductionRunValueScalarFieldEnum[]
  }

  /**
   * ProductionRunValue findMany
   */
  export type ProductionRunValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRunValues to fetch.
     */
    where?: ProductionRunValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRunValues to fetch.
     */
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionRunValues.
     */
    cursor?: ProductionRunValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRunValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRunValues.
     */
    skip?: number
    distinct?: ProductionRunValueScalarFieldEnum | ProductionRunValueScalarFieldEnum[]
  }

  /**
   * ProductionRunValue create
   */
  export type ProductionRunValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionRunValue.
     */
    data: XOR<ProductionRunValueCreateInput, ProductionRunValueUncheckedCreateInput>
  }

  /**
   * ProductionRunValue createMany
   */
  export type ProductionRunValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionRunValues.
     */
    data: ProductionRunValueCreateManyInput | ProductionRunValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionRunValue createManyAndReturn
   */
  export type ProductionRunValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionRunValues.
     */
    data: ProductionRunValueCreateManyInput | ProductionRunValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionRunValue update
   */
  export type ProductionRunValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionRunValue.
     */
    data: XOR<ProductionRunValueUpdateInput, ProductionRunValueUncheckedUpdateInput>
    /**
     * Choose, which ProductionRunValue to update.
     */
    where: ProductionRunValueWhereUniqueInput
  }

  /**
   * ProductionRunValue updateMany
   */
  export type ProductionRunValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionRunValues.
     */
    data: XOR<ProductionRunValueUpdateManyMutationInput, ProductionRunValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductionRunValues to update
     */
    where?: ProductionRunValueWhereInput
    /**
     * Limit how many ProductionRunValues to update.
     */
    limit?: number
  }

  /**
   * ProductionRunValue updateManyAndReturn
   */
  export type ProductionRunValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * The data used to update ProductionRunValues.
     */
    data: XOR<ProductionRunValueUpdateManyMutationInput, ProductionRunValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductionRunValues to update
     */
    where?: ProductionRunValueWhereInput
    /**
     * Limit how many ProductionRunValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionRunValue upsert
   */
  export type ProductionRunValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionRunValue to update in case it exists.
     */
    where: ProductionRunValueWhereUniqueInput
    /**
     * In case the ProductionRunValue found by the `where` argument doesn't exist, create a new ProductionRunValue with this data.
     */
    create: XOR<ProductionRunValueCreateInput, ProductionRunValueUncheckedCreateInput>
    /**
     * In case the ProductionRunValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionRunValueUpdateInput, ProductionRunValueUncheckedUpdateInput>
  }

  /**
   * ProductionRunValue delete
   */
  export type ProductionRunValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter which ProductionRunValue to delete.
     */
    where: ProductionRunValueWhereUniqueInput
  }

  /**
   * ProductionRunValue deleteMany
   */
  export type ProductionRunValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionRunValues to delete
     */
    where?: ProductionRunValueWhereInput
    /**
     * Limit how many ProductionRunValues to delete.
     */
    limit?: number
  }

  /**
   * ProductionRunValue without action
   */
  export type ProductionRunValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    name: 'name',
    role: 'role',
    telegramId: 'telegramId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DistrictScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name'
  };

  export type DistrictScalarFieldEnum = (typeof DistrictScalarFieldEnum)[keyof typeof DistrictScalarFieldEnum]


  export const ManagerScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    phone: 'phone'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    altName: 'altName',
    priceListName: 'priceListName',
    category: 'category',
    status: 'status',
    coefficient: 'coefficient',
    lossNorm: 'lossNorm',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    legalName: 'legalName',
    districtId: 'districtId',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    legalName: 'legalName',
    altName: 'altName',
    phone: 'phone',
    telegram: 'telegram',
    isActive: 'isActive',
    primaryMmlId: 'primaryMmlId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const SupplierProductScalarFieldEnum: {
    supplierId: 'supplierId',
    productId: 'productId'
  };

  export type SupplierProductScalarFieldEnum = (typeof SupplierProductScalarFieldEnum)[keyof typeof SupplierProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    idn: 'idn',
    date: 'date',
    status: 'status',
    paymentType: 'paymentType',
    customerId: 'customerId',
    expeditorId: 'expeditorId',
    totalAmount: 'totalAmount',
    totalWeight: 'totalWeight',
    isDisabled: 'isDisabled',
    deliveryAddress: 'deliveryAddress',
    assignedAt: 'assignedAt',
    deliveryStatus: 'deliveryStatus',
    completedAt: 'completedAt',
    signatureUrl: 'signatureUrl',
    signedInvoiceUrl: 'signedInvoiceUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderAttachmentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    type: 'type',
    filename: 'filename',
    url: 'url',
    mimeType: 'mimeType',
    createdAt: 'createdAt'
  };

  export type OrderAttachmentScalarFieldEnum = (typeof OrderAttachmentScalarFieldEnum)[keyof typeof OrderAttachmentScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    price: 'price',
    amount: 'amount',
    shippedQty: 'shippedQty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    distributionCoef: 'distributionCoef',
    sumWithRevaluation: 'sumWithRevaluation',
    weightToDistribute: 'weightToDistribute'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const ExpeditorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpeditorScalarFieldEnum = (typeof ExpeditorScalarFieldEnum)[keyof typeof ExpeditorScalarFieldEnum]


  export const StockScalarFieldEnum: {
    productId: 'productId',
    quantity: 'quantity',
    updatedAt: 'updatedAt'
  };

  export type StockScalarFieldEnum = (typeof StockScalarFieldEnum)[keyof typeof StockScalarFieldEnum]


  export const StockTransactionScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    type: 'type',
    quantity: 'quantity',
    orderId: 'orderId',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type StockTransactionScalarFieldEnum = (typeof StockTransactionScalarFieldEnum)[keyof typeof StockTransactionScalarFieldEnum]


  export const SummaryOrderJournalScalarFieldEnum: {
    id: 'id',
    idn: 'idn',
    shipDate: 'shipDate',
    paymentType: 'paymentType',
    customerId: 'customerId',
    customerName: 'customerName',
    productId: 'productId',
    productCode: 'productCode',
    productFullName: 'productFullName',
    category: 'category',
    shortNameMorning: 'shortNameMorning',
    priceType: 'priceType',
    price: 'price',
    shippedQty: 'shippedQty',
    orderQty: 'orderQty',
    sumWithRevaluation: 'sumWithRevaluation',
    distributionCoef: 'distributionCoef',
    weightToDistribute: 'weightToDistribute',
    managerId: 'managerId',
    managerName: 'managerName',
    district: 'district',
    pointAddress: 'pointAddress',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SummaryOrderJournalScalarFieldEnum = (typeof SummaryOrderJournalScalarFieldEnum)[keyof typeof SummaryOrderJournalScalarFieldEnum]


  export const SummaryOrdersJournalScalarFieldEnum: {
    id: 'id',
    summaryDate: 'summaryDate',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    isHidden: 'isHidden',
    data: 'data'
  };

  export type SummaryOrdersJournalScalarFieldEnum = (typeof SummaryOrdersJournalScalarFieldEnum)[keyof typeof SummaryOrdersJournalScalarFieldEnum]


  export const AssemblyOrdersJournalScalarFieldEnum: {
    id: 'id',
    assemblyDate: 'assemblyDate',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    isHidden: 'isHidden',
    sourceSummaryId: 'sourceSummaryId',
    data: 'data'
  };

  export type AssemblyOrdersJournalScalarFieldEnum = (typeof AssemblyOrdersJournalScalarFieldEnum)[keyof typeof AssemblyOrdersJournalScalarFieldEnum]


  export const ProductionStaffScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    phone: 'phone',
    userId: 'userId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionStaffScalarFieldEnum = (typeof ProductionStaffScalarFieldEnum)[keyof typeof ProductionStaffScalarFieldEnum]


  export const ProductionJournalScalarFieldEnum: {
    id: 'id',
    productionDate: 'productionDate',
    staffId: 'staffId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ProductionJournalScalarFieldEnum = (typeof ProductionJournalScalarFieldEnum)[keyof typeof ProductionJournalScalarFieldEnum]


  export const ProductionItemScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    productId: 'productId',
    productName: 'productName',
    state: 'state',
    sortOrder: 'sortOrder',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ProductionItemScalarFieldEnum = (typeof ProductionItemScalarFieldEnum)[keyof typeof ProductionItemScalarFieldEnum]


  export const ProductionItemValueScalarFieldEnum: {
    id: 'id',
    productionItemId: 'productionItemId',
    fieldKey: 'fieldKey',
    fieldValue: 'fieldValue',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ProductionItemValueScalarFieldEnum = (typeof ProductionItemValueScalarFieldEnum)[keyof typeof ProductionItemValueScalarFieldEnum]


  export const PurchasePriceListScalarFieldEnum: {
    id: 'id',
    date: 'date',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type PurchasePriceListScalarFieldEnum = (typeof PurchasePriceListScalarFieldEnum)[keyof typeof PurchasePriceListScalarFieldEnum]


  export const PurchasePriceListSupplierScalarFieldEnum: {
    id: 'id',
    priceListId: 'priceListId',
    supplierId: 'supplierId',
    primaryMmlId: 'primaryMmlId',
    createdAt: 'createdAt'
  };

  export type PurchasePriceListSupplierScalarFieldEnum = (typeof PurchasePriceListSupplierScalarFieldEnum)[keyof typeof PurchasePriceListSupplierScalarFieldEnum]


  export const PurchasePriceItemScalarFieldEnum: {
    id: 'id',
    priceListId: 'priceListId',
    supplierId: 'supplierId',
    productId: 'productId',
    purchasePrice: 'purchasePrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchasePriceItemScalarFieldEnum = (typeof PurchasePriceItemScalarFieldEnum)[keyof typeof PurchasePriceItemScalarFieldEnum]


  export const SalesPriceListScalarFieldEnum: {
    id: 'id',
    listType: 'listType',
    customerId: 'customerId',
    title: 'title',
    effectiveDate: 'effectiveDate',
    status: 'status',
    isCurrent: 'isCurrent',
    isHidden: 'isHidden',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type SalesPriceListScalarFieldEnum = (typeof SalesPriceListScalarFieldEnum)[keyof typeof SalesPriceListScalarFieldEnum]


  export const SalesPriceItemScalarFieldEnum: {
    id: 'id',
    priceListId: 'priceListId',
    productId: 'productId',
    salePrice: 'salePrice',
    rowDate: 'rowDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SalesPriceItemScalarFieldEnum = (typeof SalesPriceItemScalarFieldEnum)[keyof typeof SalesPriceItemScalarFieldEnum]


  export const ProductionMmlScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    createdBy: 'createdBy',
    isLocked: 'isLocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionMmlScalarFieldEnum = (typeof ProductionMmlScalarFieldEnum)[keyof typeof ProductionMmlScalarFieldEnum]


  export const ProductionMmlNodeScalarFieldEnum: {
    id: 'id',
    mmlId: 'mmlId',
    parentNodeId: 'parentNodeId',
    productId: 'productId',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionMmlNodeScalarFieldEnum = (typeof ProductionMmlNodeScalarFieldEnum)[keyof typeof ProductionMmlNodeScalarFieldEnum]


  export const ProductionRunScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    mmlId: 'mmlId',
    userId: 'userId',
    isLocked: 'isLocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionRunScalarFieldEnum = (typeof ProductionRunScalarFieldEnum)[keyof typeof ProductionRunScalarFieldEnum]


  export const ProductionRunValueScalarFieldEnum: {
    id: 'id',
    productionRunId: 'productionRunId',
    mmlNodeId: 'mmlNodeId',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionRunValueScalarFieldEnum = (typeof ProductionRunValueScalarFieldEnum)[keyof typeof ProductionRunValueScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    telegramId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    productionStaff?: XOR<ProductionStaffNullableScalarRelationFilter, ProductionStaffWhereInput> | null
    createdMmls?: ProductionMmlListRelationFilter
    productionRuns?: ProductionRunListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    telegramId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productionStaff?: ProductionStaffOrderByWithRelationInput
    createdMmls?: ProductionMmlOrderByRelationAggregateInput
    productionRuns?: ProductionRunOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    telegramId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    productionStaff?: XOR<ProductionStaffNullableScalarRelationFilter, ProductionStaffWhereInput> | null
    createdMmls?: ProductionMmlListRelationFilter
    productionRuns?: ProductionRunListRelationFilter
  }, "id" | "username" | "telegramId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    telegramId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    telegramId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type DistrictWhereInput = {
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    id?: IntFilter<"District"> | number
    code?: StringFilter<"District"> | string
    name?: StringFilter<"District"> | string
    customers?: CustomerListRelationFilter
  }

  export type DistrictOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    customers?: CustomerOrderByRelationAggregateInput
  }

  export type DistrictWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    name?: StringFilter<"District"> | string
    customers?: CustomerListRelationFilter
  }, "id" | "code">

  export type DistrictOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    _count?: DistrictCountOrderByAggregateInput
    _avg?: DistrictAvgOrderByAggregateInput
    _max?: DistrictMaxOrderByAggregateInput
    _min?: DistrictMinOrderByAggregateInput
    _sum?: DistrictSumOrderByAggregateInput
  }

  export type DistrictScalarWhereWithAggregatesInput = {
    AND?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    OR?: DistrictScalarWhereWithAggregatesInput[]
    NOT?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"District"> | number
    code?: StringWithAggregatesFilter<"District"> | string
    name?: StringWithAggregatesFilter<"District"> | string
  }

  export type ManagerWhereInput = {
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    id?: IntFilter<"Manager"> | number
    code?: StringFilter<"Manager"> | string
    name?: StringFilter<"Manager"> | string
    phone?: StringNullableFilter<"Manager"> | string | null
    customers?: CustomerListRelationFilter
  }

  export type ManagerOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    customers?: CustomerOrderByRelationAggregateInput
  }

  export type ManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    name?: StringFilter<"Manager"> | string
    phone?: StringNullableFilter<"Manager"> | string | null
    customers?: CustomerListRelationFilter
  }, "id" | "code">

  export type ManagerOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: ManagerCountOrderByAggregateInput
    _avg?: ManagerAvgOrderByAggregateInput
    _max?: ManagerMaxOrderByAggregateInput
    _min?: ManagerMinOrderByAggregateInput
    _sum?: ManagerSumOrderByAggregateInput
  }

  export type ManagerScalarWhereWithAggregatesInput = {
    AND?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    OR?: ManagerScalarWhereWithAggregatesInput[]
    NOT?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Manager"> | number
    code?: StringWithAggregatesFilter<"Manager"> | string
    name?: StringWithAggregatesFilter<"Manager"> | string
    phone?: StringNullableWithAggregatesFilter<"Manager"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    code?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    altName?: StringNullableFilter<"Product"> | string | null
    priceListName?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    status?: StringFilter<"Product"> | string
    coefficient?: FloatFilter<"Product"> | number
    lossNorm?: FloatFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    orderItems?: OrderItemListRelationFilter
    stock?: XOR<StockNullableScalarRelationFilter, StockWhereInput> | null
    stockTransactions?: StockTransactionListRelationFilter
    suppliers?: SupplierProductListRelationFilter
    summaryJournalEntries?: SummaryOrderJournalListRelationFilter
    productionItems?: ProductionItemListRelationFilter
    purchasePriceItems?: PurchasePriceItemListRelationFilter
    salesPriceItems?: SalesPriceItemListRelationFilter
    productionMmls?: ProductionMmlListRelationFilter
    mmlNodes?: ProductionMmlNodeListRelationFilter
    productionRuns?: ProductionRunListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    altName?: SortOrderInput | SortOrder
    priceListName?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    stock?: StockOrderByWithRelationInput
    stockTransactions?: StockTransactionOrderByRelationAggregateInput
    suppliers?: SupplierProductOrderByRelationAggregateInput
    summaryJournalEntries?: SummaryOrderJournalOrderByRelationAggregateInput
    productionItems?: ProductionItemOrderByRelationAggregateInput
    purchasePriceItems?: PurchasePriceItemOrderByRelationAggregateInput
    salesPriceItems?: SalesPriceItemOrderByRelationAggregateInput
    productionMmls?: ProductionMmlOrderByRelationAggregateInput
    mmlNodes?: ProductionMmlNodeOrderByRelationAggregateInput
    productionRuns?: ProductionRunOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    altName?: StringNullableFilter<"Product"> | string | null
    priceListName?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    status?: StringFilter<"Product"> | string
    coefficient?: FloatFilter<"Product"> | number
    lossNorm?: FloatFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    orderItems?: OrderItemListRelationFilter
    stock?: XOR<StockNullableScalarRelationFilter, StockWhereInput> | null
    stockTransactions?: StockTransactionListRelationFilter
    suppliers?: SupplierProductListRelationFilter
    summaryJournalEntries?: SummaryOrderJournalListRelationFilter
    productionItems?: ProductionItemListRelationFilter
    purchasePriceItems?: PurchasePriceItemListRelationFilter
    salesPriceItems?: SalesPriceItemListRelationFilter
    productionMmls?: ProductionMmlListRelationFilter
    mmlNodes?: ProductionMmlNodeListRelationFilter
    productionRuns?: ProductionRunListRelationFilter
  }, "id" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    altName?: SortOrderInput | SortOrder
    priceListName?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    code?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    altName?: StringNullableWithAggregatesFilter<"Product"> | string | null
    priceListName?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    status?: StringWithAggregatesFilter<"Product"> | string
    coefficient?: FloatWithAggregatesFilter<"Product"> | number
    lossNorm?: FloatWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    code?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    legalName?: StringNullableFilter<"Customer"> | string | null
    districtId?: StringNullableFilter<"Customer"> | string | null
    managerId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    district?: XOR<DistrictNullableScalarRelationFilter, DistrictWhereInput> | null
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    orders?: OrderListRelationFilter
    summaryJournalEntries?: SummaryOrderJournalListRelationFilter
    salesPriceLists?: SalesPriceListListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    districtId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    district?: DistrictOrderByWithRelationInput
    manager?: ManagerOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    summaryJournalEntries?: SummaryOrderJournalOrderByRelationAggregateInput
    salesPriceLists?: SalesPriceListOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    legalName?: StringNullableFilter<"Customer"> | string | null
    districtId?: StringNullableFilter<"Customer"> | string | null
    managerId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    district?: XOR<DistrictNullableScalarRelationFilter, DistrictWhereInput> | null
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    orders?: OrderListRelationFilter
    summaryJournalEntries?: SummaryOrderJournalListRelationFilter
    salesPriceLists?: SalesPriceListListRelationFilter
  }, "id" | "code">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    districtId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    code?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    legalName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    districtId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: IntFilter<"Supplier"> | number
    code?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    legalName?: StringNullableFilter<"Supplier"> | string | null
    altName?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    telegram?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    primaryMmlId?: IntNullableFilter<"Supplier"> | number | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    primaryMml?: XOR<ProductionMmlNullableScalarRelationFilter, ProductionMmlWhereInput> | null
    products?: SupplierProductListRelationFilter
    purchasePriceListSuppliers?: PurchasePriceListSupplierListRelationFilter
    purchasePriceItems?: PurchasePriceItemListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    altName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    isActive?: SortOrder
    primaryMmlId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryMml?: ProductionMmlOrderByWithRelationInput
    products?: SupplierProductOrderByRelationAggregateInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierOrderByRelationAggregateInput
    purchasePriceItems?: PurchasePriceItemOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    legalName?: StringNullableFilter<"Supplier"> | string | null
    altName?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    telegram?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    primaryMmlId?: IntNullableFilter<"Supplier"> | number | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    primaryMml?: XOR<ProductionMmlNullableScalarRelationFilter, ProductionMmlWhereInput> | null
    products?: SupplierProductListRelationFilter
    purchasePriceListSuppliers?: PurchasePriceListSupplierListRelationFilter
    purchasePriceItems?: PurchasePriceItemListRelationFilter
  }, "id" | "code">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    altName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    isActive?: SortOrder
    primaryMmlId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Supplier"> | number
    code?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    legalName?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    altName?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    telegram?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    primaryMmlId?: IntNullableWithAggregatesFilter<"Supplier"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type SupplierProductWhereInput = {
    AND?: SupplierProductWhereInput | SupplierProductWhereInput[]
    OR?: SupplierProductWhereInput[]
    NOT?: SupplierProductWhereInput | SupplierProductWhereInput[]
    supplierId?: IntFilter<"SupplierProduct"> | number
    productId?: IntFilter<"SupplierProduct"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type SupplierProductOrderByWithRelationInput = {
    supplierId?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type SupplierProductWhereUniqueInput = Prisma.AtLeast<{
    supplierId_productId?: SupplierProductSupplierIdProductIdCompoundUniqueInput
    AND?: SupplierProductWhereInput | SupplierProductWhereInput[]
    OR?: SupplierProductWhereInput[]
    NOT?: SupplierProductWhereInput | SupplierProductWhereInput[]
    supplierId?: IntFilter<"SupplierProduct"> | number
    productId?: IntFilter<"SupplierProduct"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "supplierId_productId">

  export type SupplierProductOrderByWithAggregationInput = {
    supplierId?: SortOrder
    productId?: SortOrder
    _count?: SupplierProductCountOrderByAggregateInput
    _avg?: SupplierProductAvgOrderByAggregateInput
    _max?: SupplierProductMaxOrderByAggregateInput
    _min?: SupplierProductMinOrderByAggregateInput
    _sum?: SupplierProductSumOrderByAggregateInput
  }

  export type SupplierProductScalarWhereWithAggregatesInput = {
    AND?: SupplierProductScalarWhereWithAggregatesInput | SupplierProductScalarWhereWithAggregatesInput[]
    OR?: SupplierProductScalarWhereWithAggregatesInput[]
    NOT?: SupplierProductScalarWhereWithAggregatesInput | SupplierProductScalarWhereWithAggregatesInput[]
    supplierId?: IntWithAggregatesFilter<"SupplierProduct"> | number
    productId?: IntWithAggregatesFilter<"SupplierProduct"> | number
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    idn?: StringNullableFilter<"Order"> | string | null
    date?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    paymentType?: StringNullableFilter<"Order"> | string | null
    customerId?: IntFilter<"Order"> | number
    expeditorId?: IntNullableFilter<"Order"> | number | null
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFilter<"Order"> | number
    isDisabled?: BoolFilter<"Order"> | boolean
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    assignedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryStatus?: StringFilter<"Order"> | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    signatureUrl?: StringNullableFilter<"Order"> | string | null
    signedInvoiceUrl?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    expeditor?: XOR<ExpeditorNullableScalarRelationFilter, ExpeditorWhereInput> | null
    items?: OrderItemListRelationFilter
    stockTransactions?: StockTransactionListRelationFilter
    attachments?: OrderAttachmentListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    idn?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
    isDisabled?: SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    deliveryStatus?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    signedInvoiceUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    expeditor?: ExpeditorOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    stockTransactions?: StockTransactionOrderByRelationAggregateInput
    attachments?: OrderAttachmentOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    idn?: StringNullableFilter<"Order"> | string | null
    date?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    paymentType?: StringNullableFilter<"Order"> | string | null
    customerId?: IntFilter<"Order"> | number
    expeditorId?: IntNullableFilter<"Order"> | number | null
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFilter<"Order"> | number
    isDisabled?: BoolFilter<"Order"> | boolean
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    assignedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryStatus?: StringFilter<"Order"> | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    signatureUrl?: StringNullableFilter<"Order"> | string | null
    signedInvoiceUrl?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    expeditor?: XOR<ExpeditorNullableScalarRelationFilter, ExpeditorWhereInput> | null
    items?: OrderItemListRelationFilter
    stockTransactions?: StockTransactionListRelationFilter
    attachments?: OrderAttachmentListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    idn?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
    isDisabled?: SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    deliveryStatus?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    signedInvoiceUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    idn?: StringNullableWithAggregatesFilter<"Order"> | string | null
    date?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    status?: StringWithAggregatesFilter<"Order"> | string
    paymentType?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerId?: IntWithAggregatesFilter<"Order"> | number
    expeditorId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    totalAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatWithAggregatesFilter<"Order"> | number
    isDisabled?: BoolWithAggregatesFilter<"Order"> | boolean
    deliveryAddress?: StringNullableWithAggregatesFilter<"Order"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    deliveryStatus?: StringWithAggregatesFilter<"Order"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    signatureUrl?: StringNullableWithAggregatesFilter<"Order"> | string | null
    signedInvoiceUrl?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderAttachmentWhereInput = {
    AND?: OrderAttachmentWhereInput | OrderAttachmentWhereInput[]
    OR?: OrderAttachmentWhereInput[]
    NOT?: OrderAttachmentWhereInput | OrderAttachmentWhereInput[]
    id?: IntFilter<"OrderAttachment"> | number
    orderId?: IntFilter<"OrderAttachment"> | number
    type?: StringFilter<"OrderAttachment"> | string
    filename?: StringFilter<"OrderAttachment"> | string
    url?: StringFilter<"OrderAttachment"> | string
    mimeType?: StringNullableFilter<"OrderAttachment"> | string | null
    createdAt?: DateTimeFilter<"OrderAttachment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type OrderAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type OrderAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderAttachmentWhereInput | OrderAttachmentWhereInput[]
    OR?: OrderAttachmentWhereInput[]
    NOT?: OrderAttachmentWhereInput | OrderAttachmentWhereInput[]
    orderId?: IntFilter<"OrderAttachment"> | number
    type?: StringFilter<"OrderAttachment"> | string
    filename?: StringFilter<"OrderAttachment"> | string
    url?: StringFilter<"OrderAttachment"> | string
    mimeType?: StringNullableFilter<"OrderAttachment"> | string | null
    createdAt?: DateTimeFilter<"OrderAttachment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type OrderAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OrderAttachmentCountOrderByAggregateInput
    _avg?: OrderAttachmentAvgOrderByAggregateInput
    _max?: OrderAttachmentMaxOrderByAggregateInput
    _min?: OrderAttachmentMinOrderByAggregateInput
    _sum?: OrderAttachmentSumOrderByAggregateInput
  }

  export type OrderAttachmentScalarWhereWithAggregatesInput = {
    AND?: OrderAttachmentScalarWhereWithAggregatesInput | OrderAttachmentScalarWhereWithAggregatesInput[]
    OR?: OrderAttachmentScalarWhereWithAggregatesInput[]
    NOT?: OrderAttachmentScalarWhereWithAggregatesInput | OrderAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderAttachment"> | number
    orderId?: IntWithAggregatesFilter<"OrderAttachment"> | number
    type?: StringWithAggregatesFilter<"OrderAttachment"> | string
    filename?: StringWithAggregatesFilter<"OrderAttachment"> | string
    url?: StringWithAggregatesFilter<"OrderAttachment"> | string
    mimeType?: StringNullableWithAggregatesFilter<"OrderAttachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderAttachment"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: FloatFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    distributionCoef?: FloatNullableFilter<"OrderItem"> | number | null
    sumWithRevaluation?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: FloatNullableFilter<"OrderItem"> | number | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributionCoef?: SortOrderInput | SortOrder
    sumWithRevaluation?: SortOrderInput | SortOrder
    weightToDistribute?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: FloatFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    distributionCoef?: FloatNullableFilter<"OrderItem"> | number | null
    sumWithRevaluation?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: FloatNullableFilter<"OrderItem"> | number | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributionCoef?: SortOrderInput | SortOrder
    sumWithRevaluation?: SortOrderInput | SortOrder
    weightToDistribute?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    productId?: IntWithAggregatesFilter<"OrderItem"> | number
    quantity?: FloatWithAggregatesFilter<"OrderItem"> | number
    price?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatWithAggregatesFilter<"OrderItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    distributionCoef?: FloatNullableWithAggregatesFilter<"OrderItem"> | number | null
    sumWithRevaluation?: DecimalNullableWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: FloatNullableWithAggregatesFilter<"OrderItem"> | number | null
  }

  export type ExpeditorWhereInput = {
    AND?: ExpeditorWhereInput | ExpeditorWhereInput[]
    OR?: ExpeditorWhereInput[]
    NOT?: ExpeditorWhereInput | ExpeditorWhereInput[]
    id?: IntFilter<"Expeditor"> | number
    name?: StringFilter<"Expeditor"> | string
    phone?: StringNullableFilter<"Expeditor"> | string | null
    isActive?: BoolFilter<"Expeditor"> | boolean
    createdAt?: DateTimeFilter<"Expeditor"> | Date | string
    updatedAt?: DateTimeFilter<"Expeditor"> | Date | string
    orders?: OrderListRelationFilter
  }

  export type ExpeditorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type ExpeditorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExpeditorWhereInput | ExpeditorWhereInput[]
    OR?: ExpeditorWhereInput[]
    NOT?: ExpeditorWhereInput | ExpeditorWhereInput[]
    name?: StringFilter<"Expeditor"> | string
    phone?: StringNullableFilter<"Expeditor"> | string | null
    isActive?: BoolFilter<"Expeditor"> | boolean
    createdAt?: DateTimeFilter<"Expeditor"> | Date | string
    updatedAt?: DateTimeFilter<"Expeditor"> | Date | string
    orders?: OrderListRelationFilter
  }, "id">

  export type ExpeditorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpeditorCountOrderByAggregateInput
    _avg?: ExpeditorAvgOrderByAggregateInput
    _max?: ExpeditorMaxOrderByAggregateInput
    _min?: ExpeditorMinOrderByAggregateInput
    _sum?: ExpeditorSumOrderByAggregateInput
  }

  export type ExpeditorScalarWhereWithAggregatesInput = {
    AND?: ExpeditorScalarWhereWithAggregatesInput | ExpeditorScalarWhereWithAggregatesInput[]
    OR?: ExpeditorScalarWhereWithAggregatesInput[]
    NOT?: ExpeditorScalarWhereWithAggregatesInput | ExpeditorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Expeditor"> | number
    name?: StringWithAggregatesFilter<"Expeditor"> | string
    phone?: StringNullableWithAggregatesFilter<"Expeditor"> | string | null
    isActive?: BoolWithAggregatesFilter<"Expeditor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Expeditor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expeditor"> | Date | string
  }

  export type StockWhereInput = {
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    productId?: IntFilter<"Stock"> | number
    quantity?: FloatFilter<"Stock"> | number
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type StockOrderByWithRelationInput = {
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type StockWhereUniqueInput = Prisma.AtLeast<{
    productId?: number
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    quantity?: FloatFilter<"Stock"> | number
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "productId">

  export type StockOrderByWithAggregationInput = {
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
    _count?: StockCountOrderByAggregateInput
    _avg?: StockAvgOrderByAggregateInput
    _max?: StockMaxOrderByAggregateInput
    _min?: StockMinOrderByAggregateInput
    _sum?: StockSumOrderByAggregateInput
  }

  export type StockScalarWhereWithAggregatesInput = {
    AND?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    OR?: StockScalarWhereWithAggregatesInput[]
    NOT?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    productId?: IntWithAggregatesFilter<"Stock"> | number
    quantity?: FloatWithAggregatesFilter<"Stock"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Stock"> | Date | string
  }

  export type StockTransactionWhereInput = {
    AND?: StockTransactionWhereInput | StockTransactionWhereInput[]
    OR?: StockTransactionWhereInput[]
    NOT?: StockTransactionWhereInput | StockTransactionWhereInput[]
    id?: IntFilter<"StockTransaction"> | number
    productId?: IntFilter<"StockTransaction"> | number
    type?: StringFilter<"StockTransaction"> | string
    quantity?: FloatFilter<"StockTransaction"> | number
    orderId?: IntNullableFilter<"StockTransaction"> | number | null
    note?: StringNullableFilter<"StockTransaction"> | string | null
    createdAt?: DateTimeFilter<"StockTransaction"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type StockTransactionOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type StockTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StockTransactionWhereInput | StockTransactionWhereInput[]
    OR?: StockTransactionWhereInput[]
    NOT?: StockTransactionWhereInput | StockTransactionWhereInput[]
    productId?: IntFilter<"StockTransaction"> | number
    type?: StringFilter<"StockTransaction"> | string
    quantity?: FloatFilter<"StockTransaction"> | number
    orderId?: IntNullableFilter<"StockTransaction"> | number | null
    note?: StringNullableFilter<"StockTransaction"> | string | null
    createdAt?: DateTimeFilter<"StockTransaction"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type StockTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StockTransactionCountOrderByAggregateInput
    _avg?: StockTransactionAvgOrderByAggregateInput
    _max?: StockTransactionMaxOrderByAggregateInput
    _min?: StockTransactionMinOrderByAggregateInput
    _sum?: StockTransactionSumOrderByAggregateInput
  }

  export type StockTransactionScalarWhereWithAggregatesInput = {
    AND?: StockTransactionScalarWhereWithAggregatesInput | StockTransactionScalarWhereWithAggregatesInput[]
    OR?: StockTransactionScalarWhereWithAggregatesInput[]
    NOT?: StockTransactionScalarWhereWithAggregatesInput | StockTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StockTransaction"> | number
    productId?: IntWithAggregatesFilter<"StockTransaction"> | number
    type?: StringWithAggregatesFilter<"StockTransaction"> | string
    quantity?: FloatWithAggregatesFilter<"StockTransaction"> | number
    orderId?: IntNullableWithAggregatesFilter<"StockTransaction"> | number | null
    note?: StringNullableWithAggregatesFilter<"StockTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockTransaction"> | Date | string
  }

  export type SummaryOrderJournalWhereInput = {
    AND?: SummaryOrderJournalWhereInput | SummaryOrderJournalWhereInput[]
    OR?: SummaryOrderJournalWhereInput[]
    NOT?: SummaryOrderJournalWhereInput | SummaryOrderJournalWhereInput[]
    id?: IntFilter<"SummaryOrderJournal"> | number
    idn?: StringFilter<"SummaryOrderJournal"> | string
    shipDate?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    paymentType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    customerId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    customerName?: StringFilter<"SummaryOrderJournal"> | string
    productId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    productCode?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    productFullName?: StringFilter<"SummaryOrderJournal"> | string
    category?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    shortNameMorning?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    priceType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    price?: DecimalFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"SummaryOrderJournal"> | number
    orderQty?: FloatFilter<"SummaryOrderJournal"> | number
    sumWithRevaluation?: DecimalNullableFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    weightToDistribute?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    managerId?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    managerName?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    district?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    pointAddress?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    status?: StringFilter<"SummaryOrderJournal"> | string
    createdAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    updatedAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }

  export type SummaryOrderJournalOrderByWithRelationInput = {
    id?: SortOrder
    idn?: SortOrder
    shipDate?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    productId?: SortOrderInput | SortOrder
    productCode?: SortOrderInput | SortOrder
    productFullName?: SortOrder
    category?: SortOrderInput | SortOrder
    shortNameMorning?: SortOrderInput | SortOrder
    priceType?: SortOrderInput | SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrderInput | SortOrder
    distributionCoef?: SortOrderInput | SortOrder
    weightToDistribute?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    managerName?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    pointAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type SummaryOrderJournalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SummaryOrderJournalWhereInput | SummaryOrderJournalWhereInput[]
    OR?: SummaryOrderJournalWhereInput[]
    NOT?: SummaryOrderJournalWhereInput | SummaryOrderJournalWhereInput[]
    idn?: StringFilter<"SummaryOrderJournal"> | string
    shipDate?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    paymentType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    customerId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    customerName?: StringFilter<"SummaryOrderJournal"> | string
    productId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    productCode?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    productFullName?: StringFilter<"SummaryOrderJournal"> | string
    category?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    shortNameMorning?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    priceType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    price?: DecimalFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"SummaryOrderJournal"> | number
    orderQty?: FloatFilter<"SummaryOrderJournal"> | number
    sumWithRevaluation?: DecimalNullableFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    weightToDistribute?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    managerId?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    managerName?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    district?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    pointAddress?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    status?: StringFilter<"SummaryOrderJournal"> | string
    createdAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    updatedAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }, "id">

  export type SummaryOrderJournalOrderByWithAggregationInput = {
    id?: SortOrder
    idn?: SortOrder
    shipDate?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    productId?: SortOrderInput | SortOrder
    productCode?: SortOrderInput | SortOrder
    productFullName?: SortOrder
    category?: SortOrderInput | SortOrder
    shortNameMorning?: SortOrderInput | SortOrder
    priceType?: SortOrderInput | SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrderInput | SortOrder
    distributionCoef?: SortOrderInput | SortOrder
    weightToDistribute?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    managerName?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    pointAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SummaryOrderJournalCountOrderByAggregateInput
    _avg?: SummaryOrderJournalAvgOrderByAggregateInput
    _max?: SummaryOrderJournalMaxOrderByAggregateInput
    _min?: SummaryOrderJournalMinOrderByAggregateInput
    _sum?: SummaryOrderJournalSumOrderByAggregateInput
  }

  export type SummaryOrderJournalScalarWhereWithAggregatesInput = {
    AND?: SummaryOrderJournalScalarWhereWithAggregatesInput | SummaryOrderJournalScalarWhereWithAggregatesInput[]
    OR?: SummaryOrderJournalScalarWhereWithAggregatesInput[]
    NOT?: SummaryOrderJournalScalarWhereWithAggregatesInput | SummaryOrderJournalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SummaryOrderJournal"> | number
    idn?: StringWithAggregatesFilter<"SummaryOrderJournal"> | string
    shipDate?: DateTimeWithAggregatesFilter<"SummaryOrderJournal"> | Date | string
    paymentType?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    customerId?: IntNullableWithAggregatesFilter<"SummaryOrderJournal"> | number | null
    customerName?: StringWithAggregatesFilter<"SummaryOrderJournal"> | string
    productId?: IntNullableWithAggregatesFilter<"SummaryOrderJournal"> | number | null
    productCode?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    productFullName?: StringWithAggregatesFilter<"SummaryOrderJournal"> | string
    category?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    shortNameMorning?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    priceType?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    price?: DecimalWithAggregatesFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatWithAggregatesFilter<"SummaryOrderJournal"> | number
    orderQty?: FloatWithAggregatesFilter<"SummaryOrderJournal"> | number
    sumWithRevaluation?: DecimalNullableWithAggregatesFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: FloatNullableWithAggregatesFilter<"SummaryOrderJournal"> | number | null
    weightToDistribute?: FloatNullableWithAggregatesFilter<"SummaryOrderJournal"> | number | null
    managerId?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    managerName?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    district?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    pointAddress?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    status?: StringWithAggregatesFilter<"SummaryOrderJournal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SummaryOrderJournal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SummaryOrderJournal"> | Date | string
  }

  export type SummaryOrdersJournalWhereInput = {
    AND?: SummaryOrdersJournalWhereInput | SummaryOrdersJournalWhereInput[]
    OR?: SummaryOrdersJournalWhereInput[]
    NOT?: SummaryOrdersJournalWhereInput | SummaryOrdersJournalWhereInput[]
    id?: IntFilter<"SummaryOrdersJournal"> | number
    summaryDate?: DateTimeFilter<"SummaryOrdersJournal"> | Date | string
    createdAt?: DateTimeFilter<"SummaryOrdersJournal"> | Date | string
    createdBy?: StringFilter<"SummaryOrdersJournal"> | string
    isHidden?: BoolFilter<"SummaryOrdersJournal"> | boolean
    data?: JsonFilter<"SummaryOrdersJournal">
  }

  export type SummaryOrdersJournalOrderByWithRelationInput = {
    id?: SortOrder
    summaryDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    data?: SortOrder
  }

  export type SummaryOrdersJournalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SummaryOrdersJournalWhereInput | SummaryOrdersJournalWhereInput[]
    OR?: SummaryOrdersJournalWhereInput[]
    NOT?: SummaryOrdersJournalWhereInput | SummaryOrdersJournalWhereInput[]
    summaryDate?: DateTimeFilter<"SummaryOrdersJournal"> | Date | string
    createdAt?: DateTimeFilter<"SummaryOrdersJournal"> | Date | string
    createdBy?: StringFilter<"SummaryOrdersJournal"> | string
    isHidden?: BoolFilter<"SummaryOrdersJournal"> | boolean
    data?: JsonFilter<"SummaryOrdersJournal">
  }, "id">

  export type SummaryOrdersJournalOrderByWithAggregationInput = {
    id?: SortOrder
    summaryDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    data?: SortOrder
    _count?: SummaryOrdersJournalCountOrderByAggregateInput
    _avg?: SummaryOrdersJournalAvgOrderByAggregateInput
    _max?: SummaryOrdersJournalMaxOrderByAggregateInput
    _min?: SummaryOrdersJournalMinOrderByAggregateInput
    _sum?: SummaryOrdersJournalSumOrderByAggregateInput
  }

  export type SummaryOrdersJournalScalarWhereWithAggregatesInput = {
    AND?: SummaryOrdersJournalScalarWhereWithAggregatesInput | SummaryOrdersJournalScalarWhereWithAggregatesInput[]
    OR?: SummaryOrdersJournalScalarWhereWithAggregatesInput[]
    NOT?: SummaryOrdersJournalScalarWhereWithAggregatesInput | SummaryOrdersJournalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SummaryOrdersJournal"> | number
    summaryDate?: DateTimeWithAggregatesFilter<"SummaryOrdersJournal"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SummaryOrdersJournal"> | Date | string
    createdBy?: StringWithAggregatesFilter<"SummaryOrdersJournal"> | string
    isHidden?: BoolWithAggregatesFilter<"SummaryOrdersJournal"> | boolean
    data?: JsonWithAggregatesFilter<"SummaryOrdersJournal">
  }

  export type AssemblyOrdersJournalWhereInput = {
    AND?: AssemblyOrdersJournalWhereInput | AssemblyOrdersJournalWhereInput[]
    OR?: AssemblyOrdersJournalWhereInput[]
    NOT?: AssemblyOrdersJournalWhereInput | AssemblyOrdersJournalWhereInput[]
    id?: IntFilter<"AssemblyOrdersJournal"> | number
    assemblyDate?: DateTimeFilter<"AssemblyOrdersJournal"> | Date | string
    createdAt?: DateTimeFilter<"AssemblyOrdersJournal"> | Date | string
    createdBy?: StringFilter<"AssemblyOrdersJournal"> | string
    isHidden?: BoolFilter<"AssemblyOrdersJournal"> | boolean
    sourceSummaryId?: IntNullableFilter<"AssemblyOrdersJournal"> | number | null
    data?: JsonFilter<"AssemblyOrdersJournal">
  }

  export type AssemblyOrdersJournalOrderByWithRelationInput = {
    id?: SortOrder
    assemblyDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    sourceSummaryId?: SortOrderInput | SortOrder
    data?: SortOrder
  }

  export type AssemblyOrdersJournalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssemblyOrdersJournalWhereInput | AssemblyOrdersJournalWhereInput[]
    OR?: AssemblyOrdersJournalWhereInput[]
    NOT?: AssemblyOrdersJournalWhereInput | AssemblyOrdersJournalWhereInput[]
    assemblyDate?: DateTimeFilter<"AssemblyOrdersJournal"> | Date | string
    createdAt?: DateTimeFilter<"AssemblyOrdersJournal"> | Date | string
    createdBy?: StringFilter<"AssemblyOrdersJournal"> | string
    isHidden?: BoolFilter<"AssemblyOrdersJournal"> | boolean
    sourceSummaryId?: IntNullableFilter<"AssemblyOrdersJournal"> | number | null
    data?: JsonFilter<"AssemblyOrdersJournal">
  }, "id">

  export type AssemblyOrdersJournalOrderByWithAggregationInput = {
    id?: SortOrder
    assemblyDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    sourceSummaryId?: SortOrderInput | SortOrder
    data?: SortOrder
    _count?: AssemblyOrdersJournalCountOrderByAggregateInput
    _avg?: AssemblyOrdersJournalAvgOrderByAggregateInput
    _max?: AssemblyOrdersJournalMaxOrderByAggregateInput
    _min?: AssemblyOrdersJournalMinOrderByAggregateInput
    _sum?: AssemblyOrdersJournalSumOrderByAggregateInput
  }

  export type AssemblyOrdersJournalScalarWhereWithAggregatesInput = {
    AND?: AssemblyOrdersJournalScalarWhereWithAggregatesInput | AssemblyOrdersJournalScalarWhereWithAggregatesInput[]
    OR?: AssemblyOrdersJournalScalarWhereWithAggregatesInput[]
    NOT?: AssemblyOrdersJournalScalarWhereWithAggregatesInput | AssemblyOrdersJournalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssemblyOrdersJournal"> | number
    assemblyDate?: DateTimeWithAggregatesFilter<"AssemblyOrdersJournal"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AssemblyOrdersJournal"> | Date | string
    createdBy?: StringWithAggregatesFilter<"AssemblyOrdersJournal"> | string
    isHidden?: BoolWithAggregatesFilter<"AssemblyOrdersJournal"> | boolean
    sourceSummaryId?: IntNullableWithAggregatesFilter<"AssemblyOrdersJournal"> | number | null
    data?: JsonWithAggregatesFilter<"AssemblyOrdersJournal">
  }

  export type ProductionStaffWhereInput = {
    AND?: ProductionStaffWhereInput | ProductionStaffWhereInput[]
    OR?: ProductionStaffWhereInput[]
    NOT?: ProductionStaffWhereInput | ProductionStaffWhereInput[]
    id?: IntFilter<"ProductionStaff"> | number
    fullName?: StringFilter<"ProductionStaff"> | string
    phone?: StringNullableFilter<"ProductionStaff"> | string | null
    userId?: IntFilter<"ProductionStaff"> | number
    isActive?: BoolFilter<"ProductionStaff"> | boolean
    createdAt?: DateTimeFilter<"ProductionStaff"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    journals?: ProductionJournalListRelationFilter
  }

  export type ProductionStaffOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    journals?: ProductionJournalOrderByRelationAggregateInput
  }

  export type ProductionStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: ProductionStaffWhereInput | ProductionStaffWhereInput[]
    OR?: ProductionStaffWhereInput[]
    NOT?: ProductionStaffWhereInput | ProductionStaffWhereInput[]
    fullName?: StringFilter<"ProductionStaff"> | string
    phone?: StringNullableFilter<"ProductionStaff"> | string | null
    isActive?: BoolFilter<"ProductionStaff"> | boolean
    createdAt?: DateTimeFilter<"ProductionStaff"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    journals?: ProductionJournalListRelationFilter
  }, "id" | "userId">

  export type ProductionStaffOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionStaffCountOrderByAggregateInput
    _avg?: ProductionStaffAvgOrderByAggregateInput
    _max?: ProductionStaffMaxOrderByAggregateInput
    _min?: ProductionStaffMinOrderByAggregateInput
    _sum?: ProductionStaffSumOrderByAggregateInput
  }

  export type ProductionStaffScalarWhereWithAggregatesInput = {
    AND?: ProductionStaffScalarWhereWithAggregatesInput | ProductionStaffScalarWhereWithAggregatesInput[]
    OR?: ProductionStaffScalarWhereWithAggregatesInput[]
    NOT?: ProductionStaffScalarWhereWithAggregatesInput | ProductionStaffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionStaff"> | number
    fullName?: StringWithAggregatesFilter<"ProductionStaff"> | string
    phone?: StringNullableWithAggregatesFilter<"ProductionStaff"> | string | null
    userId?: IntWithAggregatesFilter<"ProductionStaff"> | number
    isActive?: BoolWithAggregatesFilter<"ProductionStaff"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductionStaff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionStaff"> | Date | string
  }

  export type ProductionJournalWhereInput = {
    AND?: ProductionJournalWhereInput | ProductionJournalWhereInput[]
    OR?: ProductionJournalWhereInput[]
    NOT?: ProductionJournalWhereInput | ProductionJournalWhereInput[]
    id?: IntFilter<"ProductionJournal"> | number
    productionDate?: DateTimeFilter<"ProductionJournal"> | Date | string
    staffId?: IntFilter<"ProductionJournal"> | number
    status?: StringFilter<"ProductionJournal"> | string
    createdAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    createdBy?: StringFilter<"ProductionJournal"> | string
    updatedBy?: StringNullableFilter<"ProductionJournal"> | string | null
    staff?: XOR<ProductionStaffScalarRelationFilter, ProductionStaffWhereInput>
    items?: ProductionItemListRelationFilter
  }

  export type ProductionJournalOrderByWithRelationInput = {
    id?: SortOrder
    productionDate?: SortOrder
    staffId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    staff?: ProductionStaffOrderByWithRelationInput
    items?: ProductionItemOrderByRelationAggregateInput
  }

  export type ProductionJournalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productionDate_staffId?: ProductionJournalProductionDateStaffIdCompoundUniqueInput
    AND?: ProductionJournalWhereInput | ProductionJournalWhereInput[]
    OR?: ProductionJournalWhereInput[]
    NOT?: ProductionJournalWhereInput | ProductionJournalWhereInput[]
    productionDate?: DateTimeFilter<"ProductionJournal"> | Date | string
    staffId?: IntFilter<"ProductionJournal"> | number
    status?: StringFilter<"ProductionJournal"> | string
    createdAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    createdBy?: StringFilter<"ProductionJournal"> | string
    updatedBy?: StringNullableFilter<"ProductionJournal"> | string | null
    staff?: XOR<ProductionStaffScalarRelationFilter, ProductionStaffWhereInput>
    items?: ProductionItemListRelationFilter
  }, "id" | "productionDate_staffId">

  export type ProductionJournalOrderByWithAggregationInput = {
    id?: SortOrder
    productionDate?: SortOrder
    staffId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ProductionJournalCountOrderByAggregateInput
    _avg?: ProductionJournalAvgOrderByAggregateInput
    _max?: ProductionJournalMaxOrderByAggregateInput
    _min?: ProductionJournalMinOrderByAggregateInput
    _sum?: ProductionJournalSumOrderByAggregateInput
  }

  export type ProductionJournalScalarWhereWithAggregatesInput = {
    AND?: ProductionJournalScalarWhereWithAggregatesInput | ProductionJournalScalarWhereWithAggregatesInput[]
    OR?: ProductionJournalScalarWhereWithAggregatesInput[]
    NOT?: ProductionJournalScalarWhereWithAggregatesInput | ProductionJournalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionJournal"> | number
    productionDate?: DateTimeWithAggregatesFilter<"ProductionJournal"> | Date | string
    staffId?: IntWithAggregatesFilter<"ProductionJournal"> | number
    status?: StringWithAggregatesFilter<"ProductionJournal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductionJournal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionJournal"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ProductionJournal"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"ProductionJournal"> | string | null
  }

  export type ProductionItemWhereInput = {
    AND?: ProductionItemWhereInput | ProductionItemWhereInput[]
    OR?: ProductionItemWhereInput[]
    NOT?: ProductionItemWhereInput | ProductionItemWhereInput[]
    id?: IntFilter<"ProductionItem"> | number
    journalId?: IntFilter<"ProductionItem"> | number
    productId?: IntNullableFilter<"ProductionItem"> | number | null
    productName?: StringNullableFilter<"ProductionItem"> | string | null
    state?: StringFilter<"ProductionItem"> | string
    sortOrder?: IntFilter<"ProductionItem"> | number
    isDeleted?: BoolFilter<"ProductionItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"ProductionItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"ProductionItem"> | string | null
    createdAt?: DateTimeFilter<"ProductionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionItem"> | Date | string
    createdBy?: StringFilter<"ProductionItem"> | string
    updatedBy?: StringNullableFilter<"ProductionItem"> | string | null
    journal?: XOR<ProductionJournalScalarRelationFilter, ProductionJournalWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    values?: ProductionItemValueListRelationFilter
  }

  export type ProductionItemOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    state?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    journal?: ProductionJournalOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    values?: ProductionItemValueOrderByRelationAggregateInput
  }

  export type ProductionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductionItemWhereInput | ProductionItemWhereInput[]
    OR?: ProductionItemWhereInput[]
    NOT?: ProductionItemWhereInput | ProductionItemWhereInput[]
    journalId?: IntFilter<"ProductionItem"> | number
    productId?: IntNullableFilter<"ProductionItem"> | number | null
    productName?: StringNullableFilter<"ProductionItem"> | string | null
    state?: StringFilter<"ProductionItem"> | string
    sortOrder?: IntFilter<"ProductionItem"> | number
    isDeleted?: BoolFilter<"ProductionItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"ProductionItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"ProductionItem"> | string | null
    createdAt?: DateTimeFilter<"ProductionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionItem"> | Date | string
    createdBy?: StringFilter<"ProductionItem"> | string
    updatedBy?: StringNullableFilter<"ProductionItem"> | string | null
    journal?: XOR<ProductionJournalScalarRelationFilter, ProductionJournalWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    values?: ProductionItemValueListRelationFilter
  }, "id">

  export type ProductionItemOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    state?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ProductionItemCountOrderByAggregateInput
    _avg?: ProductionItemAvgOrderByAggregateInput
    _max?: ProductionItemMaxOrderByAggregateInput
    _min?: ProductionItemMinOrderByAggregateInput
    _sum?: ProductionItemSumOrderByAggregateInput
  }

  export type ProductionItemScalarWhereWithAggregatesInput = {
    AND?: ProductionItemScalarWhereWithAggregatesInput | ProductionItemScalarWhereWithAggregatesInput[]
    OR?: ProductionItemScalarWhereWithAggregatesInput[]
    NOT?: ProductionItemScalarWhereWithAggregatesInput | ProductionItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionItem"> | number
    journalId?: IntWithAggregatesFilter<"ProductionItem"> | number
    productId?: IntNullableWithAggregatesFilter<"ProductionItem"> | number | null
    productName?: StringNullableWithAggregatesFilter<"ProductionItem"> | string | null
    state?: StringWithAggregatesFilter<"ProductionItem"> | string
    sortOrder?: IntWithAggregatesFilter<"ProductionItem"> | number
    isDeleted?: BoolWithAggregatesFilter<"ProductionItem"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ProductionItem"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"ProductionItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductionItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionItem"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ProductionItem"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"ProductionItem"> | string | null
  }

  export type ProductionItemValueWhereInput = {
    AND?: ProductionItemValueWhereInput | ProductionItemValueWhereInput[]
    OR?: ProductionItemValueWhereInput[]
    NOT?: ProductionItemValueWhereInput | ProductionItemValueWhereInput[]
    id?: IntFilter<"ProductionItemValue"> | number
    productionItemId?: IntFilter<"ProductionItemValue"> | number
    fieldKey?: StringFilter<"ProductionItemValue"> | string
    fieldValue?: StringNullableFilter<"ProductionItemValue"> | string | null
    updatedAt?: DateTimeFilter<"ProductionItemValue"> | Date | string
    updatedBy?: StringNullableFilter<"ProductionItemValue"> | string | null
    productionItem?: XOR<ProductionItemScalarRelationFilter, ProductionItemWhereInput>
  }

  export type ProductionItemValueOrderByWithRelationInput = {
    id?: SortOrder
    productionItemId?: SortOrder
    fieldKey?: SortOrder
    fieldValue?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    productionItem?: ProductionItemOrderByWithRelationInput
  }

  export type ProductionItemValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productionItemId_fieldKey?: ProductionItemValueProductionItemIdFieldKeyCompoundUniqueInput
    AND?: ProductionItemValueWhereInput | ProductionItemValueWhereInput[]
    OR?: ProductionItemValueWhereInput[]
    NOT?: ProductionItemValueWhereInput | ProductionItemValueWhereInput[]
    productionItemId?: IntFilter<"ProductionItemValue"> | number
    fieldKey?: StringFilter<"ProductionItemValue"> | string
    fieldValue?: StringNullableFilter<"ProductionItemValue"> | string | null
    updatedAt?: DateTimeFilter<"ProductionItemValue"> | Date | string
    updatedBy?: StringNullableFilter<"ProductionItemValue"> | string | null
    productionItem?: XOR<ProductionItemScalarRelationFilter, ProductionItemWhereInput>
  }, "id" | "productionItemId_fieldKey">

  export type ProductionItemValueOrderByWithAggregationInput = {
    id?: SortOrder
    productionItemId?: SortOrder
    fieldKey?: SortOrder
    fieldValue?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ProductionItemValueCountOrderByAggregateInput
    _avg?: ProductionItemValueAvgOrderByAggregateInput
    _max?: ProductionItemValueMaxOrderByAggregateInput
    _min?: ProductionItemValueMinOrderByAggregateInput
    _sum?: ProductionItemValueSumOrderByAggregateInput
  }

  export type ProductionItemValueScalarWhereWithAggregatesInput = {
    AND?: ProductionItemValueScalarWhereWithAggregatesInput | ProductionItemValueScalarWhereWithAggregatesInput[]
    OR?: ProductionItemValueScalarWhereWithAggregatesInput[]
    NOT?: ProductionItemValueScalarWhereWithAggregatesInput | ProductionItemValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionItemValue"> | number
    productionItemId?: IntWithAggregatesFilter<"ProductionItemValue"> | number
    fieldKey?: StringWithAggregatesFilter<"ProductionItemValue"> | string
    fieldValue?: StringNullableWithAggregatesFilter<"ProductionItemValue"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionItemValue"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"ProductionItemValue"> | string | null
  }

  export type PurchasePriceListWhereInput = {
    AND?: PurchasePriceListWhereInput | PurchasePriceListWhereInput[]
    OR?: PurchasePriceListWhereInput[]
    NOT?: PurchasePriceListWhereInput | PurchasePriceListWhereInput[]
    id?: IntFilter<"PurchasePriceList"> | number
    date?: DateTimeFilter<"PurchasePriceList"> | Date | string
    name?: StringNullableFilter<"PurchasePriceList"> | string | null
    isActive?: BoolFilter<"PurchasePriceList"> | boolean
    createdAt?: DateTimeFilter<"PurchasePriceList"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasePriceList"> | Date | string
    createdBy?: StringFilter<"PurchasePriceList"> | string
    updatedBy?: StringNullableFilter<"PurchasePriceList"> | string | null
    suppliers?: PurchasePriceListSupplierListRelationFilter
    items?: PurchasePriceItemListRelationFilter
  }

  export type PurchasePriceListOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    suppliers?: PurchasePriceListSupplierOrderByRelationAggregateInput
    items?: PurchasePriceItemOrderByRelationAggregateInput
  }

  export type PurchasePriceListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchasePriceListWhereInput | PurchasePriceListWhereInput[]
    OR?: PurchasePriceListWhereInput[]
    NOT?: PurchasePriceListWhereInput | PurchasePriceListWhereInput[]
    date?: DateTimeFilter<"PurchasePriceList"> | Date | string
    name?: StringNullableFilter<"PurchasePriceList"> | string | null
    isActive?: BoolFilter<"PurchasePriceList"> | boolean
    createdAt?: DateTimeFilter<"PurchasePriceList"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasePriceList"> | Date | string
    createdBy?: StringFilter<"PurchasePriceList"> | string
    updatedBy?: StringNullableFilter<"PurchasePriceList"> | string | null
    suppliers?: PurchasePriceListSupplierListRelationFilter
    items?: PurchasePriceItemListRelationFilter
  }, "id">

  export type PurchasePriceListOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: PurchasePriceListCountOrderByAggregateInput
    _avg?: PurchasePriceListAvgOrderByAggregateInput
    _max?: PurchasePriceListMaxOrderByAggregateInput
    _min?: PurchasePriceListMinOrderByAggregateInput
    _sum?: PurchasePriceListSumOrderByAggregateInput
  }

  export type PurchasePriceListScalarWhereWithAggregatesInput = {
    AND?: PurchasePriceListScalarWhereWithAggregatesInput | PurchasePriceListScalarWhereWithAggregatesInput[]
    OR?: PurchasePriceListScalarWhereWithAggregatesInput[]
    NOT?: PurchasePriceListScalarWhereWithAggregatesInput | PurchasePriceListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchasePriceList"> | number
    date?: DateTimeWithAggregatesFilter<"PurchasePriceList"> | Date | string
    name?: StringNullableWithAggregatesFilter<"PurchasePriceList"> | string | null
    isActive?: BoolWithAggregatesFilter<"PurchasePriceList"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PurchasePriceList"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchasePriceList"> | Date | string
    createdBy?: StringWithAggregatesFilter<"PurchasePriceList"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"PurchasePriceList"> | string | null
  }

  export type PurchasePriceListSupplierWhereInput = {
    AND?: PurchasePriceListSupplierWhereInput | PurchasePriceListSupplierWhereInput[]
    OR?: PurchasePriceListSupplierWhereInput[]
    NOT?: PurchasePriceListSupplierWhereInput | PurchasePriceListSupplierWhereInput[]
    id?: IntFilter<"PurchasePriceListSupplier"> | number
    priceListId?: IntFilter<"PurchasePriceListSupplier"> | number
    supplierId?: IntFilter<"PurchasePriceListSupplier"> | number
    primaryMmlId?: IntNullableFilter<"PurchasePriceListSupplier"> | number | null
    createdAt?: DateTimeFilter<"PurchasePriceListSupplier"> | Date | string
    priceList?: XOR<PurchasePriceListScalarRelationFilter, PurchasePriceListWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    primaryMml?: XOR<ProductionMmlNullableScalarRelationFilter, ProductionMmlWhereInput> | null
  }

  export type PurchasePriceListSupplierOrderByWithRelationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    priceList?: PurchasePriceListOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    primaryMml?: ProductionMmlOrderByWithRelationInput
  }

  export type PurchasePriceListSupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    priceListId_supplierId?: PurchasePriceListSupplierPriceListIdSupplierIdCompoundUniqueInput
    AND?: PurchasePriceListSupplierWhereInput | PurchasePriceListSupplierWhereInput[]
    OR?: PurchasePriceListSupplierWhereInput[]
    NOT?: PurchasePriceListSupplierWhereInput | PurchasePriceListSupplierWhereInput[]
    priceListId?: IntFilter<"PurchasePriceListSupplier"> | number
    supplierId?: IntFilter<"PurchasePriceListSupplier"> | number
    primaryMmlId?: IntNullableFilter<"PurchasePriceListSupplier"> | number | null
    createdAt?: DateTimeFilter<"PurchasePriceListSupplier"> | Date | string
    priceList?: XOR<PurchasePriceListScalarRelationFilter, PurchasePriceListWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    primaryMml?: XOR<ProductionMmlNullableScalarRelationFilter, ProductionMmlWhereInput> | null
  }, "id" | "priceListId_supplierId">

  export type PurchasePriceListSupplierOrderByWithAggregationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PurchasePriceListSupplierCountOrderByAggregateInput
    _avg?: PurchasePriceListSupplierAvgOrderByAggregateInput
    _max?: PurchasePriceListSupplierMaxOrderByAggregateInput
    _min?: PurchasePriceListSupplierMinOrderByAggregateInput
    _sum?: PurchasePriceListSupplierSumOrderByAggregateInput
  }

  export type PurchasePriceListSupplierScalarWhereWithAggregatesInput = {
    AND?: PurchasePriceListSupplierScalarWhereWithAggregatesInput | PurchasePriceListSupplierScalarWhereWithAggregatesInput[]
    OR?: PurchasePriceListSupplierScalarWhereWithAggregatesInput[]
    NOT?: PurchasePriceListSupplierScalarWhereWithAggregatesInput | PurchasePriceListSupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchasePriceListSupplier"> | number
    priceListId?: IntWithAggregatesFilter<"PurchasePriceListSupplier"> | number
    supplierId?: IntWithAggregatesFilter<"PurchasePriceListSupplier"> | number
    primaryMmlId?: IntNullableWithAggregatesFilter<"PurchasePriceListSupplier"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchasePriceListSupplier"> | Date | string
  }

  export type PurchasePriceItemWhereInput = {
    AND?: PurchasePriceItemWhereInput | PurchasePriceItemWhereInput[]
    OR?: PurchasePriceItemWhereInput[]
    NOT?: PurchasePriceItemWhereInput | PurchasePriceItemWhereInput[]
    id?: IntFilter<"PurchasePriceItem"> | number
    priceListId?: IntFilter<"PurchasePriceItem"> | number
    supplierId?: IntFilter<"PurchasePriceItem"> | number
    productId?: IntFilter<"PurchasePriceItem"> | number
    purchasePrice?: DecimalFilter<"PurchasePriceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
    priceList?: XOR<PurchasePriceListScalarRelationFilter, PurchasePriceListWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type PurchasePriceItemOrderByWithRelationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    priceList?: PurchasePriceListOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PurchasePriceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    priceListId_supplierId_productId?: PurchasePriceItemPriceListIdSupplierIdProductIdCompoundUniqueInput
    AND?: PurchasePriceItemWhereInput | PurchasePriceItemWhereInput[]
    OR?: PurchasePriceItemWhereInput[]
    NOT?: PurchasePriceItemWhereInput | PurchasePriceItemWhereInput[]
    priceListId?: IntFilter<"PurchasePriceItem"> | number
    supplierId?: IntFilter<"PurchasePriceItem"> | number
    productId?: IntFilter<"PurchasePriceItem"> | number
    purchasePrice?: DecimalFilter<"PurchasePriceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
    priceList?: XOR<PurchasePriceListScalarRelationFilter, PurchasePriceListWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "priceListId_supplierId_productId">

  export type PurchasePriceItemOrderByWithAggregationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchasePriceItemCountOrderByAggregateInput
    _avg?: PurchasePriceItemAvgOrderByAggregateInput
    _max?: PurchasePriceItemMaxOrderByAggregateInput
    _min?: PurchasePriceItemMinOrderByAggregateInput
    _sum?: PurchasePriceItemSumOrderByAggregateInput
  }

  export type PurchasePriceItemScalarWhereWithAggregatesInput = {
    AND?: PurchasePriceItemScalarWhereWithAggregatesInput | PurchasePriceItemScalarWhereWithAggregatesInput[]
    OR?: PurchasePriceItemScalarWhereWithAggregatesInput[]
    NOT?: PurchasePriceItemScalarWhereWithAggregatesInput | PurchasePriceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchasePriceItem"> | number
    priceListId?: IntWithAggregatesFilter<"PurchasePriceItem"> | number
    supplierId?: IntWithAggregatesFilter<"PurchasePriceItem"> | number
    productId?: IntWithAggregatesFilter<"PurchasePriceItem"> | number
    purchasePrice?: DecimalWithAggregatesFilter<"PurchasePriceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"PurchasePriceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchasePriceItem"> | Date | string
  }

  export type SalesPriceListWhereInput = {
    AND?: SalesPriceListWhereInput | SalesPriceListWhereInput[]
    OR?: SalesPriceListWhereInput[]
    NOT?: SalesPriceListWhereInput | SalesPriceListWhereInput[]
    id?: IntFilter<"SalesPriceList"> | number
    listType?: StringFilter<"SalesPriceList"> | string
    customerId?: IntNullableFilter<"SalesPriceList"> | number | null
    title?: StringNullableFilter<"SalesPriceList"> | string | null
    effectiveDate?: DateTimeFilter<"SalesPriceList"> | Date | string
    status?: StringFilter<"SalesPriceList"> | string
    isCurrent?: BoolFilter<"SalesPriceList"> | boolean
    isHidden?: BoolFilter<"SalesPriceList"> | boolean
    createdAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    createdBy?: StringFilter<"SalesPriceList"> | string
    updatedBy?: StringNullableFilter<"SalesPriceList"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: SalesPriceItemListRelationFilter
  }

  export type SalesPriceListOrderByWithRelationInput = {
    id?: SortOrder
    listType?: SortOrder
    customerId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    status?: SortOrder
    isCurrent?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    items?: SalesPriceItemOrderByRelationAggregateInput
  }

  export type SalesPriceListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalesPriceListWhereInput | SalesPriceListWhereInput[]
    OR?: SalesPriceListWhereInput[]
    NOT?: SalesPriceListWhereInput | SalesPriceListWhereInput[]
    listType?: StringFilter<"SalesPriceList"> | string
    customerId?: IntNullableFilter<"SalesPriceList"> | number | null
    title?: StringNullableFilter<"SalesPriceList"> | string | null
    effectiveDate?: DateTimeFilter<"SalesPriceList"> | Date | string
    status?: StringFilter<"SalesPriceList"> | string
    isCurrent?: BoolFilter<"SalesPriceList"> | boolean
    isHidden?: BoolFilter<"SalesPriceList"> | boolean
    createdAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    createdBy?: StringFilter<"SalesPriceList"> | string
    updatedBy?: StringNullableFilter<"SalesPriceList"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: SalesPriceItemListRelationFilter
  }, "id">

  export type SalesPriceListOrderByWithAggregationInput = {
    id?: SortOrder
    listType?: SortOrder
    customerId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    status?: SortOrder
    isCurrent?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SalesPriceListCountOrderByAggregateInput
    _avg?: SalesPriceListAvgOrderByAggregateInput
    _max?: SalesPriceListMaxOrderByAggregateInput
    _min?: SalesPriceListMinOrderByAggregateInput
    _sum?: SalesPriceListSumOrderByAggregateInput
  }

  export type SalesPriceListScalarWhereWithAggregatesInput = {
    AND?: SalesPriceListScalarWhereWithAggregatesInput | SalesPriceListScalarWhereWithAggregatesInput[]
    OR?: SalesPriceListScalarWhereWithAggregatesInput[]
    NOT?: SalesPriceListScalarWhereWithAggregatesInput | SalesPriceListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesPriceList"> | number
    listType?: StringWithAggregatesFilter<"SalesPriceList"> | string
    customerId?: IntNullableWithAggregatesFilter<"SalesPriceList"> | number | null
    title?: StringNullableWithAggregatesFilter<"SalesPriceList"> | string | null
    effectiveDate?: DateTimeWithAggregatesFilter<"SalesPriceList"> | Date | string
    status?: StringWithAggregatesFilter<"SalesPriceList"> | string
    isCurrent?: BoolWithAggregatesFilter<"SalesPriceList"> | boolean
    isHidden?: BoolWithAggregatesFilter<"SalesPriceList"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SalesPriceList"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesPriceList"> | Date | string
    createdBy?: StringWithAggregatesFilter<"SalesPriceList"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"SalesPriceList"> | string | null
  }

  export type SalesPriceItemWhereInput = {
    AND?: SalesPriceItemWhereInput | SalesPriceItemWhereInput[]
    OR?: SalesPriceItemWhereInput[]
    NOT?: SalesPriceItemWhereInput | SalesPriceItemWhereInput[]
    id?: IntFilter<"SalesPriceItem"> | number
    priceListId?: IntFilter<"SalesPriceItem"> | number
    productId?: IntFilter<"SalesPriceItem"> | number
    salePrice?: DecimalFilter<"SalesPriceItem"> | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFilter<"SalesPriceItem"> | Date | string
    createdAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedBy?: StringNullableFilter<"SalesPriceItem"> | string | null
    priceList?: XOR<SalesPriceListScalarRelationFilter, SalesPriceListWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type SalesPriceItemOrderByWithRelationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
    rowDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    priceList?: SalesPriceListOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type SalesPriceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    priceListId_productId?: SalesPriceItemPriceListIdProductIdCompoundUniqueInput
    AND?: SalesPriceItemWhereInput | SalesPriceItemWhereInput[]
    OR?: SalesPriceItemWhereInput[]
    NOT?: SalesPriceItemWhereInput | SalesPriceItemWhereInput[]
    priceListId?: IntFilter<"SalesPriceItem"> | number
    productId?: IntFilter<"SalesPriceItem"> | number
    salePrice?: DecimalFilter<"SalesPriceItem"> | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFilter<"SalesPriceItem"> | Date | string
    createdAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedBy?: StringNullableFilter<"SalesPriceItem"> | string | null
    priceList?: XOR<SalesPriceListScalarRelationFilter, SalesPriceListWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "priceListId_productId">

  export type SalesPriceItemOrderByWithAggregationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
    rowDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SalesPriceItemCountOrderByAggregateInput
    _avg?: SalesPriceItemAvgOrderByAggregateInput
    _max?: SalesPriceItemMaxOrderByAggregateInput
    _min?: SalesPriceItemMinOrderByAggregateInput
    _sum?: SalesPriceItemSumOrderByAggregateInput
  }

  export type SalesPriceItemScalarWhereWithAggregatesInput = {
    AND?: SalesPriceItemScalarWhereWithAggregatesInput | SalesPriceItemScalarWhereWithAggregatesInput[]
    OR?: SalesPriceItemScalarWhereWithAggregatesInput[]
    NOT?: SalesPriceItemScalarWhereWithAggregatesInput | SalesPriceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesPriceItem"> | number
    priceListId?: IntWithAggregatesFilter<"SalesPriceItem"> | number
    productId?: IntWithAggregatesFilter<"SalesPriceItem"> | number
    salePrice?: DecimalWithAggregatesFilter<"SalesPriceItem"> | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeWithAggregatesFilter<"SalesPriceItem"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SalesPriceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesPriceItem"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"SalesPriceItem"> | string | null
  }

  export type ProductionMmlWhereInput = {
    AND?: ProductionMmlWhereInput | ProductionMmlWhereInput[]
    OR?: ProductionMmlWhereInput[]
    NOT?: ProductionMmlWhereInput | ProductionMmlWhereInput[]
    id?: IntFilter<"ProductionMml"> | number
    productId?: IntFilter<"ProductionMml"> | number
    createdBy?: IntFilter<"ProductionMml"> | number
    isLocked?: BoolFilter<"ProductionMml"> | boolean
    createdAt?: DateTimeFilter<"ProductionMml"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMml"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    nodes?: ProductionMmlNodeListRelationFilter
    runs?: ProductionRunListRelationFilter
    suppliersWithPrimaryMml?: SupplierListRelationFilter
    priceListSuppliers?: PurchasePriceListSupplierListRelationFilter
  }

  export type ProductionMmlOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    nodes?: ProductionMmlNodeOrderByRelationAggregateInput
    runs?: ProductionRunOrderByRelationAggregateInput
    suppliersWithPrimaryMml?: SupplierOrderByRelationAggregateInput
    priceListSuppliers?: PurchasePriceListSupplierOrderByRelationAggregateInput
  }

  export type ProductionMmlWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productId?: number
    AND?: ProductionMmlWhereInput | ProductionMmlWhereInput[]
    OR?: ProductionMmlWhereInput[]
    NOT?: ProductionMmlWhereInput | ProductionMmlWhereInput[]
    createdBy?: IntFilter<"ProductionMml"> | number
    isLocked?: BoolFilter<"ProductionMml"> | boolean
    createdAt?: DateTimeFilter<"ProductionMml"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMml"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    nodes?: ProductionMmlNodeListRelationFilter
    runs?: ProductionRunListRelationFilter
    suppliersWithPrimaryMml?: SupplierListRelationFilter
    priceListSuppliers?: PurchasePriceListSupplierListRelationFilter
  }, "id" | "productId">

  export type ProductionMmlOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionMmlCountOrderByAggregateInput
    _avg?: ProductionMmlAvgOrderByAggregateInput
    _max?: ProductionMmlMaxOrderByAggregateInput
    _min?: ProductionMmlMinOrderByAggregateInput
    _sum?: ProductionMmlSumOrderByAggregateInput
  }

  export type ProductionMmlScalarWhereWithAggregatesInput = {
    AND?: ProductionMmlScalarWhereWithAggregatesInput | ProductionMmlScalarWhereWithAggregatesInput[]
    OR?: ProductionMmlScalarWhereWithAggregatesInput[]
    NOT?: ProductionMmlScalarWhereWithAggregatesInput | ProductionMmlScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionMml"> | number
    productId?: IntWithAggregatesFilter<"ProductionMml"> | number
    createdBy?: IntWithAggregatesFilter<"ProductionMml"> | number
    isLocked?: BoolWithAggregatesFilter<"ProductionMml"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductionMml"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionMml"> | Date | string
  }

  export type ProductionMmlNodeWhereInput = {
    AND?: ProductionMmlNodeWhereInput | ProductionMmlNodeWhereInput[]
    OR?: ProductionMmlNodeWhereInput[]
    NOT?: ProductionMmlNodeWhereInput | ProductionMmlNodeWhereInput[]
    id?: IntFilter<"ProductionMmlNode"> | number
    mmlId?: IntFilter<"ProductionMmlNode"> | number
    parentNodeId?: IntNullableFilter<"ProductionMmlNode"> | number | null
    productId?: IntFilter<"ProductionMmlNode"> | number
    sortOrder?: IntFilter<"ProductionMmlNode"> | number
    createdAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
    mml?: XOR<ProductionMmlScalarRelationFilter, ProductionMmlWhereInput>
    parentNode?: XOR<ProductionMmlNodeNullableScalarRelationFilter, ProductionMmlNodeWhereInput> | null
    children?: ProductionMmlNodeListRelationFilter
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    runValues?: ProductionRunValueListRelationFilter
  }

  export type ProductionMmlNodeOrderByWithRelationInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrderInput | SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mml?: ProductionMmlOrderByWithRelationInput
    parentNode?: ProductionMmlNodeOrderByWithRelationInput
    children?: ProductionMmlNodeOrderByRelationAggregateInput
    product?: ProductOrderByWithRelationInput
    runValues?: ProductionRunValueOrderByRelationAggregateInput
  }

  export type ProductionMmlNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductionMmlNodeWhereInput | ProductionMmlNodeWhereInput[]
    OR?: ProductionMmlNodeWhereInput[]
    NOT?: ProductionMmlNodeWhereInput | ProductionMmlNodeWhereInput[]
    mmlId?: IntFilter<"ProductionMmlNode"> | number
    parentNodeId?: IntNullableFilter<"ProductionMmlNode"> | number | null
    productId?: IntFilter<"ProductionMmlNode"> | number
    sortOrder?: IntFilter<"ProductionMmlNode"> | number
    createdAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
    mml?: XOR<ProductionMmlScalarRelationFilter, ProductionMmlWhereInput>
    parentNode?: XOR<ProductionMmlNodeNullableScalarRelationFilter, ProductionMmlNodeWhereInput> | null
    children?: ProductionMmlNodeListRelationFilter
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    runValues?: ProductionRunValueListRelationFilter
  }, "id">

  export type ProductionMmlNodeOrderByWithAggregationInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrderInput | SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionMmlNodeCountOrderByAggregateInput
    _avg?: ProductionMmlNodeAvgOrderByAggregateInput
    _max?: ProductionMmlNodeMaxOrderByAggregateInput
    _min?: ProductionMmlNodeMinOrderByAggregateInput
    _sum?: ProductionMmlNodeSumOrderByAggregateInput
  }

  export type ProductionMmlNodeScalarWhereWithAggregatesInput = {
    AND?: ProductionMmlNodeScalarWhereWithAggregatesInput | ProductionMmlNodeScalarWhereWithAggregatesInput[]
    OR?: ProductionMmlNodeScalarWhereWithAggregatesInput[]
    NOT?: ProductionMmlNodeScalarWhereWithAggregatesInput | ProductionMmlNodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionMmlNode"> | number
    mmlId?: IntWithAggregatesFilter<"ProductionMmlNode"> | number
    parentNodeId?: IntNullableWithAggregatesFilter<"ProductionMmlNode"> | number | null
    productId?: IntWithAggregatesFilter<"ProductionMmlNode"> | number
    sortOrder?: IntWithAggregatesFilter<"ProductionMmlNode"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductionMmlNode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionMmlNode"> | Date | string
  }

  export type ProductionRunWhereInput = {
    AND?: ProductionRunWhereInput | ProductionRunWhereInput[]
    OR?: ProductionRunWhereInput[]
    NOT?: ProductionRunWhereInput | ProductionRunWhereInput[]
    id?: IntFilter<"ProductionRun"> | number
    productId?: IntFilter<"ProductionRun"> | number
    mmlId?: IntFilter<"ProductionRun"> | number
    userId?: IntFilter<"ProductionRun"> | number
    isLocked?: BoolFilter<"ProductionRun"> | boolean
    createdAt?: DateTimeFilter<"ProductionRun"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRun"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    mml?: XOR<ProductionMmlScalarRelationFilter, ProductionMmlWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    values?: ProductionRunValueListRelationFilter
  }

  export type ProductionRunOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    mml?: ProductionMmlOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    values?: ProductionRunValueOrderByRelationAggregateInput
  }

  export type ProductionRunWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductionRunWhereInput | ProductionRunWhereInput[]
    OR?: ProductionRunWhereInput[]
    NOT?: ProductionRunWhereInput | ProductionRunWhereInput[]
    productId?: IntFilter<"ProductionRun"> | number
    mmlId?: IntFilter<"ProductionRun"> | number
    userId?: IntFilter<"ProductionRun"> | number
    isLocked?: BoolFilter<"ProductionRun"> | boolean
    createdAt?: DateTimeFilter<"ProductionRun"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRun"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    mml?: XOR<ProductionMmlScalarRelationFilter, ProductionMmlWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    values?: ProductionRunValueListRelationFilter
  }, "id">

  export type ProductionRunOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionRunCountOrderByAggregateInput
    _avg?: ProductionRunAvgOrderByAggregateInput
    _max?: ProductionRunMaxOrderByAggregateInput
    _min?: ProductionRunMinOrderByAggregateInput
    _sum?: ProductionRunSumOrderByAggregateInput
  }

  export type ProductionRunScalarWhereWithAggregatesInput = {
    AND?: ProductionRunScalarWhereWithAggregatesInput | ProductionRunScalarWhereWithAggregatesInput[]
    OR?: ProductionRunScalarWhereWithAggregatesInput[]
    NOT?: ProductionRunScalarWhereWithAggregatesInput | ProductionRunScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionRun"> | number
    productId?: IntWithAggregatesFilter<"ProductionRun"> | number
    mmlId?: IntWithAggregatesFilter<"ProductionRun"> | number
    userId?: IntWithAggregatesFilter<"ProductionRun"> | number
    isLocked?: BoolWithAggregatesFilter<"ProductionRun"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductionRun"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionRun"> | Date | string
  }

  export type ProductionRunValueWhereInput = {
    AND?: ProductionRunValueWhereInput | ProductionRunValueWhereInput[]
    OR?: ProductionRunValueWhereInput[]
    NOT?: ProductionRunValueWhereInput | ProductionRunValueWhereInput[]
    id?: IntFilter<"ProductionRunValue"> | number
    productionRunId?: IntFilter<"ProductionRunValue"> | number
    mmlNodeId?: IntFilter<"ProductionRunValue"> | number
    value?: DecimalNullableFilter<"ProductionRunValue"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
    run?: XOR<ProductionRunScalarRelationFilter, ProductionRunWhereInput>
    node?: XOR<ProductionMmlNodeScalarRelationFilter, ProductionMmlNodeWhereInput>
  }

  export type ProductionRunValueOrderByWithRelationInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    run?: ProductionRunOrderByWithRelationInput
    node?: ProductionMmlNodeOrderByWithRelationInput
  }

  export type ProductionRunValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productionRunId_mmlNodeId?: ProductionRunValueProductionRunIdMmlNodeIdCompoundUniqueInput
    AND?: ProductionRunValueWhereInput | ProductionRunValueWhereInput[]
    OR?: ProductionRunValueWhereInput[]
    NOT?: ProductionRunValueWhereInput | ProductionRunValueWhereInput[]
    productionRunId?: IntFilter<"ProductionRunValue"> | number
    mmlNodeId?: IntFilter<"ProductionRunValue"> | number
    value?: DecimalNullableFilter<"ProductionRunValue"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
    run?: XOR<ProductionRunScalarRelationFilter, ProductionRunWhereInput>
    node?: XOR<ProductionMmlNodeScalarRelationFilter, ProductionMmlNodeWhereInput>
  }, "id" | "productionRunId_mmlNodeId">

  export type ProductionRunValueOrderByWithAggregationInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionRunValueCountOrderByAggregateInput
    _avg?: ProductionRunValueAvgOrderByAggregateInput
    _max?: ProductionRunValueMaxOrderByAggregateInput
    _min?: ProductionRunValueMinOrderByAggregateInput
    _sum?: ProductionRunValueSumOrderByAggregateInput
  }

  export type ProductionRunValueScalarWhereWithAggregatesInput = {
    AND?: ProductionRunValueScalarWhereWithAggregatesInput | ProductionRunValueScalarWhereWithAggregatesInput[]
    OR?: ProductionRunValueScalarWhereWithAggregatesInput[]
    NOT?: ProductionRunValueScalarWhereWithAggregatesInput | ProductionRunValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionRunValue"> | number
    productionRunId?: IntWithAggregatesFilter<"ProductionRunValue"> | number
    mmlNodeId?: IntWithAggregatesFilter<"ProductionRunValue"> | number
    value?: DecimalNullableWithAggregatesFilter<"ProductionRunValue"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductionRunValue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionRunValue"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffUncheckedCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUncheckedUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistrictCreateInput = {
    code: string
    name: string
    customers?: CustomerCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    customers?: CustomerUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customers?: CustomerUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customers?: CustomerUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictCreateManyInput = {
    id?: number
    code: string
    name: string
  }

  export type DistrictUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DistrictUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerCreateInput = {
    code: string
    name: string
    phone?: string | null
    customers?: CustomerCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    phone?: string | null
    customers?: CustomerUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ManagerCreateManyInput = {
    id?: number
    code: string
    name: string
    phone?: string | null
  }

  export type ManagerUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: DistrictCreateNestedOneWithoutCustomersInput
    manager?: ManagerCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneWithoutCustomersNestedInput
    manager?: ManagerUpdateOneWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierProductCreateInput = {
    product: ProductCreateNestedOneWithoutSuppliersInput
    supplier: SupplierCreateNestedOneWithoutProductsInput
  }

  export type SupplierProductUncheckedCreateInput = {
    supplierId: number
    productId: number
  }

  export type SupplierProductUpdateInput = {
    product?: ProductUpdateOneRequiredWithoutSuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutProductsNestedInput
  }

  export type SupplierProductUncheckedUpdateInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierProductCreateManyInput = {
    supplierId: number
    productId: number
  }

  export type SupplierProductUpdateManyMutationInput = {

  }

  export type SupplierProductUncheckedUpdateManyInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderCreateInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    expeditor?: ExpeditorCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    expeditor?: ExpeditorUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentCreateInput = {
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutAttachmentsInput
  }

  export type OrderAttachmentUncheckedCreateInput = {
    id?: number
    orderId: number
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
  }

  export type OrderAttachmentUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type OrderAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentCreateManyInput = {
    id?: number
    orderId: number
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
  }

  export type OrderAttachmentUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type OrderItemUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ExpeditorCreateInput = {
    name: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutExpeditorInput
  }

  export type ExpeditorUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutExpeditorInput
  }

  export type ExpeditorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutExpeditorNestedInput
  }

  export type ExpeditorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutExpeditorNestedInput
  }

  export type ExpeditorCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpeditorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpeditorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCreateInput = {
    quantity?: number
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStockInput
  }

  export type StockUncheckedCreateInput = {
    productId: number
    quantity?: number
    updatedAt?: Date | string
  }

  export type StockUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockNestedInput
  }

  export type StockUncheckedUpdateInput = {
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCreateManyInput = {
    productId: number
    quantity?: number
    updatedAt?: Date | string
  }

  export type StockUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockUncheckedUpdateManyInput = {
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionCreateInput = {
    type: string
    quantity: number
    note?: string | null
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutStockTransactionsInput
    product: ProductCreateNestedOneWithoutStockTransactionsInput
  }

  export type StockTransactionUncheckedCreateInput = {
    id?: number
    productId: number
    type: string
    quantity: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type StockTransactionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutStockTransactionsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockTransactionsNestedInput
  }

  export type StockTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionCreateManyInput = {
    id?: number
    productId: number
    type: string
    quantity: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type StockTransactionUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrderJournalCreateInput = {
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerName: string
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutSummaryJournalEntriesInput
    product?: ProductCreateNestedOneWithoutSummaryJournalEntriesInput
  }

  export type SummaryOrderJournalUncheckedCreateInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerId?: number | null
    customerName: string
    productId?: number | null
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SummaryOrderJournalUpdateInput = {
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutSummaryJournalEntriesNestedInput
    product?: ProductUpdateOneWithoutSummaryJournalEntriesNestedInput
  }

  export type SummaryOrderJournalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrderJournalCreateManyInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerId?: number | null
    customerName: string
    productId?: number | null
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SummaryOrderJournalUpdateManyMutationInput = {
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrderJournalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrdersJournalCreateInput = {
    summaryDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    data: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalUncheckedCreateInput = {
    id?: number
    summaryDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    data: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalUpdateInput = {
    summaryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    summaryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalCreateManyInput = {
    id?: number
    summaryDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    data: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalUpdateManyMutationInput = {
    summaryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    summaryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalCreateInput = {
    assemblyDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    sourceSummaryId?: number | null
    data: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalUncheckedCreateInput = {
    id?: number
    assemblyDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    sourceSummaryId?: number | null
    data: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalUpdateInput = {
    assemblyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    sourceSummaryId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assemblyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    sourceSummaryId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalCreateManyInput = {
    id?: number
    assemblyDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    sourceSummaryId?: number | null
    data: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalUpdateManyMutationInput = {
    assemblyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    sourceSummaryId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assemblyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    sourceSummaryId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProductionStaffCreateInput = {
    fullName: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProductionStaffInput
    journals?: ProductionJournalCreateNestedManyWithoutStaffInput
  }

  export type ProductionStaffUncheckedCreateInput = {
    id?: number
    fullName: string
    phone?: string | null
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journals?: ProductionJournalUncheckedCreateNestedManyWithoutStaffInput
  }

  export type ProductionStaffUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductionStaffNestedInput
    journals?: ProductionJournalUpdateManyWithoutStaffNestedInput
  }

  export type ProductionStaffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: ProductionJournalUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type ProductionStaffCreateManyInput = {
    id?: number
    fullName: string
    phone?: string | null
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionStaffUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionStaffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionJournalCreateInput = {
    productionDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    staff: ProductionStaffCreateNestedOneWithoutJournalsInput
    items?: ProductionItemCreateNestedManyWithoutJournalInput
  }

  export type ProductionJournalUncheckedCreateInput = {
    id?: number
    productionDate: Date | string
    staffId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: ProductionItemUncheckedCreateNestedManyWithoutJournalInput
  }

  export type ProductionJournalUpdateInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: ProductionStaffUpdateOneRequiredWithoutJournalsNestedInput
    items?: ProductionItemUpdateManyWithoutJournalNestedInput
  }

  export type ProductionJournalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ProductionItemUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type ProductionJournalCreateManyInput = {
    id?: number
    productionDate: Date | string
    staffId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionJournalUpdateManyMutationInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionJournalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemCreateInput = {
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    journal: ProductionJournalCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutProductionItemsInput
    values?: ProductionItemValueCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemUncheckedCreateInput = {
    id?: number
    journalId: number
    productId?: number | null
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    values?: ProductionItemValueUncheckedCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemUpdateInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: ProductionJournalUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutProductionItemsNestedInput
    values?: ProductionItemValueUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    journalId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    values?: ProductionItemValueUncheckedUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemCreateManyInput = {
    id?: number
    journalId: number
    productId?: number | null
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionItemUpdateManyMutationInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    journalId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueCreateInput = {
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    productionItem: ProductionItemCreateNestedOneWithoutValuesInput
  }

  export type ProductionItemValueUncheckedCreateInput = {
    id?: number
    productionItemId: number
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionItemValueUpdateInput = {
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    productionItem?: ProductionItemUpdateOneRequiredWithoutValuesNestedInput
  }

  export type ProductionItemValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionItemId?: IntFieldUpdateOperationsInput | number
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueCreateManyInput = {
    id?: number
    productionItemId: number
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionItemValueUpdateManyMutationInput = {
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionItemId?: IntFieldUpdateOperationsInput | number
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceListCreateInput = {
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    suppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPriceListInput
    items?: PurchasePriceItemCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListUncheckedCreateInput = {
    id?: number
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    suppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPriceListInput
    items?: PurchasePriceItemUncheckedCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suppliers?: PurchasePriceListSupplierUpdateManyWithoutPriceListNestedInput
    items?: PurchasePriceItemUpdateManyWithoutPriceListNestedInput
  }

  export type PurchasePriceListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPriceListNestedInput
    items?: PurchasePriceItemUncheckedUpdateManyWithoutPriceListNestedInput
  }

  export type PurchasePriceListCreateManyInput = {
    id?: number
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type PurchasePriceListUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceListSupplierCreateInput = {
    createdAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutSuppliersInput
    supplier: SupplierCreateNestedOneWithoutPurchasePriceListSuppliersInput
    primaryMml?: ProductionMmlCreateNestedOneWithoutPriceListSuppliersInput
  }

  export type PurchasePriceListSupplierUncheckedCreateInput = {
    id?: number
    priceListId: number
    supplierId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceListSupplierUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutSuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceListSuppliersNestedInput
    primaryMml?: ProductionMmlUpdateOneWithoutPriceListSuppliersNestedInput
  }

  export type PurchasePriceListSupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierCreateManyInput = {
    id?: number
    priceListId: number
    supplierId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceListSupplierUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemCreateInput = {
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutItemsInput
    supplier: SupplierCreateNestedOneWithoutPurchasePriceItemsInput
    product: ProductCreateNestedOneWithoutPurchasePriceItemsInput
  }

  export type PurchasePriceItemUncheckedCreateInput = {
    id?: number
    priceListId: number
    supplierId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceItemUpdateInput = {
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutItemsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
  }

  export type PurchasePriceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemCreateManyInput = {
    id?: number
    priceListId: number
    supplierId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceItemUpdateManyMutationInput = {
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesPriceListCreateInput = {
    listType: string
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    customer?: CustomerCreateNestedOneWithoutSalesPriceListsInput
    items?: SalesPriceItemCreateNestedManyWithoutPriceListInput
  }

  export type SalesPriceListUncheckedCreateInput = {
    id?: number
    listType: string
    customerId?: number | null
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: SalesPriceItemUncheckedCreateNestedManyWithoutPriceListInput
  }

  export type SalesPriceListUpdateInput = {
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutSalesPriceListsNestedInput
    items?: SalesPriceItemUpdateManyWithoutPriceListNestedInput
  }

  export type SalesPriceListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    listType?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: SalesPriceItemUncheckedUpdateManyWithoutPriceListNestedInput
  }

  export type SalesPriceListCreateManyInput = {
    id?: number
    listType: string
    customerId?: number | null
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type SalesPriceListUpdateManyMutationInput = {
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    listType?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceItemCreateInput = {
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    priceList: SalesPriceListCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSalesPriceItemsInput
  }

  export type SalesPriceItemUncheckedCreateInput = {
    id?: number
    priceListId: number
    productId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SalesPriceItemUpdateInput = {
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    priceList?: SalesPriceListUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSalesPriceItemsNestedInput
  }

  export type SalesPriceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceItemCreateManyInput = {
    id?: number
    priceListId: number
    productId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SalesPriceItemUpdateManyMutationInput = {
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionMmlCreateInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlUncheckedCreateInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlUpdateInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlCreateManyInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionMmlUpdateManyMutationInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionMmlUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionMmlNodeCreateInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutNodesInput
    parentNode?: ProductionMmlNodeCreateNestedOneWithoutChildrenInput
    children?: ProductionMmlNodeCreateNestedManyWithoutParentNodeInput
    product: ProductCreateNestedOneWithoutMmlNodesInput
    runValues?: ProductionRunValueCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUncheckedCreateInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput
    runValues?: ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUpdateInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutNodesNestedInput
    parentNode?: ProductionMmlNodeUpdateOneWithoutChildrenNestedInput
    children?: ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput
    product?: ProductUpdateOneRequiredWithoutMmlNodesNestedInput
    runValues?: ProductionRunValueUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput
    runValues?: ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeCreateManyInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionMmlNodeUpdateManyMutationInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionMmlNodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunCreateInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionRunsInput
    mml: ProductionMmlCreateNestedOneWithoutRunsInput
    user: UserCreateNestedOneWithoutProductionRunsInput
    values?: ProductionRunValueCreateNestedManyWithoutRunInput
  }

  export type ProductionRunUncheckedCreateInput = {
    id?: number
    productId: number
    mmlId: number
    userId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: ProductionRunValueUncheckedCreateNestedManyWithoutRunInput
  }

  export type ProductionRunUpdateInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionRunsNestedInput
    mml?: ProductionMmlUpdateOneRequiredWithoutRunsNestedInput
    user?: UserUpdateOneRequiredWithoutProductionRunsNestedInput
    values?: ProductionRunValueUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: ProductionRunValueUncheckedUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunCreateManyInput = {
    id?: number
    productId: number
    mmlId: number
    userId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunUpdateManyMutationInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueCreateInput = {
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    run: ProductionRunCreateNestedOneWithoutValuesInput
    node: ProductionMmlNodeCreateNestedOneWithoutRunValuesInput
  }

  export type ProductionRunValueUncheckedCreateInput = {
    id?: number
    productionRunId: number
    mmlNodeId: number
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueUpdateInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: ProductionRunUpdateOneRequiredWithoutValuesNestedInput
    node?: ProductionMmlNodeUpdateOneRequiredWithoutRunValuesNestedInput
  }

  export type ProductionRunValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionRunId?: IntFieldUpdateOperationsInput | number
    mmlNodeId?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueCreateManyInput = {
    id?: number
    productionRunId: number
    mmlNodeId: number
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueUpdateManyMutationInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionRunId?: IntFieldUpdateOperationsInput | number
    mmlNodeId?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProductionStaffNullableScalarRelationFilter = {
    is?: ProductionStaffWhereInput | null
    isNot?: ProductionStaffWhereInput | null
  }

  export type ProductionMmlListRelationFilter = {
    every?: ProductionMmlWhereInput
    some?: ProductionMmlWhereInput
    none?: ProductionMmlWhereInput
  }

  export type ProductionRunListRelationFilter = {
    every?: ProductionRunWhereInput
    some?: ProductionRunWhereInput
    none?: ProductionRunWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProductionMmlOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DistrictCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type DistrictAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DistrictMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type DistrictMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type DistrictSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ManagerCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phone?: SortOrder
  }

  export type ManagerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phone?: SortOrder
  }

  export type ManagerMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phone?: SortOrder
  }

  export type ManagerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type StockNullableScalarRelationFilter = {
    is?: StockWhereInput | null
    isNot?: StockWhereInput | null
  }

  export type StockTransactionListRelationFilter = {
    every?: StockTransactionWhereInput
    some?: StockTransactionWhereInput
    none?: StockTransactionWhereInput
  }

  export type SupplierProductListRelationFilter = {
    every?: SupplierProductWhereInput
    some?: SupplierProductWhereInput
    none?: SupplierProductWhereInput
  }

  export type SummaryOrderJournalListRelationFilter = {
    every?: SummaryOrderJournalWhereInput
    some?: SummaryOrderJournalWhereInput
    none?: SummaryOrderJournalWhereInput
  }

  export type ProductionItemListRelationFilter = {
    every?: ProductionItemWhereInput
    some?: ProductionItemWhereInput
    none?: ProductionItemWhereInput
  }

  export type PurchasePriceItemListRelationFilter = {
    every?: PurchasePriceItemWhereInput
    some?: PurchasePriceItemWhereInput
    none?: PurchasePriceItemWhereInput
  }

  export type SalesPriceItemListRelationFilter = {
    every?: SalesPriceItemWhereInput
    some?: SalesPriceItemWhereInput
    none?: SalesPriceItemWhereInput
  }

  export type ProductionMmlNodeListRelationFilter = {
    every?: ProductionMmlNodeWhereInput
    some?: ProductionMmlNodeWhereInput
    none?: ProductionMmlNodeWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SummaryOrderJournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchasePriceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesPriceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionMmlNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    altName?: SortOrder
    priceListName?: SortOrder
    category?: SortOrder
    status?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    altName?: SortOrder
    priceListName?: SortOrder
    category?: SortOrder
    status?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    altName?: SortOrder
    priceListName?: SortOrder
    category?: SortOrder
    status?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DistrictNullableScalarRelationFilter = {
    is?: DistrictWhereInput | null
    isNot?: DistrictWhereInput | null
  }

  export type ManagerNullableScalarRelationFilter = {
    is?: ManagerWhereInput | null
    isNot?: ManagerWhereInput | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type SalesPriceListListRelationFilter = {
    every?: SalesPriceListWhereInput
    some?: SalesPriceListWhereInput
    none?: SalesPriceListWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesPriceListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    districtId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    districtId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    districtId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProductionMmlNullableScalarRelationFilter = {
    is?: ProductionMmlWhereInput | null
    isNot?: ProductionMmlWhereInput | null
  }

  export type PurchasePriceListSupplierListRelationFilter = {
    every?: PurchasePriceListSupplierWhereInput
    some?: PurchasePriceListSupplierWhereInput
    none?: PurchasePriceListSupplierWhereInput
  }

  export type PurchasePriceListSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    altName?: SortOrder
    phone?: SortOrder
    telegram?: SortOrder
    isActive?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    primaryMmlId?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    altName?: SortOrder
    phone?: SortOrder
    telegram?: SortOrder
    isActive?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    altName?: SortOrder
    phone?: SortOrder
    telegram?: SortOrder
    isActive?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    id?: SortOrder
    primaryMmlId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type SupplierProductSupplierIdProductIdCompoundUniqueInput = {
    supplierId: number
    productId: number
  }

  export type SupplierProductCountOrderByAggregateInput = {
    supplierId?: SortOrder
    productId?: SortOrder
  }

  export type SupplierProductAvgOrderByAggregateInput = {
    supplierId?: SortOrder
    productId?: SortOrder
  }

  export type SupplierProductMaxOrderByAggregateInput = {
    supplierId?: SortOrder
    productId?: SortOrder
  }

  export type SupplierProductMinOrderByAggregateInput = {
    supplierId?: SortOrder
    productId?: SortOrder
  }

  export type SupplierProductSumOrderByAggregateInput = {
    supplierId?: SortOrder
    productId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type ExpeditorNullableScalarRelationFilter = {
    is?: ExpeditorWhereInput | null
    isNot?: ExpeditorWhereInput | null
  }

  export type OrderAttachmentListRelationFilter = {
    every?: OrderAttachmentWhereInput
    some?: OrderAttachmentWhereInput
    none?: OrderAttachmentWhereInput
  }

  export type OrderAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    date?: SortOrder
    status?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
    isDisabled?: SortOrder
    deliveryAddress?: SortOrder
    assignedAt?: SortOrder
    deliveryStatus?: SortOrder
    completedAt?: SortOrder
    signatureUrl?: SortOrder
    signedInvoiceUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    date?: SortOrder
    status?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
    isDisabled?: SortOrder
    deliveryAddress?: SortOrder
    assignedAt?: SortOrder
    deliveryStatus?: SortOrder
    completedAt?: SortOrder
    signatureUrl?: SortOrder
    signedInvoiceUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    date?: SortOrder
    status?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
    isDisabled?: SortOrder
    deliveryAddress?: SortOrder
    assignedAt?: SortOrder
    deliveryStatus?: SortOrder
    completedAt?: SortOrder
    signatureUrl?: SortOrder
    signedInvoiceUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type OrderAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributionCoef?: SortOrder
    sumWithRevaluation?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    distributionCoef?: SortOrder
    sumWithRevaluation?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributionCoef?: SortOrder
    sumWithRevaluation?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributionCoef?: SortOrder
    sumWithRevaluation?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    distributionCoef?: SortOrder
    sumWithRevaluation?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ExpeditorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpeditorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExpeditorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpeditorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpeditorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StockCountOrderByAggregateInput = {
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockAvgOrderByAggregateInput = {
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type StockMaxOrderByAggregateInput = {
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockMinOrderByAggregateInput = {
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockSumOrderByAggregateInput = {
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type StockTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type StockTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
  }

  export type StockTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type StockTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type StockTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type SummaryOrderJournalCountOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    shipDate?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    productId?: SortOrder
    productCode?: SortOrder
    productFullName?: SortOrder
    category?: SortOrder
    shortNameMorning?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrder
    distributionCoef?: SortOrder
    weightToDistribute?: SortOrder
    managerId?: SortOrder
    managerName?: SortOrder
    district?: SortOrder
    pointAddress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SummaryOrderJournalAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrder
    distributionCoef?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type SummaryOrderJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    shipDate?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    productId?: SortOrder
    productCode?: SortOrder
    productFullName?: SortOrder
    category?: SortOrder
    shortNameMorning?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrder
    distributionCoef?: SortOrder
    weightToDistribute?: SortOrder
    managerId?: SortOrder
    managerName?: SortOrder
    district?: SortOrder
    pointAddress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SummaryOrderJournalMinOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    shipDate?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    productId?: SortOrder
    productCode?: SortOrder
    productFullName?: SortOrder
    category?: SortOrder
    shortNameMorning?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrder
    distributionCoef?: SortOrder
    weightToDistribute?: SortOrder
    managerId?: SortOrder
    managerName?: SortOrder
    district?: SortOrder
    pointAddress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SummaryOrderJournalSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrder
    distributionCoef?: SortOrder
    weightToDistribute?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SummaryOrdersJournalCountOrderByAggregateInput = {
    id?: SortOrder
    summaryDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    data?: SortOrder
  }

  export type SummaryOrdersJournalAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SummaryOrdersJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    summaryDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
  }

  export type SummaryOrdersJournalMinOrderByAggregateInput = {
    id?: SortOrder
    summaryDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
  }

  export type SummaryOrdersJournalSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AssemblyOrdersJournalCountOrderByAggregateInput = {
    id?: SortOrder
    assemblyDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    sourceSummaryId?: SortOrder
    data?: SortOrder
  }

  export type AssemblyOrdersJournalAvgOrderByAggregateInput = {
    id?: SortOrder
    sourceSummaryId?: SortOrder
  }

  export type AssemblyOrdersJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    assemblyDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    sourceSummaryId?: SortOrder
  }

  export type AssemblyOrdersJournalMinOrderByAggregateInput = {
    id?: SortOrder
    assemblyDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    sourceSummaryId?: SortOrder
  }

  export type AssemblyOrdersJournalSumOrderByAggregateInput = {
    id?: SortOrder
    sourceSummaryId?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProductionJournalListRelationFilter = {
    every?: ProductionJournalWhereInput
    some?: ProductionJournalWhereInput
    none?: ProductionJournalWhereInput
  }

  export type ProductionJournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionStaffCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionStaffAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProductionStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionStaffMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionStaffSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProductionStaffScalarRelationFilter = {
    is?: ProductionStaffWhereInput
    isNot?: ProductionStaffWhereInput
  }

  export type ProductionJournalProductionDateStaffIdCompoundUniqueInput = {
    productionDate: Date | string
    staffId: number
  }

  export type ProductionJournalCountOrderByAggregateInput = {
    id?: SortOrder
    productionDate?: SortOrder
    staffId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionJournalAvgOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
  }

  export type ProductionJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    productionDate?: SortOrder
    staffId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionJournalMinOrderByAggregateInput = {
    id?: SortOrder
    productionDate?: SortOrder
    staffId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionJournalSumOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
  }

  export type ProductionJournalScalarRelationFilter = {
    is?: ProductionJournalWhereInput
    isNot?: ProductionJournalWhereInput
  }

  export type ProductionItemValueListRelationFilter = {
    every?: ProductionItemValueWhereInput
    some?: ProductionItemValueWhereInput
    none?: ProductionItemValueWhereInput
  }

  export type ProductionItemValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionItemCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    state?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemAvgOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    state?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    state?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemSumOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductionItemScalarRelationFilter = {
    is?: ProductionItemWhereInput
    isNot?: ProductionItemWhereInput
  }

  export type ProductionItemValueProductionItemIdFieldKeyCompoundUniqueInput = {
    productionItemId: number
    fieldKey: string
  }

  export type ProductionItemValueCountOrderByAggregateInput = {
    id?: SortOrder
    productionItemId?: SortOrder
    fieldKey?: SortOrder
    fieldValue?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemValueAvgOrderByAggregateInput = {
    id?: SortOrder
    productionItemId?: SortOrder
  }

  export type ProductionItemValueMaxOrderByAggregateInput = {
    id?: SortOrder
    productionItemId?: SortOrder
    fieldKey?: SortOrder
    fieldValue?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemValueMinOrderByAggregateInput = {
    id?: SortOrder
    productionItemId?: SortOrder
    fieldKey?: SortOrder
    fieldValue?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemValueSumOrderByAggregateInput = {
    id?: SortOrder
    productionItemId?: SortOrder
  }

  export type PurchasePriceListCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type PurchasePriceListAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PurchasePriceListMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type PurchasePriceListMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type PurchasePriceListSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PurchasePriceListScalarRelationFilter = {
    is?: PurchasePriceListWhereInput
    isNot?: PurchasePriceListWhereInput
  }

  export type PurchasePriceListSupplierPriceListIdSupplierIdCompoundUniqueInput = {
    priceListId: number
    supplierId: number
  }

  export type PurchasePriceListSupplierCountOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchasePriceListSupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrder
  }

  export type PurchasePriceListSupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchasePriceListSupplierMinOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchasePriceListSupplierSumOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrder
  }

  export type PurchasePriceItemPriceListIdSupplierIdProductIdCompoundUniqueInput = {
    priceListId: number
    supplierId: number
    productId: number
  }

  export type PurchasePriceItemCountOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasePriceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
  }

  export type PurchasePriceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasePriceItemMinOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasePriceItemSumOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
  }

  export type SalesPriceListCountOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    effectiveDate?: SortOrder
    status?: SortOrder
    isCurrent?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceListAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type SalesPriceListMaxOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    effectiveDate?: SortOrder
    status?: SortOrder
    isCurrent?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceListMinOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    effectiveDate?: SortOrder
    status?: SortOrder
    isCurrent?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceListSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type SalesPriceListScalarRelationFilter = {
    is?: SalesPriceListWhereInput
    isNot?: SalesPriceListWhereInput
  }

  export type SalesPriceItemPriceListIdProductIdCompoundUniqueInput = {
    priceListId: number
    productId: number
  }

  export type SalesPriceItemCountOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
    rowDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
  }

  export type SalesPriceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
    rowDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceItemMinOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
    rowDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceItemSumOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionMmlCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
  }

  export type ProductionMmlMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
  }

  export type ProductionMmlScalarRelationFilter = {
    is?: ProductionMmlWhereInput
    isNot?: ProductionMmlWhereInput
  }

  export type ProductionMmlNodeNullableScalarRelationFilter = {
    is?: ProductionMmlNodeWhereInput | null
    isNot?: ProductionMmlNodeWhereInput | null
  }

  export type ProductionRunValueListRelationFilter = {
    every?: ProductionRunValueWhereInput
    some?: ProductionRunValueWhereInput
    none?: ProductionRunValueWhereInput
  }

  export type ProductionRunValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionMmlNodeCountOrderByAggregateInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlNodeAvgOrderByAggregateInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductionMmlNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlNodeMinOrderByAggregateInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlNodeSumOrderByAggregateInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductionRunCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
  }

  export type ProductionRunMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
  }

  export type ProductionRunScalarRelationFilter = {
    is?: ProductionRunWhereInput
    isNot?: ProductionRunWhereInput
  }

  export type ProductionMmlNodeScalarRelationFilter = {
    is?: ProductionMmlNodeWhereInput
    isNot?: ProductionMmlNodeWhereInput
  }

  export type ProductionRunValueProductionRunIdMmlNodeIdCompoundUniqueInput = {
    productionRunId: number
    mmlNodeId: number
  }

  export type ProductionRunValueCountOrderByAggregateInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunValueAvgOrderByAggregateInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    value?: SortOrder
  }

  export type ProductionRunValueMaxOrderByAggregateInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunValueMinOrderByAggregateInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunValueSumOrderByAggregateInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    value?: SortOrder
  }

  export type ProductionStaffCreateNestedOneWithoutUserInput = {
    create?: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutUserInput
    connect?: ProductionStaffWhereUniqueInput
  }

  export type ProductionMmlCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput> | ProductionMmlCreateWithoutCreatorInput[] | ProductionMmlUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutCreatorInput | ProductionMmlCreateOrConnectWithoutCreatorInput[]
    createMany?: ProductionMmlCreateManyCreatorInputEnvelope
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
  }

  export type ProductionRunCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput> | ProductionRunCreateWithoutUserInput[] | ProductionRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutUserInput | ProductionRunCreateOrConnectWithoutUserInput[]
    createMany?: ProductionRunCreateManyUserInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type ProductionStaffUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutUserInput
    connect?: ProductionStaffWhereUniqueInput
  }

  export type ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput> | ProductionMmlCreateWithoutCreatorInput[] | ProductionMmlUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutCreatorInput | ProductionMmlCreateOrConnectWithoutCreatorInput[]
    createMany?: ProductionMmlCreateManyCreatorInputEnvelope
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
  }

  export type ProductionRunUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput> | ProductionRunCreateWithoutUserInput[] | ProductionRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutUserInput | ProductionRunCreateOrConnectWithoutUserInput[]
    createMany?: ProductionRunCreateManyUserInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProductionStaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutUserInput
    upsert?: ProductionStaffUpsertWithoutUserInput
    disconnect?: ProductionStaffWhereInput | boolean
    delete?: ProductionStaffWhereInput | boolean
    connect?: ProductionStaffWhereUniqueInput
    update?: XOR<XOR<ProductionStaffUpdateToOneWithWhereWithoutUserInput, ProductionStaffUpdateWithoutUserInput>, ProductionStaffUncheckedUpdateWithoutUserInput>
  }

  export type ProductionMmlUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput> | ProductionMmlCreateWithoutCreatorInput[] | ProductionMmlUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutCreatorInput | ProductionMmlCreateOrConnectWithoutCreatorInput[]
    upsert?: ProductionMmlUpsertWithWhereUniqueWithoutCreatorInput | ProductionMmlUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProductionMmlCreateManyCreatorInputEnvelope
    set?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    disconnect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    delete?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    update?: ProductionMmlUpdateWithWhereUniqueWithoutCreatorInput | ProductionMmlUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProductionMmlUpdateManyWithWhereWithoutCreatorInput | ProductionMmlUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
  }

  export type ProductionRunUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput> | ProductionRunCreateWithoutUserInput[] | ProductionRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutUserInput | ProductionRunCreateOrConnectWithoutUserInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutUserInput | ProductionRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductionRunCreateManyUserInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutUserInput | ProductionRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutUserInput | ProductionRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductionStaffUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutUserInput
    upsert?: ProductionStaffUpsertWithoutUserInput
    disconnect?: ProductionStaffWhereInput | boolean
    delete?: ProductionStaffWhereInput | boolean
    connect?: ProductionStaffWhereUniqueInput
    update?: XOR<XOR<ProductionStaffUpdateToOneWithWhereWithoutUserInput, ProductionStaffUpdateWithoutUserInput>, ProductionStaffUncheckedUpdateWithoutUserInput>
  }

  export type ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput> | ProductionMmlCreateWithoutCreatorInput[] | ProductionMmlUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutCreatorInput | ProductionMmlCreateOrConnectWithoutCreatorInput[]
    upsert?: ProductionMmlUpsertWithWhereUniqueWithoutCreatorInput | ProductionMmlUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProductionMmlCreateManyCreatorInputEnvelope
    set?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    disconnect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    delete?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    update?: ProductionMmlUpdateWithWhereUniqueWithoutCreatorInput | ProductionMmlUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProductionMmlUpdateManyWithWhereWithoutCreatorInput | ProductionMmlUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
  }

  export type ProductionRunUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput> | ProductionRunCreateWithoutUserInput[] | ProductionRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutUserInput | ProductionRunCreateOrConnectWithoutUserInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutUserInput | ProductionRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductionRunCreateManyUserInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutUserInput | ProductionRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutUserInput | ProductionRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type CustomerCreateNestedManyWithoutDistrictInput = {
    create?: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput> | CustomerCreateWithoutDistrictInput[] | CustomerUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDistrictInput | CustomerCreateOrConnectWithoutDistrictInput[]
    createMany?: CustomerCreateManyDistrictInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput> | CustomerCreateWithoutDistrictInput[] | CustomerUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDistrictInput | CustomerCreateOrConnectWithoutDistrictInput[]
    createMany?: CustomerCreateManyDistrictInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput> | CustomerCreateWithoutDistrictInput[] | CustomerUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDistrictInput | CustomerCreateOrConnectWithoutDistrictInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutDistrictInput | CustomerUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: CustomerCreateManyDistrictInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutDistrictInput | CustomerUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutDistrictInput | CustomerUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput> | CustomerCreateWithoutDistrictInput[] | CustomerUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDistrictInput | CustomerCreateOrConnectWithoutDistrictInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutDistrictInput | CustomerUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: CustomerCreateManyDistrictInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutDistrictInput | CustomerUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutDistrictInput | CustomerUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerCreateNestedManyWithoutManagerInput = {
    create?: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput> | CustomerCreateWithoutManagerInput[] | CustomerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutManagerInput | CustomerCreateOrConnectWithoutManagerInput[]
    createMany?: CustomerCreateManyManagerInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput> | CustomerCreateWithoutManagerInput[] | CustomerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutManagerInput | CustomerCreateOrConnectWithoutManagerInput[]
    createMany?: CustomerCreateManyManagerInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUpdateManyWithoutManagerNestedInput = {
    create?: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput> | CustomerCreateWithoutManagerInput[] | CustomerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutManagerInput | CustomerCreateOrConnectWithoutManagerInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutManagerInput | CustomerUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: CustomerCreateManyManagerInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutManagerInput | CustomerUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutManagerInput | CustomerUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput> | CustomerCreateWithoutManagerInput[] | CustomerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutManagerInput | CustomerCreateOrConnectWithoutManagerInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutManagerInput | CustomerUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: CustomerCreateManyManagerInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutManagerInput | CustomerUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutManagerInput | CustomerUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StockCreateNestedOneWithoutProductInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    connect?: StockWhereUniqueInput
  }

  export type StockTransactionCreateNestedManyWithoutProductInput = {
    create?: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput> | StockTransactionCreateWithoutProductInput[] | StockTransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutProductInput | StockTransactionCreateOrConnectWithoutProductInput[]
    createMany?: StockTransactionCreateManyProductInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type SupplierProductCreateNestedManyWithoutProductInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type SummaryOrderJournalCreateNestedManyWithoutProductInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput> | SummaryOrderJournalCreateWithoutProductInput[] | SummaryOrderJournalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutProductInput | SummaryOrderJournalCreateOrConnectWithoutProductInput[]
    createMany?: SummaryOrderJournalCreateManyProductInputEnvelope
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
  }

  export type ProductionItemCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput> | ProductionItemCreateWithoutProductInput[] | ProductionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutProductInput | ProductionItemCreateOrConnectWithoutProductInput[]
    createMany?: ProductionItemCreateManyProductInputEnvelope
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
  }

  export type PurchasePriceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput> | PurchasePriceItemCreateWithoutProductInput[] | PurchasePriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutProductInput | PurchasePriceItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchasePriceItemCreateManyProductInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type SalesPriceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput> | SalesPriceItemCreateWithoutProductInput[] | SalesPriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutProductInput | SalesPriceItemCreateOrConnectWithoutProductInput[]
    createMany?: SalesPriceItemCreateManyProductInputEnvelope
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
  }

  export type ProductionMmlCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput> | ProductionMmlCreateWithoutProductInput[] | ProductionMmlUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutProductInput | ProductionMmlCreateOrConnectWithoutProductInput[]
    createMany?: ProductionMmlCreateManyProductInputEnvelope
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
  }

  export type ProductionMmlNodeCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput> | ProductionMmlNodeCreateWithoutProductInput[] | ProductionMmlNodeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutProductInput | ProductionMmlNodeCreateOrConnectWithoutProductInput[]
    createMany?: ProductionMmlNodeCreateManyProductInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductionRunCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput> | ProductionRunCreateWithoutProductInput[] | ProductionRunUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutProductInput | ProductionRunCreateOrConnectWithoutProductInput[]
    createMany?: ProductionRunCreateManyProductInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StockUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    connect?: StockWhereUniqueInput
  }

  export type StockTransactionUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput> | StockTransactionCreateWithoutProductInput[] | StockTransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutProductInput | StockTransactionCreateOrConnectWithoutProductInput[]
    createMany?: StockTransactionCreateManyProductInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type SupplierProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput> | SummaryOrderJournalCreateWithoutProductInput[] | SummaryOrderJournalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutProductInput | SummaryOrderJournalCreateOrConnectWithoutProductInput[]
    createMany?: SummaryOrderJournalCreateManyProductInputEnvelope
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
  }

  export type ProductionItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput> | ProductionItemCreateWithoutProductInput[] | ProductionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutProductInput | ProductionItemCreateOrConnectWithoutProductInput[]
    createMany?: ProductionItemCreateManyProductInputEnvelope
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
  }

  export type PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput> | PurchasePriceItemCreateWithoutProductInput[] | PurchasePriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutProductInput | PurchasePriceItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchasePriceItemCreateManyProductInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type SalesPriceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput> | SalesPriceItemCreateWithoutProductInput[] | SalesPriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutProductInput | SalesPriceItemCreateOrConnectWithoutProductInput[]
    createMany?: SalesPriceItemCreateManyProductInputEnvelope
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
  }

  export type ProductionMmlUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput> | ProductionMmlCreateWithoutProductInput[] | ProductionMmlUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutProductInput | ProductionMmlCreateOrConnectWithoutProductInput[]
    createMany?: ProductionMmlCreateManyProductInputEnvelope
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
  }

  export type ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput> | ProductionMmlNodeCreateWithoutProductInput[] | ProductionMmlNodeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutProductInput | ProductionMmlNodeCreateOrConnectWithoutProductInput[]
    createMany?: ProductionMmlNodeCreateManyProductInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductionRunUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput> | ProductionRunCreateWithoutProductInput[] | ProductionRunUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutProductInput | ProductionRunCreateOrConnectWithoutProductInput[]
    createMany?: ProductionRunCreateManyProductInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StockUpdateOneWithoutProductNestedInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    upsert?: StockUpsertWithoutProductInput
    disconnect?: StockWhereInput | boolean
    delete?: StockWhereInput | boolean
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutProductInput, StockUpdateWithoutProductInput>, StockUncheckedUpdateWithoutProductInput>
  }

  export type StockTransactionUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput> | StockTransactionCreateWithoutProductInput[] | StockTransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutProductInput | StockTransactionCreateOrConnectWithoutProductInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutProductInput | StockTransactionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockTransactionCreateManyProductInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutProductInput | StockTransactionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutProductInput | StockTransactionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type SupplierProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutProductInput | SupplierProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutProductInput | SupplierProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutProductInput | SupplierProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type SummaryOrderJournalUpdateManyWithoutProductNestedInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput> | SummaryOrderJournalCreateWithoutProductInput[] | SummaryOrderJournalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutProductInput | SummaryOrderJournalCreateOrConnectWithoutProductInput[]
    upsert?: SummaryOrderJournalUpsertWithWhereUniqueWithoutProductInput | SummaryOrderJournalUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SummaryOrderJournalCreateManyProductInputEnvelope
    set?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    disconnect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    delete?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    update?: SummaryOrderJournalUpdateWithWhereUniqueWithoutProductInput | SummaryOrderJournalUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SummaryOrderJournalUpdateManyWithWhereWithoutProductInput | SummaryOrderJournalUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
  }

  export type ProductionItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput> | ProductionItemCreateWithoutProductInput[] | ProductionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutProductInput | ProductionItemCreateOrConnectWithoutProductInput[]
    upsert?: ProductionItemUpsertWithWhereUniqueWithoutProductInput | ProductionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionItemCreateManyProductInputEnvelope
    set?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    disconnect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    delete?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    update?: ProductionItemUpdateWithWhereUniqueWithoutProductInput | ProductionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionItemUpdateManyWithWhereWithoutProductInput | ProductionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
  }

  export type PurchasePriceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput> | PurchasePriceItemCreateWithoutProductInput[] | PurchasePriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutProductInput | PurchasePriceItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutProductInput | PurchasePriceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchasePriceItemCreateManyProductInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutProductInput | PurchasePriceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutProductInput | PurchasePriceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type SalesPriceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput> | SalesPriceItemCreateWithoutProductInput[] | SalesPriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutProductInput | SalesPriceItemCreateOrConnectWithoutProductInput[]
    upsert?: SalesPriceItemUpsertWithWhereUniqueWithoutProductInput | SalesPriceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SalesPriceItemCreateManyProductInputEnvelope
    set?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    disconnect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    delete?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    update?: SalesPriceItemUpdateWithWhereUniqueWithoutProductInput | SalesPriceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SalesPriceItemUpdateManyWithWhereWithoutProductInput | SalesPriceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
  }

  export type ProductionMmlUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput> | ProductionMmlCreateWithoutProductInput[] | ProductionMmlUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutProductInput | ProductionMmlCreateOrConnectWithoutProductInput[]
    upsert?: ProductionMmlUpsertWithWhereUniqueWithoutProductInput | ProductionMmlUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionMmlCreateManyProductInputEnvelope
    set?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    disconnect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    delete?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    update?: ProductionMmlUpdateWithWhereUniqueWithoutProductInput | ProductionMmlUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionMmlUpdateManyWithWhereWithoutProductInput | ProductionMmlUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
  }

  export type ProductionMmlNodeUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput> | ProductionMmlNodeCreateWithoutProductInput[] | ProductionMmlNodeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutProductInput | ProductionMmlNodeCreateOrConnectWithoutProductInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutProductInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionMmlNodeCreateManyProductInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutProductInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutProductInput | ProductionMmlNodeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductionRunUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput> | ProductionRunCreateWithoutProductInput[] | ProductionRunUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutProductInput | ProductionRunCreateOrConnectWithoutProductInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutProductInput | ProductionRunUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionRunCreateManyProductInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutProductInput | ProductionRunUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutProductInput | ProductionRunUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StockUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    upsert?: StockUpsertWithoutProductInput
    disconnect?: StockWhereInput | boolean
    delete?: StockWhereInput | boolean
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutProductInput, StockUpdateWithoutProductInput>, StockUncheckedUpdateWithoutProductInput>
  }

  export type StockTransactionUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput> | StockTransactionCreateWithoutProductInput[] | StockTransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutProductInput | StockTransactionCreateOrConnectWithoutProductInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutProductInput | StockTransactionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockTransactionCreateManyProductInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutProductInput | StockTransactionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutProductInput | StockTransactionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type SupplierProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutProductInput | SupplierProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutProductInput | SupplierProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutProductInput | SupplierProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput> | SummaryOrderJournalCreateWithoutProductInput[] | SummaryOrderJournalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutProductInput | SummaryOrderJournalCreateOrConnectWithoutProductInput[]
    upsert?: SummaryOrderJournalUpsertWithWhereUniqueWithoutProductInput | SummaryOrderJournalUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SummaryOrderJournalCreateManyProductInputEnvelope
    set?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    disconnect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    delete?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    update?: SummaryOrderJournalUpdateWithWhereUniqueWithoutProductInput | SummaryOrderJournalUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SummaryOrderJournalUpdateManyWithWhereWithoutProductInput | SummaryOrderJournalUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
  }

  export type ProductionItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput> | ProductionItemCreateWithoutProductInput[] | ProductionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutProductInput | ProductionItemCreateOrConnectWithoutProductInput[]
    upsert?: ProductionItemUpsertWithWhereUniqueWithoutProductInput | ProductionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionItemCreateManyProductInputEnvelope
    set?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    disconnect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    delete?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    update?: ProductionItemUpdateWithWhereUniqueWithoutProductInput | ProductionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionItemUpdateManyWithWhereWithoutProductInput | ProductionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput> | PurchasePriceItemCreateWithoutProductInput[] | PurchasePriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutProductInput | PurchasePriceItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutProductInput | PurchasePriceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchasePriceItemCreateManyProductInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutProductInput | PurchasePriceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutProductInput | PurchasePriceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput> | SalesPriceItemCreateWithoutProductInput[] | SalesPriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutProductInput | SalesPriceItemCreateOrConnectWithoutProductInput[]
    upsert?: SalesPriceItemUpsertWithWhereUniqueWithoutProductInput | SalesPriceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SalesPriceItemCreateManyProductInputEnvelope
    set?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    disconnect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    delete?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    update?: SalesPriceItemUpdateWithWhereUniqueWithoutProductInput | SalesPriceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SalesPriceItemUpdateManyWithWhereWithoutProductInput | SalesPriceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
  }

  export type ProductionMmlUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput> | ProductionMmlCreateWithoutProductInput[] | ProductionMmlUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutProductInput | ProductionMmlCreateOrConnectWithoutProductInput[]
    upsert?: ProductionMmlUpsertWithWhereUniqueWithoutProductInput | ProductionMmlUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionMmlCreateManyProductInputEnvelope
    set?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    disconnect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    delete?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    update?: ProductionMmlUpdateWithWhereUniqueWithoutProductInput | ProductionMmlUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionMmlUpdateManyWithWhereWithoutProductInput | ProductionMmlUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput> | ProductionMmlNodeCreateWithoutProductInput[] | ProductionMmlNodeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutProductInput | ProductionMmlNodeCreateOrConnectWithoutProductInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutProductInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionMmlNodeCreateManyProductInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutProductInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutProductInput | ProductionMmlNodeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductionRunUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput> | ProductionRunCreateWithoutProductInput[] | ProductionRunUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutProductInput | ProductionRunCreateOrConnectWithoutProductInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutProductInput | ProductionRunUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionRunCreateManyProductInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutProductInput | ProductionRunUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutProductInput | ProductionRunUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type DistrictCreateNestedOneWithoutCustomersInput = {
    create?: XOR<DistrictCreateWithoutCustomersInput, DistrictUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutCustomersInput
    connect?: DistrictWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutCustomersInput = {
    create?: XOR<ManagerCreateWithoutCustomersInput, ManagerUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutCustomersInput
    connect?: ManagerWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SummaryOrderJournalCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput> | SummaryOrderJournalCreateWithoutCustomerInput[] | SummaryOrderJournalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutCustomerInput | SummaryOrderJournalCreateOrConnectWithoutCustomerInput[]
    createMany?: SummaryOrderJournalCreateManyCustomerInputEnvelope
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
  }

  export type SalesPriceListCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput> | SalesPriceListCreateWithoutCustomerInput[] | SalesPriceListUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutCustomerInput | SalesPriceListCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesPriceListCreateManyCustomerInputEnvelope
    connect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput> | SummaryOrderJournalCreateWithoutCustomerInput[] | SummaryOrderJournalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutCustomerInput | SummaryOrderJournalCreateOrConnectWithoutCustomerInput[]
    createMany?: SummaryOrderJournalCreateManyCustomerInputEnvelope
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
  }

  export type SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput> | SalesPriceListCreateWithoutCustomerInput[] | SalesPriceListUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutCustomerInput | SalesPriceListCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesPriceListCreateManyCustomerInputEnvelope
    connect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
  }

  export type DistrictUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<DistrictCreateWithoutCustomersInput, DistrictUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutCustomersInput
    upsert?: DistrictUpsertWithoutCustomersInput
    disconnect?: DistrictWhereInput | boolean
    delete?: DistrictWhereInput | boolean
    connect?: DistrictWhereUniqueInput
    update?: XOR<XOR<DistrictUpdateToOneWithWhereWithoutCustomersInput, DistrictUpdateWithoutCustomersInput>, DistrictUncheckedUpdateWithoutCustomersInput>
  }

  export type ManagerUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<ManagerCreateWithoutCustomersInput, ManagerUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutCustomersInput
    upsert?: ManagerUpsertWithoutCustomersInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutCustomersInput, ManagerUpdateWithoutCustomersInput>, ManagerUncheckedUpdateWithoutCustomersInput>
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SummaryOrderJournalUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput> | SummaryOrderJournalCreateWithoutCustomerInput[] | SummaryOrderJournalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutCustomerInput | SummaryOrderJournalCreateOrConnectWithoutCustomerInput[]
    upsert?: SummaryOrderJournalUpsertWithWhereUniqueWithoutCustomerInput | SummaryOrderJournalUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SummaryOrderJournalCreateManyCustomerInputEnvelope
    set?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    disconnect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    delete?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    update?: SummaryOrderJournalUpdateWithWhereUniqueWithoutCustomerInput | SummaryOrderJournalUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SummaryOrderJournalUpdateManyWithWhereWithoutCustomerInput | SummaryOrderJournalUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
  }

  export type SalesPriceListUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput> | SalesPriceListCreateWithoutCustomerInput[] | SalesPriceListUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutCustomerInput | SalesPriceListCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesPriceListUpsertWithWhereUniqueWithoutCustomerInput | SalesPriceListUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesPriceListCreateManyCustomerInputEnvelope
    set?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    disconnect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    delete?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    connect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    update?: SalesPriceListUpdateWithWhereUniqueWithoutCustomerInput | SalesPriceListUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesPriceListUpdateManyWithWhereWithoutCustomerInput | SalesPriceListUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesPriceListScalarWhereInput | SalesPriceListScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput> | SummaryOrderJournalCreateWithoutCustomerInput[] | SummaryOrderJournalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutCustomerInput | SummaryOrderJournalCreateOrConnectWithoutCustomerInput[]
    upsert?: SummaryOrderJournalUpsertWithWhereUniqueWithoutCustomerInput | SummaryOrderJournalUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SummaryOrderJournalCreateManyCustomerInputEnvelope
    set?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    disconnect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    delete?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    update?: SummaryOrderJournalUpdateWithWhereUniqueWithoutCustomerInput | SummaryOrderJournalUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SummaryOrderJournalUpdateManyWithWhereWithoutCustomerInput | SummaryOrderJournalUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
  }

  export type SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput> | SalesPriceListCreateWithoutCustomerInput[] | SalesPriceListUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutCustomerInput | SalesPriceListCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesPriceListUpsertWithWhereUniqueWithoutCustomerInput | SalesPriceListUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesPriceListCreateManyCustomerInputEnvelope
    set?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    disconnect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    delete?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    connect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    update?: SalesPriceListUpdateWithWhereUniqueWithoutCustomerInput | SalesPriceListUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesPriceListUpdateManyWithWhereWithoutCustomerInput | SalesPriceListUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesPriceListScalarWhereInput | SalesPriceListScalarWhereInput[]
  }

  export type ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput = {
    create?: XOR<ProductionMmlCreateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedCreateWithoutSuppliersWithPrimaryMmlInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutSuppliersWithPrimaryMmlInput
    connect?: ProductionMmlWhereUniqueInput
  }

  export type SupplierProductCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput> | PurchasePriceListSupplierCreateWithoutSupplierInput[] | PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput | PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchasePriceListSupplierCreateManySupplierInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type PurchasePriceItemCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput> | PurchasePriceItemCreateWithoutSupplierInput[] | PurchasePriceItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutSupplierInput | PurchasePriceItemCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchasePriceItemCreateManySupplierInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type SupplierProductUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput> | PurchasePriceListSupplierCreateWithoutSupplierInput[] | PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput | PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchasePriceListSupplierCreateManySupplierInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput> | PurchasePriceItemCreateWithoutSupplierInput[] | PurchasePriceItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutSupplierInput | PurchasePriceItemCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchasePriceItemCreateManySupplierInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedCreateWithoutSuppliersWithPrimaryMmlInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutSuppliersWithPrimaryMmlInput
    upsert?: ProductionMmlUpsertWithoutSuppliersWithPrimaryMmlInput
    disconnect?: ProductionMmlWhereInput | boolean
    delete?: ProductionMmlWhereInput | boolean
    connect?: ProductionMmlWhereUniqueInput
    update?: XOR<XOR<ProductionMmlUpdateToOneWithWhereWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUpdateWithoutSuppliersWithPrimaryMmlInput>, ProductionMmlUncheckedUpdateWithoutSuppliersWithPrimaryMmlInput>
  }

  export type SupplierProductUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutSupplierInput | SupplierProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutSupplierInput | SupplierProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutSupplierInput | SupplierProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput> | PurchasePriceListSupplierCreateWithoutSupplierInput[] | PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput | PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutSupplierInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchasePriceListSupplierCreateManySupplierInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutSupplierInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutSupplierInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type PurchasePriceItemUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput> | PurchasePriceItemCreateWithoutSupplierInput[] | PurchasePriceItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutSupplierInput | PurchasePriceItemCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutSupplierInput | PurchasePriceItemUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchasePriceItemCreateManySupplierInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutSupplierInput | PurchasePriceItemUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutSupplierInput | PurchasePriceItemUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutSupplierInput | SupplierProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutSupplierInput | SupplierProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutSupplierInput | SupplierProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput> | PurchasePriceListSupplierCreateWithoutSupplierInput[] | PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput | PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutSupplierInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchasePriceListSupplierCreateManySupplierInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutSupplierInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutSupplierInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput> | PurchasePriceItemCreateWithoutSupplierInput[] | PurchasePriceItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutSupplierInput | PurchasePriceItemCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutSupplierInput | PurchasePriceItemUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchasePriceItemCreateManySupplierInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutSupplierInput | PurchasePriceItemUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutSupplierInput | PurchasePriceItemUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<ProductCreateWithoutSuppliersInput, ProductUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSuppliersInput
    connect?: ProductWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutProductsInput = {
    create?: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductsInput
    connect?: SupplierWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<ProductCreateWithoutSuppliersInput, ProductUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSuppliersInput
    upsert?: ProductUpsertWithoutSuppliersInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSuppliersInput, ProductUpdateWithoutSuppliersInput>, ProductUncheckedUpdateWithoutSuppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductsInput
    upsert?: SupplierUpsertWithoutProductsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutProductsInput, SupplierUpdateWithoutProductsInput>, SupplierUncheckedUpdateWithoutProductsInput>
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type ExpeditorCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ExpeditorCreateWithoutOrdersInput, ExpeditorUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ExpeditorCreateOrConnectWithoutOrdersInput
    connect?: ExpeditorWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StockTransactionCreateNestedManyWithoutOrderInput = {
    create?: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput> | StockTransactionCreateWithoutOrderInput[] | StockTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutOrderInput | StockTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: StockTransactionCreateManyOrderInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type OrderAttachmentCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput> | OrderAttachmentCreateWithoutOrderInput[] | OrderAttachmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAttachmentCreateOrConnectWithoutOrderInput | OrderAttachmentCreateOrConnectWithoutOrderInput[]
    createMany?: OrderAttachmentCreateManyOrderInputEnvelope
    connect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StockTransactionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput> | StockTransactionCreateWithoutOrderInput[] | StockTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutOrderInput | StockTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: StockTransactionCreateManyOrderInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput> | OrderAttachmentCreateWithoutOrderInput[] | OrderAttachmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAttachmentCreateOrConnectWithoutOrderInput | OrderAttachmentCreateOrConnectWithoutOrderInput[]
    createMany?: OrderAttachmentCreateManyOrderInputEnvelope
    connect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type ExpeditorUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<ExpeditorCreateWithoutOrdersInput, ExpeditorUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ExpeditorCreateOrConnectWithoutOrdersInput
    upsert?: ExpeditorUpsertWithoutOrdersInput
    disconnect?: ExpeditorWhereInput | boolean
    delete?: ExpeditorWhereInput | boolean
    connect?: ExpeditorWhereUniqueInput
    update?: XOR<XOR<ExpeditorUpdateToOneWithWhereWithoutOrdersInput, ExpeditorUpdateWithoutOrdersInput>, ExpeditorUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StockTransactionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput> | StockTransactionCreateWithoutOrderInput[] | StockTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutOrderInput | StockTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutOrderInput | StockTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: StockTransactionCreateManyOrderInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutOrderInput | StockTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutOrderInput | StockTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type OrderAttachmentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput> | OrderAttachmentCreateWithoutOrderInput[] | OrderAttachmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAttachmentCreateOrConnectWithoutOrderInput | OrderAttachmentCreateOrConnectWithoutOrderInput[]
    upsert?: OrderAttachmentUpsertWithWhereUniqueWithoutOrderInput | OrderAttachmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderAttachmentCreateManyOrderInputEnvelope
    set?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    disconnect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    delete?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    connect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    update?: OrderAttachmentUpdateWithWhereUniqueWithoutOrderInput | OrderAttachmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderAttachmentUpdateManyWithWhereWithoutOrderInput | OrderAttachmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderAttachmentScalarWhereInput | OrderAttachmentScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StockTransactionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput> | StockTransactionCreateWithoutOrderInput[] | StockTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutOrderInput | StockTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutOrderInput | StockTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: StockTransactionCreateManyOrderInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutOrderInput | StockTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutOrderInput | StockTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput> | OrderAttachmentCreateWithoutOrderInput[] | OrderAttachmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAttachmentCreateOrConnectWithoutOrderInput | OrderAttachmentCreateOrConnectWithoutOrderInput[]
    upsert?: OrderAttachmentUpsertWithWhereUniqueWithoutOrderInput | OrderAttachmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderAttachmentCreateManyOrderInputEnvelope
    set?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    disconnect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    delete?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    connect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    update?: OrderAttachmentUpdateWithWhereUniqueWithoutOrderInput | OrderAttachmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderAttachmentUpdateManyWithWhereWithoutOrderInput | OrderAttachmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderAttachmentScalarWhereInput | OrderAttachmentScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<OrderCreateWithoutAttachmentsInput, OrderUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAttachmentsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<OrderCreateWithoutAttachmentsInput, OrderUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAttachmentsInput
    upsert?: OrderUpsertWithoutAttachmentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutAttachmentsInput, OrderUpdateWithoutAttachmentsInput>, OrderUncheckedUpdateWithoutAttachmentsInput>
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderCreateNestedManyWithoutExpeditorInput = {
    create?: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput> | OrderCreateWithoutExpeditorInput[] | OrderUncheckedCreateWithoutExpeditorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutExpeditorInput | OrderCreateOrConnectWithoutExpeditorInput[]
    createMany?: OrderCreateManyExpeditorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutExpeditorInput = {
    create?: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput> | OrderCreateWithoutExpeditorInput[] | OrderUncheckedCreateWithoutExpeditorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutExpeditorInput | OrderCreateOrConnectWithoutExpeditorInput[]
    createMany?: OrderCreateManyExpeditorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutExpeditorNestedInput = {
    create?: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput> | OrderCreateWithoutExpeditorInput[] | OrderUncheckedCreateWithoutExpeditorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutExpeditorInput | OrderCreateOrConnectWithoutExpeditorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutExpeditorInput | OrderUpsertWithWhereUniqueWithoutExpeditorInput[]
    createMany?: OrderCreateManyExpeditorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutExpeditorInput | OrderUpdateWithWhereUniqueWithoutExpeditorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutExpeditorInput | OrderUpdateManyWithWhereWithoutExpeditorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutExpeditorNestedInput = {
    create?: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput> | OrderCreateWithoutExpeditorInput[] | OrderUncheckedCreateWithoutExpeditorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutExpeditorInput | OrderCreateOrConnectWithoutExpeditorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutExpeditorInput | OrderUpsertWithWhereUniqueWithoutExpeditorInput[]
    createMany?: OrderCreateManyExpeditorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutExpeditorInput | OrderUpdateWithWhereUniqueWithoutExpeditorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutExpeditorInput | OrderUpdateManyWithWhereWithoutExpeditorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutStockInput = {
    create?: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutStockNestedInput = {
    create?: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockInput
    upsert?: ProductUpsertWithoutStockInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockInput, ProductUpdateWithoutStockInput>, ProductUncheckedUpdateWithoutStockInput>
  }

  export type OrderCreateNestedOneWithoutStockTransactionsInput = {
    create?: XOR<OrderCreateWithoutStockTransactionsInput, OrderUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStockTransactionsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutStockTransactionsInput = {
    create?: XOR<ProductCreateWithoutStockTransactionsInput, ProductUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockTransactionsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneWithoutStockTransactionsNestedInput = {
    create?: XOR<OrderCreateWithoutStockTransactionsInput, OrderUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStockTransactionsInput
    upsert?: OrderUpsertWithoutStockTransactionsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutStockTransactionsInput, OrderUpdateWithoutStockTransactionsInput>, OrderUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type ProductUpdateOneRequiredWithoutStockTransactionsNestedInput = {
    create?: XOR<ProductCreateWithoutStockTransactionsInput, ProductUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockTransactionsInput
    upsert?: ProductUpsertWithoutStockTransactionsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockTransactionsInput, ProductUpdateWithoutStockTransactionsInput>, ProductUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type CustomerCreateNestedOneWithoutSummaryJournalEntriesInput = {
    create?: XOR<CustomerCreateWithoutSummaryJournalEntriesInput, CustomerUncheckedCreateWithoutSummaryJournalEntriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSummaryJournalEntriesInput
    connect?: CustomerWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSummaryJournalEntriesInput = {
    create?: XOR<ProductCreateWithoutSummaryJournalEntriesInput, ProductUncheckedCreateWithoutSummaryJournalEntriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSummaryJournalEntriesInput
    connect?: ProductWhereUniqueInput
  }

  export type CustomerUpdateOneWithoutSummaryJournalEntriesNestedInput = {
    create?: XOR<CustomerCreateWithoutSummaryJournalEntriesInput, CustomerUncheckedCreateWithoutSummaryJournalEntriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSummaryJournalEntriesInput
    upsert?: CustomerUpsertWithoutSummaryJournalEntriesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSummaryJournalEntriesInput, CustomerUpdateWithoutSummaryJournalEntriesInput>, CustomerUncheckedUpdateWithoutSummaryJournalEntriesInput>
  }

  export type ProductUpdateOneWithoutSummaryJournalEntriesNestedInput = {
    create?: XOR<ProductCreateWithoutSummaryJournalEntriesInput, ProductUncheckedCreateWithoutSummaryJournalEntriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSummaryJournalEntriesInput
    upsert?: ProductUpsertWithoutSummaryJournalEntriesInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSummaryJournalEntriesInput, ProductUpdateWithoutSummaryJournalEntriesInput>, ProductUncheckedUpdateWithoutSummaryJournalEntriesInput>
  }

  export type UserCreateNestedOneWithoutProductionStaffInput = {
    create?: XOR<UserCreateWithoutProductionStaffInput, UserUncheckedCreateWithoutProductionStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionStaffInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionJournalCreateNestedManyWithoutStaffInput = {
    create?: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput> | ProductionJournalCreateWithoutStaffInput[] | ProductionJournalUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutStaffInput | ProductionJournalCreateOrConnectWithoutStaffInput[]
    createMany?: ProductionJournalCreateManyStaffInputEnvelope
    connect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
  }

  export type ProductionJournalUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput> | ProductionJournalCreateWithoutStaffInput[] | ProductionJournalUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutStaffInput | ProductionJournalCreateOrConnectWithoutStaffInput[]
    createMany?: ProductionJournalCreateManyStaffInputEnvelope
    connect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutProductionStaffNestedInput = {
    create?: XOR<UserCreateWithoutProductionStaffInput, UserUncheckedCreateWithoutProductionStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionStaffInput
    upsert?: UserUpsertWithoutProductionStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductionStaffInput, UserUpdateWithoutProductionStaffInput>, UserUncheckedUpdateWithoutProductionStaffInput>
  }

  export type ProductionJournalUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput> | ProductionJournalCreateWithoutStaffInput[] | ProductionJournalUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutStaffInput | ProductionJournalCreateOrConnectWithoutStaffInput[]
    upsert?: ProductionJournalUpsertWithWhereUniqueWithoutStaffInput | ProductionJournalUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ProductionJournalCreateManyStaffInputEnvelope
    set?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    disconnect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    delete?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    connect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    update?: ProductionJournalUpdateWithWhereUniqueWithoutStaffInput | ProductionJournalUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ProductionJournalUpdateManyWithWhereWithoutStaffInput | ProductionJournalUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ProductionJournalScalarWhereInput | ProductionJournalScalarWhereInput[]
  }

  export type ProductionJournalUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput> | ProductionJournalCreateWithoutStaffInput[] | ProductionJournalUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutStaffInput | ProductionJournalCreateOrConnectWithoutStaffInput[]
    upsert?: ProductionJournalUpsertWithWhereUniqueWithoutStaffInput | ProductionJournalUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ProductionJournalCreateManyStaffInputEnvelope
    set?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    disconnect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    delete?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    connect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    update?: ProductionJournalUpdateWithWhereUniqueWithoutStaffInput | ProductionJournalUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ProductionJournalUpdateManyWithWhereWithoutStaffInput | ProductionJournalUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ProductionJournalScalarWhereInput | ProductionJournalScalarWhereInput[]
  }

  export type ProductionStaffCreateNestedOneWithoutJournalsInput = {
    create?: XOR<ProductionStaffCreateWithoutJournalsInput, ProductionStaffUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutJournalsInput
    connect?: ProductionStaffWhereUniqueInput
  }

  export type ProductionItemCreateNestedManyWithoutJournalInput = {
    create?: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput> | ProductionItemCreateWithoutJournalInput[] | ProductionItemUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutJournalInput | ProductionItemCreateOrConnectWithoutJournalInput[]
    createMany?: ProductionItemCreateManyJournalInputEnvelope
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
  }

  export type ProductionItemUncheckedCreateNestedManyWithoutJournalInput = {
    create?: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput> | ProductionItemCreateWithoutJournalInput[] | ProductionItemUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutJournalInput | ProductionItemCreateOrConnectWithoutJournalInput[]
    createMany?: ProductionItemCreateManyJournalInputEnvelope
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
  }

  export type ProductionStaffUpdateOneRequiredWithoutJournalsNestedInput = {
    create?: XOR<ProductionStaffCreateWithoutJournalsInput, ProductionStaffUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutJournalsInput
    upsert?: ProductionStaffUpsertWithoutJournalsInput
    connect?: ProductionStaffWhereUniqueInput
    update?: XOR<XOR<ProductionStaffUpdateToOneWithWhereWithoutJournalsInput, ProductionStaffUpdateWithoutJournalsInput>, ProductionStaffUncheckedUpdateWithoutJournalsInput>
  }

  export type ProductionItemUpdateManyWithoutJournalNestedInput = {
    create?: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput> | ProductionItemCreateWithoutJournalInput[] | ProductionItemUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutJournalInput | ProductionItemCreateOrConnectWithoutJournalInput[]
    upsert?: ProductionItemUpsertWithWhereUniqueWithoutJournalInput | ProductionItemUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: ProductionItemCreateManyJournalInputEnvelope
    set?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    disconnect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    delete?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    update?: ProductionItemUpdateWithWhereUniqueWithoutJournalInput | ProductionItemUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: ProductionItemUpdateManyWithWhereWithoutJournalInput | ProductionItemUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
  }

  export type ProductionItemUncheckedUpdateManyWithoutJournalNestedInput = {
    create?: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput> | ProductionItemCreateWithoutJournalInput[] | ProductionItemUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutJournalInput | ProductionItemCreateOrConnectWithoutJournalInput[]
    upsert?: ProductionItemUpsertWithWhereUniqueWithoutJournalInput | ProductionItemUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: ProductionItemCreateManyJournalInputEnvelope
    set?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    disconnect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    delete?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    update?: ProductionItemUpdateWithWhereUniqueWithoutJournalInput | ProductionItemUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: ProductionItemUpdateManyWithWhereWithoutJournalInput | ProductionItemUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
  }

  export type ProductionJournalCreateNestedOneWithoutItemsInput = {
    create?: XOR<ProductionJournalCreateWithoutItemsInput, ProductionJournalUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutItemsInput
    connect?: ProductionJournalWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProductionItemsInput = {
    create?: XOR<ProductCreateWithoutProductionItemsInput, ProductUncheckedCreateWithoutProductionItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductionItemValueCreateNestedManyWithoutProductionItemInput = {
    create?: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput> | ProductionItemValueCreateWithoutProductionItemInput[] | ProductionItemValueUncheckedCreateWithoutProductionItemInput[]
    connectOrCreate?: ProductionItemValueCreateOrConnectWithoutProductionItemInput | ProductionItemValueCreateOrConnectWithoutProductionItemInput[]
    createMany?: ProductionItemValueCreateManyProductionItemInputEnvelope
    connect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
  }

  export type ProductionItemValueUncheckedCreateNestedManyWithoutProductionItemInput = {
    create?: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput> | ProductionItemValueCreateWithoutProductionItemInput[] | ProductionItemValueUncheckedCreateWithoutProductionItemInput[]
    connectOrCreate?: ProductionItemValueCreateOrConnectWithoutProductionItemInput | ProductionItemValueCreateOrConnectWithoutProductionItemInput[]
    createMany?: ProductionItemValueCreateManyProductionItemInputEnvelope
    connect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
  }

  export type ProductionJournalUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ProductionJournalCreateWithoutItemsInput, ProductionJournalUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutItemsInput
    upsert?: ProductionJournalUpsertWithoutItemsInput
    connect?: ProductionJournalWhereUniqueInput
    update?: XOR<XOR<ProductionJournalUpdateToOneWithWhereWithoutItemsInput, ProductionJournalUpdateWithoutItemsInput>, ProductionJournalUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneWithoutProductionItemsNestedInput = {
    create?: XOR<ProductCreateWithoutProductionItemsInput, ProductUncheckedCreateWithoutProductionItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionItemsInput
    upsert?: ProductUpsertWithoutProductionItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductionItemsInput, ProductUpdateWithoutProductionItemsInput>, ProductUncheckedUpdateWithoutProductionItemsInput>
  }

  export type ProductionItemValueUpdateManyWithoutProductionItemNestedInput = {
    create?: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput> | ProductionItemValueCreateWithoutProductionItemInput[] | ProductionItemValueUncheckedCreateWithoutProductionItemInput[]
    connectOrCreate?: ProductionItemValueCreateOrConnectWithoutProductionItemInput | ProductionItemValueCreateOrConnectWithoutProductionItemInput[]
    upsert?: ProductionItemValueUpsertWithWhereUniqueWithoutProductionItemInput | ProductionItemValueUpsertWithWhereUniqueWithoutProductionItemInput[]
    createMany?: ProductionItemValueCreateManyProductionItemInputEnvelope
    set?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    disconnect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    delete?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    connect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    update?: ProductionItemValueUpdateWithWhereUniqueWithoutProductionItemInput | ProductionItemValueUpdateWithWhereUniqueWithoutProductionItemInput[]
    updateMany?: ProductionItemValueUpdateManyWithWhereWithoutProductionItemInput | ProductionItemValueUpdateManyWithWhereWithoutProductionItemInput[]
    deleteMany?: ProductionItemValueScalarWhereInput | ProductionItemValueScalarWhereInput[]
  }

  export type ProductionItemValueUncheckedUpdateManyWithoutProductionItemNestedInput = {
    create?: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput> | ProductionItemValueCreateWithoutProductionItemInput[] | ProductionItemValueUncheckedCreateWithoutProductionItemInput[]
    connectOrCreate?: ProductionItemValueCreateOrConnectWithoutProductionItemInput | ProductionItemValueCreateOrConnectWithoutProductionItemInput[]
    upsert?: ProductionItemValueUpsertWithWhereUniqueWithoutProductionItemInput | ProductionItemValueUpsertWithWhereUniqueWithoutProductionItemInput[]
    createMany?: ProductionItemValueCreateManyProductionItemInputEnvelope
    set?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    disconnect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    delete?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    connect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    update?: ProductionItemValueUpdateWithWhereUniqueWithoutProductionItemInput | ProductionItemValueUpdateWithWhereUniqueWithoutProductionItemInput[]
    updateMany?: ProductionItemValueUpdateManyWithWhereWithoutProductionItemInput | ProductionItemValueUpdateManyWithWhereWithoutProductionItemInput[]
    deleteMany?: ProductionItemValueScalarWhereInput | ProductionItemValueScalarWhereInput[]
  }

  export type ProductionItemCreateNestedOneWithoutValuesInput = {
    create?: XOR<ProductionItemCreateWithoutValuesInput, ProductionItemUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductionItemCreateOrConnectWithoutValuesInput
    connect?: ProductionItemWhereUniqueInput
  }

  export type ProductionItemUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<ProductionItemCreateWithoutValuesInput, ProductionItemUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductionItemCreateOrConnectWithoutValuesInput
    upsert?: ProductionItemUpsertWithoutValuesInput
    connect?: ProductionItemWhereUniqueInput
    update?: XOR<XOR<ProductionItemUpdateToOneWithWhereWithoutValuesInput, ProductionItemUpdateWithoutValuesInput>, ProductionItemUncheckedUpdateWithoutValuesInput>
  }

  export type PurchasePriceListSupplierCreateNestedManyWithoutPriceListInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput> | PurchasePriceListSupplierCreateWithoutPriceListInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput | PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput[]
    createMany?: PurchasePriceListSupplierCreateManyPriceListInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type PurchasePriceItemCreateNestedManyWithoutPriceListInput = {
    create?: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput> | PurchasePriceItemCreateWithoutPriceListInput[] | PurchasePriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutPriceListInput | PurchasePriceItemCreateOrConnectWithoutPriceListInput[]
    createMany?: PurchasePriceItemCreateManyPriceListInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPriceListInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput> | PurchasePriceListSupplierCreateWithoutPriceListInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput | PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput[]
    createMany?: PurchasePriceListSupplierCreateManyPriceListInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type PurchasePriceItemUncheckedCreateNestedManyWithoutPriceListInput = {
    create?: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput> | PurchasePriceItemCreateWithoutPriceListInput[] | PurchasePriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutPriceListInput | PurchasePriceItemCreateOrConnectWithoutPriceListInput[]
    createMany?: PurchasePriceItemCreateManyPriceListInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput> | PurchasePriceListSupplierCreateWithoutPriceListInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput | PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPriceListInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: PurchasePriceListSupplierCreateManyPriceListInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPriceListInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutPriceListInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type PurchasePriceItemUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput> | PurchasePriceItemCreateWithoutPriceListInput[] | PurchasePriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutPriceListInput | PurchasePriceItemCreateOrConnectWithoutPriceListInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutPriceListInput | PurchasePriceItemUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: PurchasePriceItemCreateManyPriceListInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutPriceListInput | PurchasePriceItemUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutPriceListInput | PurchasePriceItemUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput> | PurchasePriceListSupplierCreateWithoutPriceListInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput | PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPriceListInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: PurchasePriceListSupplierCreateManyPriceListInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPriceListInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutPriceListInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput> | PurchasePriceItemCreateWithoutPriceListInput[] | PurchasePriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutPriceListInput | PurchasePriceItemCreateOrConnectWithoutPriceListInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutPriceListInput | PurchasePriceItemUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: PurchasePriceItemCreateManyPriceListInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutPriceListInput | PurchasePriceItemUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutPriceListInput | PurchasePriceItemUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type PurchasePriceListCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<PurchasePriceListCreateWithoutSuppliersInput, PurchasePriceListUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: PurchasePriceListCreateOrConnectWithoutSuppliersInput
    connect?: PurchasePriceListWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchasePriceListSuppliersInput = {
    create?: XOR<SupplierCreateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedCreateWithoutPurchasePriceListSuppliersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasePriceListSuppliersInput
    connect?: SupplierWhereUniqueInput
  }

  export type ProductionMmlCreateNestedOneWithoutPriceListSuppliersInput = {
    create?: XOR<ProductionMmlCreateWithoutPriceListSuppliersInput, ProductionMmlUncheckedCreateWithoutPriceListSuppliersInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutPriceListSuppliersInput
    connect?: ProductionMmlWhereUniqueInput
  }

  export type PurchasePriceListUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<PurchasePriceListCreateWithoutSuppliersInput, PurchasePriceListUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: PurchasePriceListCreateOrConnectWithoutSuppliersInput
    upsert?: PurchasePriceListUpsertWithoutSuppliersInput
    connect?: PurchasePriceListWhereUniqueInput
    update?: XOR<XOR<PurchasePriceListUpdateToOneWithWhereWithoutSuppliersInput, PurchasePriceListUpdateWithoutSuppliersInput>, PurchasePriceListUncheckedUpdateWithoutSuppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutPurchasePriceListSuppliersNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedCreateWithoutPurchasePriceListSuppliersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasePriceListSuppliersInput
    upsert?: SupplierUpsertWithoutPurchasePriceListSuppliersInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchasePriceListSuppliersInput, SupplierUpdateWithoutPurchasePriceListSuppliersInput>, SupplierUncheckedUpdateWithoutPurchasePriceListSuppliersInput>
  }

  export type ProductionMmlUpdateOneWithoutPriceListSuppliersNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutPriceListSuppliersInput, ProductionMmlUncheckedCreateWithoutPriceListSuppliersInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutPriceListSuppliersInput
    upsert?: ProductionMmlUpsertWithoutPriceListSuppliersInput
    disconnect?: ProductionMmlWhereInput | boolean
    delete?: ProductionMmlWhereInput | boolean
    connect?: ProductionMmlWhereUniqueInput
    update?: XOR<XOR<ProductionMmlUpdateToOneWithWhereWithoutPriceListSuppliersInput, ProductionMmlUpdateWithoutPriceListSuppliersInput>, ProductionMmlUncheckedUpdateWithoutPriceListSuppliersInput>
  }

  export type PurchasePriceListCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchasePriceListCreateWithoutItemsInput, PurchasePriceListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchasePriceListCreateOrConnectWithoutItemsInput
    connect?: PurchasePriceListWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchasePriceItemsInput = {
    create?: XOR<SupplierCreateWithoutPurchasePriceItemsInput, SupplierUncheckedCreateWithoutPurchasePriceItemsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasePriceItemsInput
    connect?: SupplierWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchasePriceItemsInput = {
    create?: XOR<ProductCreateWithoutPurchasePriceItemsInput, ProductUncheckedCreateWithoutPurchasePriceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchasePriceItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type PurchasePriceListUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchasePriceListCreateWithoutItemsInput, PurchasePriceListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchasePriceListCreateOrConnectWithoutItemsInput
    upsert?: PurchasePriceListUpsertWithoutItemsInput
    connect?: PurchasePriceListWhereUniqueInput
    update?: XOR<XOR<PurchasePriceListUpdateToOneWithWhereWithoutItemsInput, PurchasePriceListUpdateWithoutItemsInput>, PurchasePriceListUncheckedUpdateWithoutItemsInput>
  }

  export type SupplierUpdateOneRequiredWithoutPurchasePriceItemsNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchasePriceItemsInput, SupplierUncheckedCreateWithoutPurchasePriceItemsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasePriceItemsInput
    upsert?: SupplierUpsertWithoutPurchasePriceItemsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchasePriceItemsInput, SupplierUpdateWithoutPurchasePriceItemsInput>, SupplierUncheckedUpdateWithoutPurchasePriceItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchasePriceItemsNestedInput = {
    create?: XOR<ProductCreateWithoutPurchasePriceItemsInput, ProductUncheckedCreateWithoutPurchasePriceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchasePriceItemsInput
    upsert?: ProductUpsertWithoutPurchasePriceItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchasePriceItemsInput, ProductUpdateWithoutPurchasePriceItemsInput>, ProductUncheckedUpdateWithoutPurchasePriceItemsInput>
  }

  export type CustomerCreateNestedOneWithoutSalesPriceListsInput = {
    create?: XOR<CustomerCreateWithoutSalesPriceListsInput, CustomerUncheckedCreateWithoutSalesPriceListsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesPriceListsInput
    connect?: CustomerWhereUniqueInput
  }

  export type SalesPriceItemCreateNestedManyWithoutPriceListInput = {
    create?: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput> | SalesPriceItemCreateWithoutPriceListInput[] | SalesPriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutPriceListInput | SalesPriceItemCreateOrConnectWithoutPriceListInput[]
    createMany?: SalesPriceItemCreateManyPriceListInputEnvelope
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
  }

  export type SalesPriceItemUncheckedCreateNestedManyWithoutPriceListInput = {
    create?: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput> | SalesPriceItemCreateWithoutPriceListInput[] | SalesPriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutPriceListInput | SalesPriceItemCreateOrConnectWithoutPriceListInput[]
    createMany?: SalesPriceItemCreateManyPriceListInputEnvelope
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutSalesPriceListsNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesPriceListsInput, CustomerUncheckedCreateWithoutSalesPriceListsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesPriceListsInput
    upsert?: CustomerUpsertWithoutSalesPriceListsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesPriceListsInput, CustomerUpdateWithoutSalesPriceListsInput>, CustomerUncheckedUpdateWithoutSalesPriceListsInput>
  }

  export type SalesPriceItemUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput> | SalesPriceItemCreateWithoutPriceListInput[] | SalesPriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutPriceListInput | SalesPriceItemCreateOrConnectWithoutPriceListInput[]
    upsert?: SalesPriceItemUpsertWithWhereUniqueWithoutPriceListInput | SalesPriceItemUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: SalesPriceItemCreateManyPriceListInputEnvelope
    set?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    disconnect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    delete?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    update?: SalesPriceItemUpdateWithWhereUniqueWithoutPriceListInput | SalesPriceItemUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: SalesPriceItemUpdateManyWithWhereWithoutPriceListInput | SalesPriceItemUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
  }

  export type SalesPriceItemUncheckedUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput> | SalesPriceItemCreateWithoutPriceListInput[] | SalesPriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutPriceListInput | SalesPriceItemCreateOrConnectWithoutPriceListInput[]
    upsert?: SalesPriceItemUpsertWithWhereUniqueWithoutPriceListInput | SalesPriceItemUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: SalesPriceItemCreateManyPriceListInputEnvelope
    set?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    disconnect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    delete?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    update?: SalesPriceItemUpdateWithWhereUniqueWithoutPriceListInput | SalesPriceItemUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: SalesPriceItemUpdateManyWithWhereWithoutPriceListInput | SalesPriceItemUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
  }

  export type SalesPriceListCreateNestedOneWithoutItemsInput = {
    create?: XOR<SalesPriceListCreateWithoutItemsInput, SalesPriceListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutItemsInput
    connect?: SalesPriceListWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSalesPriceItemsInput = {
    create?: XOR<ProductCreateWithoutSalesPriceItemsInput, ProductUncheckedCreateWithoutSalesPriceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSalesPriceItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type SalesPriceListUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SalesPriceListCreateWithoutItemsInput, SalesPriceListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutItemsInput
    upsert?: SalesPriceListUpsertWithoutItemsInput
    connect?: SalesPriceListWhereUniqueInput
    update?: XOR<XOR<SalesPriceListUpdateToOneWithWhereWithoutItemsInput, SalesPriceListUpdateWithoutItemsInput>, SalesPriceListUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutSalesPriceItemsNestedInput = {
    create?: XOR<ProductCreateWithoutSalesPriceItemsInput, ProductUncheckedCreateWithoutSalesPriceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSalesPriceItemsInput
    upsert?: ProductUpsertWithoutSalesPriceItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSalesPriceItemsInput, ProductUpdateWithoutSalesPriceItemsInput>, ProductUncheckedUpdateWithoutSalesPriceItemsInput>
  }

  export type ProductCreateNestedOneWithoutProductionMmlsInput = {
    create?: XOR<ProductCreateWithoutProductionMmlsInput, ProductUncheckedCreateWithoutProductionMmlsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionMmlsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedMmlsInput = {
    create?: XOR<UserCreateWithoutCreatedMmlsInput, UserUncheckedCreateWithoutCreatedMmlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedMmlsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionMmlNodeCreateNestedManyWithoutMmlInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput> | ProductionMmlNodeCreateWithoutMmlInput[] | ProductionMmlNodeUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutMmlInput | ProductionMmlNodeCreateOrConnectWithoutMmlInput[]
    createMany?: ProductionMmlNodeCreateManyMmlInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductionRunCreateNestedManyWithoutMmlInput = {
    create?: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput> | ProductionRunCreateWithoutMmlInput[] | ProductionRunUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutMmlInput | ProductionRunCreateOrConnectWithoutMmlInput[]
    createMany?: ProductionRunCreateManyMmlInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutPrimaryMmlInput = {
    create?: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput> | SupplierCreateWithoutPrimaryMmlInput[] | SupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutPrimaryMmlInput | SupplierCreateOrConnectWithoutPrimaryMmlInput[]
    createMany?: SupplierCreateManyPrimaryMmlInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput> | PurchasePriceListSupplierCreateWithoutPrimaryMmlInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput | PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput[]
    createMany?: PurchasePriceListSupplierCreateManyPrimaryMmlInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput> | ProductionMmlNodeCreateWithoutMmlInput[] | ProductionMmlNodeUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutMmlInput | ProductionMmlNodeCreateOrConnectWithoutMmlInput[]
    createMany?: ProductionMmlNodeCreateManyMmlInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductionRunUncheckedCreateNestedManyWithoutMmlInput = {
    create?: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput> | ProductionRunCreateWithoutMmlInput[] | ProductionRunUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutMmlInput | ProductionRunCreateOrConnectWithoutMmlInput[]
    createMany?: ProductionRunCreateManyMmlInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput = {
    create?: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput> | SupplierCreateWithoutPrimaryMmlInput[] | SupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutPrimaryMmlInput | SupplierCreateOrConnectWithoutPrimaryMmlInput[]
    createMany?: SupplierCreateManyPrimaryMmlInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput> | PurchasePriceListSupplierCreateWithoutPrimaryMmlInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput | PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput[]
    createMany?: PurchasePriceListSupplierCreateManyPrimaryMmlInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutProductionMmlsNestedInput = {
    create?: XOR<ProductCreateWithoutProductionMmlsInput, ProductUncheckedCreateWithoutProductionMmlsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionMmlsInput
    upsert?: ProductUpsertWithoutProductionMmlsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductionMmlsInput, ProductUpdateWithoutProductionMmlsInput>, ProductUncheckedUpdateWithoutProductionMmlsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedMmlsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedMmlsInput, UserUncheckedCreateWithoutCreatedMmlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedMmlsInput
    upsert?: UserUpsertWithoutCreatedMmlsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedMmlsInput, UserUpdateWithoutCreatedMmlsInput>, UserUncheckedUpdateWithoutCreatedMmlsInput>
  }

  export type ProductionMmlNodeUpdateManyWithoutMmlNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput> | ProductionMmlNodeCreateWithoutMmlInput[] | ProductionMmlNodeUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutMmlInput | ProductionMmlNodeCreateOrConnectWithoutMmlInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutMmlInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutMmlInput[]
    createMany?: ProductionMmlNodeCreateManyMmlInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutMmlInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutMmlInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutMmlInput | ProductionMmlNodeUpdateManyWithWhereWithoutMmlInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductionRunUpdateManyWithoutMmlNestedInput = {
    create?: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput> | ProductionRunCreateWithoutMmlInput[] | ProductionRunUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutMmlInput | ProductionRunCreateOrConnectWithoutMmlInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutMmlInput | ProductionRunUpsertWithWhereUniqueWithoutMmlInput[]
    createMany?: ProductionRunCreateManyMmlInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutMmlInput | ProductionRunUpdateWithWhereUniqueWithoutMmlInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutMmlInput | ProductionRunUpdateManyWithWhereWithoutMmlInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutPrimaryMmlNestedInput = {
    create?: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput> | SupplierCreateWithoutPrimaryMmlInput[] | SupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutPrimaryMmlInput | SupplierCreateOrConnectWithoutPrimaryMmlInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput | SupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput[]
    createMany?: SupplierCreateManyPrimaryMmlInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput | SupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutPrimaryMmlInput | SupplierUpdateManyWithWhereWithoutPrimaryMmlInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput> | PurchasePriceListSupplierCreateWithoutPrimaryMmlInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput | PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput[]
    createMany?: PurchasePriceListSupplierCreateManyPrimaryMmlInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutPrimaryMmlInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutPrimaryMmlInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput> | ProductionMmlNodeCreateWithoutMmlInput[] | ProductionMmlNodeUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutMmlInput | ProductionMmlNodeCreateOrConnectWithoutMmlInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutMmlInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutMmlInput[]
    createMany?: ProductionMmlNodeCreateManyMmlInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutMmlInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutMmlInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutMmlInput | ProductionMmlNodeUpdateManyWithWhereWithoutMmlInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductionRunUncheckedUpdateManyWithoutMmlNestedInput = {
    create?: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput> | ProductionRunCreateWithoutMmlInput[] | ProductionRunUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutMmlInput | ProductionRunCreateOrConnectWithoutMmlInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutMmlInput | ProductionRunUpsertWithWhereUniqueWithoutMmlInput[]
    createMany?: ProductionRunCreateManyMmlInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutMmlInput | ProductionRunUpdateWithWhereUniqueWithoutMmlInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutMmlInput | ProductionRunUpdateManyWithWhereWithoutMmlInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput = {
    create?: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput> | SupplierCreateWithoutPrimaryMmlInput[] | SupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutPrimaryMmlInput | SupplierCreateOrConnectWithoutPrimaryMmlInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput | SupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput[]
    createMany?: SupplierCreateManyPrimaryMmlInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput | SupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutPrimaryMmlInput | SupplierUpdateManyWithWhereWithoutPrimaryMmlInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput> | PurchasePriceListSupplierCreateWithoutPrimaryMmlInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput | PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput[]
    createMany?: PurchasePriceListSupplierCreateManyPrimaryMmlInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutPrimaryMmlInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutPrimaryMmlInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type ProductionMmlCreateNestedOneWithoutNodesInput = {
    create?: XOR<ProductionMmlCreateWithoutNodesInput, ProductionMmlUncheckedCreateWithoutNodesInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutNodesInput
    connect?: ProductionMmlWhereUniqueInput
  }

  export type ProductionMmlNodeCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutChildrenInput, ProductionMmlNodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutChildrenInput
    connect?: ProductionMmlNodeWhereUniqueInput
  }

  export type ProductionMmlNodeCreateNestedManyWithoutParentNodeInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput> | ProductionMmlNodeCreateWithoutParentNodeInput[] | ProductionMmlNodeUncheckedCreateWithoutParentNodeInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutParentNodeInput | ProductionMmlNodeCreateOrConnectWithoutParentNodeInput[]
    createMany?: ProductionMmlNodeCreateManyParentNodeInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductCreateNestedOneWithoutMmlNodesInput = {
    create?: XOR<ProductCreateWithoutMmlNodesInput, ProductUncheckedCreateWithoutMmlNodesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMmlNodesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductionRunValueCreateNestedManyWithoutNodeInput = {
    create?: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput> | ProductionRunValueCreateWithoutNodeInput[] | ProductionRunValueUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutNodeInput | ProductionRunValueCreateOrConnectWithoutNodeInput[]
    createMany?: ProductionRunValueCreateManyNodeInputEnvelope
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
  }

  export type ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput> | ProductionMmlNodeCreateWithoutParentNodeInput[] | ProductionMmlNodeUncheckedCreateWithoutParentNodeInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutParentNodeInput | ProductionMmlNodeCreateOrConnectWithoutParentNodeInput[]
    createMany?: ProductionMmlNodeCreateManyParentNodeInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput = {
    create?: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput> | ProductionRunValueCreateWithoutNodeInput[] | ProductionRunValueUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutNodeInput | ProductionRunValueCreateOrConnectWithoutNodeInput[]
    createMany?: ProductionRunValueCreateManyNodeInputEnvelope
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
  }

  export type ProductionMmlUpdateOneRequiredWithoutNodesNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutNodesInput, ProductionMmlUncheckedCreateWithoutNodesInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutNodesInput
    upsert?: ProductionMmlUpsertWithoutNodesInput
    connect?: ProductionMmlWhereUniqueInput
    update?: XOR<XOR<ProductionMmlUpdateToOneWithWhereWithoutNodesInput, ProductionMmlUpdateWithoutNodesInput>, ProductionMmlUncheckedUpdateWithoutNodesInput>
  }

  export type ProductionMmlNodeUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutChildrenInput, ProductionMmlNodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutChildrenInput
    upsert?: ProductionMmlNodeUpsertWithoutChildrenInput
    disconnect?: ProductionMmlNodeWhereInput | boolean
    delete?: ProductionMmlNodeWhereInput | boolean
    connect?: ProductionMmlNodeWhereUniqueInput
    update?: XOR<XOR<ProductionMmlNodeUpdateToOneWithWhereWithoutChildrenInput, ProductionMmlNodeUpdateWithoutChildrenInput>, ProductionMmlNodeUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput> | ProductionMmlNodeCreateWithoutParentNodeInput[] | ProductionMmlNodeUncheckedCreateWithoutParentNodeInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutParentNodeInput | ProductionMmlNodeCreateOrConnectWithoutParentNodeInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutParentNodeInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutParentNodeInput[]
    createMany?: ProductionMmlNodeCreateManyParentNodeInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutParentNodeInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutParentNodeInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutParentNodeInput | ProductionMmlNodeUpdateManyWithWhereWithoutParentNodeInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductUpdateOneRequiredWithoutMmlNodesNestedInput = {
    create?: XOR<ProductCreateWithoutMmlNodesInput, ProductUncheckedCreateWithoutMmlNodesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMmlNodesInput
    upsert?: ProductUpsertWithoutMmlNodesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutMmlNodesInput, ProductUpdateWithoutMmlNodesInput>, ProductUncheckedUpdateWithoutMmlNodesInput>
  }

  export type ProductionRunValueUpdateManyWithoutNodeNestedInput = {
    create?: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput> | ProductionRunValueCreateWithoutNodeInput[] | ProductionRunValueUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutNodeInput | ProductionRunValueCreateOrConnectWithoutNodeInput[]
    upsert?: ProductionRunValueUpsertWithWhereUniqueWithoutNodeInput | ProductionRunValueUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: ProductionRunValueCreateManyNodeInputEnvelope
    set?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    disconnect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    delete?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    update?: ProductionRunValueUpdateWithWhereUniqueWithoutNodeInput | ProductionRunValueUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: ProductionRunValueUpdateManyWithWhereWithoutNodeInput | ProductionRunValueUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput> | ProductionMmlNodeCreateWithoutParentNodeInput[] | ProductionMmlNodeUncheckedCreateWithoutParentNodeInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutParentNodeInput | ProductionMmlNodeCreateOrConnectWithoutParentNodeInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutParentNodeInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutParentNodeInput[]
    createMany?: ProductionMmlNodeCreateManyParentNodeInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutParentNodeInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutParentNodeInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutParentNodeInput | ProductionMmlNodeUpdateManyWithWhereWithoutParentNodeInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput = {
    create?: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput> | ProductionRunValueCreateWithoutNodeInput[] | ProductionRunValueUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutNodeInput | ProductionRunValueCreateOrConnectWithoutNodeInput[]
    upsert?: ProductionRunValueUpsertWithWhereUniqueWithoutNodeInput | ProductionRunValueUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: ProductionRunValueCreateManyNodeInputEnvelope
    set?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    disconnect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    delete?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    update?: ProductionRunValueUpdateWithWhereUniqueWithoutNodeInput | ProductionRunValueUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: ProductionRunValueUpdateManyWithWhereWithoutNodeInput | ProductionRunValueUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductionRunsInput = {
    create?: XOR<ProductCreateWithoutProductionRunsInput, ProductUncheckedCreateWithoutProductionRunsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionRunsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductionMmlCreateNestedOneWithoutRunsInput = {
    create?: XOR<ProductionMmlCreateWithoutRunsInput, ProductionMmlUncheckedCreateWithoutRunsInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutRunsInput
    connect?: ProductionMmlWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductionRunsInput = {
    create?: XOR<UserCreateWithoutProductionRunsInput, UserUncheckedCreateWithoutProductionRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionRunsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionRunValueCreateNestedManyWithoutRunInput = {
    create?: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput> | ProductionRunValueCreateWithoutRunInput[] | ProductionRunValueUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutRunInput | ProductionRunValueCreateOrConnectWithoutRunInput[]
    createMany?: ProductionRunValueCreateManyRunInputEnvelope
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
  }

  export type ProductionRunValueUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput> | ProductionRunValueCreateWithoutRunInput[] | ProductionRunValueUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutRunInput | ProductionRunValueCreateOrConnectWithoutRunInput[]
    createMany?: ProductionRunValueCreateManyRunInputEnvelope
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutProductionRunsNestedInput = {
    create?: XOR<ProductCreateWithoutProductionRunsInput, ProductUncheckedCreateWithoutProductionRunsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionRunsInput
    upsert?: ProductUpsertWithoutProductionRunsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductionRunsInput, ProductUpdateWithoutProductionRunsInput>, ProductUncheckedUpdateWithoutProductionRunsInput>
  }

  export type ProductionMmlUpdateOneRequiredWithoutRunsNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutRunsInput, ProductionMmlUncheckedCreateWithoutRunsInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutRunsInput
    upsert?: ProductionMmlUpsertWithoutRunsInput
    connect?: ProductionMmlWhereUniqueInput
    update?: XOR<XOR<ProductionMmlUpdateToOneWithWhereWithoutRunsInput, ProductionMmlUpdateWithoutRunsInput>, ProductionMmlUncheckedUpdateWithoutRunsInput>
  }

  export type UserUpdateOneRequiredWithoutProductionRunsNestedInput = {
    create?: XOR<UserCreateWithoutProductionRunsInput, UserUncheckedCreateWithoutProductionRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionRunsInput
    upsert?: UserUpsertWithoutProductionRunsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductionRunsInput, UserUpdateWithoutProductionRunsInput>, UserUncheckedUpdateWithoutProductionRunsInput>
  }

  export type ProductionRunValueUpdateManyWithoutRunNestedInput = {
    create?: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput> | ProductionRunValueCreateWithoutRunInput[] | ProductionRunValueUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutRunInput | ProductionRunValueCreateOrConnectWithoutRunInput[]
    upsert?: ProductionRunValueUpsertWithWhereUniqueWithoutRunInput | ProductionRunValueUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: ProductionRunValueCreateManyRunInputEnvelope
    set?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    disconnect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    delete?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    update?: ProductionRunValueUpdateWithWhereUniqueWithoutRunInput | ProductionRunValueUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: ProductionRunValueUpdateManyWithWhereWithoutRunInput | ProductionRunValueUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
  }

  export type ProductionRunValueUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput> | ProductionRunValueCreateWithoutRunInput[] | ProductionRunValueUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutRunInput | ProductionRunValueCreateOrConnectWithoutRunInput[]
    upsert?: ProductionRunValueUpsertWithWhereUniqueWithoutRunInput | ProductionRunValueUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: ProductionRunValueCreateManyRunInputEnvelope
    set?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    disconnect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    delete?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    update?: ProductionRunValueUpdateWithWhereUniqueWithoutRunInput | ProductionRunValueUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: ProductionRunValueUpdateManyWithWhereWithoutRunInput | ProductionRunValueUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
  }

  export type ProductionRunCreateNestedOneWithoutValuesInput = {
    create?: XOR<ProductionRunCreateWithoutValuesInput, ProductionRunUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductionRunCreateOrConnectWithoutValuesInput
    connect?: ProductionRunWhereUniqueInput
  }

  export type ProductionMmlNodeCreateNestedOneWithoutRunValuesInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutRunValuesInput, ProductionMmlNodeUncheckedCreateWithoutRunValuesInput>
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutRunValuesInput
    connect?: ProductionMmlNodeWhereUniqueInput
  }

  export type ProductionRunUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<ProductionRunCreateWithoutValuesInput, ProductionRunUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductionRunCreateOrConnectWithoutValuesInput
    upsert?: ProductionRunUpsertWithoutValuesInput
    connect?: ProductionRunWhereUniqueInput
    update?: XOR<XOR<ProductionRunUpdateToOneWithWhereWithoutValuesInput, ProductionRunUpdateWithoutValuesInput>, ProductionRunUncheckedUpdateWithoutValuesInput>
  }

  export type ProductionMmlNodeUpdateOneRequiredWithoutRunValuesNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutRunValuesInput, ProductionMmlNodeUncheckedCreateWithoutRunValuesInput>
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutRunValuesInput
    upsert?: ProductionMmlNodeUpsertWithoutRunValuesInput
    connect?: ProductionMmlNodeWhereUniqueInput
    update?: XOR<XOR<ProductionMmlNodeUpdateToOneWithWhereWithoutRunValuesInput, ProductionMmlNodeUpdateWithoutRunValuesInput>, ProductionMmlNodeUncheckedUpdateWithoutRunValuesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProductionStaffCreateWithoutUserInput = {
    fullName: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journals?: ProductionJournalCreateNestedManyWithoutStaffInput
  }

  export type ProductionStaffUncheckedCreateWithoutUserInput = {
    id?: number
    fullName: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journals?: ProductionJournalUncheckedCreateNestedManyWithoutStaffInput
  }

  export type ProductionStaffCreateOrConnectWithoutUserInput = {
    where: ProductionStaffWhereUniqueInput
    create: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
  }

  export type ProductionMmlCreateWithoutCreatorInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutCreatorInput = {
    id?: number
    productId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutCreatorInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput>
  }

  export type ProductionMmlCreateManyCreatorInputEnvelope = {
    data: ProductionMmlCreateManyCreatorInput | ProductionMmlCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProductionRunCreateWithoutUserInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionRunsInput
    mml: ProductionMmlCreateNestedOneWithoutRunsInput
    values?: ProductionRunValueCreateNestedManyWithoutRunInput
  }

  export type ProductionRunUncheckedCreateWithoutUserInput = {
    id?: number
    productId: number
    mmlId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: ProductionRunValueUncheckedCreateNestedManyWithoutRunInput
  }

  export type ProductionRunCreateOrConnectWithoutUserInput = {
    where: ProductionRunWhereUniqueInput
    create: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput>
  }

  export type ProductionRunCreateManyUserInputEnvelope = {
    data: ProductionRunCreateManyUserInput | ProductionRunCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductionStaffUpsertWithoutUserInput = {
    update: XOR<ProductionStaffUpdateWithoutUserInput, ProductionStaffUncheckedUpdateWithoutUserInput>
    create: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
    where?: ProductionStaffWhereInput
  }

  export type ProductionStaffUpdateToOneWithWhereWithoutUserInput = {
    where?: ProductionStaffWhereInput
    data: XOR<ProductionStaffUpdateWithoutUserInput, ProductionStaffUncheckedUpdateWithoutUserInput>
  }

  export type ProductionStaffUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: ProductionJournalUpdateManyWithoutStaffNestedInput
  }

  export type ProductionStaffUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: ProductionJournalUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type ProductionMmlUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProductionMmlWhereUniqueInput
    update: XOR<ProductionMmlUpdateWithoutCreatorInput, ProductionMmlUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput>
  }

  export type ProductionMmlUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProductionMmlWhereUniqueInput
    data: XOR<ProductionMmlUpdateWithoutCreatorInput, ProductionMmlUncheckedUpdateWithoutCreatorInput>
  }

  export type ProductionMmlUpdateManyWithWhereWithoutCreatorInput = {
    where: ProductionMmlScalarWhereInput
    data: XOR<ProductionMmlUpdateManyMutationInput, ProductionMmlUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProductionMmlScalarWhereInput = {
    AND?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
    OR?: ProductionMmlScalarWhereInput[]
    NOT?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
    id?: IntFilter<"ProductionMml"> | number
    productId?: IntFilter<"ProductionMml"> | number
    createdBy?: IntFilter<"ProductionMml"> | number
    isLocked?: BoolFilter<"ProductionMml"> | boolean
    createdAt?: DateTimeFilter<"ProductionMml"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMml"> | Date | string
  }

  export type ProductionRunUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductionRunWhereUniqueInput
    update: XOR<ProductionRunUpdateWithoutUserInput, ProductionRunUncheckedUpdateWithoutUserInput>
    create: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput>
  }

  export type ProductionRunUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductionRunWhereUniqueInput
    data: XOR<ProductionRunUpdateWithoutUserInput, ProductionRunUncheckedUpdateWithoutUserInput>
  }

  export type ProductionRunUpdateManyWithWhereWithoutUserInput = {
    where: ProductionRunScalarWhereInput
    data: XOR<ProductionRunUpdateManyMutationInput, ProductionRunUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductionRunScalarWhereInput = {
    AND?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
    OR?: ProductionRunScalarWhereInput[]
    NOT?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
    id?: IntFilter<"ProductionRun"> | number
    productId?: IntFilter<"ProductionRun"> | number
    mmlId?: IntFilter<"ProductionRun"> | number
    userId?: IntFilter<"ProductionRun"> | number
    isLocked?: BoolFilter<"ProductionRun"> | boolean
    createdAt?: DateTimeFilter<"ProductionRun"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRun"> | Date | string
  }

  export type CustomerCreateWithoutDistrictInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: ManagerCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutDistrictInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutDistrictInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput>
  }

  export type CustomerCreateManyDistrictInputEnvelope = {
    data: CustomerCreateManyDistrictInput | CustomerCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithWhereUniqueWithoutDistrictInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutDistrictInput, CustomerUncheckedUpdateWithoutDistrictInput>
    create: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutDistrictInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutDistrictInput, CustomerUncheckedUpdateWithoutDistrictInput>
  }

  export type CustomerUpdateManyWithWhereWithoutDistrictInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutDistrictInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: IntFilter<"Customer"> | number
    code?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    legalName?: StringNullableFilter<"Customer"> | string | null
    districtId?: StringNullableFilter<"Customer"> | string | null
    managerId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type CustomerCreateWithoutManagerInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: DistrictCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutManagerInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutManagerInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput>
  }

  export type CustomerCreateManyManagerInputEnvelope = {
    data: CustomerCreateManyManagerInput | CustomerCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithWhereUniqueWithoutManagerInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutManagerInput, CustomerUncheckedUpdateWithoutManagerInput>
    create: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutManagerInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutManagerInput, CustomerUncheckedUpdateWithoutManagerInput>
  }

  export type CustomerUpdateManyWithWhereWithoutManagerInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutManagerInput>
  }

  export type OrderItemCreateWithoutProductInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: number
    orderId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockCreateWithoutProductInput = {
    quantity?: number
    updatedAt?: Date | string
  }

  export type StockUncheckedCreateWithoutProductInput = {
    quantity?: number
    updatedAt?: Date | string
  }

  export type StockCreateOrConnectWithoutProductInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
  }

  export type StockTransactionCreateWithoutProductInput = {
    type: string
    quantity: number
    note?: string | null
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutStockTransactionsInput
  }

  export type StockTransactionUncheckedCreateWithoutProductInput = {
    id?: number
    type: string
    quantity: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type StockTransactionCreateOrConnectWithoutProductInput = {
    where: StockTransactionWhereUniqueInput
    create: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput>
  }

  export type StockTransactionCreateManyProductInputEnvelope = {
    data: StockTransactionCreateManyProductInput | StockTransactionCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SupplierProductCreateWithoutProductInput = {
    supplier: SupplierCreateNestedOneWithoutProductsInput
  }

  export type SupplierProductUncheckedCreateWithoutProductInput = {
    supplierId: number
  }

  export type SupplierProductCreateOrConnectWithoutProductInput = {
    where: SupplierProductWhereUniqueInput
    create: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput>
  }

  export type SupplierProductCreateManyProductInputEnvelope = {
    data: SupplierProductCreateManyProductInput | SupplierProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SummaryOrderJournalCreateWithoutProductInput = {
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerName: string
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutSummaryJournalEntriesInput
  }

  export type SummaryOrderJournalUncheckedCreateWithoutProductInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerId?: number | null
    customerName: string
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SummaryOrderJournalCreateOrConnectWithoutProductInput = {
    where: SummaryOrderJournalWhereUniqueInput
    create: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput>
  }

  export type SummaryOrderJournalCreateManyProductInputEnvelope = {
    data: SummaryOrderJournalCreateManyProductInput | SummaryOrderJournalCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionItemCreateWithoutProductInput = {
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    journal: ProductionJournalCreateNestedOneWithoutItemsInput
    values?: ProductionItemValueCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemUncheckedCreateWithoutProductInput = {
    id?: number
    journalId: number
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    values?: ProductionItemValueUncheckedCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemCreateOrConnectWithoutProductInput = {
    where: ProductionItemWhereUniqueInput
    create: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput>
  }

  export type ProductionItemCreateManyProductInputEnvelope = {
    data: ProductionItemCreateManyProductInput | ProductionItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceItemCreateWithoutProductInput = {
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutItemsInput
    supplier: SupplierCreateNestedOneWithoutPurchasePriceItemsInput
  }

  export type PurchasePriceItemUncheckedCreateWithoutProductInput = {
    id?: number
    priceListId: number
    supplierId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceItemCreateOrConnectWithoutProductInput = {
    where: PurchasePriceItemWhereUniqueInput
    create: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput>
  }

  export type PurchasePriceItemCreateManyProductInputEnvelope = {
    data: PurchasePriceItemCreateManyProductInput | PurchasePriceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SalesPriceItemCreateWithoutProductInput = {
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    priceList: SalesPriceListCreateNestedOneWithoutItemsInput
  }

  export type SalesPriceItemUncheckedCreateWithoutProductInput = {
    id?: number
    priceListId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SalesPriceItemCreateOrConnectWithoutProductInput = {
    where: SalesPriceItemWhereUniqueInput
    create: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput>
  }

  export type SalesPriceItemCreateManyProductInputEnvelope = {
    data: SalesPriceItemCreateManyProductInput | SalesPriceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionMmlCreateWithoutProductInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutProductInput = {
    id?: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutProductInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput>
  }

  export type ProductionMmlCreateManyProductInputEnvelope = {
    data: ProductionMmlCreateManyProductInput | ProductionMmlCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionMmlNodeCreateWithoutProductInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutNodesInput
    parentNode?: ProductionMmlNodeCreateNestedOneWithoutChildrenInput
    children?: ProductionMmlNodeCreateNestedManyWithoutParentNodeInput
    runValues?: ProductionRunValueCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUncheckedCreateWithoutProductInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput
    runValues?: ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeCreateOrConnectWithoutProductInput = {
    where: ProductionMmlNodeWhereUniqueInput
    create: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput>
  }

  export type ProductionMmlNodeCreateManyProductInputEnvelope = {
    data: ProductionMmlNodeCreateManyProductInput | ProductionMmlNodeCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionRunCreateWithoutProductInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutRunsInput
    user: UserCreateNestedOneWithoutProductionRunsInput
    values?: ProductionRunValueCreateNestedManyWithoutRunInput
  }

  export type ProductionRunUncheckedCreateWithoutProductInput = {
    id?: number
    mmlId: number
    userId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: ProductionRunValueUncheckedCreateNestedManyWithoutRunInput
  }

  export type ProductionRunCreateOrConnectWithoutProductInput = {
    where: ProductionRunWhereUniqueInput
    create: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput>
  }

  export type ProductionRunCreateManyProductInputEnvelope = {
    data: ProductionRunCreateManyProductInput | ProductionRunCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: FloatFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    distributionCoef?: FloatNullableFilter<"OrderItem"> | number | null
    sumWithRevaluation?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: FloatNullableFilter<"OrderItem"> | number | null
  }

  export type StockUpsertWithoutProductInput = {
    update: XOR<StockUpdateWithoutProductInput, StockUncheckedUpdateWithoutProductInput>
    create: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutProductInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutProductInput, StockUncheckedUpdateWithoutProductInput>
  }

  export type StockUpdateWithoutProductInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockUncheckedUpdateWithoutProductInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUpsertWithWhereUniqueWithoutProductInput = {
    where: StockTransactionWhereUniqueInput
    update: XOR<StockTransactionUpdateWithoutProductInput, StockTransactionUncheckedUpdateWithoutProductInput>
    create: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput>
  }

  export type StockTransactionUpdateWithWhereUniqueWithoutProductInput = {
    where: StockTransactionWhereUniqueInput
    data: XOR<StockTransactionUpdateWithoutProductInput, StockTransactionUncheckedUpdateWithoutProductInput>
  }

  export type StockTransactionUpdateManyWithWhereWithoutProductInput = {
    where: StockTransactionScalarWhereInput
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyWithoutProductInput>
  }

  export type StockTransactionScalarWhereInput = {
    AND?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
    OR?: StockTransactionScalarWhereInput[]
    NOT?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
    id?: IntFilter<"StockTransaction"> | number
    productId?: IntFilter<"StockTransaction"> | number
    type?: StringFilter<"StockTransaction"> | string
    quantity?: FloatFilter<"StockTransaction"> | number
    orderId?: IntNullableFilter<"StockTransaction"> | number | null
    note?: StringNullableFilter<"StockTransaction"> | string | null
    createdAt?: DateTimeFilter<"StockTransaction"> | Date | string
  }

  export type SupplierProductUpsertWithWhereUniqueWithoutProductInput = {
    where: SupplierProductWhereUniqueInput
    update: XOR<SupplierProductUpdateWithoutProductInput, SupplierProductUncheckedUpdateWithoutProductInput>
    create: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput>
  }

  export type SupplierProductUpdateWithWhereUniqueWithoutProductInput = {
    where: SupplierProductWhereUniqueInput
    data: XOR<SupplierProductUpdateWithoutProductInput, SupplierProductUncheckedUpdateWithoutProductInput>
  }

  export type SupplierProductUpdateManyWithWhereWithoutProductInput = {
    where: SupplierProductScalarWhereInput
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyWithoutProductInput>
  }

  export type SupplierProductScalarWhereInput = {
    AND?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
    OR?: SupplierProductScalarWhereInput[]
    NOT?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
    supplierId?: IntFilter<"SupplierProduct"> | number
    productId?: IntFilter<"SupplierProduct"> | number
  }

  export type SummaryOrderJournalUpsertWithWhereUniqueWithoutProductInput = {
    where: SummaryOrderJournalWhereUniqueInput
    update: XOR<SummaryOrderJournalUpdateWithoutProductInput, SummaryOrderJournalUncheckedUpdateWithoutProductInput>
    create: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput>
  }

  export type SummaryOrderJournalUpdateWithWhereUniqueWithoutProductInput = {
    where: SummaryOrderJournalWhereUniqueInput
    data: XOR<SummaryOrderJournalUpdateWithoutProductInput, SummaryOrderJournalUncheckedUpdateWithoutProductInput>
  }

  export type SummaryOrderJournalUpdateManyWithWhereWithoutProductInput = {
    where: SummaryOrderJournalScalarWhereInput
    data: XOR<SummaryOrderJournalUpdateManyMutationInput, SummaryOrderJournalUncheckedUpdateManyWithoutProductInput>
  }

  export type SummaryOrderJournalScalarWhereInput = {
    AND?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
    OR?: SummaryOrderJournalScalarWhereInput[]
    NOT?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
    id?: IntFilter<"SummaryOrderJournal"> | number
    idn?: StringFilter<"SummaryOrderJournal"> | string
    shipDate?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    paymentType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    customerId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    customerName?: StringFilter<"SummaryOrderJournal"> | string
    productId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    productCode?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    productFullName?: StringFilter<"SummaryOrderJournal"> | string
    category?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    shortNameMorning?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    priceType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    price?: DecimalFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"SummaryOrderJournal"> | number
    orderQty?: FloatFilter<"SummaryOrderJournal"> | number
    sumWithRevaluation?: DecimalNullableFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    weightToDistribute?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    managerId?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    managerName?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    district?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    pointAddress?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    status?: StringFilter<"SummaryOrderJournal"> | string
    createdAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    updatedAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
  }

  export type ProductionItemUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductionItemWhereUniqueInput
    update: XOR<ProductionItemUpdateWithoutProductInput, ProductionItemUncheckedUpdateWithoutProductInput>
    create: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput>
  }

  export type ProductionItemUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductionItemWhereUniqueInput
    data: XOR<ProductionItemUpdateWithoutProductInput, ProductionItemUncheckedUpdateWithoutProductInput>
  }

  export type ProductionItemUpdateManyWithWhereWithoutProductInput = {
    where: ProductionItemScalarWhereInput
    data: XOR<ProductionItemUpdateManyMutationInput, ProductionItemUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductionItemScalarWhereInput = {
    AND?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
    OR?: ProductionItemScalarWhereInput[]
    NOT?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
    id?: IntFilter<"ProductionItem"> | number
    journalId?: IntFilter<"ProductionItem"> | number
    productId?: IntNullableFilter<"ProductionItem"> | number | null
    productName?: StringNullableFilter<"ProductionItem"> | string | null
    state?: StringFilter<"ProductionItem"> | string
    sortOrder?: IntFilter<"ProductionItem"> | number
    isDeleted?: BoolFilter<"ProductionItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"ProductionItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"ProductionItem"> | string | null
    createdAt?: DateTimeFilter<"ProductionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionItem"> | Date | string
    createdBy?: StringFilter<"ProductionItem"> | string
    updatedBy?: StringNullableFilter<"ProductionItem"> | string | null
  }

  export type PurchasePriceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchasePriceItemWhereUniqueInput
    update: XOR<PurchasePriceItemUpdateWithoutProductInput, PurchasePriceItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput>
  }

  export type PurchasePriceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchasePriceItemWhereUniqueInput
    data: XOR<PurchasePriceItemUpdateWithoutProductInput, PurchasePriceItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchasePriceItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchasePriceItemScalarWhereInput
    data: XOR<PurchasePriceItemUpdateManyMutationInput, PurchasePriceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchasePriceItemScalarWhereInput = {
    AND?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
    OR?: PurchasePriceItemScalarWhereInput[]
    NOT?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
    id?: IntFilter<"PurchasePriceItem"> | number
    priceListId?: IntFilter<"PurchasePriceItem"> | number
    supplierId?: IntFilter<"PurchasePriceItem"> | number
    productId?: IntFilter<"PurchasePriceItem"> | number
    purchasePrice?: DecimalFilter<"PurchasePriceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
  }

  export type SalesPriceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: SalesPriceItemWhereUniqueInput
    update: XOR<SalesPriceItemUpdateWithoutProductInput, SalesPriceItemUncheckedUpdateWithoutProductInput>
    create: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput>
  }

  export type SalesPriceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: SalesPriceItemWhereUniqueInput
    data: XOR<SalesPriceItemUpdateWithoutProductInput, SalesPriceItemUncheckedUpdateWithoutProductInput>
  }

  export type SalesPriceItemUpdateManyWithWhereWithoutProductInput = {
    where: SalesPriceItemScalarWhereInput
    data: XOR<SalesPriceItemUpdateManyMutationInput, SalesPriceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type SalesPriceItemScalarWhereInput = {
    AND?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
    OR?: SalesPriceItemScalarWhereInput[]
    NOT?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
    id?: IntFilter<"SalesPriceItem"> | number
    priceListId?: IntFilter<"SalesPriceItem"> | number
    productId?: IntFilter<"SalesPriceItem"> | number
    salePrice?: DecimalFilter<"SalesPriceItem"> | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFilter<"SalesPriceItem"> | Date | string
    createdAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedBy?: StringNullableFilter<"SalesPriceItem"> | string | null
  }

  export type ProductionMmlUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductionMmlWhereUniqueInput
    update: XOR<ProductionMmlUpdateWithoutProductInput, ProductionMmlUncheckedUpdateWithoutProductInput>
    create: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput>
  }

  export type ProductionMmlUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductionMmlWhereUniqueInput
    data: XOR<ProductionMmlUpdateWithoutProductInput, ProductionMmlUncheckedUpdateWithoutProductInput>
  }

  export type ProductionMmlUpdateManyWithWhereWithoutProductInput = {
    where: ProductionMmlScalarWhereInput
    data: XOR<ProductionMmlUpdateManyMutationInput, ProductionMmlUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductionMmlNodeUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductionMmlNodeWhereUniqueInput
    update: XOR<ProductionMmlNodeUpdateWithoutProductInput, ProductionMmlNodeUncheckedUpdateWithoutProductInput>
    create: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput>
  }

  export type ProductionMmlNodeUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductionMmlNodeWhereUniqueInput
    data: XOR<ProductionMmlNodeUpdateWithoutProductInput, ProductionMmlNodeUncheckedUpdateWithoutProductInput>
  }

  export type ProductionMmlNodeUpdateManyWithWhereWithoutProductInput = {
    where: ProductionMmlNodeScalarWhereInput
    data: XOR<ProductionMmlNodeUpdateManyMutationInput, ProductionMmlNodeUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductionMmlNodeScalarWhereInput = {
    AND?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
    OR?: ProductionMmlNodeScalarWhereInput[]
    NOT?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
    id?: IntFilter<"ProductionMmlNode"> | number
    mmlId?: IntFilter<"ProductionMmlNode"> | number
    parentNodeId?: IntNullableFilter<"ProductionMmlNode"> | number | null
    productId?: IntFilter<"ProductionMmlNode"> | number
    sortOrder?: IntFilter<"ProductionMmlNode"> | number
    createdAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
  }

  export type ProductionRunUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductionRunWhereUniqueInput
    update: XOR<ProductionRunUpdateWithoutProductInput, ProductionRunUncheckedUpdateWithoutProductInput>
    create: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput>
  }

  export type ProductionRunUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductionRunWhereUniqueInput
    data: XOR<ProductionRunUpdateWithoutProductInput, ProductionRunUncheckedUpdateWithoutProductInput>
  }

  export type ProductionRunUpdateManyWithWhereWithoutProductInput = {
    where: ProductionRunScalarWhereInput
    data: XOR<ProductionRunUpdateManyMutationInput, ProductionRunUncheckedUpdateManyWithoutProductInput>
  }

  export type DistrictCreateWithoutCustomersInput = {
    code: string
    name: string
  }

  export type DistrictUncheckedCreateWithoutCustomersInput = {
    id?: number
    code: string
    name: string
  }

  export type DistrictCreateOrConnectWithoutCustomersInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutCustomersInput, DistrictUncheckedCreateWithoutCustomersInput>
  }

  export type ManagerCreateWithoutCustomersInput = {
    code: string
    name: string
    phone?: string | null
  }

  export type ManagerUncheckedCreateWithoutCustomersInput = {
    id?: number
    code: string
    name: string
    phone?: string | null
  }

  export type ManagerCreateOrConnectWithoutCustomersInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutCustomersInput, ManagerUncheckedCreateWithoutCustomersInput>
  }

  export type OrderCreateWithoutCustomerInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expeditor?: ExpeditorCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SummaryOrderJournalCreateWithoutCustomerInput = {
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerName: string
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutSummaryJournalEntriesInput
  }

  export type SummaryOrderJournalUncheckedCreateWithoutCustomerInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerName: string
    productId?: number | null
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SummaryOrderJournalCreateOrConnectWithoutCustomerInput = {
    where: SummaryOrderJournalWhereUniqueInput
    create: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput>
  }

  export type SummaryOrderJournalCreateManyCustomerInputEnvelope = {
    data: SummaryOrderJournalCreateManyCustomerInput | SummaryOrderJournalCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SalesPriceListCreateWithoutCustomerInput = {
    listType: string
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: SalesPriceItemCreateNestedManyWithoutPriceListInput
  }

  export type SalesPriceListUncheckedCreateWithoutCustomerInput = {
    id?: number
    listType: string
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: SalesPriceItemUncheckedCreateNestedManyWithoutPriceListInput
  }

  export type SalesPriceListCreateOrConnectWithoutCustomerInput = {
    where: SalesPriceListWhereUniqueInput
    create: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput>
  }

  export type SalesPriceListCreateManyCustomerInputEnvelope = {
    data: SalesPriceListCreateManyCustomerInput | SalesPriceListCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type DistrictUpsertWithoutCustomersInput = {
    update: XOR<DistrictUpdateWithoutCustomersInput, DistrictUncheckedUpdateWithoutCustomersInput>
    create: XOR<DistrictCreateWithoutCustomersInput, DistrictUncheckedCreateWithoutCustomersInput>
    where?: DistrictWhereInput
  }

  export type DistrictUpdateToOneWithWhereWithoutCustomersInput = {
    where?: DistrictWhereInput
    data: XOR<DistrictUpdateWithoutCustomersInput, DistrictUncheckedUpdateWithoutCustomersInput>
  }

  export type DistrictUpdateWithoutCustomersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DistrictUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerUpsertWithoutCustomersInput = {
    update: XOR<ManagerUpdateWithoutCustomersInput, ManagerUncheckedUpdateWithoutCustomersInput>
    create: XOR<ManagerCreateWithoutCustomersInput, ManagerUncheckedCreateWithoutCustomersInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutCustomersInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutCustomersInput, ManagerUncheckedUpdateWithoutCustomersInput>
  }

  export type ManagerUpdateWithoutCustomersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    idn?: StringNullableFilter<"Order"> | string | null
    date?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    paymentType?: StringNullableFilter<"Order"> | string | null
    customerId?: IntFilter<"Order"> | number
    expeditorId?: IntNullableFilter<"Order"> | number | null
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFilter<"Order"> | number
    isDisabled?: BoolFilter<"Order"> | boolean
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    assignedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryStatus?: StringFilter<"Order"> | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    signatureUrl?: StringNullableFilter<"Order"> | string | null
    signedInvoiceUrl?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type SummaryOrderJournalUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SummaryOrderJournalWhereUniqueInput
    update: XOR<SummaryOrderJournalUpdateWithoutCustomerInput, SummaryOrderJournalUncheckedUpdateWithoutCustomerInput>
    create: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput>
  }

  export type SummaryOrderJournalUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SummaryOrderJournalWhereUniqueInput
    data: XOR<SummaryOrderJournalUpdateWithoutCustomerInput, SummaryOrderJournalUncheckedUpdateWithoutCustomerInput>
  }

  export type SummaryOrderJournalUpdateManyWithWhereWithoutCustomerInput = {
    where: SummaryOrderJournalScalarWhereInput
    data: XOR<SummaryOrderJournalUpdateManyMutationInput, SummaryOrderJournalUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SalesPriceListUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SalesPriceListWhereUniqueInput
    update: XOR<SalesPriceListUpdateWithoutCustomerInput, SalesPriceListUncheckedUpdateWithoutCustomerInput>
    create: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput>
  }

  export type SalesPriceListUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SalesPriceListWhereUniqueInput
    data: XOR<SalesPriceListUpdateWithoutCustomerInput, SalesPriceListUncheckedUpdateWithoutCustomerInput>
  }

  export type SalesPriceListUpdateManyWithWhereWithoutCustomerInput = {
    where: SalesPriceListScalarWhereInput
    data: XOR<SalesPriceListUpdateManyMutationInput, SalesPriceListUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SalesPriceListScalarWhereInput = {
    AND?: SalesPriceListScalarWhereInput | SalesPriceListScalarWhereInput[]
    OR?: SalesPriceListScalarWhereInput[]
    NOT?: SalesPriceListScalarWhereInput | SalesPriceListScalarWhereInput[]
    id?: IntFilter<"SalesPriceList"> | number
    listType?: StringFilter<"SalesPriceList"> | string
    customerId?: IntNullableFilter<"SalesPriceList"> | number | null
    title?: StringNullableFilter<"SalesPriceList"> | string | null
    effectiveDate?: DateTimeFilter<"SalesPriceList"> | Date | string
    status?: StringFilter<"SalesPriceList"> | string
    isCurrent?: BoolFilter<"SalesPriceList"> | boolean
    isHidden?: BoolFilter<"SalesPriceList"> | boolean
    createdAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    createdBy?: StringFilter<"SalesPriceList"> | string
    updatedBy?: StringNullableFilter<"SalesPriceList"> | string | null
  }

  export type ProductionMmlCreateWithoutSuppliersWithPrimaryMmlInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutSuppliersWithPrimaryMmlInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutSuppliersWithPrimaryMmlInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedCreateWithoutSuppliersWithPrimaryMmlInput>
  }

  export type SupplierProductCreateWithoutSupplierInput = {
    product: ProductCreateNestedOneWithoutSuppliersInput
  }

  export type SupplierProductUncheckedCreateWithoutSupplierInput = {
    productId: number
  }

  export type SupplierProductCreateOrConnectWithoutSupplierInput = {
    where: SupplierProductWhereUniqueInput
    create: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierProductCreateManySupplierInputEnvelope = {
    data: SupplierProductCreateManySupplierInput | SupplierProductCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceListSupplierCreateWithoutSupplierInput = {
    createdAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutSuppliersInput
    primaryMml?: ProductionMmlCreateNestedOneWithoutPriceListSuppliersInput
  }

  export type PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput = {
    id?: number
    priceListId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    create: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type PurchasePriceListSupplierCreateManySupplierInputEnvelope = {
    data: PurchasePriceListSupplierCreateManySupplierInput | PurchasePriceListSupplierCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceItemCreateWithoutSupplierInput = {
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchasePriceItemsInput
  }

  export type PurchasePriceItemUncheckedCreateWithoutSupplierInput = {
    id?: number
    priceListId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceItemCreateOrConnectWithoutSupplierInput = {
    where: PurchasePriceItemWhereUniqueInput
    create: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput>
  }

  export type PurchasePriceItemCreateManySupplierInputEnvelope = {
    data: PurchasePriceItemCreateManySupplierInput | PurchasePriceItemCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ProductionMmlUpsertWithoutSuppliersWithPrimaryMmlInput = {
    update: XOR<ProductionMmlUpdateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedUpdateWithoutSuppliersWithPrimaryMmlInput>
    create: XOR<ProductionMmlCreateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedCreateWithoutSuppliersWithPrimaryMmlInput>
    where?: ProductionMmlWhereInput
  }

  export type ProductionMmlUpdateToOneWithWhereWithoutSuppliersWithPrimaryMmlInput = {
    where?: ProductionMmlWhereInput
    data: XOR<ProductionMmlUpdateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedUpdateWithoutSuppliersWithPrimaryMmlInput>
  }

  export type ProductionMmlUpdateWithoutSuppliersWithPrimaryMmlInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutSuppliersWithPrimaryMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type SupplierProductUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierProductWhereUniqueInput
    update: XOR<SupplierProductUpdateWithoutSupplierInput, SupplierProductUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierProductUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierProductWhereUniqueInput
    data: XOR<SupplierProductUpdateWithoutSupplierInput, SupplierProductUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierProductUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierProductScalarWhereInput
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchasePriceListSupplierUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    update: XOR<PurchasePriceListSupplierUpdateWithoutSupplierInput, PurchasePriceListSupplierUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type PurchasePriceListSupplierUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    data: XOR<PurchasePriceListSupplierUpdateWithoutSupplierInput, PurchasePriceListSupplierUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchasePriceListSupplierUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchasePriceListSupplierScalarWhereInput
    data: XOR<PurchasePriceListSupplierUpdateManyMutationInput, PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchasePriceListSupplierScalarWhereInput = {
    AND?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
    OR?: PurchasePriceListSupplierScalarWhereInput[]
    NOT?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
    id?: IntFilter<"PurchasePriceListSupplier"> | number
    priceListId?: IntFilter<"PurchasePriceListSupplier"> | number
    supplierId?: IntFilter<"PurchasePriceListSupplier"> | number
    primaryMmlId?: IntNullableFilter<"PurchasePriceListSupplier"> | number | null
    createdAt?: DateTimeFilter<"PurchasePriceListSupplier"> | Date | string
  }

  export type PurchasePriceItemUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchasePriceItemWhereUniqueInput
    update: XOR<PurchasePriceItemUpdateWithoutSupplierInput, PurchasePriceItemUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput>
  }

  export type PurchasePriceItemUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchasePriceItemWhereUniqueInput
    data: XOR<PurchasePriceItemUpdateWithoutSupplierInput, PurchasePriceItemUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchasePriceItemUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchasePriceItemScalarWhereInput
    data: XOR<PurchasePriceItemUpdateManyMutationInput, PurchasePriceItemUncheckedUpdateManyWithoutSupplierInput>
  }

  export type ProductCreateWithoutSuppliersInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSuppliersInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSuppliersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSuppliersInput, ProductUncheckedCreateWithoutSuppliersInput>
  }

  export type SupplierCreateWithoutProductsInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutProductsInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutProductsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
  }

  export type ProductUpsertWithoutSuppliersInput = {
    update: XOR<ProductUpdateWithoutSuppliersInput, ProductUncheckedUpdateWithoutSuppliersInput>
    create: XOR<ProductCreateWithoutSuppliersInput, ProductUncheckedCreateWithoutSuppliersInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSuppliersInput, ProductUncheckedUpdateWithoutSuppliersInput>
  }

  export type ProductUpdateWithoutSuppliersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SupplierUpsertWithoutProductsInput = {
    update: XOR<SupplierUpdateWithoutProductsInput, SupplierUncheckedUpdateWithoutProductsInput>
    create: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutProductsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutProductsInput, SupplierUncheckedUpdateWithoutProductsInput>
  }

  export type SupplierUpdateWithoutProductsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type CustomerCreateWithoutOrdersInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: DistrictCreateNestedOneWithoutCustomersInput
    manager?: ManagerCreateNestedOneWithoutCustomersInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type ExpeditorCreateWithoutOrdersInput = {
    name: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpeditorUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpeditorCreateOrConnectWithoutOrdersInput = {
    where: ExpeditorWhereUniqueInput
    create: XOR<ExpeditorCreateWithoutOrdersInput, ExpeditorUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    productId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type StockTransactionCreateWithoutOrderInput = {
    type: string
    quantity: number
    note?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockTransactionsInput
  }

  export type StockTransactionUncheckedCreateWithoutOrderInput = {
    id?: number
    productId: number
    type: string
    quantity: number
    note?: string | null
    createdAt?: Date | string
  }

  export type StockTransactionCreateOrConnectWithoutOrderInput = {
    where: StockTransactionWhereUniqueInput
    create: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput>
  }

  export type StockTransactionCreateManyOrderInputEnvelope = {
    data: StockTransactionCreateManyOrderInput | StockTransactionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderAttachmentCreateWithoutOrderInput = {
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
  }

  export type OrderAttachmentUncheckedCreateWithoutOrderInput = {
    id?: number
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
  }

  export type OrderAttachmentCreateOrConnectWithoutOrderInput = {
    where: OrderAttachmentWhereUniqueInput
    create: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput>
  }

  export type OrderAttachmentCreateManyOrderInputEnvelope = {
    data: OrderAttachmentCreateManyOrderInput | OrderAttachmentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneWithoutCustomersNestedInput
    manager?: ManagerUpdateOneWithoutCustomersNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ExpeditorUpsertWithoutOrdersInput = {
    update: XOR<ExpeditorUpdateWithoutOrdersInput, ExpeditorUncheckedUpdateWithoutOrdersInput>
    create: XOR<ExpeditorCreateWithoutOrdersInput, ExpeditorUncheckedCreateWithoutOrdersInput>
    where?: ExpeditorWhereInput
  }

  export type ExpeditorUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ExpeditorWhereInput
    data: XOR<ExpeditorUpdateWithoutOrdersInput, ExpeditorUncheckedUpdateWithoutOrdersInput>
  }

  export type ExpeditorUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpeditorUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type StockTransactionUpsertWithWhereUniqueWithoutOrderInput = {
    where: StockTransactionWhereUniqueInput
    update: XOR<StockTransactionUpdateWithoutOrderInput, StockTransactionUncheckedUpdateWithoutOrderInput>
    create: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput>
  }

  export type StockTransactionUpdateWithWhereUniqueWithoutOrderInput = {
    where: StockTransactionWhereUniqueInput
    data: XOR<StockTransactionUpdateWithoutOrderInput, StockTransactionUncheckedUpdateWithoutOrderInput>
  }

  export type StockTransactionUpdateManyWithWhereWithoutOrderInput = {
    where: StockTransactionScalarWhereInput
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderAttachmentUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderAttachmentWhereUniqueInput
    update: XOR<OrderAttachmentUpdateWithoutOrderInput, OrderAttachmentUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput>
  }

  export type OrderAttachmentUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderAttachmentWhereUniqueInput
    data: XOR<OrderAttachmentUpdateWithoutOrderInput, OrderAttachmentUncheckedUpdateWithoutOrderInput>
  }

  export type OrderAttachmentUpdateManyWithWhereWithoutOrderInput = {
    where: OrderAttachmentScalarWhereInput
    data: XOR<OrderAttachmentUpdateManyMutationInput, OrderAttachmentUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderAttachmentScalarWhereInput = {
    AND?: OrderAttachmentScalarWhereInput | OrderAttachmentScalarWhereInput[]
    OR?: OrderAttachmentScalarWhereInput[]
    NOT?: OrderAttachmentScalarWhereInput | OrderAttachmentScalarWhereInput[]
    id?: IntFilter<"OrderAttachment"> | number
    orderId?: IntFilter<"OrderAttachment"> | number
    type?: StringFilter<"OrderAttachment"> | string
    filename?: StringFilter<"OrderAttachment"> | string
    url?: StringFilter<"OrderAttachment"> | string
    mimeType?: StringNullableFilter<"OrderAttachment"> | string | null
    createdAt?: DateTimeFilter<"OrderAttachment"> | Date | string
  }

  export type OrderCreateWithoutAttachmentsInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    expeditor?: ExpeditorCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAttachmentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAttachmentsInput, OrderUncheckedCreateWithoutAttachmentsInput>
  }

  export type OrderUpsertWithoutAttachmentsInput = {
    update: XOR<OrderUpdateWithoutAttachmentsInput, OrderUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<OrderCreateWithoutAttachmentsInput, OrderUncheckedCreateWithoutAttachmentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutAttachmentsInput, OrderUncheckedUpdateWithoutAttachmentsInput>
  }

  export type OrderUpdateWithoutAttachmentsInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    expeditor?: ExpeditorUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateWithoutItemsInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    expeditor?: ExpeditorCreateNestedOneWithoutOrdersInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    expeditor?: ExpeditorUpdateOneWithoutOrdersNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutExpeditorInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutExpeditorInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutExpeditorInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput>
  }

  export type OrderCreateManyExpeditorInputEnvelope = {
    data: OrderCreateManyExpeditorInput | OrderCreateManyExpeditorInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutExpeditorInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutExpeditorInput, OrderUncheckedUpdateWithoutExpeditorInput>
    create: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutExpeditorInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutExpeditorInput, OrderUncheckedUpdateWithoutExpeditorInput>
  }

  export type OrderUpdateManyWithWhereWithoutExpeditorInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutExpeditorInput>
  }

  export type ProductCreateWithoutStockInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
  }

  export type ProductUpsertWithoutStockInput = {
    update: XOR<ProductUpdateWithoutStockInput, ProductUncheckedUpdateWithoutStockInput>
    create: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockInput, ProductUncheckedUpdateWithoutStockInput>
  }

  export type ProductUpdateWithoutStockInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutStockTransactionsInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    expeditor?: ExpeditorCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutStockTransactionsInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStockTransactionsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStockTransactionsInput, OrderUncheckedCreateWithoutStockTransactionsInput>
  }

  export type ProductCreateWithoutStockTransactionsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockTransactionsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockTransactionsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockTransactionsInput, ProductUncheckedCreateWithoutStockTransactionsInput>
  }

  export type OrderUpsertWithoutStockTransactionsInput = {
    update: XOR<OrderUpdateWithoutStockTransactionsInput, OrderUncheckedUpdateWithoutStockTransactionsInput>
    create: XOR<OrderCreateWithoutStockTransactionsInput, OrderUncheckedCreateWithoutStockTransactionsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutStockTransactionsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutStockTransactionsInput, OrderUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type OrderUpdateWithoutStockTransactionsInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    expeditor?: ExpeditorUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutStockTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutStockTransactionsInput = {
    update: XOR<ProductUpdateWithoutStockTransactionsInput, ProductUncheckedUpdateWithoutStockTransactionsInput>
    create: XOR<ProductCreateWithoutStockTransactionsInput, ProductUncheckedCreateWithoutStockTransactionsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockTransactionsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockTransactionsInput, ProductUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type ProductUpdateWithoutStockTransactionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CustomerCreateWithoutSummaryJournalEntriesInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: DistrictCreateNestedOneWithoutCustomersInput
    manager?: ManagerCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSummaryJournalEntriesInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSummaryJournalEntriesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSummaryJournalEntriesInput, CustomerUncheckedCreateWithoutSummaryJournalEntriesInput>
  }

  export type ProductCreateWithoutSummaryJournalEntriesInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSummaryJournalEntriesInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSummaryJournalEntriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSummaryJournalEntriesInput, ProductUncheckedCreateWithoutSummaryJournalEntriesInput>
  }

  export type CustomerUpsertWithoutSummaryJournalEntriesInput = {
    update: XOR<CustomerUpdateWithoutSummaryJournalEntriesInput, CustomerUncheckedUpdateWithoutSummaryJournalEntriesInput>
    create: XOR<CustomerCreateWithoutSummaryJournalEntriesInput, CustomerUncheckedCreateWithoutSummaryJournalEntriesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSummaryJournalEntriesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSummaryJournalEntriesInput, CustomerUncheckedUpdateWithoutSummaryJournalEntriesInput>
  }

  export type CustomerUpdateWithoutSummaryJournalEntriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneWithoutCustomersNestedInput
    manager?: ManagerUpdateOneWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSummaryJournalEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ProductUpsertWithoutSummaryJournalEntriesInput = {
    update: XOR<ProductUpdateWithoutSummaryJournalEntriesInput, ProductUncheckedUpdateWithoutSummaryJournalEntriesInput>
    create: XOR<ProductCreateWithoutSummaryJournalEntriesInput, ProductUncheckedCreateWithoutSummaryJournalEntriesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSummaryJournalEntriesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSummaryJournalEntriesInput, ProductUncheckedUpdateWithoutSummaryJournalEntriesInput>
  }

  export type ProductUpdateWithoutSummaryJournalEntriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSummaryJournalEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutProductionStaffInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMmls?: ProductionMmlCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductionStaffInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMmls?: ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductionStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductionStaffInput, UserUncheckedCreateWithoutProductionStaffInput>
  }

  export type ProductionJournalCreateWithoutStaffInput = {
    productionDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: ProductionItemCreateNestedManyWithoutJournalInput
  }

  export type ProductionJournalUncheckedCreateWithoutStaffInput = {
    id?: number
    productionDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: ProductionItemUncheckedCreateNestedManyWithoutJournalInput
  }

  export type ProductionJournalCreateOrConnectWithoutStaffInput = {
    where: ProductionJournalWhereUniqueInput
    create: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput>
  }

  export type ProductionJournalCreateManyStaffInputEnvelope = {
    data: ProductionJournalCreateManyStaffInput | ProductionJournalCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProductionStaffInput = {
    update: XOR<UserUpdateWithoutProductionStaffInput, UserUncheckedUpdateWithoutProductionStaffInput>
    create: XOR<UserCreateWithoutProductionStaffInput, UserUncheckedCreateWithoutProductionStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductionStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductionStaffInput, UserUncheckedUpdateWithoutProductionStaffInput>
  }

  export type UserUpdateWithoutProductionStaffInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMmls?: ProductionMmlUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductionStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMmls?: ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductionJournalUpsertWithWhereUniqueWithoutStaffInput = {
    where: ProductionJournalWhereUniqueInput
    update: XOR<ProductionJournalUpdateWithoutStaffInput, ProductionJournalUncheckedUpdateWithoutStaffInput>
    create: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput>
  }

  export type ProductionJournalUpdateWithWhereUniqueWithoutStaffInput = {
    where: ProductionJournalWhereUniqueInput
    data: XOR<ProductionJournalUpdateWithoutStaffInput, ProductionJournalUncheckedUpdateWithoutStaffInput>
  }

  export type ProductionJournalUpdateManyWithWhereWithoutStaffInput = {
    where: ProductionJournalScalarWhereInput
    data: XOR<ProductionJournalUpdateManyMutationInput, ProductionJournalUncheckedUpdateManyWithoutStaffInput>
  }

  export type ProductionJournalScalarWhereInput = {
    AND?: ProductionJournalScalarWhereInput | ProductionJournalScalarWhereInput[]
    OR?: ProductionJournalScalarWhereInput[]
    NOT?: ProductionJournalScalarWhereInput | ProductionJournalScalarWhereInput[]
    id?: IntFilter<"ProductionJournal"> | number
    productionDate?: DateTimeFilter<"ProductionJournal"> | Date | string
    staffId?: IntFilter<"ProductionJournal"> | number
    status?: StringFilter<"ProductionJournal"> | string
    createdAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    createdBy?: StringFilter<"ProductionJournal"> | string
    updatedBy?: StringNullableFilter<"ProductionJournal"> | string | null
  }

  export type ProductionStaffCreateWithoutJournalsInput = {
    fullName: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProductionStaffInput
  }

  export type ProductionStaffUncheckedCreateWithoutJournalsInput = {
    id?: number
    fullName: string
    phone?: string | null
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionStaffCreateOrConnectWithoutJournalsInput = {
    where: ProductionStaffWhereUniqueInput
    create: XOR<ProductionStaffCreateWithoutJournalsInput, ProductionStaffUncheckedCreateWithoutJournalsInput>
  }

  export type ProductionItemCreateWithoutJournalInput = {
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    product?: ProductCreateNestedOneWithoutProductionItemsInput
    values?: ProductionItemValueCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemUncheckedCreateWithoutJournalInput = {
    id?: number
    productId?: number | null
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    values?: ProductionItemValueUncheckedCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemCreateOrConnectWithoutJournalInput = {
    where: ProductionItemWhereUniqueInput
    create: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput>
  }

  export type ProductionItemCreateManyJournalInputEnvelope = {
    data: ProductionItemCreateManyJournalInput | ProductionItemCreateManyJournalInput[]
    skipDuplicates?: boolean
  }

  export type ProductionStaffUpsertWithoutJournalsInput = {
    update: XOR<ProductionStaffUpdateWithoutJournalsInput, ProductionStaffUncheckedUpdateWithoutJournalsInput>
    create: XOR<ProductionStaffCreateWithoutJournalsInput, ProductionStaffUncheckedCreateWithoutJournalsInput>
    where?: ProductionStaffWhereInput
  }

  export type ProductionStaffUpdateToOneWithWhereWithoutJournalsInput = {
    where?: ProductionStaffWhereInput
    data: XOR<ProductionStaffUpdateWithoutJournalsInput, ProductionStaffUncheckedUpdateWithoutJournalsInput>
  }

  export type ProductionStaffUpdateWithoutJournalsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductionStaffNestedInput
  }

  export type ProductionStaffUncheckedUpdateWithoutJournalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionItemUpsertWithWhereUniqueWithoutJournalInput = {
    where: ProductionItemWhereUniqueInput
    update: XOR<ProductionItemUpdateWithoutJournalInput, ProductionItemUncheckedUpdateWithoutJournalInput>
    create: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput>
  }

  export type ProductionItemUpdateWithWhereUniqueWithoutJournalInput = {
    where: ProductionItemWhereUniqueInput
    data: XOR<ProductionItemUpdateWithoutJournalInput, ProductionItemUncheckedUpdateWithoutJournalInput>
  }

  export type ProductionItemUpdateManyWithWhereWithoutJournalInput = {
    where: ProductionItemScalarWhereInput
    data: XOR<ProductionItemUpdateManyMutationInput, ProductionItemUncheckedUpdateManyWithoutJournalInput>
  }

  export type ProductionJournalCreateWithoutItemsInput = {
    productionDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    staff: ProductionStaffCreateNestedOneWithoutJournalsInput
  }

  export type ProductionJournalUncheckedCreateWithoutItemsInput = {
    id?: number
    productionDate: Date | string
    staffId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionJournalCreateOrConnectWithoutItemsInput = {
    where: ProductionJournalWhereUniqueInput
    create: XOR<ProductionJournalCreateWithoutItemsInput, ProductionJournalUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutProductionItemsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductionItemsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductionItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductionItemsInput, ProductUncheckedCreateWithoutProductionItemsInput>
  }

  export type ProductionItemValueCreateWithoutProductionItemInput = {
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionItemValueUncheckedCreateWithoutProductionItemInput = {
    id?: number
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionItemValueCreateOrConnectWithoutProductionItemInput = {
    where: ProductionItemValueWhereUniqueInput
    create: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput>
  }

  export type ProductionItemValueCreateManyProductionItemInputEnvelope = {
    data: ProductionItemValueCreateManyProductionItemInput | ProductionItemValueCreateManyProductionItemInput[]
    skipDuplicates?: boolean
  }

  export type ProductionJournalUpsertWithoutItemsInput = {
    update: XOR<ProductionJournalUpdateWithoutItemsInput, ProductionJournalUncheckedUpdateWithoutItemsInput>
    create: XOR<ProductionJournalCreateWithoutItemsInput, ProductionJournalUncheckedCreateWithoutItemsInput>
    where?: ProductionJournalWhereInput
  }

  export type ProductionJournalUpdateToOneWithWhereWithoutItemsInput = {
    where?: ProductionJournalWhereInput
    data: XOR<ProductionJournalUpdateWithoutItemsInput, ProductionJournalUncheckedUpdateWithoutItemsInput>
  }

  export type ProductionJournalUpdateWithoutItemsInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: ProductionStaffUpdateOneRequiredWithoutJournalsNestedInput
  }

  export type ProductionJournalUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithoutProductionItemsInput = {
    update: XOR<ProductUpdateWithoutProductionItemsInput, ProductUncheckedUpdateWithoutProductionItemsInput>
    create: XOR<ProductCreateWithoutProductionItemsInput, ProductUncheckedCreateWithoutProductionItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductionItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductionItemsInput, ProductUncheckedUpdateWithoutProductionItemsInput>
  }

  export type ProductUpdateWithoutProductionItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductionItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductionItemValueUpsertWithWhereUniqueWithoutProductionItemInput = {
    where: ProductionItemValueWhereUniqueInput
    update: XOR<ProductionItemValueUpdateWithoutProductionItemInput, ProductionItemValueUncheckedUpdateWithoutProductionItemInput>
    create: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput>
  }

  export type ProductionItemValueUpdateWithWhereUniqueWithoutProductionItemInput = {
    where: ProductionItemValueWhereUniqueInput
    data: XOR<ProductionItemValueUpdateWithoutProductionItemInput, ProductionItemValueUncheckedUpdateWithoutProductionItemInput>
  }

  export type ProductionItemValueUpdateManyWithWhereWithoutProductionItemInput = {
    where: ProductionItemValueScalarWhereInput
    data: XOR<ProductionItemValueUpdateManyMutationInput, ProductionItemValueUncheckedUpdateManyWithoutProductionItemInput>
  }

  export type ProductionItemValueScalarWhereInput = {
    AND?: ProductionItemValueScalarWhereInput | ProductionItemValueScalarWhereInput[]
    OR?: ProductionItemValueScalarWhereInput[]
    NOT?: ProductionItemValueScalarWhereInput | ProductionItemValueScalarWhereInput[]
    id?: IntFilter<"ProductionItemValue"> | number
    productionItemId?: IntFilter<"ProductionItemValue"> | number
    fieldKey?: StringFilter<"ProductionItemValue"> | string
    fieldValue?: StringNullableFilter<"ProductionItemValue"> | string | null
    updatedAt?: DateTimeFilter<"ProductionItemValue"> | Date | string
    updatedBy?: StringNullableFilter<"ProductionItemValue"> | string | null
  }

  export type ProductionItemCreateWithoutValuesInput = {
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    journal: ProductionJournalCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutProductionItemsInput
  }

  export type ProductionItemUncheckedCreateWithoutValuesInput = {
    id?: number
    journalId: number
    productId?: number | null
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionItemCreateOrConnectWithoutValuesInput = {
    where: ProductionItemWhereUniqueInput
    create: XOR<ProductionItemCreateWithoutValuesInput, ProductionItemUncheckedCreateWithoutValuesInput>
  }

  export type ProductionItemUpsertWithoutValuesInput = {
    update: XOR<ProductionItemUpdateWithoutValuesInput, ProductionItemUncheckedUpdateWithoutValuesInput>
    create: XOR<ProductionItemCreateWithoutValuesInput, ProductionItemUncheckedCreateWithoutValuesInput>
    where?: ProductionItemWhereInput
  }

  export type ProductionItemUpdateToOneWithWhereWithoutValuesInput = {
    where?: ProductionItemWhereInput
    data: XOR<ProductionItemUpdateWithoutValuesInput, ProductionItemUncheckedUpdateWithoutValuesInput>
  }

  export type ProductionItemUpdateWithoutValuesInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: ProductionJournalUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutProductionItemsNestedInput
  }

  export type ProductionItemUncheckedUpdateWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    journalId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceListSupplierCreateWithoutPriceListInput = {
    createdAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchasePriceListSuppliersInput
    primaryMml?: ProductionMmlCreateNestedOneWithoutPriceListSuppliersInput
  }

  export type PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput = {
    id?: number
    supplierId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    create: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput>
  }

  export type PurchasePriceListSupplierCreateManyPriceListInputEnvelope = {
    data: PurchasePriceListSupplierCreateManyPriceListInput | PurchasePriceListSupplierCreateManyPriceListInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceItemCreateWithoutPriceListInput = {
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchasePriceItemsInput
    product: ProductCreateNestedOneWithoutPurchasePriceItemsInput
  }

  export type PurchasePriceItemUncheckedCreateWithoutPriceListInput = {
    id?: number
    supplierId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceItemCreateOrConnectWithoutPriceListInput = {
    where: PurchasePriceItemWhereUniqueInput
    create: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput>
  }

  export type PurchasePriceItemCreateManyPriceListInputEnvelope = {
    data: PurchasePriceItemCreateManyPriceListInput | PurchasePriceItemCreateManyPriceListInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPriceListInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    update: XOR<PurchasePriceListSupplierUpdateWithoutPriceListInput, PurchasePriceListSupplierUncheckedUpdateWithoutPriceListInput>
    create: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput>
  }

  export type PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPriceListInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    data: XOR<PurchasePriceListSupplierUpdateWithoutPriceListInput, PurchasePriceListSupplierUncheckedUpdateWithoutPriceListInput>
  }

  export type PurchasePriceListSupplierUpdateManyWithWhereWithoutPriceListInput = {
    where: PurchasePriceListSupplierScalarWhereInput
    data: XOR<PurchasePriceListSupplierUpdateManyMutationInput, PurchasePriceListSupplierUncheckedUpdateManyWithoutPriceListInput>
  }

  export type PurchasePriceItemUpsertWithWhereUniqueWithoutPriceListInput = {
    where: PurchasePriceItemWhereUniqueInput
    update: XOR<PurchasePriceItemUpdateWithoutPriceListInput, PurchasePriceItemUncheckedUpdateWithoutPriceListInput>
    create: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput>
  }

  export type PurchasePriceItemUpdateWithWhereUniqueWithoutPriceListInput = {
    where: PurchasePriceItemWhereUniqueInput
    data: XOR<PurchasePriceItemUpdateWithoutPriceListInput, PurchasePriceItemUncheckedUpdateWithoutPriceListInput>
  }

  export type PurchasePriceItemUpdateManyWithWhereWithoutPriceListInput = {
    where: PurchasePriceItemScalarWhereInput
    data: XOR<PurchasePriceItemUpdateManyMutationInput, PurchasePriceItemUncheckedUpdateManyWithoutPriceListInput>
  }

  export type PurchasePriceListCreateWithoutSuppliersInput = {
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: PurchasePriceItemCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListUncheckedCreateWithoutSuppliersInput = {
    id?: number
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: PurchasePriceItemUncheckedCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListCreateOrConnectWithoutSuppliersInput = {
    where: PurchasePriceListWhereUniqueInput
    create: XOR<PurchasePriceListCreateWithoutSuppliersInput, PurchasePriceListUncheckedCreateWithoutSuppliersInput>
  }

  export type SupplierCreateWithoutPurchasePriceListSuppliersInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchasePriceListSuppliersInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPurchasePriceListSuppliersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedCreateWithoutPurchasePriceListSuppliersInput>
  }

  export type ProductionMmlCreateWithoutPriceListSuppliersInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutPriceListSuppliersInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutPriceListSuppliersInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutPriceListSuppliersInput, ProductionMmlUncheckedCreateWithoutPriceListSuppliersInput>
  }

  export type PurchasePriceListUpsertWithoutSuppliersInput = {
    update: XOR<PurchasePriceListUpdateWithoutSuppliersInput, PurchasePriceListUncheckedUpdateWithoutSuppliersInput>
    create: XOR<PurchasePriceListCreateWithoutSuppliersInput, PurchasePriceListUncheckedCreateWithoutSuppliersInput>
    where?: PurchasePriceListWhereInput
  }

  export type PurchasePriceListUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: PurchasePriceListWhereInput
    data: XOR<PurchasePriceListUpdateWithoutSuppliersInput, PurchasePriceListUncheckedUpdateWithoutSuppliersInput>
  }

  export type PurchasePriceListUpdateWithoutSuppliersInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PurchasePriceItemUpdateManyWithoutPriceListNestedInput
  }

  export type PurchasePriceListUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PurchasePriceItemUncheckedUpdateManyWithoutPriceListNestedInput
  }

  export type SupplierUpsertWithoutPurchasePriceListSuppliersInput = {
    update: XOR<SupplierUpdateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedUpdateWithoutPurchasePriceListSuppliersInput>
    create: XOR<SupplierCreateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedCreateWithoutPurchasePriceListSuppliersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchasePriceListSuppliersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedUpdateWithoutPurchasePriceListSuppliersInput>
  }

  export type SupplierUpdateWithoutPurchasePriceListSuppliersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchasePriceListSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ProductionMmlUpsertWithoutPriceListSuppliersInput = {
    update: XOR<ProductionMmlUpdateWithoutPriceListSuppliersInput, ProductionMmlUncheckedUpdateWithoutPriceListSuppliersInput>
    create: XOR<ProductionMmlCreateWithoutPriceListSuppliersInput, ProductionMmlUncheckedCreateWithoutPriceListSuppliersInput>
    where?: ProductionMmlWhereInput
  }

  export type ProductionMmlUpdateToOneWithWhereWithoutPriceListSuppliersInput = {
    where?: ProductionMmlWhereInput
    data: XOR<ProductionMmlUpdateWithoutPriceListSuppliersInput, ProductionMmlUncheckedUpdateWithoutPriceListSuppliersInput>
  }

  export type ProductionMmlUpdateWithoutPriceListSuppliersInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutPriceListSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type PurchasePriceListCreateWithoutItemsInput = {
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    suppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListUncheckedCreateWithoutItemsInput = {
    id?: number
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    suppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListCreateOrConnectWithoutItemsInput = {
    where: PurchasePriceListWhereUniqueInput
    create: XOR<PurchasePriceListCreateWithoutItemsInput, PurchasePriceListUncheckedCreateWithoutItemsInput>
  }

  export type SupplierCreateWithoutPurchasePriceItemsInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchasePriceItemsInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPurchasePriceItemsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchasePriceItemsInput, SupplierUncheckedCreateWithoutPurchasePriceItemsInput>
  }

  export type ProductCreateWithoutPurchasePriceItemsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchasePriceItemsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchasePriceItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchasePriceItemsInput, ProductUncheckedCreateWithoutPurchasePriceItemsInput>
  }

  export type PurchasePriceListUpsertWithoutItemsInput = {
    update: XOR<PurchasePriceListUpdateWithoutItemsInput, PurchasePriceListUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchasePriceListCreateWithoutItemsInput, PurchasePriceListUncheckedCreateWithoutItemsInput>
    where?: PurchasePriceListWhereInput
  }

  export type PurchasePriceListUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchasePriceListWhereInput
    data: XOR<PurchasePriceListUpdateWithoutItemsInput, PurchasePriceListUncheckedUpdateWithoutItemsInput>
  }

  export type PurchasePriceListUpdateWithoutItemsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suppliers?: PurchasePriceListSupplierUpdateManyWithoutPriceListNestedInput
  }

  export type PurchasePriceListUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPriceListNestedInput
  }

  export type SupplierUpsertWithoutPurchasePriceItemsInput = {
    update: XOR<SupplierUpdateWithoutPurchasePriceItemsInput, SupplierUncheckedUpdateWithoutPurchasePriceItemsInput>
    create: XOR<SupplierCreateWithoutPurchasePriceItemsInput, SupplierUncheckedCreateWithoutPurchasePriceItemsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchasePriceItemsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchasePriceItemsInput, SupplierUncheckedUpdateWithoutPurchasePriceItemsInput>
  }

  export type SupplierUpdateWithoutPurchasePriceItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchasePriceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ProductUpsertWithoutPurchasePriceItemsInput = {
    update: XOR<ProductUpdateWithoutPurchasePriceItemsInput, ProductUncheckedUpdateWithoutPurchasePriceItemsInput>
    create: XOR<ProductCreateWithoutPurchasePriceItemsInput, ProductUncheckedCreateWithoutPurchasePriceItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchasePriceItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchasePriceItemsInput, ProductUncheckedUpdateWithoutPurchasePriceItemsInput>
  }

  export type ProductUpdateWithoutPurchasePriceItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchasePriceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CustomerCreateWithoutSalesPriceListsInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: DistrictCreateNestedOneWithoutCustomersInput
    manager?: ManagerCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesPriceListsInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesPriceListsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesPriceListsInput, CustomerUncheckedCreateWithoutSalesPriceListsInput>
  }

  export type SalesPriceItemCreateWithoutPriceListInput = {
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    product: ProductCreateNestedOneWithoutSalesPriceItemsInput
  }

  export type SalesPriceItemUncheckedCreateWithoutPriceListInput = {
    id?: number
    productId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SalesPriceItemCreateOrConnectWithoutPriceListInput = {
    where: SalesPriceItemWhereUniqueInput
    create: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput>
  }

  export type SalesPriceItemCreateManyPriceListInputEnvelope = {
    data: SalesPriceItemCreateManyPriceListInput | SalesPriceItemCreateManyPriceListInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutSalesPriceListsInput = {
    update: XOR<CustomerUpdateWithoutSalesPriceListsInput, CustomerUncheckedUpdateWithoutSalesPriceListsInput>
    create: XOR<CustomerCreateWithoutSalesPriceListsInput, CustomerUncheckedCreateWithoutSalesPriceListsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesPriceListsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesPriceListsInput, CustomerUncheckedUpdateWithoutSalesPriceListsInput>
  }

  export type CustomerUpdateWithoutSalesPriceListsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneWithoutCustomersNestedInput
    manager?: ManagerUpdateOneWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesPriceListsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SalesPriceItemUpsertWithWhereUniqueWithoutPriceListInput = {
    where: SalesPriceItemWhereUniqueInput
    update: XOR<SalesPriceItemUpdateWithoutPriceListInput, SalesPriceItemUncheckedUpdateWithoutPriceListInput>
    create: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput>
  }

  export type SalesPriceItemUpdateWithWhereUniqueWithoutPriceListInput = {
    where: SalesPriceItemWhereUniqueInput
    data: XOR<SalesPriceItemUpdateWithoutPriceListInput, SalesPriceItemUncheckedUpdateWithoutPriceListInput>
  }

  export type SalesPriceItemUpdateManyWithWhereWithoutPriceListInput = {
    where: SalesPriceItemScalarWhereInput
    data: XOR<SalesPriceItemUpdateManyMutationInput, SalesPriceItemUncheckedUpdateManyWithoutPriceListInput>
  }

  export type SalesPriceListCreateWithoutItemsInput = {
    listType: string
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    customer?: CustomerCreateNestedOneWithoutSalesPriceListsInput
  }

  export type SalesPriceListUncheckedCreateWithoutItemsInput = {
    id?: number
    listType: string
    customerId?: number | null
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type SalesPriceListCreateOrConnectWithoutItemsInput = {
    where: SalesPriceListWhereUniqueInput
    create: XOR<SalesPriceListCreateWithoutItemsInput, SalesPriceListUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutSalesPriceItemsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSalesPriceItemsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSalesPriceItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSalesPriceItemsInput, ProductUncheckedCreateWithoutSalesPriceItemsInput>
  }

  export type SalesPriceListUpsertWithoutItemsInput = {
    update: XOR<SalesPriceListUpdateWithoutItemsInput, SalesPriceListUncheckedUpdateWithoutItemsInput>
    create: XOR<SalesPriceListCreateWithoutItemsInput, SalesPriceListUncheckedCreateWithoutItemsInput>
    where?: SalesPriceListWhereInput
  }

  export type SalesPriceListUpdateToOneWithWhereWithoutItemsInput = {
    where?: SalesPriceListWhereInput
    data: XOR<SalesPriceListUpdateWithoutItemsInput, SalesPriceListUncheckedUpdateWithoutItemsInput>
  }

  export type SalesPriceListUpdateWithoutItemsInput = {
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutSalesPriceListsNestedInput
  }

  export type SalesPriceListUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    listType?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithoutSalesPriceItemsInput = {
    update: XOR<ProductUpdateWithoutSalesPriceItemsInput, ProductUncheckedUpdateWithoutSalesPriceItemsInput>
    create: XOR<ProductCreateWithoutSalesPriceItemsInput, ProductUncheckedCreateWithoutSalesPriceItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSalesPriceItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSalesPriceItemsInput, ProductUncheckedUpdateWithoutSalesPriceItemsInput>
  }

  export type ProductUpdateWithoutSalesPriceItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSalesPriceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutProductionMmlsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductionMmlsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductionMmlsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductionMmlsInput, ProductUncheckedCreateWithoutProductionMmlsInput>
  }

  export type UserCreateWithoutCreatedMmlsInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffCreateNestedOneWithoutUserInput
    productionRuns?: ProductionRunCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedMmlsInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffUncheckedCreateNestedOneWithoutUserInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedMmlsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedMmlsInput, UserUncheckedCreateWithoutCreatedMmlsInput>
  }

  export type ProductionMmlNodeCreateWithoutMmlInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentNode?: ProductionMmlNodeCreateNestedOneWithoutChildrenInput
    children?: ProductionMmlNodeCreateNestedManyWithoutParentNodeInput
    product: ProductCreateNestedOneWithoutMmlNodesInput
    runValues?: ProductionRunValueCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUncheckedCreateWithoutMmlInput = {
    id?: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput
    runValues?: ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeCreateOrConnectWithoutMmlInput = {
    where: ProductionMmlNodeWhereUniqueInput
    create: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput>
  }

  export type ProductionMmlNodeCreateManyMmlInputEnvelope = {
    data: ProductionMmlNodeCreateManyMmlInput | ProductionMmlNodeCreateManyMmlInput[]
    skipDuplicates?: boolean
  }

  export type ProductionRunCreateWithoutMmlInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionRunsInput
    user: UserCreateNestedOneWithoutProductionRunsInput
    values?: ProductionRunValueCreateNestedManyWithoutRunInput
  }

  export type ProductionRunUncheckedCreateWithoutMmlInput = {
    id?: number
    productId: number
    userId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: ProductionRunValueUncheckedCreateNestedManyWithoutRunInput
  }

  export type ProductionRunCreateOrConnectWithoutMmlInput = {
    where: ProductionRunWhereUniqueInput
    create: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput>
  }

  export type ProductionRunCreateManyMmlInputEnvelope = {
    data: ProductionRunCreateManyMmlInput | ProductionRunCreateManyMmlInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutPrimaryMmlInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPrimaryMmlInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPrimaryMmlInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput>
  }

  export type SupplierCreateManyPrimaryMmlInputEnvelope = {
    data: SupplierCreateManyPrimaryMmlInput | SupplierCreateManyPrimaryMmlInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceListSupplierCreateWithoutPrimaryMmlInput = {
    createdAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutSuppliersInput
    supplier: SupplierCreateNestedOneWithoutPurchasePriceListSuppliersInput
  }

  export type PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput = {
    id?: number
    priceListId: number
    supplierId: number
    createdAt?: Date | string
  }

  export type PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    create: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput>
  }

  export type PurchasePriceListSupplierCreateManyPrimaryMmlInputEnvelope = {
    data: PurchasePriceListSupplierCreateManyPrimaryMmlInput | PurchasePriceListSupplierCreateManyPrimaryMmlInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutProductionMmlsInput = {
    update: XOR<ProductUpdateWithoutProductionMmlsInput, ProductUncheckedUpdateWithoutProductionMmlsInput>
    create: XOR<ProductCreateWithoutProductionMmlsInput, ProductUncheckedCreateWithoutProductionMmlsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductionMmlsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductionMmlsInput, ProductUncheckedUpdateWithoutProductionMmlsInput>
  }

  export type ProductUpdateWithoutProductionMmlsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductionMmlsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutCreatedMmlsInput = {
    update: XOR<UserUpdateWithoutCreatedMmlsInput, UserUncheckedUpdateWithoutCreatedMmlsInput>
    create: XOR<UserCreateWithoutCreatedMmlsInput, UserUncheckedCreateWithoutCreatedMmlsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedMmlsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedMmlsInput, UserUncheckedUpdateWithoutCreatedMmlsInput>
  }

  export type UserUpdateWithoutCreatedMmlsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUpdateOneWithoutUserNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedMmlsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUncheckedUpdateOneWithoutUserNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductionMmlNodeUpsertWithWhereUniqueWithoutMmlInput = {
    where: ProductionMmlNodeWhereUniqueInput
    update: XOR<ProductionMmlNodeUpdateWithoutMmlInput, ProductionMmlNodeUncheckedUpdateWithoutMmlInput>
    create: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput>
  }

  export type ProductionMmlNodeUpdateWithWhereUniqueWithoutMmlInput = {
    where: ProductionMmlNodeWhereUniqueInput
    data: XOR<ProductionMmlNodeUpdateWithoutMmlInput, ProductionMmlNodeUncheckedUpdateWithoutMmlInput>
  }

  export type ProductionMmlNodeUpdateManyWithWhereWithoutMmlInput = {
    where: ProductionMmlNodeScalarWhereInput
    data: XOR<ProductionMmlNodeUpdateManyMutationInput, ProductionMmlNodeUncheckedUpdateManyWithoutMmlInput>
  }

  export type ProductionRunUpsertWithWhereUniqueWithoutMmlInput = {
    where: ProductionRunWhereUniqueInput
    update: XOR<ProductionRunUpdateWithoutMmlInput, ProductionRunUncheckedUpdateWithoutMmlInput>
    create: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput>
  }

  export type ProductionRunUpdateWithWhereUniqueWithoutMmlInput = {
    where: ProductionRunWhereUniqueInput
    data: XOR<ProductionRunUpdateWithoutMmlInput, ProductionRunUncheckedUpdateWithoutMmlInput>
  }

  export type ProductionRunUpdateManyWithWhereWithoutMmlInput = {
    where: ProductionRunScalarWhereInput
    data: XOR<ProductionRunUpdateManyMutationInput, ProductionRunUncheckedUpdateManyWithoutMmlInput>
  }

  export type SupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutPrimaryMmlInput, SupplierUncheckedUpdateWithoutPrimaryMmlInput>
    create: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutPrimaryMmlInput, SupplierUncheckedUpdateWithoutPrimaryMmlInput>
  }

  export type SupplierUpdateManyWithWhereWithoutPrimaryMmlInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutPrimaryMmlInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: IntFilter<"Supplier"> | number
    code?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    legalName?: StringNullableFilter<"Supplier"> | string | null
    altName?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    telegram?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    primaryMmlId?: IntNullableFilter<"Supplier"> | number | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
  }

  export type PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    update: XOR<PurchasePriceListSupplierUpdateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedUpdateWithoutPrimaryMmlInput>
    create: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput>
  }

  export type PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    data: XOR<PurchasePriceListSupplierUpdateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedUpdateWithoutPrimaryMmlInput>
  }

  export type PurchasePriceListSupplierUpdateManyWithWhereWithoutPrimaryMmlInput = {
    where: PurchasePriceListSupplierScalarWhereInput
    data: XOR<PurchasePriceListSupplierUpdateManyMutationInput, PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlInput>
  }

  export type ProductionMmlCreateWithoutNodesInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutNodesInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutNodesInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutNodesInput, ProductionMmlUncheckedCreateWithoutNodesInput>
  }

  export type ProductionMmlNodeCreateWithoutChildrenInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutNodesInput
    parentNode?: ProductionMmlNodeCreateNestedOneWithoutChildrenInput
    product: ProductCreateNestedOneWithoutMmlNodesInput
    runValues?: ProductionRunValueCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUncheckedCreateWithoutChildrenInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    runValues?: ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeCreateOrConnectWithoutChildrenInput = {
    where: ProductionMmlNodeWhereUniqueInput
    create: XOR<ProductionMmlNodeCreateWithoutChildrenInput, ProductionMmlNodeUncheckedCreateWithoutChildrenInput>
  }

  export type ProductionMmlNodeCreateWithoutParentNodeInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutNodesInput
    children?: ProductionMmlNodeCreateNestedManyWithoutParentNodeInput
    product: ProductCreateNestedOneWithoutMmlNodesInput
    runValues?: ProductionRunValueCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUncheckedCreateWithoutParentNodeInput = {
    id?: number
    mmlId: number
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput
    runValues?: ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeCreateOrConnectWithoutParentNodeInput = {
    where: ProductionMmlNodeWhereUniqueInput
    create: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput>
  }

  export type ProductionMmlNodeCreateManyParentNodeInputEnvelope = {
    data: ProductionMmlNodeCreateManyParentNodeInput | ProductionMmlNodeCreateManyParentNodeInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutMmlNodesInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutMmlNodesInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutMmlNodesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMmlNodesInput, ProductUncheckedCreateWithoutMmlNodesInput>
  }

  export type ProductionRunValueCreateWithoutNodeInput = {
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    run: ProductionRunCreateNestedOneWithoutValuesInput
  }

  export type ProductionRunValueUncheckedCreateWithoutNodeInput = {
    id?: number
    productionRunId: number
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueCreateOrConnectWithoutNodeInput = {
    where: ProductionRunValueWhereUniqueInput
    create: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput>
  }

  export type ProductionRunValueCreateManyNodeInputEnvelope = {
    data: ProductionRunValueCreateManyNodeInput | ProductionRunValueCreateManyNodeInput[]
    skipDuplicates?: boolean
  }

  export type ProductionMmlUpsertWithoutNodesInput = {
    update: XOR<ProductionMmlUpdateWithoutNodesInput, ProductionMmlUncheckedUpdateWithoutNodesInput>
    create: XOR<ProductionMmlCreateWithoutNodesInput, ProductionMmlUncheckedCreateWithoutNodesInput>
    where?: ProductionMmlWhereInput
  }

  export type ProductionMmlUpdateToOneWithWhereWithoutNodesInput = {
    where?: ProductionMmlWhereInput
    data: XOR<ProductionMmlUpdateWithoutNodesInput, ProductionMmlUncheckedUpdateWithoutNodesInput>
  }

  export type ProductionMmlUpdateWithoutNodesInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutNodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlNodeUpsertWithoutChildrenInput = {
    update: XOR<ProductionMmlNodeUpdateWithoutChildrenInput, ProductionMmlNodeUncheckedUpdateWithoutChildrenInput>
    create: XOR<ProductionMmlNodeCreateWithoutChildrenInput, ProductionMmlNodeUncheckedCreateWithoutChildrenInput>
    where?: ProductionMmlNodeWhereInput
  }

  export type ProductionMmlNodeUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ProductionMmlNodeWhereInput
    data: XOR<ProductionMmlNodeUpdateWithoutChildrenInput, ProductionMmlNodeUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductionMmlNodeUpdateWithoutChildrenInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutNodesNestedInput
    parentNode?: ProductionMmlNodeUpdateOneWithoutChildrenNestedInput
    product?: ProductUpdateOneRequiredWithoutMmlNodesNestedInput
    runValues?: ProductionRunValueUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runValues?: ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUpsertWithWhereUniqueWithoutParentNodeInput = {
    where: ProductionMmlNodeWhereUniqueInput
    update: XOR<ProductionMmlNodeUpdateWithoutParentNodeInput, ProductionMmlNodeUncheckedUpdateWithoutParentNodeInput>
    create: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput>
  }

  export type ProductionMmlNodeUpdateWithWhereUniqueWithoutParentNodeInput = {
    where: ProductionMmlNodeWhereUniqueInput
    data: XOR<ProductionMmlNodeUpdateWithoutParentNodeInput, ProductionMmlNodeUncheckedUpdateWithoutParentNodeInput>
  }

  export type ProductionMmlNodeUpdateManyWithWhereWithoutParentNodeInput = {
    where: ProductionMmlNodeScalarWhereInput
    data: XOR<ProductionMmlNodeUpdateManyMutationInput, ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeInput>
  }

  export type ProductUpsertWithoutMmlNodesInput = {
    update: XOR<ProductUpdateWithoutMmlNodesInput, ProductUncheckedUpdateWithoutMmlNodesInput>
    create: XOR<ProductCreateWithoutMmlNodesInput, ProductUncheckedCreateWithoutMmlNodesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutMmlNodesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutMmlNodesInput, ProductUncheckedUpdateWithoutMmlNodesInput>
  }

  export type ProductUpdateWithoutMmlNodesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutMmlNodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductionRunValueUpsertWithWhereUniqueWithoutNodeInput = {
    where: ProductionRunValueWhereUniqueInput
    update: XOR<ProductionRunValueUpdateWithoutNodeInput, ProductionRunValueUncheckedUpdateWithoutNodeInput>
    create: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput>
  }

  export type ProductionRunValueUpdateWithWhereUniqueWithoutNodeInput = {
    where: ProductionRunValueWhereUniqueInput
    data: XOR<ProductionRunValueUpdateWithoutNodeInput, ProductionRunValueUncheckedUpdateWithoutNodeInput>
  }

  export type ProductionRunValueUpdateManyWithWhereWithoutNodeInput = {
    where: ProductionRunValueScalarWhereInput
    data: XOR<ProductionRunValueUpdateManyMutationInput, ProductionRunValueUncheckedUpdateManyWithoutNodeInput>
  }

  export type ProductionRunValueScalarWhereInput = {
    AND?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
    OR?: ProductionRunValueScalarWhereInput[]
    NOT?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
    id?: IntFilter<"ProductionRunValue"> | number
    productionRunId?: IntFilter<"ProductionRunValue"> | number
    mmlNodeId?: IntFilter<"ProductionRunValue"> | number
    value?: DecimalNullableFilter<"ProductionRunValue"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
  }

  export type ProductCreateWithoutProductionRunsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductionRunsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductionRunsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductionRunsInput, ProductUncheckedCreateWithoutProductionRunsInput>
  }

  export type ProductionMmlCreateWithoutRunsInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutRunsInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutRunsInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutRunsInput, ProductionMmlUncheckedCreateWithoutRunsInput>
  }

  export type UserCreateWithoutProductionRunsInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutProductionRunsInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffUncheckedCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutProductionRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductionRunsInput, UserUncheckedCreateWithoutProductionRunsInput>
  }

  export type ProductionRunValueCreateWithoutRunInput = {
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    node: ProductionMmlNodeCreateNestedOneWithoutRunValuesInput
  }

  export type ProductionRunValueUncheckedCreateWithoutRunInput = {
    id?: number
    mmlNodeId: number
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueCreateOrConnectWithoutRunInput = {
    where: ProductionRunValueWhereUniqueInput
    create: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput>
  }

  export type ProductionRunValueCreateManyRunInputEnvelope = {
    data: ProductionRunValueCreateManyRunInput | ProductionRunValueCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutProductionRunsInput = {
    update: XOR<ProductUpdateWithoutProductionRunsInput, ProductUncheckedUpdateWithoutProductionRunsInput>
    create: XOR<ProductCreateWithoutProductionRunsInput, ProductUncheckedCreateWithoutProductionRunsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductionRunsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductionRunsInput, ProductUncheckedUpdateWithoutProductionRunsInput>
  }

  export type ProductUpdateWithoutProductionRunsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductionRunsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductionMmlUpsertWithoutRunsInput = {
    update: XOR<ProductionMmlUpdateWithoutRunsInput, ProductionMmlUncheckedUpdateWithoutRunsInput>
    create: XOR<ProductionMmlCreateWithoutRunsInput, ProductionMmlUncheckedCreateWithoutRunsInput>
    where?: ProductionMmlWhereInput
  }

  export type ProductionMmlUpdateToOneWithWhereWithoutRunsInput = {
    where?: ProductionMmlWhereInput
    data: XOR<ProductionMmlUpdateWithoutRunsInput, ProductionMmlUncheckedUpdateWithoutRunsInput>
  }

  export type ProductionMmlUpdateWithoutRunsInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutRunsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type UserUpsertWithoutProductionRunsInput = {
    update: XOR<UserUpdateWithoutProductionRunsInput, UserUncheckedUpdateWithoutProductionRunsInput>
    create: XOR<UserCreateWithoutProductionRunsInput, UserUncheckedCreateWithoutProductionRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductionRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductionRunsInput, UserUncheckedUpdateWithoutProductionRunsInput>
  }

  export type UserUpdateWithoutProductionRunsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutProductionRunsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUncheckedUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProductionRunValueUpsertWithWhereUniqueWithoutRunInput = {
    where: ProductionRunValueWhereUniqueInput
    update: XOR<ProductionRunValueUpdateWithoutRunInput, ProductionRunValueUncheckedUpdateWithoutRunInput>
    create: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput>
  }

  export type ProductionRunValueUpdateWithWhereUniqueWithoutRunInput = {
    where: ProductionRunValueWhereUniqueInput
    data: XOR<ProductionRunValueUpdateWithoutRunInput, ProductionRunValueUncheckedUpdateWithoutRunInput>
  }

  export type ProductionRunValueUpdateManyWithWhereWithoutRunInput = {
    where: ProductionRunValueScalarWhereInput
    data: XOR<ProductionRunValueUpdateManyMutationInput, ProductionRunValueUncheckedUpdateManyWithoutRunInput>
  }

  export type ProductionRunCreateWithoutValuesInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionRunsInput
    mml: ProductionMmlCreateNestedOneWithoutRunsInput
    user: UserCreateNestedOneWithoutProductionRunsInput
  }

  export type ProductionRunUncheckedCreateWithoutValuesInput = {
    id?: number
    productId: number
    mmlId: number
    userId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunCreateOrConnectWithoutValuesInput = {
    where: ProductionRunWhereUniqueInput
    create: XOR<ProductionRunCreateWithoutValuesInput, ProductionRunUncheckedCreateWithoutValuesInput>
  }

  export type ProductionMmlNodeCreateWithoutRunValuesInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutNodesInput
    parentNode?: ProductionMmlNodeCreateNestedOneWithoutChildrenInput
    children?: ProductionMmlNodeCreateNestedManyWithoutParentNodeInput
    product: ProductCreateNestedOneWithoutMmlNodesInput
  }

  export type ProductionMmlNodeUncheckedCreateWithoutRunValuesInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput
  }

  export type ProductionMmlNodeCreateOrConnectWithoutRunValuesInput = {
    where: ProductionMmlNodeWhereUniqueInput
    create: XOR<ProductionMmlNodeCreateWithoutRunValuesInput, ProductionMmlNodeUncheckedCreateWithoutRunValuesInput>
  }

  export type ProductionRunUpsertWithoutValuesInput = {
    update: XOR<ProductionRunUpdateWithoutValuesInput, ProductionRunUncheckedUpdateWithoutValuesInput>
    create: XOR<ProductionRunCreateWithoutValuesInput, ProductionRunUncheckedCreateWithoutValuesInput>
    where?: ProductionRunWhereInput
  }

  export type ProductionRunUpdateToOneWithWhereWithoutValuesInput = {
    where?: ProductionRunWhereInput
    data: XOR<ProductionRunUpdateWithoutValuesInput, ProductionRunUncheckedUpdateWithoutValuesInput>
  }

  export type ProductionRunUpdateWithoutValuesInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionRunsNestedInput
    mml?: ProductionMmlUpdateOneRequiredWithoutRunsNestedInput
    user?: UserUpdateOneRequiredWithoutProductionRunsNestedInput
  }

  export type ProductionRunUncheckedUpdateWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionMmlNodeUpsertWithoutRunValuesInput = {
    update: XOR<ProductionMmlNodeUpdateWithoutRunValuesInput, ProductionMmlNodeUncheckedUpdateWithoutRunValuesInput>
    create: XOR<ProductionMmlNodeCreateWithoutRunValuesInput, ProductionMmlNodeUncheckedCreateWithoutRunValuesInput>
    where?: ProductionMmlNodeWhereInput
  }

  export type ProductionMmlNodeUpdateToOneWithWhereWithoutRunValuesInput = {
    where?: ProductionMmlNodeWhereInput
    data: XOR<ProductionMmlNodeUpdateWithoutRunValuesInput, ProductionMmlNodeUncheckedUpdateWithoutRunValuesInput>
  }

  export type ProductionMmlNodeUpdateWithoutRunValuesInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutNodesNestedInput
    parentNode?: ProductionMmlNodeUpdateOneWithoutChildrenNestedInput
    children?: ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput
    product?: ProductUpdateOneRequiredWithoutMmlNodesNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateWithoutRunValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput
  }

  export type ProductionMmlCreateManyCreatorInput = {
    id?: number
    productId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunCreateManyUserInput = {
    id?: number
    productId: number
    mmlId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionMmlUpdateWithoutCreatorInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunUpdateWithoutUserInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionRunsNestedInput
    mml?: ProductionMmlUpdateOneRequiredWithoutRunsNestedInput
    values?: ProductionRunValueUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: ProductionRunValueUncheckedUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateManyDistrictInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateWithoutDistrictInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateManyManagerInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateWithoutManagerInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: number
    orderId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type StockTransactionCreateManyProductInput = {
    id?: number
    type: string
    quantity: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SupplierProductCreateManyProductInput = {
    supplierId: number
  }

  export type SummaryOrderJournalCreateManyProductInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerId?: number | null
    customerName: string
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionItemCreateManyProductInput = {
    id?: number
    journalId: number
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type PurchasePriceItemCreateManyProductInput = {
    id?: number
    priceListId: number
    supplierId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesPriceItemCreateManyProductInput = {
    id?: number
    priceListId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionMmlCreateManyProductInput = {
    id?: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionMmlNodeCreateManyProductInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunCreateManyProductInput = {
    id?: number
    mmlId: number
    userId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StockTransactionUpdateWithoutProductInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutStockTransactionsNestedInput
  }

  export type StockTransactionUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierProductUpdateWithoutProductInput = {
    supplier?: SupplierUpdateOneRequiredWithoutProductsNestedInput
  }

  export type SupplierProductUncheckedUpdateWithoutProductInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierProductUncheckedUpdateManyWithoutProductInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type SummaryOrderJournalUpdateWithoutProductInput = {
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutSummaryJournalEntriesNestedInput
  }

  export type SummaryOrderJournalUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrderJournalUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionItemUpdateWithoutProductInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: ProductionJournalUpdateOneRequiredWithoutItemsNestedInput
    values?: ProductionItemValueUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    journalId?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    values?: ProductionItemValueUncheckedUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    journalId?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceItemUpdateWithoutProductInput = {
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutItemsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
  }

  export type PurchasePriceItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesPriceItemUpdateWithoutProductInput = {
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    priceList?: SalesPriceListUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SalesPriceItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionMmlUpdateWithoutProductInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionMmlNodeUpdateWithoutProductInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutNodesNestedInput
    parentNode?: ProductionMmlNodeUpdateOneWithoutChildrenNestedInput
    children?: ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput
    runValues?: ProductionRunValueUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput
    runValues?: ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunUpdateWithoutProductInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutRunsNestedInput
    user?: UserUpdateOneRequiredWithoutProductionRunsNestedInput
    values?: ProductionRunValueUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: ProductionRunValueUncheckedUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SummaryOrderJournalCreateManyCustomerInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerName: string
    productId?: number | null
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesPriceListCreateManyCustomerInput = {
    id?: number
    listType: string
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type OrderUpdateWithoutCustomerInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expeditor?: ExpeditorUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrderJournalUpdateWithoutCustomerInput = {
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutSummaryJournalEntriesNestedInput
  }

  export type SummaryOrderJournalUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrderJournalUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesPriceListUpdateWithoutCustomerInput = {
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: SalesPriceItemUpdateManyWithoutPriceListNestedInput
  }

  export type SalesPriceListUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: SalesPriceItemUncheckedUpdateManyWithoutPriceListNestedInput
  }

  export type SalesPriceListUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierProductCreateManySupplierInput = {
    productId: number
  }

  export type PurchasePriceListSupplierCreateManySupplierInput = {
    id?: number
    priceListId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceItemCreateManySupplierInput = {
    id?: number
    priceListId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierProductUpdateWithoutSupplierInput = {
    product?: ProductUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type SupplierProductUncheckedUpdateWithoutSupplierInput = {
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierProductUncheckedUpdateManyWithoutSupplierInput = {
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type PurchasePriceListSupplierUpdateWithoutSupplierInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutSuppliersNestedInput
    primaryMml?: ProductionMmlUpdateOneWithoutPriceListSuppliersNestedInput
  }

  export type PurchasePriceListSupplierUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUpdateWithoutSupplierInput = {
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
  }

  export type PurchasePriceItemUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    productId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type StockTransactionCreateManyOrderInput = {
    id?: number
    productId: number
    type: string
    quantity: number
    note?: string | null
    createdAt?: Date | string
  }

  export type OrderAttachmentCreateManyOrderInput = {
    id?: number
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StockTransactionUpdateWithoutOrderInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockTransactionsNestedInput
  }

  export type StockTransactionUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentUpdateWithoutOrderInput = {
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyExpeditorInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutExpeditorInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutExpeditorInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutExpeditorInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionJournalCreateManyStaffInput = {
    id?: number
    productionDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionJournalUpdateWithoutStaffInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ProductionItemUpdateManyWithoutJournalNestedInput
  }

  export type ProductionJournalUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ProductionItemUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type ProductionJournalUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemCreateManyJournalInput = {
    id?: number
    productId?: number | null
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionItemUpdateWithoutJournalInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneWithoutProductionItemsNestedInput
    values?: ProductionItemValueUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemUncheckedUpdateWithoutJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    values?: ProductionItemValueUncheckedUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemUncheckedUpdateManyWithoutJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueCreateManyProductionItemInput = {
    id?: number
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionItemValueUpdateWithoutProductionItemInput = {
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueUncheckedUpdateWithoutProductionItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueUncheckedUpdateManyWithoutProductionItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceListSupplierCreateManyPriceListInput = {
    id?: number
    supplierId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceItemCreateManyPriceListInput = {
    id?: number
    supplierId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceListSupplierUpdateWithoutPriceListInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceListSuppliersNestedInput
    primaryMml?: ProductionMmlUpdateOneWithoutPriceListSuppliersNestedInput
  }

  export type PurchasePriceListSupplierUncheckedUpdateWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUpdateWithoutPriceListInput = {
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
  }

  export type PurchasePriceItemUncheckedUpdateWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesPriceItemCreateManyPriceListInput = {
    id?: number
    productId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SalesPriceItemUpdateWithoutPriceListInput = {
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutSalesPriceItemsNestedInput
  }

  export type SalesPriceItemUncheckedUpdateWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceItemUncheckedUpdateManyWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionMmlNodeCreateManyMmlInput = {
    id?: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunCreateManyMmlInput = {
    id?: number
    productId: number
    userId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateManyPrimaryMmlInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceListSupplierCreateManyPrimaryMmlInput = {
    id?: number
    priceListId: number
    supplierId: number
    createdAt?: Date | string
  }

  export type ProductionMmlNodeUpdateWithoutMmlInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentNode?: ProductionMmlNodeUpdateOneWithoutChildrenNestedInput
    children?: ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput
    product?: ProductUpdateOneRequiredWithoutMmlNodesNestedInput
    runValues?: ProductionRunValueUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateWithoutMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput
    runValues?: ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunUpdateWithoutMmlInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionRunsNestedInput
    user?: UserUpdateOneRequiredWithoutProductionRunsNestedInput
    values?: ProductionRunValueUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateWithoutMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: ProductionRunValueUncheckedUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateManyWithoutMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpdateWithoutPrimaryMmlInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPrimaryMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutPrimaryMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierUpdateWithoutPrimaryMmlInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutSuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceListSuppliersNestedInput
  }

  export type PurchasePriceListSupplierUncheckedUpdateWithoutPrimaryMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionMmlNodeCreateManyParentNodeInput = {
    id?: number
    mmlId: number
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueCreateManyNodeInput = {
    id?: number
    productionRunId: number
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionMmlNodeUpdateWithoutParentNodeInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutNodesNestedInput
    children?: ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput
    product?: ProductUpdateOneRequiredWithoutMmlNodesNestedInput
    runValues?: ProductionRunValueUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateWithoutParentNodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput
    runValues?: ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueUpdateWithoutNodeInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: ProductionRunUpdateOneRequiredWithoutValuesNestedInput
  }

  export type ProductionRunValueUncheckedUpdateWithoutNodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionRunId?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueUncheckedUpdateManyWithoutNodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionRunId?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueCreateManyRunInput = {
    id?: number
    mmlNodeId: number
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueUpdateWithoutRunInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: ProductionMmlNodeUpdateOneRequiredWithoutRunValuesNestedInput
  }

  export type ProductionRunValueUncheckedUpdateWithoutRunInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlNodeId?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueUncheckedUpdateManyWithoutRunInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlNodeId?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}