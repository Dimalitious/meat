
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model District
 * 
 */
export type District = $Result.DefaultSelection<Prisma.$DistrictPayload>
/**
 * Model Manager
 * 
 */
export type Manager = $Result.DefaultSelection<Prisma.$ManagerPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerProduct
 * 
 */
export type CustomerProduct = $Result.DefaultSelection<Prisma.$CustomerProductPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model SupplierProduct
 * 
 */
export type SupplierProduct = $Result.DefaultSelection<Prisma.$SupplierProductPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderAttachment
 * 
 */
export type OrderAttachment = $Result.DefaultSelection<Prisma.$OrderAttachmentPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Expeditor
 * 
 */
export type Expeditor = $Result.DefaultSelection<Prisma.$ExpeditorPayload>
/**
 * Model Stock
 * 
 */
export type Stock = $Result.DefaultSelection<Prisma.$StockPayload>
/**
 * Model StockTransaction
 * 
 */
export type StockTransaction = $Result.DefaultSelection<Prisma.$StockTransactionPayload>
/**
 * Model SummaryOrderJournal
 * 
 */
export type SummaryOrderJournal = $Result.DefaultSelection<Prisma.$SummaryOrderJournalPayload>
/**
 * Model SummaryOrderEvent
 * 
 */
export type SummaryOrderEvent = $Result.DefaultSelection<Prisma.$SummaryOrderEventPayload>
/**
 * Model SummaryOrdersJournal
 * 
 */
export type SummaryOrdersJournal = $Result.DefaultSelection<Prisma.$SummaryOrdersJournalPayload>
/**
 * Model AssemblyOrdersJournal
 * 
 */
export type AssemblyOrdersJournal = $Result.DefaultSelection<Prisma.$AssemblyOrdersJournalPayload>
/**
 * Model ProductionStaff
 * 
 */
export type ProductionStaff = $Result.DefaultSelection<Prisma.$ProductionStaffPayload>
/**
 * Model ProductionJournal
 * 
 */
export type ProductionJournal = $Result.DefaultSelection<Prisma.$ProductionJournalPayload>
/**
 * Model ProductionItem
 * 
 */
export type ProductionItem = $Result.DefaultSelection<Prisma.$ProductionItemPayload>
/**
 * Model ProductionItemValue
 * 
 */
export type ProductionItemValue = $Result.DefaultSelection<Prisma.$ProductionItemValuePayload>
/**
 * Model PurchasePriceList
 * 
 */
export type PurchasePriceList = $Result.DefaultSelection<Prisma.$PurchasePriceListPayload>
/**
 * Model PurchasePriceListSupplier
 * 
 */
export type PurchasePriceListSupplier = $Result.DefaultSelection<Prisma.$PurchasePriceListSupplierPayload>
/**
 * Model PurchasePriceItem
 * 
 */
export type PurchasePriceItem = $Result.DefaultSelection<Prisma.$PurchasePriceItemPayload>
/**
 * Model SalesPriceList
 * 
 */
export type SalesPriceList = $Result.DefaultSelection<Prisma.$SalesPriceListPayload>
/**
 * Model SalesPriceItem
 * 
 */
export type SalesPriceItem = $Result.DefaultSelection<Prisma.$SalesPriceItemPayload>
/**
 * Model ProductionMml
 * 
 */
export type ProductionMml = $Result.DefaultSelection<Prisma.$ProductionMmlPayload>
/**
 * Model ProductionMmlNode
 * 
 */
export type ProductionMmlNode = $Result.DefaultSelection<Prisma.$ProductionMmlNodePayload>
/**
 * Model ProductionRun
 * 
 */
export type ProductionRun = $Result.DefaultSelection<Prisma.$ProductionRunPayload>
/**
 * Model ProductionRunValue
 * 
 */
export type ProductionRunValue = $Result.DefaultSelection<Prisma.$ProductionRunValuePayload>
/**
 * Model PaymentType
 * 
 */
export type PaymentType = $Result.DefaultSelection<Prisma.$PaymentTypePayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model PurchaseSupplier
 * 
 */
export type PurchaseSupplier = $Result.DefaultSelection<Prisma.$PurchaseSupplierPayload>
/**
 * Model PurchaseItem
 * 
 */
export type PurchaseItem = $Result.DefaultSelection<Prisma.$PurchaseItemPayload>
/**
 * Model TelegramGroup
 * 
 */
export type TelegramGroup = $Result.DefaultSelection<Prisma.$TelegramGroupPayload>
/**
 * Model TelegramOrderDraft
 * 
 */
export type TelegramOrderDraft = $Result.DefaultSelection<Prisma.$TelegramOrderDraftPayload>
/**
 * Model TelegramOrderDraftItem
 * 
 */
export type TelegramOrderDraftItem = $Result.DefaultSelection<Prisma.$TelegramOrderDraftItemPayload>
/**
 * Model Warehouse
 * 
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model SvodHeader
 * 
 */
export type SvodHeader = $Result.DefaultSelection<Prisma.$SvodHeaderPayload>
/**
 * Model SvodLine
 * 
 */
export type SvodLine = $Result.DefaultSelection<Prisma.$SvodLinePayload>
/**
 * Model SvodSupplierCol
 * 
 */
export type SvodSupplierCol = $Result.DefaultSelection<Prisma.$SvodSupplierColPayload>
/**
 * Model SvodSupplierValue
 * 
 */
export type SvodSupplierValue = $Result.DefaultSelection<Prisma.$SvodSupplierValuePayload>
/**
 * Model ProductionDoc
 * 
 */
export type ProductionDoc = $Result.DefaultSelection<Prisma.$ProductionDocPayload>
/**
 * Model ProductionInput
 * 
 */
export type ProductionInput = $Result.DefaultSelection<Prisma.$ProductionInputPayload>
/**
 * Model ProductionOutput
 * 
 */
export type ProductionOutput = $Result.DefaultSelection<Prisma.$ProductionOutputPayload>
/**
 * Model ProductionCuttingLine
 * 
 */
export type ProductionCuttingLine = $Result.DefaultSelection<Prisma.$ProductionCuttingLinePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.district`: Exposes CRUD operations for the **District** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Districts
    * const districts = await prisma.district.findMany()
    * ```
    */
  get district(): Prisma.DistrictDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerProduct`: Exposes CRUD operations for the **CustomerProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerProducts
    * const customerProducts = await prisma.customerProduct.findMany()
    * ```
    */
  get customerProduct(): Prisma.CustomerProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierProduct`: Exposes CRUD operations for the **SupplierProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierProducts
    * const supplierProducts = await prisma.supplierProduct.findMany()
    * ```
    */
  get supplierProduct(): Prisma.SupplierProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderAttachment`: Exposes CRUD operations for the **OrderAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderAttachments
    * const orderAttachments = await prisma.orderAttachment.findMany()
    * ```
    */
  get orderAttachment(): Prisma.OrderAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expeditor`: Exposes CRUD operations for the **Expeditor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expeditors
    * const expeditors = await prisma.expeditor.findMany()
    * ```
    */
  get expeditor(): Prisma.ExpeditorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stock`: Exposes CRUD operations for the **Stock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stock.findMany()
    * ```
    */
  get stock(): Prisma.StockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockTransaction`: Exposes CRUD operations for the **StockTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockTransactions
    * const stockTransactions = await prisma.stockTransaction.findMany()
    * ```
    */
  get stockTransaction(): Prisma.StockTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.summaryOrderJournal`: Exposes CRUD operations for the **SummaryOrderJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SummaryOrderJournals
    * const summaryOrderJournals = await prisma.summaryOrderJournal.findMany()
    * ```
    */
  get summaryOrderJournal(): Prisma.SummaryOrderJournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.summaryOrderEvent`: Exposes CRUD operations for the **SummaryOrderEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SummaryOrderEvents
    * const summaryOrderEvents = await prisma.summaryOrderEvent.findMany()
    * ```
    */
  get summaryOrderEvent(): Prisma.SummaryOrderEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.summaryOrdersJournal`: Exposes CRUD operations for the **SummaryOrdersJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SummaryOrdersJournals
    * const summaryOrdersJournals = await prisma.summaryOrdersJournal.findMany()
    * ```
    */
  get summaryOrdersJournal(): Prisma.SummaryOrdersJournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assemblyOrdersJournal`: Exposes CRUD operations for the **AssemblyOrdersJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssemblyOrdersJournals
    * const assemblyOrdersJournals = await prisma.assemblyOrdersJournal.findMany()
    * ```
    */
  get assemblyOrdersJournal(): Prisma.AssemblyOrdersJournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionStaff`: Exposes CRUD operations for the **ProductionStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionStaffs
    * const productionStaffs = await prisma.productionStaff.findMany()
    * ```
    */
  get productionStaff(): Prisma.ProductionStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionJournal`: Exposes CRUD operations for the **ProductionJournal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionJournals
    * const productionJournals = await prisma.productionJournal.findMany()
    * ```
    */
  get productionJournal(): Prisma.ProductionJournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionItem`: Exposes CRUD operations for the **ProductionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionItems
    * const productionItems = await prisma.productionItem.findMany()
    * ```
    */
  get productionItem(): Prisma.ProductionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionItemValue`: Exposes CRUD operations for the **ProductionItemValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionItemValues
    * const productionItemValues = await prisma.productionItemValue.findMany()
    * ```
    */
  get productionItemValue(): Prisma.ProductionItemValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchasePriceList`: Exposes CRUD operations for the **PurchasePriceList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasePriceLists
    * const purchasePriceLists = await prisma.purchasePriceList.findMany()
    * ```
    */
  get purchasePriceList(): Prisma.PurchasePriceListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchasePriceListSupplier`: Exposes CRUD operations for the **PurchasePriceListSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasePriceListSuppliers
    * const purchasePriceListSuppliers = await prisma.purchasePriceListSupplier.findMany()
    * ```
    */
  get purchasePriceListSupplier(): Prisma.PurchasePriceListSupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchasePriceItem`: Exposes CRUD operations for the **PurchasePriceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasePriceItems
    * const purchasePriceItems = await prisma.purchasePriceItem.findMany()
    * ```
    */
  get purchasePriceItem(): Prisma.PurchasePriceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesPriceList`: Exposes CRUD operations for the **SalesPriceList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesPriceLists
    * const salesPriceLists = await prisma.salesPriceList.findMany()
    * ```
    */
  get salesPriceList(): Prisma.SalesPriceListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesPriceItem`: Exposes CRUD operations for the **SalesPriceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesPriceItems
    * const salesPriceItems = await prisma.salesPriceItem.findMany()
    * ```
    */
  get salesPriceItem(): Prisma.SalesPriceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionMml`: Exposes CRUD operations for the **ProductionMml** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionMmls
    * const productionMmls = await prisma.productionMml.findMany()
    * ```
    */
  get productionMml(): Prisma.ProductionMmlDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionMmlNode`: Exposes CRUD operations for the **ProductionMmlNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionMmlNodes
    * const productionMmlNodes = await prisma.productionMmlNode.findMany()
    * ```
    */
  get productionMmlNode(): Prisma.ProductionMmlNodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionRun`: Exposes CRUD operations for the **ProductionRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionRuns
    * const productionRuns = await prisma.productionRun.findMany()
    * ```
    */
  get productionRun(): Prisma.ProductionRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionRunValue`: Exposes CRUD operations for the **ProductionRunValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionRunValues
    * const productionRunValues = await prisma.productionRunValue.findMany()
    * ```
    */
  get productionRunValue(): Prisma.ProductionRunValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentType`: Exposes CRUD operations for the **PaymentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentTypes
    * const paymentTypes = await prisma.paymentType.findMany()
    * ```
    */
  get paymentType(): Prisma.PaymentTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseSupplier`: Exposes CRUD operations for the **PurchaseSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseSuppliers
    * const purchaseSuppliers = await prisma.purchaseSupplier.findMany()
    * ```
    */
  get purchaseSupplier(): Prisma.PurchaseSupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseItem`: Exposes CRUD operations for the **PurchaseItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseItems
    * const purchaseItems = await prisma.purchaseItem.findMany()
    * ```
    */
  get purchaseItem(): Prisma.PurchaseItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telegramGroup`: Exposes CRUD operations for the **TelegramGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelegramGroups
    * const telegramGroups = await prisma.telegramGroup.findMany()
    * ```
    */
  get telegramGroup(): Prisma.TelegramGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telegramOrderDraft`: Exposes CRUD operations for the **TelegramOrderDraft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelegramOrderDrafts
    * const telegramOrderDrafts = await prisma.telegramOrderDraft.findMany()
    * ```
    */
  get telegramOrderDraft(): Prisma.TelegramOrderDraftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telegramOrderDraftItem`: Exposes CRUD operations for the **TelegramOrderDraftItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelegramOrderDraftItems
    * const telegramOrderDraftItems = await prisma.telegramOrderDraftItem.findMany()
    * ```
    */
  get telegramOrderDraftItem(): Prisma.TelegramOrderDraftItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.svodHeader`: Exposes CRUD operations for the **SvodHeader** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SvodHeaders
    * const svodHeaders = await prisma.svodHeader.findMany()
    * ```
    */
  get svodHeader(): Prisma.SvodHeaderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.svodLine`: Exposes CRUD operations for the **SvodLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SvodLines
    * const svodLines = await prisma.svodLine.findMany()
    * ```
    */
  get svodLine(): Prisma.SvodLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.svodSupplierCol`: Exposes CRUD operations for the **SvodSupplierCol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SvodSupplierCols
    * const svodSupplierCols = await prisma.svodSupplierCol.findMany()
    * ```
    */
  get svodSupplierCol(): Prisma.SvodSupplierColDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.svodSupplierValue`: Exposes CRUD operations for the **SvodSupplierValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SvodSupplierValues
    * const svodSupplierValues = await prisma.svodSupplierValue.findMany()
    * ```
    */
  get svodSupplierValue(): Prisma.SvodSupplierValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionDoc`: Exposes CRUD operations for the **ProductionDoc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionDocs
    * const productionDocs = await prisma.productionDoc.findMany()
    * ```
    */
  get productionDoc(): Prisma.ProductionDocDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionInput`: Exposes CRUD operations for the **ProductionInput** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionInputs
    * const productionInputs = await prisma.productionInput.findMany()
    * ```
    */
  get productionInput(): Prisma.ProductionInputDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionOutput`: Exposes CRUD operations for the **ProductionOutput** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionOutputs
    * const productionOutputs = await prisma.productionOutput.findMany()
    * ```
    */
  get productionOutput(): Prisma.ProductionOutputDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionCuttingLine`: Exposes CRUD operations for the **ProductionCuttingLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionCuttingLines
    * const productionCuttingLines = await prisma.productionCuttingLine.findMany()
    * ```
    */
  get productionCuttingLine(): Prisma.ProductionCuttingLineDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    District: 'District',
    Manager: 'Manager',
    Product: 'Product',
    Customer: 'Customer',
    CustomerProduct: 'CustomerProduct',
    Supplier: 'Supplier',
    SupplierProduct: 'SupplierProduct',
    Order: 'Order',
    OrderAttachment: 'OrderAttachment',
    OrderItem: 'OrderItem',
    Expeditor: 'Expeditor',
    Stock: 'Stock',
    StockTransaction: 'StockTransaction',
    SummaryOrderJournal: 'SummaryOrderJournal',
    SummaryOrderEvent: 'SummaryOrderEvent',
    SummaryOrdersJournal: 'SummaryOrdersJournal',
    AssemblyOrdersJournal: 'AssemblyOrdersJournal',
    ProductionStaff: 'ProductionStaff',
    ProductionJournal: 'ProductionJournal',
    ProductionItem: 'ProductionItem',
    ProductionItemValue: 'ProductionItemValue',
    PurchasePriceList: 'PurchasePriceList',
    PurchasePriceListSupplier: 'PurchasePriceListSupplier',
    PurchasePriceItem: 'PurchasePriceItem',
    SalesPriceList: 'SalesPriceList',
    SalesPriceItem: 'SalesPriceItem',
    ProductionMml: 'ProductionMml',
    ProductionMmlNode: 'ProductionMmlNode',
    ProductionRun: 'ProductionRun',
    ProductionRunValue: 'ProductionRunValue',
    PaymentType: 'PaymentType',
    Purchase: 'Purchase',
    PurchaseSupplier: 'PurchaseSupplier',
    PurchaseItem: 'PurchaseItem',
    TelegramGroup: 'TelegramGroup',
    TelegramOrderDraft: 'TelegramOrderDraft',
    TelegramOrderDraftItem: 'TelegramOrderDraftItem',
    Warehouse: 'Warehouse',
    SvodHeader: 'SvodHeader',
    SvodLine: 'SvodLine',
    SvodSupplierCol: 'SvodSupplierCol',
    SvodSupplierValue: 'SvodSupplierValue',
    ProductionDoc: 'ProductionDoc',
    ProductionInput: 'ProductionInput',
    ProductionOutput: 'ProductionOutput',
    ProductionCuttingLine: 'ProductionCuttingLine'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "district" | "manager" | "product" | "customer" | "customerProduct" | "supplier" | "supplierProduct" | "order" | "orderAttachment" | "orderItem" | "expeditor" | "stock" | "stockTransaction" | "summaryOrderJournal" | "summaryOrderEvent" | "summaryOrdersJournal" | "assemblyOrdersJournal" | "productionStaff" | "productionJournal" | "productionItem" | "productionItemValue" | "purchasePriceList" | "purchasePriceListSupplier" | "purchasePriceItem" | "salesPriceList" | "salesPriceItem" | "productionMml" | "productionMmlNode" | "productionRun" | "productionRunValue" | "paymentType" | "purchase" | "purchaseSupplier" | "purchaseItem" | "telegramGroup" | "telegramOrderDraft" | "telegramOrderDraftItem" | "warehouse" | "svodHeader" | "svodLine" | "svodSupplierCol" | "svodSupplierValue" | "productionDoc" | "productionInput" | "productionOutput" | "productionCuttingLine"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      District: {
        payload: Prisma.$DistrictPayload<ExtArgs>
        fields: Prisma.DistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistrictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistrictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findFirst: {
            args: Prisma.DistrictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistrictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findMany: {
            args: Prisma.DistrictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          create: {
            args: Prisma.DistrictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          createMany: {
            args: Prisma.DistrictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistrictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          delete: {
            args: Prisma.DistrictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          update: {
            args: Prisma.DistrictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          deleteMany: {
            args: Prisma.DistrictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistrictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DistrictUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          upsert: {
            args: Prisma.DistrictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          aggregate: {
            args: Prisma.DistrictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistrict>
          }
          groupBy: {
            args: Prisma.DistrictGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistrictCountArgs<ExtArgs>
            result: $Utils.Optional<DistrictCountAggregateOutputType> | number
          }
        }
      }
      Manager: {
        payload: Prisma.$ManagerPayload<ExtArgs>
        fields: Prisma.ManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findFirst: {
            args: Prisma.ManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findMany: {
            args: Prisma.ManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          create: {
            args: Prisma.ManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          createMany: {
            args: Prisma.ManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          delete: {
            args: Prisma.ManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          update: {
            args: Prisma.ManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          deleteMany: {
            args: Prisma.ManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          upsert: {
            args: Prisma.ManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          aggregate: {
            args: Prisma.ManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManager>
          }
          groupBy: {
            args: Prisma.ManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManagerCountArgs<ExtArgs>
            result: $Utils.Optional<ManagerCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerProduct: {
        payload: Prisma.$CustomerProductPayload<ExtArgs>
        fields: Prisma.CustomerProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductPayload>
          }
          findFirst: {
            args: Prisma.CustomerProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductPayload>
          }
          findMany: {
            args: Prisma.CustomerProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductPayload>[]
          }
          create: {
            args: Prisma.CustomerProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductPayload>
          }
          createMany: {
            args: Prisma.CustomerProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductPayload>[]
          }
          delete: {
            args: Prisma.CustomerProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductPayload>
          }
          update: {
            args: Prisma.CustomerProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductPayload>
          }
          deleteMany: {
            args: Prisma.CustomerProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductPayload>[]
          }
          upsert: {
            args: Prisma.CustomerProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductPayload>
          }
          aggregate: {
            args: Prisma.CustomerProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerProduct>
          }
          groupBy: {
            args: Prisma.CustomerProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerProductCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerProductCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      SupplierProduct: {
        payload: Prisma.$SupplierProductPayload<ExtArgs>
        fields: Prisma.SupplierProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          findFirst: {
            args: Prisma.SupplierProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          findMany: {
            args: Prisma.SupplierProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>[]
          }
          create: {
            args: Prisma.SupplierProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          createMany: {
            args: Prisma.SupplierProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>[]
          }
          delete: {
            args: Prisma.SupplierProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          update: {
            args: Prisma.SupplierProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          deleteMany: {
            args: Prisma.SupplierProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>[]
          }
          upsert: {
            args: Prisma.SupplierProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          aggregate: {
            args: Prisma.SupplierProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierProduct>
          }
          groupBy: {
            args: Prisma.SupplierProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierProductCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderAttachment: {
        payload: Prisma.$OrderAttachmentPayload<ExtArgs>
        fields: Prisma.OrderAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          findFirst: {
            args: Prisma.OrderAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          findMany: {
            args: Prisma.OrderAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>[]
          }
          create: {
            args: Prisma.OrderAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          createMany: {
            args: Prisma.OrderAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>[]
          }
          delete: {
            args: Prisma.OrderAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          update: {
            args: Prisma.OrderAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.OrderAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.OrderAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAttachmentPayload>
          }
          aggregate: {
            args: Prisma.OrderAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderAttachment>
          }
          groupBy: {
            args: Prisma.OrderAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<OrderAttachmentCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Expeditor: {
        payload: Prisma.$ExpeditorPayload<ExtArgs>
        fields: Prisma.ExpeditorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpeditorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpeditorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          findFirst: {
            args: Prisma.ExpeditorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpeditorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          findMany: {
            args: Prisma.ExpeditorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>[]
          }
          create: {
            args: Prisma.ExpeditorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          createMany: {
            args: Prisma.ExpeditorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpeditorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>[]
          }
          delete: {
            args: Prisma.ExpeditorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          update: {
            args: Prisma.ExpeditorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          deleteMany: {
            args: Prisma.ExpeditorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpeditorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpeditorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>[]
          }
          upsert: {
            args: Prisma.ExpeditorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpeditorPayload>
          }
          aggregate: {
            args: Prisma.ExpeditorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpeditor>
          }
          groupBy: {
            args: Prisma.ExpeditorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpeditorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpeditorCountArgs<ExtArgs>
            result: $Utils.Optional<ExpeditorCountAggregateOutputType> | number
          }
        }
      }
      Stock: {
        payload: Prisma.$StockPayload<ExtArgs>
        fields: Prisma.StockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findFirst: {
            args: Prisma.StockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findMany: {
            args: Prisma.StockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          create: {
            args: Prisma.StockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          createMany: {
            args: Prisma.StockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          delete: {
            args: Prisma.StockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          update: {
            args: Prisma.StockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          deleteMany: {
            args: Prisma.StockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          upsert: {
            args: Prisma.StockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          aggregate: {
            args: Prisma.StockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStock>
          }
          groupBy: {
            args: Prisma.StockGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockCountArgs<ExtArgs>
            result: $Utils.Optional<StockCountAggregateOutputType> | number
          }
        }
      }
      StockTransaction: {
        payload: Prisma.$StockTransactionPayload<ExtArgs>
        fields: Prisma.StockTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          findFirst: {
            args: Prisma.StockTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          findMany: {
            args: Prisma.StockTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>[]
          }
          create: {
            args: Prisma.StockTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          createMany: {
            args: Prisma.StockTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>[]
          }
          delete: {
            args: Prisma.StockTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          update: {
            args: Prisma.StockTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          deleteMany: {
            args: Prisma.StockTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>[]
          }
          upsert: {
            args: Prisma.StockTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransactionPayload>
          }
          aggregate: {
            args: Prisma.StockTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockTransaction>
          }
          groupBy: {
            args: Prisma.StockTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<StockTransactionCountAggregateOutputType> | number
          }
        }
      }
      SummaryOrderJournal: {
        payload: Prisma.$SummaryOrderJournalPayload<ExtArgs>
        fields: Prisma.SummaryOrderJournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SummaryOrderJournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SummaryOrderJournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          findFirst: {
            args: Prisma.SummaryOrderJournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SummaryOrderJournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          findMany: {
            args: Prisma.SummaryOrderJournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>[]
          }
          create: {
            args: Prisma.SummaryOrderJournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          createMany: {
            args: Prisma.SummaryOrderJournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SummaryOrderJournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>[]
          }
          delete: {
            args: Prisma.SummaryOrderJournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          update: {
            args: Prisma.SummaryOrderJournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          deleteMany: {
            args: Prisma.SummaryOrderJournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SummaryOrderJournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SummaryOrderJournalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>[]
          }
          upsert: {
            args: Prisma.SummaryOrderJournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderJournalPayload>
          }
          aggregate: {
            args: Prisma.SummaryOrderJournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSummaryOrderJournal>
          }
          groupBy: {
            args: Prisma.SummaryOrderJournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<SummaryOrderJournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.SummaryOrderJournalCountArgs<ExtArgs>
            result: $Utils.Optional<SummaryOrderJournalCountAggregateOutputType> | number
          }
        }
      }
      SummaryOrderEvent: {
        payload: Prisma.$SummaryOrderEventPayload<ExtArgs>
        fields: Prisma.SummaryOrderEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SummaryOrderEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SummaryOrderEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderEventPayload>
          }
          findFirst: {
            args: Prisma.SummaryOrderEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SummaryOrderEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderEventPayload>
          }
          findMany: {
            args: Prisma.SummaryOrderEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderEventPayload>[]
          }
          create: {
            args: Prisma.SummaryOrderEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderEventPayload>
          }
          createMany: {
            args: Prisma.SummaryOrderEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SummaryOrderEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderEventPayload>[]
          }
          delete: {
            args: Prisma.SummaryOrderEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderEventPayload>
          }
          update: {
            args: Prisma.SummaryOrderEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderEventPayload>
          }
          deleteMany: {
            args: Prisma.SummaryOrderEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SummaryOrderEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SummaryOrderEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderEventPayload>[]
          }
          upsert: {
            args: Prisma.SummaryOrderEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrderEventPayload>
          }
          aggregate: {
            args: Prisma.SummaryOrderEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSummaryOrderEvent>
          }
          groupBy: {
            args: Prisma.SummaryOrderEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SummaryOrderEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SummaryOrderEventCountArgs<ExtArgs>
            result: $Utils.Optional<SummaryOrderEventCountAggregateOutputType> | number
          }
        }
      }
      SummaryOrdersJournal: {
        payload: Prisma.$SummaryOrdersJournalPayload<ExtArgs>
        fields: Prisma.SummaryOrdersJournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SummaryOrdersJournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SummaryOrdersJournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          findFirst: {
            args: Prisma.SummaryOrdersJournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SummaryOrdersJournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          findMany: {
            args: Prisma.SummaryOrdersJournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>[]
          }
          create: {
            args: Prisma.SummaryOrdersJournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          createMany: {
            args: Prisma.SummaryOrdersJournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SummaryOrdersJournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>[]
          }
          delete: {
            args: Prisma.SummaryOrdersJournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          update: {
            args: Prisma.SummaryOrdersJournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          deleteMany: {
            args: Prisma.SummaryOrdersJournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SummaryOrdersJournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SummaryOrdersJournalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>[]
          }
          upsert: {
            args: Prisma.SummaryOrdersJournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummaryOrdersJournalPayload>
          }
          aggregate: {
            args: Prisma.SummaryOrdersJournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSummaryOrdersJournal>
          }
          groupBy: {
            args: Prisma.SummaryOrdersJournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<SummaryOrdersJournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.SummaryOrdersJournalCountArgs<ExtArgs>
            result: $Utils.Optional<SummaryOrdersJournalCountAggregateOutputType> | number
          }
        }
      }
      AssemblyOrdersJournal: {
        payload: Prisma.$AssemblyOrdersJournalPayload<ExtArgs>
        fields: Prisma.AssemblyOrdersJournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssemblyOrdersJournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssemblyOrdersJournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          findFirst: {
            args: Prisma.AssemblyOrdersJournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssemblyOrdersJournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          findMany: {
            args: Prisma.AssemblyOrdersJournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>[]
          }
          create: {
            args: Prisma.AssemblyOrdersJournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          createMany: {
            args: Prisma.AssemblyOrdersJournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssemblyOrdersJournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>[]
          }
          delete: {
            args: Prisma.AssemblyOrdersJournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          update: {
            args: Prisma.AssemblyOrdersJournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          deleteMany: {
            args: Prisma.AssemblyOrdersJournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssemblyOrdersJournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssemblyOrdersJournalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>[]
          }
          upsert: {
            args: Prisma.AssemblyOrdersJournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssemblyOrdersJournalPayload>
          }
          aggregate: {
            args: Prisma.AssemblyOrdersJournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssemblyOrdersJournal>
          }
          groupBy: {
            args: Prisma.AssemblyOrdersJournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssemblyOrdersJournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssemblyOrdersJournalCountArgs<ExtArgs>
            result: $Utils.Optional<AssemblyOrdersJournalCountAggregateOutputType> | number
          }
        }
      }
      ProductionStaff: {
        payload: Prisma.$ProductionStaffPayload<ExtArgs>
        fields: Prisma.ProductionStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          findFirst: {
            args: Prisma.ProductionStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          findMany: {
            args: Prisma.ProductionStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>[]
          }
          create: {
            args: Prisma.ProductionStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          createMany: {
            args: Prisma.ProductionStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>[]
          }
          delete: {
            args: Prisma.ProductionStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          update: {
            args: Prisma.ProductionStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          deleteMany: {
            args: Prisma.ProductionStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>[]
          }
          upsert: {
            args: Prisma.ProductionStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionStaffPayload>
          }
          aggregate: {
            args: Prisma.ProductionStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionStaff>
          }
          groupBy: {
            args: Prisma.ProductionStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionStaffCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionStaffCountAggregateOutputType> | number
          }
        }
      }
      ProductionJournal: {
        payload: Prisma.$ProductionJournalPayload<ExtArgs>
        fields: Prisma.ProductionJournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionJournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionJournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          findFirst: {
            args: Prisma.ProductionJournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionJournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          findMany: {
            args: Prisma.ProductionJournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>[]
          }
          create: {
            args: Prisma.ProductionJournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          createMany: {
            args: Prisma.ProductionJournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionJournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>[]
          }
          delete: {
            args: Prisma.ProductionJournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          update: {
            args: Prisma.ProductionJournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          deleteMany: {
            args: Prisma.ProductionJournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionJournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionJournalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>[]
          }
          upsert: {
            args: Prisma.ProductionJournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionJournalPayload>
          }
          aggregate: {
            args: Prisma.ProductionJournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionJournal>
          }
          groupBy: {
            args: Prisma.ProductionJournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionJournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionJournalCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionJournalCountAggregateOutputType> | number
          }
        }
      }
      ProductionItem: {
        payload: Prisma.$ProductionItemPayload<ExtArgs>
        fields: Prisma.ProductionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          findFirst: {
            args: Prisma.ProductionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          findMany: {
            args: Prisma.ProductionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>[]
          }
          create: {
            args: Prisma.ProductionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          createMany: {
            args: Prisma.ProductionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>[]
          }
          delete: {
            args: Prisma.ProductionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          update: {
            args: Prisma.ProductionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          deleteMany: {
            args: Prisma.ProductionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>[]
          }
          upsert: {
            args: Prisma.ProductionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemPayload>
          }
          aggregate: {
            args: Prisma.ProductionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionItem>
          }
          groupBy: {
            args: Prisma.ProductionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionItemCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionItemCountAggregateOutputType> | number
          }
        }
      }
      ProductionItemValue: {
        payload: Prisma.$ProductionItemValuePayload<ExtArgs>
        fields: Prisma.ProductionItemValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionItemValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionItemValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          findFirst: {
            args: Prisma.ProductionItemValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionItemValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          findMany: {
            args: Prisma.ProductionItemValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>[]
          }
          create: {
            args: Prisma.ProductionItemValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          createMany: {
            args: Prisma.ProductionItemValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionItemValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>[]
          }
          delete: {
            args: Prisma.ProductionItemValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          update: {
            args: Prisma.ProductionItemValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          deleteMany: {
            args: Prisma.ProductionItemValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionItemValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionItemValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>[]
          }
          upsert: {
            args: Prisma.ProductionItemValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionItemValuePayload>
          }
          aggregate: {
            args: Prisma.ProductionItemValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionItemValue>
          }
          groupBy: {
            args: Prisma.ProductionItemValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionItemValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionItemValueCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionItemValueCountAggregateOutputType> | number
          }
        }
      }
      PurchasePriceList: {
        payload: Prisma.$PurchasePriceListPayload<ExtArgs>
        fields: Prisma.PurchasePriceListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasePriceListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasePriceListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          findFirst: {
            args: Prisma.PurchasePriceListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasePriceListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          findMany: {
            args: Prisma.PurchasePriceListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>[]
          }
          create: {
            args: Prisma.PurchasePriceListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          createMany: {
            args: Prisma.PurchasePriceListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasePriceListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>[]
          }
          delete: {
            args: Prisma.PurchasePriceListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          update: {
            args: Prisma.PurchasePriceListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          deleteMany: {
            args: Prisma.PurchasePriceListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasePriceListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchasePriceListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>[]
          }
          upsert: {
            args: Prisma.PurchasePriceListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListPayload>
          }
          aggregate: {
            args: Prisma.PurchasePriceListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasePriceList>
          }
          groupBy: {
            args: Prisma.PurchasePriceListGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceListGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasePriceListCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceListCountAggregateOutputType> | number
          }
        }
      }
      PurchasePriceListSupplier: {
        payload: Prisma.$PurchasePriceListSupplierPayload<ExtArgs>
        fields: Prisma.PurchasePriceListSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasePriceListSupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasePriceListSupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          findFirst: {
            args: Prisma.PurchasePriceListSupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasePriceListSupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          findMany: {
            args: Prisma.PurchasePriceListSupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>[]
          }
          create: {
            args: Prisma.PurchasePriceListSupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          createMany: {
            args: Prisma.PurchasePriceListSupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasePriceListSupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>[]
          }
          delete: {
            args: Prisma.PurchasePriceListSupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          update: {
            args: Prisma.PurchasePriceListSupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          deleteMany: {
            args: Prisma.PurchasePriceListSupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasePriceListSupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchasePriceListSupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>[]
          }
          upsert: {
            args: Prisma.PurchasePriceListSupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceListSupplierPayload>
          }
          aggregate: {
            args: Prisma.PurchasePriceListSupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasePriceListSupplier>
          }
          groupBy: {
            args: Prisma.PurchasePriceListSupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceListSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasePriceListSupplierCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceListSupplierCountAggregateOutputType> | number
          }
        }
      }
      PurchasePriceItem: {
        payload: Prisma.$PurchasePriceItemPayload<ExtArgs>
        fields: Prisma.PurchasePriceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasePriceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasePriceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          findFirst: {
            args: Prisma.PurchasePriceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasePriceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          findMany: {
            args: Prisma.PurchasePriceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>[]
          }
          create: {
            args: Prisma.PurchasePriceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          createMany: {
            args: Prisma.PurchasePriceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasePriceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>[]
          }
          delete: {
            args: Prisma.PurchasePriceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          update: {
            args: Prisma.PurchasePriceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchasePriceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasePriceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchasePriceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchasePriceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePriceItemPayload>
          }
          aggregate: {
            args: Prisma.PurchasePriceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasePriceItem>
          }
          groupBy: {
            args: Prisma.PurchasePriceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasePriceItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasePriceItemCountAggregateOutputType> | number
          }
        }
      }
      SalesPriceList: {
        payload: Prisma.$SalesPriceListPayload<ExtArgs>
        fields: Prisma.SalesPriceListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesPriceListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesPriceListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          findFirst: {
            args: Prisma.SalesPriceListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesPriceListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          findMany: {
            args: Prisma.SalesPriceListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>[]
          }
          create: {
            args: Prisma.SalesPriceListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          createMany: {
            args: Prisma.SalesPriceListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesPriceListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>[]
          }
          delete: {
            args: Prisma.SalesPriceListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          update: {
            args: Prisma.SalesPriceListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          deleteMany: {
            args: Prisma.SalesPriceListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesPriceListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesPriceListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>[]
          }
          upsert: {
            args: Prisma.SalesPriceListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceListPayload>
          }
          aggregate: {
            args: Prisma.SalesPriceListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesPriceList>
          }
          groupBy: {
            args: Prisma.SalesPriceListGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesPriceListGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesPriceListCountArgs<ExtArgs>
            result: $Utils.Optional<SalesPriceListCountAggregateOutputType> | number
          }
        }
      }
      SalesPriceItem: {
        payload: Prisma.$SalesPriceItemPayload<ExtArgs>
        fields: Prisma.SalesPriceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesPriceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesPriceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          findFirst: {
            args: Prisma.SalesPriceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesPriceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          findMany: {
            args: Prisma.SalesPriceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>[]
          }
          create: {
            args: Prisma.SalesPriceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          createMany: {
            args: Prisma.SalesPriceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesPriceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>[]
          }
          delete: {
            args: Prisma.SalesPriceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          update: {
            args: Prisma.SalesPriceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          deleteMany: {
            args: Prisma.SalesPriceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesPriceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesPriceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>[]
          }
          upsert: {
            args: Prisma.SalesPriceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPriceItemPayload>
          }
          aggregate: {
            args: Prisma.SalesPriceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesPriceItem>
          }
          groupBy: {
            args: Prisma.SalesPriceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesPriceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesPriceItemCountArgs<ExtArgs>
            result: $Utils.Optional<SalesPriceItemCountAggregateOutputType> | number
          }
        }
      }
      ProductionMml: {
        payload: Prisma.$ProductionMmlPayload<ExtArgs>
        fields: Prisma.ProductionMmlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionMmlFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionMmlFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          findFirst: {
            args: Prisma.ProductionMmlFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionMmlFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          findMany: {
            args: Prisma.ProductionMmlFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>[]
          }
          create: {
            args: Prisma.ProductionMmlCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          createMany: {
            args: Prisma.ProductionMmlCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionMmlCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>[]
          }
          delete: {
            args: Prisma.ProductionMmlDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          update: {
            args: Prisma.ProductionMmlUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          deleteMany: {
            args: Prisma.ProductionMmlDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionMmlUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionMmlUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>[]
          }
          upsert: {
            args: Prisma.ProductionMmlUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlPayload>
          }
          aggregate: {
            args: Prisma.ProductionMmlAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionMml>
          }
          groupBy: {
            args: Prisma.ProductionMmlGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionMmlGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionMmlCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionMmlCountAggregateOutputType> | number
          }
        }
      }
      ProductionMmlNode: {
        payload: Prisma.$ProductionMmlNodePayload<ExtArgs>
        fields: Prisma.ProductionMmlNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionMmlNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionMmlNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          findFirst: {
            args: Prisma.ProductionMmlNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionMmlNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          findMany: {
            args: Prisma.ProductionMmlNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>[]
          }
          create: {
            args: Prisma.ProductionMmlNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          createMany: {
            args: Prisma.ProductionMmlNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionMmlNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>[]
          }
          delete: {
            args: Prisma.ProductionMmlNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          update: {
            args: Prisma.ProductionMmlNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          deleteMany: {
            args: Prisma.ProductionMmlNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionMmlNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionMmlNodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>[]
          }
          upsert: {
            args: Prisma.ProductionMmlNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionMmlNodePayload>
          }
          aggregate: {
            args: Prisma.ProductionMmlNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionMmlNode>
          }
          groupBy: {
            args: Prisma.ProductionMmlNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionMmlNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionMmlNodeCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionMmlNodeCountAggregateOutputType> | number
          }
        }
      }
      ProductionRun: {
        payload: Prisma.$ProductionRunPayload<ExtArgs>
        fields: Prisma.ProductionRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          findFirst: {
            args: Prisma.ProductionRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          findMany: {
            args: Prisma.ProductionRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>[]
          }
          create: {
            args: Prisma.ProductionRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          createMany: {
            args: Prisma.ProductionRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>[]
          }
          delete: {
            args: Prisma.ProductionRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          update: {
            args: Prisma.ProductionRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          deleteMany: {
            args: Prisma.ProductionRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>[]
          }
          upsert: {
            args: Prisma.ProductionRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunPayload>
          }
          aggregate: {
            args: Prisma.ProductionRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionRun>
          }
          groupBy: {
            args: Prisma.ProductionRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionRunCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionRunCountAggregateOutputType> | number
          }
        }
      }
      ProductionRunValue: {
        payload: Prisma.$ProductionRunValuePayload<ExtArgs>
        fields: Prisma.ProductionRunValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionRunValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionRunValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          findFirst: {
            args: Prisma.ProductionRunValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionRunValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          findMany: {
            args: Prisma.ProductionRunValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>[]
          }
          create: {
            args: Prisma.ProductionRunValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          createMany: {
            args: Prisma.ProductionRunValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionRunValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>[]
          }
          delete: {
            args: Prisma.ProductionRunValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          update: {
            args: Prisma.ProductionRunValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          deleteMany: {
            args: Prisma.ProductionRunValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionRunValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionRunValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>[]
          }
          upsert: {
            args: Prisma.ProductionRunValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRunValuePayload>
          }
          aggregate: {
            args: Prisma.ProductionRunValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionRunValue>
          }
          groupBy: {
            args: Prisma.ProductionRunValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionRunValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionRunValueCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionRunValueCountAggregateOutputType> | number
          }
        }
      }
      PaymentType: {
        payload: Prisma.$PaymentTypePayload<ExtArgs>
        fields: Prisma.PaymentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTypePayload>
          }
          findFirst: {
            args: Prisma.PaymentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTypePayload>
          }
          findMany: {
            args: Prisma.PaymentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTypePayload>[]
          }
          create: {
            args: Prisma.PaymentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTypePayload>
          }
          createMany: {
            args: Prisma.PaymentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTypePayload>[]
          }
          delete: {
            args: Prisma.PaymentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTypePayload>
          }
          update: {
            args: Prisma.PaymentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTypePayload>
          }
          deleteMany: {
            args: Prisma.PaymentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTypePayload>[]
          }
          upsert: {
            args: Prisma.PaymentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTypePayload>
          }
          aggregate: {
            args: Prisma.PaymentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentType>
          }
          groupBy: {
            args: Prisma.PaymentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentTypeCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      PurchaseSupplier: {
        payload: Prisma.$PurchaseSupplierPayload<ExtArgs>
        fields: Prisma.PurchaseSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseSupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseSupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseSupplierPayload>
          }
          findFirst: {
            args: Prisma.PurchaseSupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseSupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseSupplierPayload>
          }
          findMany: {
            args: Prisma.PurchaseSupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseSupplierPayload>[]
          }
          create: {
            args: Prisma.PurchaseSupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseSupplierPayload>
          }
          createMany: {
            args: Prisma.PurchaseSupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseSupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseSupplierPayload>[]
          }
          delete: {
            args: Prisma.PurchaseSupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseSupplierPayload>
          }
          update: {
            args: Prisma.PurchaseSupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseSupplierPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseSupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseSupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseSupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseSupplierPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseSupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseSupplierPayload>
          }
          aggregate: {
            args: Prisma.PurchaseSupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseSupplier>
          }
          groupBy: {
            args: Prisma.PurchaseSupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseSupplierCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseSupplierCountAggregateOutputType> | number
          }
        }
      }
      PurchaseItem: {
        payload: Prisma.$PurchaseItemPayload<ExtArgs>
        fields: Prisma.PurchaseItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          update: {
            args: Prisma.PurchaseItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseItem>
          }
          groupBy: {
            args: Prisma.PurchaseItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemCountAggregateOutputType> | number
          }
        }
      }
      TelegramGroup: {
        payload: Prisma.$TelegramGroupPayload<ExtArgs>
        fields: Prisma.TelegramGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelegramGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelegramGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramGroupPayload>
          }
          findFirst: {
            args: Prisma.TelegramGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelegramGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramGroupPayload>
          }
          findMany: {
            args: Prisma.TelegramGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramGroupPayload>[]
          }
          create: {
            args: Prisma.TelegramGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramGroupPayload>
          }
          createMany: {
            args: Prisma.TelegramGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TelegramGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramGroupPayload>[]
          }
          delete: {
            args: Prisma.TelegramGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramGroupPayload>
          }
          update: {
            args: Prisma.TelegramGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramGroupPayload>
          }
          deleteMany: {
            args: Prisma.TelegramGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TelegramGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TelegramGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramGroupPayload>[]
          }
          upsert: {
            args: Prisma.TelegramGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramGroupPayload>
          }
          aggregate: {
            args: Prisma.TelegramGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelegramGroup>
          }
          groupBy: {
            args: Prisma.TelegramGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelegramGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelegramGroupCountArgs<ExtArgs>
            result: $Utils.Optional<TelegramGroupCountAggregateOutputType> | number
          }
        }
      }
      TelegramOrderDraft: {
        payload: Prisma.$TelegramOrderDraftPayload<ExtArgs>
        fields: Prisma.TelegramOrderDraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelegramOrderDraftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelegramOrderDraftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftPayload>
          }
          findFirst: {
            args: Prisma.TelegramOrderDraftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelegramOrderDraftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftPayload>
          }
          findMany: {
            args: Prisma.TelegramOrderDraftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftPayload>[]
          }
          create: {
            args: Prisma.TelegramOrderDraftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftPayload>
          }
          createMany: {
            args: Prisma.TelegramOrderDraftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TelegramOrderDraftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftPayload>[]
          }
          delete: {
            args: Prisma.TelegramOrderDraftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftPayload>
          }
          update: {
            args: Prisma.TelegramOrderDraftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftPayload>
          }
          deleteMany: {
            args: Prisma.TelegramOrderDraftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TelegramOrderDraftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TelegramOrderDraftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftPayload>[]
          }
          upsert: {
            args: Prisma.TelegramOrderDraftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftPayload>
          }
          aggregate: {
            args: Prisma.TelegramOrderDraftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelegramOrderDraft>
          }
          groupBy: {
            args: Prisma.TelegramOrderDraftGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelegramOrderDraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelegramOrderDraftCountArgs<ExtArgs>
            result: $Utils.Optional<TelegramOrderDraftCountAggregateOutputType> | number
          }
        }
      }
      TelegramOrderDraftItem: {
        payload: Prisma.$TelegramOrderDraftItemPayload<ExtArgs>
        fields: Prisma.TelegramOrderDraftItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelegramOrderDraftItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelegramOrderDraftItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftItemPayload>
          }
          findFirst: {
            args: Prisma.TelegramOrderDraftItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelegramOrderDraftItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftItemPayload>
          }
          findMany: {
            args: Prisma.TelegramOrderDraftItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftItemPayload>[]
          }
          create: {
            args: Prisma.TelegramOrderDraftItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftItemPayload>
          }
          createMany: {
            args: Prisma.TelegramOrderDraftItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TelegramOrderDraftItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftItemPayload>[]
          }
          delete: {
            args: Prisma.TelegramOrderDraftItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftItemPayload>
          }
          update: {
            args: Prisma.TelegramOrderDraftItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftItemPayload>
          }
          deleteMany: {
            args: Prisma.TelegramOrderDraftItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TelegramOrderDraftItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TelegramOrderDraftItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftItemPayload>[]
          }
          upsert: {
            args: Prisma.TelegramOrderDraftItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramOrderDraftItemPayload>
          }
          aggregate: {
            args: Prisma.TelegramOrderDraftItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelegramOrderDraftItem>
          }
          groupBy: {
            args: Prisma.TelegramOrderDraftItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelegramOrderDraftItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelegramOrderDraftItemCountArgs<ExtArgs>
            result: $Utils.Optional<TelegramOrderDraftItemCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      SvodHeader: {
        payload: Prisma.$SvodHeaderPayload<ExtArgs>
        fields: Prisma.SvodHeaderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SvodHeaderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodHeaderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SvodHeaderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodHeaderPayload>
          }
          findFirst: {
            args: Prisma.SvodHeaderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodHeaderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SvodHeaderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodHeaderPayload>
          }
          findMany: {
            args: Prisma.SvodHeaderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodHeaderPayload>[]
          }
          create: {
            args: Prisma.SvodHeaderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodHeaderPayload>
          }
          createMany: {
            args: Prisma.SvodHeaderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SvodHeaderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodHeaderPayload>[]
          }
          delete: {
            args: Prisma.SvodHeaderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodHeaderPayload>
          }
          update: {
            args: Prisma.SvodHeaderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodHeaderPayload>
          }
          deleteMany: {
            args: Prisma.SvodHeaderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SvodHeaderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SvodHeaderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodHeaderPayload>[]
          }
          upsert: {
            args: Prisma.SvodHeaderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodHeaderPayload>
          }
          aggregate: {
            args: Prisma.SvodHeaderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSvodHeader>
          }
          groupBy: {
            args: Prisma.SvodHeaderGroupByArgs<ExtArgs>
            result: $Utils.Optional<SvodHeaderGroupByOutputType>[]
          }
          count: {
            args: Prisma.SvodHeaderCountArgs<ExtArgs>
            result: $Utils.Optional<SvodHeaderCountAggregateOutputType> | number
          }
        }
      }
      SvodLine: {
        payload: Prisma.$SvodLinePayload<ExtArgs>
        fields: Prisma.SvodLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SvodLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SvodLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodLinePayload>
          }
          findFirst: {
            args: Prisma.SvodLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SvodLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodLinePayload>
          }
          findMany: {
            args: Prisma.SvodLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodLinePayload>[]
          }
          create: {
            args: Prisma.SvodLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodLinePayload>
          }
          createMany: {
            args: Prisma.SvodLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SvodLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodLinePayload>[]
          }
          delete: {
            args: Prisma.SvodLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodLinePayload>
          }
          update: {
            args: Prisma.SvodLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodLinePayload>
          }
          deleteMany: {
            args: Prisma.SvodLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SvodLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SvodLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodLinePayload>[]
          }
          upsert: {
            args: Prisma.SvodLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodLinePayload>
          }
          aggregate: {
            args: Prisma.SvodLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSvodLine>
          }
          groupBy: {
            args: Prisma.SvodLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<SvodLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.SvodLineCountArgs<ExtArgs>
            result: $Utils.Optional<SvodLineCountAggregateOutputType> | number
          }
        }
      }
      SvodSupplierCol: {
        payload: Prisma.$SvodSupplierColPayload<ExtArgs>
        fields: Prisma.SvodSupplierColFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SvodSupplierColFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierColPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SvodSupplierColFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierColPayload>
          }
          findFirst: {
            args: Prisma.SvodSupplierColFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierColPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SvodSupplierColFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierColPayload>
          }
          findMany: {
            args: Prisma.SvodSupplierColFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierColPayload>[]
          }
          create: {
            args: Prisma.SvodSupplierColCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierColPayload>
          }
          createMany: {
            args: Prisma.SvodSupplierColCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SvodSupplierColCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierColPayload>[]
          }
          delete: {
            args: Prisma.SvodSupplierColDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierColPayload>
          }
          update: {
            args: Prisma.SvodSupplierColUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierColPayload>
          }
          deleteMany: {
            args: Prisma.SvodSupplierColDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SvodSupplierColUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SvodSupplierColUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierColPayload>[]
          }
          upsert: {
            args: Prisma.SvodSupplierColUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierColPayload>
          }
          aggregate: {
            args: Prisma.SvodSupplierColAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSvodSupplierCol>
          }
          groupBy: {
            args: Prisma.SvodSupplierColGroupByArgs<ExtArgs>
            result: $Utils.Optional<SvodSupplierColGroupByOutputType>[]
          }
          count: {
            args: Prisma.SvodSupplierColCountArgs<ExtArgs>
            result: $Utils.Optional<SvodSupplierColCountAggregateOutputType> | number
          }
        }
      }
      SvodSupplierValue: {
        payload: Prisma.$SvodSupplierValuePayload<ExtArgs>
        fields: Prisma.SvodSupplierValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SvodSupplierValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SvodSupplierValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierValuePayload>
          }
          findFirst: {
            args: Prisma.SvodSupplierValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SvodSupplierValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierValuePayload>
          }
          findMany: {
            args: Prisma.SvodSupplierValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierValuePayload>[]
          }
          create: {
            args: Prisma.SvodSupplierValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierValuePayload>
          }
          createMany: {
            args: Prisma.SvodSupplierValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SvodSupplierValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierValuePayload>[]
          }
          delete: {
            args: Prisma.SvodSupplierValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierValuePayload>
          }
          update: {
            args: Prisma.SvodSupplierValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierValuePayload>
          }
          deleteMany: {
            args: Prisma.SvodSupplierValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SvodSupplierValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SvodSupplierValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierValuePayload>[]
          }
          upsert: {
            args: Prisma.SvodSupplierValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SvodSupplierValuePayload>
          }
          aggregate: {
            args: Prisma.SvodSupplierValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSvodSupplierValue>
          }
          groupBy: {
            args: Prisma.SvodSupplierValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<SvodSupplierValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.SvodSupplierValueCountArgs<ExtArgs>
            result: $Utils.Optional<SvodSupplierValueCountAggregateOutputType> | number
          }
        }
      }
      ProductionDoc: {
        payload: Prisma.$ProductionDocPayload<ExtArgs>
        fields: Prisma.ProductionDocFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionDocFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDocPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionDocFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDocPayload>
          }
          findFirst: {
            args: Prisma.ProductionDocFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDocPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionDocFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDocPayload>
          }
          findMany: {
            args: Prisma.ProductionDocFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDocPayload>[]
          }
          create: {
            args: Prisma.ProductionDocCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDocPayload>
          }
          createMany: {
            args: Prisma.ProductionDocCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionDocCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDocPayload>[]
          }
          delete: {
            args: Prisma.ProductionDocDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDocPayload>
          }
          update: {
            args: Prisma.ProductionDocUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDocPayload>
          }
          deleteMany: {
            args: Prisma.ProductionDocDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionDocUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionDocUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDocPayload>[]
          }
          upsert: {
            args: Prisma.ProductionDocUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDocPayload>
          }
          aggregate: {
            args: Prisma.ProductionDocAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionDoc>
          }
          groupBy: {
            args: Prisma.ProductionDocGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionDocGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionDocCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionDocCountAggregateOutputType> | number
          }
        }
      }
      ProductionInput: {
        payload: Prisma.$ProductionInputPayload<ExtArgs>
        fields: Prisma.ProductionInputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionInputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionInputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionInputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionInputPayload>
          }
          findFirst: {
            args: Prisma.ProductionInputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionInputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionInputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionInputPayload>
          }
          findMany: {
            args: Prisma.ProductionInputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionInputPayload>[]
          }
          create: {
            args: Prisma.ProductionInputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionInputPayload>
          }
          createMany: {
            args: Prisma.ProductionInputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionInputCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionInputPayload>[]
          }
          delete: {
            args: Prisma.ProductionInputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionInputPayload>
          }
          update: {
            args: Prisma.ProductionInputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionInputPayload>
          }
          deleteMany: {
            args: Prisma.ProductionInputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionInputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionInputUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionInputPayload>[]
          }
          upsert: {
            args: Prisma.ProductionInputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionInputPayload>
          }
          aggregate: {
            args: Prisma.ProductionInputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionInput>
          }
          groupBy: {
            args: Prisma.ProductionInputGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionInputGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionInputCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionInputCountAggregateOutputType> | number
          }
        }
      }
      ProductionOutput: {
        payload: Prisma.$ProductionOutputPayload<ExtArgs>
        fields: Prisma.ProductionOutputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionOutputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOutputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionOutputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOutputPayload>
          }
          findFirst: {
            args: Prisma.ProductionOutputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOutputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionOutputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOutputPayload>
          }
          findMany: {
            args: Prisma.ProductionOutputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOutputPayload>[]
          }
          create: {
            args: Prisma.ProductionOutputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOutputPayload>
          }
          createMany: {
            args: Prisma.ProductionOutputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionOutputCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOutputPayload>[]
          }
          delete: {
            args: Prisma.ProductionOutputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOutputPayload>
          }
          update: {
            args: Prisma.ProductionOutputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOutputPayload>
          }
          deleteMany: {
            args: Prisma.ProductionOutputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionOutputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionOutputUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOutputPayload>[]
          }
          upsert: {
            args: Prisma.ProductionOutputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOutputPayload>
          }
          aggregate: {
            args: Prisma.ProductionOutputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionOutput>
          }
          groupBy: {
            args: Prisma.ProductionOutputGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionOutputGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionOutputCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionOutputCountAggregateOutputType> | number
          }
        }
      }
      ProductionCuttingLine: {
        payload: Prisma.$ProductionCuttingLinePayload<ExtArgs>
        fields: Prisma.ProductionCuttingLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionCuttingLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionCuttingLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionCuttingLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionCuttingLinePayload>
          }
          findFirst: {
            args: Prisma.ProductionCuttingLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionCuttingLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionCuttingLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionCuttingLinePayload>
          }
          findMany: {
            args: Prisma.ProductionCuttingLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionCuttingLinePayload>[]
          }
          create: {
            args: Prisma.ProductionCuttingLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionCuttingLinePayload>
          }
          createMany: {
            args: Prisma.ProductionCuttingLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionCuttingLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionCuttingLinePayload>[]
          }
          delete: {
            args: Prisma.ProductionCuttingLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionCuttingLinePayload>
          }
          update: {
            args: Prisma.ProductionCuttingLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionCuttingLinePayload>
          }
          deleteMany: {
            args: Prisma.ProductionCuttingLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionCuttingLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionCuttingLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionCuttingLinePayload>[]
          }
          upsert: {
            args: Prisma.ProductionCuttingLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionCuttingLinePayload>
          }
          aggregate: {
            args: Prisma.ProductionCuttingLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionCuttingLine>
          }
          groupBy: {
            args: Prisma.ProductionCuttingLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionCuttingLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionCuttingLineCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionCuttingLineCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    district?: DistrictOmit
    manager?: ManagerOmit
    product?: ProductOmit
    customer?: CustomerOmit
    customerProduct?: CustomerProductOmit
    supplier?: SupplierOmit
    supplierProduct?: SupplierProductOmit
    order?: OrderOmit
    orderAttachment?: OrderAttachmentOmit
    orderItem?: OrderItemOmit
    expeditor?: ExpeditorOmit
    stock?: StockOmit
    stockTransaction?: StockTransactionOmit
    summaryOrderJournal?: SummaryOrderJournalOmit
    summaryOrderEvent?: SummaryOrderEventOmit
    summaryOrdersJournal?: SummaryOrdersJournalOmit
    assemblyOrdersJournal?: AssemblyOrdersJournalOmit
    productionStaff?: ProductionStaffOmit
    productionJournal?: ProductionJournalOmit
    productionItem?: ProductionItemOmit
    productionItemValue?: ProductionItemValueOmit
    purchasePriceList?: PurchasePriceListOmit
    purchasePriceListSupplier?: PurchasePriceListSupplierOmit
    purchasePriceItem?: PurchasePriceItemOmit
    salesPriceList?: SalesPriceListOmit
    salesPriceItem?: SalesPriceItemOmit
    productionMml?: ProductionMmlOmit
    productionMmlNode?: ProductionMmlNodeOmit
    productionRun?: ProductionRunOmit
    productionRunValue?: ProductionRunValueOmit
    paymentType?: PaymentTypeOmit
    purchase?: PurchaseOmit
    purchaseSupplier?: PurchaseSupplierOmit
    purchaseItem?: PurchaseItemOmit
    telegramGroup?: TelegramGroupOmit
    telegramOrderDraft?: TelegramOrderDraftOmit
    telegramOrderDraftItem?: TelegramOrderDraftItemOmit
    warehouse?: WarehouseOmit
    svodHeader?: SvodHeaderOmit
    svodLine?: SvodLineOmit
    svodSupplierCol?: SvodSupplierColOmit
    svodSupplierValue?: SvodSupplierValueOmit
    productionDoc?: ProductionDocOmit
    productionInput?: ProductionInputOmit
    productionOutput?: ProductionOutputOmit
    productionCuttingLine?: ProductionCuttingLineOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdMmls: number
    productionRuns: number
    purchases: number
    warehouses: number
    productionDocs: number
    productionInputs: number
    cuttingLines: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdMmls?: boolean | UserCountOutputTypeCountCreatedMmlsArgs
    productionRuns?: boolean | UserCountOutputTypeCountProductionRunsArgs
    purchases?: boolean | UserCountOutputTypeCountPurchasesArgs
    warehouses?: boolean | UserCountOutputTypeCountWarehousesArgs
    productionDocs?: boolean | UserCountOutputTypeCountProductionDocsArgs
    productionInputs?: boolean | UserCountOutputTypeCountProductionInputsArgs
    cuttingLines?: boolean | UserCountOutputTypeCountCuttingLinesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedMmlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductionRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWarehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductionDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionDocWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductionInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionInputWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCuttingLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionCuttingLineWhereInput
  }


  /**
   * Count Type DistrictCountOutputType
   */

  export type DistrictCountOutputType = {
    customers: number
  }

  export type DistrictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | DistrictCountOutputTypeCountCustomersArgs
  }

  // Custom InputTypes
  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistrictCountOutputType
     */
    select?: DistrictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * Count Type ManagerCountOutputType
   */

  export type ManagerCountOutputType = {
    customers: number
  }

  export type ManagerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | ManagerCountOutputTypeCountCustomersArgs
  }

  // Custom InputTypes
  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCountOutputType
     */
    select?: ManagerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderItems: number
    stockTransactions: number
    suppliers: number
    summaryJournalEntries: number
    productionItems: number
    purchasePriceItems: number
    salesPriceItems: number
    productionMmls: number
    mmlNodes: number
    productionRuns: number
    runValueSnapshots: number
    purchaseItemsRel: number
    svodLines: number
    svodSupplierValues: number
    productionInputs: number
    productionOutputs: number
    cuttingLineOutputs: number
    customerProducts: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    stockTransactions?: boolean | ProductCountOutputTypeCountStockTransactionsArgs
    suppliers?: boolean | ProductCountOutputTypeCountSuppliersArgs
    summaryJournalEntries?: boolean | ProductCountOutputTypeCountSummaryJournalEntriesArgs
    productionItems?: boolean | ProductCountOutputTypeCountProductionItemsArgs
    purchasePriceItems?: boolean | ProductCountOutputTypeCountPurchasePriceItemsArgs
    salesPriceItems?: boolean | ProductCountOutputTypeCountSalesPriceItemsArgs
    productionMmls?: boolean | ProductCountOutputTypeCountProductionMmlsArgs
    mmlNodes?: boolean | ProductCountOutputTypeCountMmlNodesArgs
    productionRuns?: boolean | ProductCountOutputTypeCountProductionRunsArgs
    runValueSnapshots?: boolean | ProductCountOutputTypeCountRunValueSnapshotsArgs
    purchaseItemsRel?: boolean | ProductCountOutputTypeCountPurchaseItemsRelArgs
    svodLines?: boolean | ProductCountOutputTypeCountSvodLinesArgs
    svodSupplierValues?: boolean | ProductCountOutputTypeCountSvodSupplierValuesArgs
    productionInputs?: boolean | ProductCountOutputTypeCountProductionInputsArgs
    productionOutputs?: boolean | ProductCountOutputTypeCountProductionOutputsArgs
    cuttingLineOutputs?: boolean | ProductCountOutputTypeCountCuttingLineOutputsArgs
    customerProducts?: boolean | ProductCountOutputTypeCountCustomerProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransactionWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSummaryJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummaryOrderJournalWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchasePriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSalesPriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesPriceItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductionMmlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountMmlNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlNodeWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductionRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRunValueSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunValueWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseItemsRelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSvodLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SvodLineWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSvodSupplierValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SvodSupplierValueWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductionInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionInputWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductionOutputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionOutputWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCuttingLineOutputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionCuttingLineWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCustomerProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerProductWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
    summaryJournalEntries: number
    salesPriceLists: number
    customerProducts: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    summaryJournalEntries?: boolean | CustomerCountOutputTypeCountSummaryJournalEntriesArgs
    salesPriceLists?: boolean | CustomerCountOutputTypeCountSalesPriceListsArgs
    customerProducts?: boolean | CustomerCountOutputTypeCountCustomerProductsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSummaryJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummaryOrderJournalWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesPriceListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesPriceListWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerProductWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    products: number
    purchasePriceListSuppliers: number
    purchasePriceItems: number
    purchases: number
    purchaseItems: number
    svodSupplierCols: number
    svodSupplierValues: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SupplierCountOutputTypeCountProductsArgs
    purchasePriceListSuppliers?: boolean | SupplierCountOutputTypeCountPurchasePriceListSuppliersArgs
    purchasePriceItems?: boolean | SupplierCountOutputTypeCountPurchasePriceItemsArgs
    purchases?: boolean | SupplierCountOutputTypeCountPurchasesArgs
    purchaseItems?: boolean | SupplierCountOutputTypeCountPurchaseItemsArgs
    svodSupplierCols?: boolean | SupplierCountOutputTypeCountSvodSupplierColsArgs
    svodSupplierValues?: boolean | SupplierCountOutputTypeCountSvodSupplierValuesArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierProductWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchasePriceListSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceListSupplierWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchasePriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceItemWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseSupplierWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountSvodSupplierColsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SvodSupplierColWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountSvodSupplierValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SvodSupplierValueWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    stockTransactions: number
    attachments: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    stockTransactions?: boolean | OrderCountOutputTypeCountStockTransactionsArgs
    attachments?: boolean | OrderCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountStockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransactionWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderAttachmentWhereInput
  }


  /**
   * Count Type ExpeditorCountOutputType
   */

  export type ExpeditorCountOutputType = {
    orders: number
  }

  export type ExpeditorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ExpeditorCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * ExpeditorCountOutputType without action
   */
  export type ExpeditorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpeditorCountOutputType
     */
    select?: ExpeditorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpeditorCountOutputType without action
   */
  export type ExpeditorCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type SummaryOrderJournalCountOutputType
   */

  export type SummaryOrderJournalCountOutputType = {
    events: number
  }

  export type SummaryOrderJournalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | SummaryOrderJournalCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * SummaryOrderJournalCountOutputType without action
   */
  export type SummaryOrderJournalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournalCountOutputType
     */
    select?: SummaryOrderJournalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SummaryOrderJournalCountOutputType without action
   */
  export type SummaryOrderJournalCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummaryOrderEventWhereInput
  }


  /**
   * Count Type ProductionStaffCountOutputType
   */

  export type ProductionStaffCountOutputType = {
    journals: number
  }

  export type ProductionStaffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journals?: boolean | ProductionStaffCountOutputTypeCountJournalsArgs
  }

  // Custom InputTypes
  /**
   * ProductionStaffCountOutputType without action
   */
  export type ProductionStaffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaffCountOutputType
     */
    select?: ProductionStaffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionStaffCountOutputType without action
   */
  export type ProductionStaffCountOutputTypeCountJournalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionJournalWhereInput
  }


  /**
   * Count Type ProductionJournalCountOutputType
   */

  export type ProductionJournalCountOutputType = {
    items: number
  }

  export type ProductionJournalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ProductionJournalCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductionJournalCountOutputType without action
   */
  export type ProductionJournalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournalCountOutputType
     */
    select?: ProductionJournalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionJournalCountOutputType without action
   */
  export type ProductionJournalCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionItemWhereInput
  }


  /**
   * Count Type ProductionItemCountOutputType
   */

  export type ProductionItemCountOutputType = {
    values: number
  }

  export type ProductionItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | ProductionItemCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * ProductionItemCountOutputType without action
   */
  export type ProductionItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemCountOutputType
     */
    select?: ProductionItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionItemCountOutputType without action
   */
  export type ProductionItemCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionItemValueWhereInput
  }


  /**
   * Count Type PurchasePriceListCountOutputType
   */

  export type PurchasePriceListCountOutputType = {
    suppliers: number
    items: number
  }

  export type PurchasePriceListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suppliers?: boolean | PurchasePriceListCountOutputTypeCountSuppliersArgs
    items?: boolean | PurchasePriceListCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchasePriceListCountOutputType without action
   */
  export type PurchasePriceListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListCountOutputType
     */
    select?: PurchasePriceListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchasePriceListCountOutputType without action
   */
  export type PurchasePriceListCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceListSupplierWhereInput
  }

  /**
   * PurchasePriceListCountOutputType without action
   */
  export type PurchasePriceListCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceItemWhereInput
  }


  /**
   * Count Type SalesPriceListCountOutputType
   */

  export type SalesPriceListCountOutputType = {
    items: number
  }

  export type SalesPriceListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SalesPriceListCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SalesPriceListCountOutputType without action
   */
  export type SalesPriceListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceListCountOutputType
     */
    select?: SalesPriceListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesPriceListCountOutputType without action
   */
  export type SalesPriceListCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesPriceItemWhereInput
  }


  /**
   * Count Type ProductionMmlCountOutputType
   */

  export type ProductionMmlCountOutputType = {
    nodes: number
    runs: number
    suppliersWithPrimaryMml: number
    priceListSuppliers: number
    cuttingLines: number
  }

  export type ProductionMmlCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | ProductionMmlCountOutputTypeCountNodesArgs
    runs?: boolean | ProductionMmlCountOutputTypeCountRunsArgs
    suppliersWithPrimaryMml?: boolean | ProductionMmlCountOutputTypeCountSuppliersWithPrimaryMmlArgs
    priceListSuppliers?: boolean | ProductionMmlCountOutputTypeCountPriceListSuppliersArgs
    cuttingLines?: boolean | ProductionMmlCountOutputTypeCountCuttingLinesArgs
  }

  // Custom InputTypes
  /**
   * ProductionMmlCountOutputType without action
   */
  export type ProductionMmlCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlCountOutputType
     */
    select?: ProductionMmlCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionMmlCountOutputType without action
   */
  export type ProductionMmlCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlNodeWhereInput
  }

  /**
   * ProductionMmlCountOutputType without action
   */
  export type ProductionMmlCountOutputTypeCountRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunWhereInput
  }

  /**
   * ProductionMmlCountOutputType without action
   */
  export type ProductionMmlCountOutputTypeCountSuppliersWithPrimaryMmlArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * ProductionMmlCountOutputType without action
   */
  export type ProductionMmlCountOutputTypeCountPriceListSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceListSupplierWhereInput
  }

  /**
   * ProductionMmlCountOutputType without action
   */
  export type ProductionMmlCountOutputTypeCountCuttingLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionCuttingLineWhereInput
  }


  /**
   * Count Type ProductionMmlNodeCountOutputType
   */

  export type ProductionMmlNodeCountOutputType = {
    children: number
    runValues: number
  }

  export type ProductionMmlNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ProductionMmlNodeCountOutputTypeCountChildrenArgs
    runValues?: boolean | ProductionMmlNodeCountOutputTypeCountRunValuesArgs
  }

  // Custom InputTypes
  /**
   * ProductionMmlNodeCountOutputType without action
   */
  export type ProductionMmlNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNodeCountOutputType
     */
    select?: ProductionMmlNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionMmlNodeCountOutputType without action
   */
  export type ProductionMmlNodeCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlNodeWhereInput
  }

  /**
   * ProductionMmlNodeCountOutputType without action
   */
  export type ProductionMmlNodeCountOutputTypeCountRunValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunValueWhereInput
  }


  /**
   * Count Type ProductionRunCountOutputType
   */

  export type ProductionRunCountOutputType = {
    values: number
  }

  export type ProductionRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | ProductionRunCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * ProductionRunCountOutputType without action
   */
  export type ProductionRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunCountOutputType
     */
    select?: ProductionRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionRunCountOutputType without action
   */
  export type ProductionRunCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunValueWhereInput
  }


  /**
   * Count Type PaymentTypeCountOutputType
   */

  export type PaymentTypeCountOutputType = {
    purchaseItems: number
  }

  export type PaymentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseItems?: boolean | PaymentTypeCountOutputTypeCountPurchaseItemsArgs
  }

  // Custom InputTypes
  /**
   * PaymentTypeCountOutputType without action
   */
  export type PaymentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTypeCountOutputType
     */
    select?: PaymentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentTypeCountOutputType without action
   */
  export type PaymentTypeCountOutputTypeCountPurchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }


  /**
   * Count Type PurchaseCountOutputType
   */

  export type PurchaseCountOutputType = {
    suppliers: number
    items: number
    productionInputs: number
  }

  export type PurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suppliers?: boolean | PurchaseCountOutputTypeCountSuppliersArgs
    items?: boolean | PurchaseCountOutputTypeCountItemsArgs
    productionInputs?: boolean | PurchaseCountOutputTypeCountProductionInputsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseCountOutputType
     */
    select?: PurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseSupplierWhereInput
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountProductionInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionInputWhereInput
  }


  /**
   * Count Type PurchaseItemCountOutputType
   */

  export type PurchaseItemCountOutputType = {
    productionInputs: number
  }

  export type PurchaseItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionInputs?: boolean | PurchaseItemCountOutputTypeCountProductionInputsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseItemCountOutputType without action
   */
  export type PurchaseItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemCountOutputType
     */
    select?: PurchaseItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseItemCountOutputType without action
   */
  export type PurchaseItemCountOutputTypeCountProductionInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionInputWhereInput
  }


  /**
   * Count Type TelegramGroupCountOutputType
   */

  export type TelegramGroupCountOutputType = {
    orderDrafts: number
  }

  export type TelegramGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderDrafts?: boolean | TelegramGroupCountOutputTypeCountOrderDraftsArgs
  }

  // Custom InputTypes
  /**
   * TelegramGroupCountOutputType without action
   */
  export type TelegramGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroupCountOutputType
     */
    select?: TelegramGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TelegramGroupCountOutputType without action
   */
  export type TelegramGroupCountOutputTypeCountOrderDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramOrderDraftWhereInput
  }


  /**
   * Count Type TelegramOrderDraftCountOutputType
   */

  export type TelegramOrderDraftCountOutputType = {
    items: number
  }

  export type TelegramOrderDraftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TelegramOrderDraftCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * TelegramOrderDraftCountOutputType without action
   */
  export type TelegramOrderDraftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftCountOutputType
     */
    select?: TelegramOrderDraftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TelegramOrderDraftCountOutputType without action
   */
  export type TelegramOrderDraftCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramOrderDraftItemWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    productionDocs: number
    productionInputs: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionDocs?: boolean | WarehouseCountOutputTypeCountProductionDocsArgs
    productionInputs?: boolean | WarehouseCountOutputTypeCountProductionInputsArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountProductionDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionDocWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountProductionInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionInputWhereInput
  }


  /**
   * Count Type SvodHeaderCountOutputType
   */

  export type SvodHeaderCountOutputType = {
    lines: number
    supplierCols: number
    supplierValues: number
  }

  export type SvodHeaderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | SvodHeaderCountOutputTypeCountLinesArgs
    supplierCols?: boolean | SvodHeaderCountOutputTypeCountSupplierColsArgs
    supplierValues?: boolean | SvodHeaderCountOutputTypeCountSupplierValuesArgs
  }

  // Custom InputTypes
  /**
   * SvodHeaderCountOutputType without action
   */
  export type SvodHeaderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeaderCountOutputType
     */
    select?: SvodHeaderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SvodHeaderCountOutputType without action
   */
  export type SvodHeaderCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SvodLineWhereInput
  }

  /**
   * SvodHeaderCountOutputType without action
   */
  export type SvodHeaderCountOutputTypeCountSupplierColsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SvodSupplierColWhereInput
  }

  /**
   * SvodHeaderCountOutputType without action
   */
  export type SvodHeaderCountOutputTypeCountSupplierValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SvodSupplierValueWhereInput
  }


  /**
   * Count Type ProductionDocCountOutputType
   */

  export type ProductionDocCountOutputType = {
    inputs: number
    outputs: number
    cuttingLines: number
  }

  export type ProductionDocCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inputs?: boolean | ProductionDocCountOutputTypeCountInputsArgs
    outputs?: boolean | ProductionDocCountOutputTypeCountOutputsArgs
    cuttingLines?: boolean | ProductionDocCountOutputTypeCountCuttingLinesArgs
  }

  // Custom InputTypes
  /**
   * ProductionDocCountOutputType without action
   */
  export type ProductionDocCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDocCountOutputType
     */
    select?: ProductionDocCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionDocCountOutputType without action
   */
  export type ProductionDocCountOutputTypeCountInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionInputWhereInput
  }

  /**
   * ProductionDocCountOutputType without action
   */
  export type ProductionDocCountOutputTypeCountOutputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionOutputWhereInput
  }

  /**
   * ProductionDocCountOutputType without action
   */
  export type ProductionDocCountOutputTypeCountCuttingLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionCuttingLineWhereInput
  }


  /**
   * Count Type ProductionInputCountOutputType
   */

  export type ProductionInputCountOutputType = {
    cuttingLines: number
  }

  export type ProductionInputCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cuttingLines?: boolean | ProductionInputCountOutputTypeCountCuttingLinesArgs
  }

  // Custom InputTypes
  /**
   * ProductionInputCountOutputType without action
   */
  export type ProductionInputCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInputCountOutputType
     */
    select?: ProductionInputCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionInputCountOutputType without action
   */
  export type ProductionInputCountOutputTypeCountCuttingLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionCuttingLineWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    name: string | null
    role: string | null
    telegramId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    name: string | null
    role: string | null
    telegramId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    name: number
    role: number
    telegramId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    role?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    role?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    role?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    name: string
    role: string
    telegramId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productionStaff?: boolean | User$productionStaffArgs<ExtArgs>
    createdMmls?: boolean | User$createdMmlsArgs<ExtArgs>
    productionRuns?: boolean | User$productionRunsArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    warehouses?: boolean | User$warehousesArgs<ExtArgs>
    productionDocs?: boolean | User$productionDocsArgs<ExtArgs>
    productionInputs?: boolean | User$productionInputsArgs<ExtArgs>
    cuttingLines?: boolean | User$cuttingLinesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "name" | "role" | "telegramId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionStaff?: boolean | User$productionStaffArgs<ExtArgs>
    createdMmls?: boolean | User$createdMmlsArgs<ExtArgs>
    productionRuns?: boolean | User$productionRunsArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    warehouses?: boolean | User$warehousesArgs<ExtArgs>
    productionDocs?: boolean | User$productionDocsArgs<ExtArgs>
    productionInputs?: boolean | User$productionInputsArgs<ExtArgs>
    cuttingLines?: boolean | User$cuttingLinesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      productionStaff: Prisma.$ProductionStaffPayload<ExtArgs> | null
      createdMmls: Prisma.$ProductionMmlPayload<ExtArgs>[]
      productionRuns: Prisma.$ProductionRunPayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      warehouses: Prisma.$WarehousePayload<ExtArgs>[]
      productionDocs: Prisma.$ProductionDocPayload<ExtArgs>[]
      productionInputs: Prisma.$ProductionInputPayload<ExtArgs>[]
      cuttingLines: Prisma.$ProductionCuttingLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      name: string
      role: string
      telegramId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionStaff<T extends User$productionStaffArgs<ExtArgs> = {}>(args?: Subset<T, User$productionStaffArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdMmls<T extends User$createdMmlsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdMmlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionRuns<T extends User$productionRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$productionRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchases<T extends User$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, User$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warehouses<T extends User$warehousesArgs<ExtArgs> = {}>(args?: Subset<T, User$warehousesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionDocs<T extends User$productionDocsArgs<ExtArgs> = {}>(args?: Subset<T, User$productionDocsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionInputs<T extends User$productionInputsArgs<ExtArgs> = {}>(args?: Subset<T, User$productionInputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cuttingLines<T extends User$cuttingLinesArgs<ExtArgs> = {}>(args?: Subset<T, User$cuttingLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly telegramId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.productionStaff
   */
  export type User$productionStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    where?: ProductionStaffWhereInput
  }

  /**
   * User.createdMmls
   */
  export type User$createdMmlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    where?: ProductionMmlWhereInput
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    cursor?: ProductionMmlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionMmlScalarFieldEnum | ProductionMmlScalarFieldEnum[]
  }

  /**
   * User.productionRuns
   */
  export type User$productionRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    where?: ProductionRunWhereInput
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    cursor?: ProductionRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * User.purchases
   */
  export type User$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * User.warehouses
   */
  export type User$warehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    cursor?: WarehouseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * User.productionDocs
   */
  export type User$productionDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
    where?: ProductionDocWhereInput
    orderBy?: ProductionDocOrderByWithRelationInput | ProductionDocOrderByWithRelationInput[]
    cursor?: ProductionDocWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionDocScalarFieldEnum | ProductionDocScalarFieldEnum[]
  }

  /**
   * User.productionInputs
   */
  export type User$productionInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    where?: ProductionInputWhereInput
    orderBy?: ProductionInputOrderByWithRelationInput | ProductionInputOrderByWithRelationInput[]
    cursor?: ProductionInputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionInputScalarFieldEnum | ProductionInputScalarFieldEnum[]
  }

  /**
   * User.cuttingLines
   */
  export type User$cuttingLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    where?: ProductionCuttingLineWhereInput
    orderBy?: ProductionCuttingLineOrderByWithRelationInput | ProductionCuttingLineOrderByWithRelationInput[]
    cursor?: ProductionCuttingLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionCuttingLineScalarFieldEnum | ProductionCuttingLineScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model District
   */

  export type AggregateDistrict = {
    _count: DistrictCountAggregateOutputType | null
    _avg: DistrictAvgAggregateOutputType | null
    _sum: DistrictSumAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  export type DistrictAvgAggregateOutputType = {
    id: number | null
  }

  export type DistrictSumAggregateOutputType = {
    id: number | null
  }

  export type DistrictMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
  }

  export type DistrictMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
  }

  export type DistrictCountAggregateOutputType = {
    id: number
    code: number
    name: number
    _all: number
  }


  export type DistrictAvgAggregateInputType = {
    id?: true
  }

  export type DistrictSumAggregateInputType = {
    id?: true
  }

  export type DistrictMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type DistrictMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type DistrictCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    _all?: true
  }

  export type DistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which District to aggregate.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Districts
    **/
    _count?: true | DistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DistrictAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DistrictSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistrictMaxAggregateInputType
  }

  export type GetDistrictAggregateType<T extends DistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistrict[P]>
      : GetScalarType<T[P], AggregateDistrict[P]>
  }




  export type DistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistrictWhereInput
    orderBy?: DistrictOrderByWithAggregationInput | DistrictOrderByWithAggregationInput[]
    by: DistrictScalarFieldEnum[] | DistrictScalarFieldEnum
    having?: DistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistrictCountAggregateInputType | true
    _avg?: DistrictAvgAggregateInputType
    _sum?: DistrictSumAggregateInputType
    _min?: DistrictMinAggregateInputType
    _max?: DistrictMaxAggregateInputType
  }

  export type DistrictGroupByOutputType = {
    id: number
    code: string
    name: string
    _count: DistrictCountAggregateOutputType | null
    _avg: DistrictAvgAggregateOutputType | null
    _sum: DistrictSumAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  type GetDistrictGroupByPayload<T extends DistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistrictGroupByOutputType[P]>
            : GetScalarType<T[P], DistrictGroupByOutputType[P]>
        }
      >
    >


  export type DistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    customers?: boolean | District$customersArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
  }

  export type DistrictOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name", ExtArgs["result"]["district"]>
  export type DistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | District$customersArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DistrictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DistrictIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "District"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
    }, ExtArgs["result"]["district"]>
    composites: {}
  }

  type DistrictGetPayload<S extends boolean | null | undefined | DistrictDefaultArgs> = $Result.GetResult<Prisma.$DistrictPayload, S>

  type DistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DistrictFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DistrictCountAggregateInputType | true
    }

  export interface DistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['District'], meta: { name: 'District' } }
    /**
     * Find zero or one District that matches the filter.
     * @param {DistrictFindUniqueArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistrictFindUniqueArgs>(args: SelectSubset<T, DistrictFindUniqueArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one District that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DistrictFindUniqueOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistrictFindUniqueOrThrowArgs>(args: SelectSubset<T, DistrictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first District that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistrictFindFirstArgs>(args?: SelectSubset<T, DistrictFindFirstArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first District that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistrictFindFirstOrThrowArgs>(args?: SelectSubset<T, DistrictFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Districts
     * const districts = await prisma.district.findMany()
     * 
     * // Get first 10 Districts
     * const districts = await prisma.district.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const districtWithIdOnly = await prisma.district.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistrictFindManyArgs>(args?: SelectSubset<T, DistrictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a District.
     * @param {DistrictCreateArgs} args - Arguments to create a District.
     * @example
     * // Create one District
     * const District = await prisma.district.create({
     *   data: {
     *     // ... data to create a District
     *   }
     * })
     * 
     */
    create<T extends DistrictCreateArgs>(args: SelectSubset<T, DistrictCreateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Districts.
     * @param {DistrictCreateManyArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistrictCreateManyArgs>(args?: SelectSubset<T, DistrictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Districts and returns the data saved in the database.
     * @param {DistrictCreateManyAndReturnArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Districts and only return the `id`
     * const districtWithIdOnly = await prisma.district.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistrictCreateManyAndReturnArgs>(args?: SelectSubset<T, DistrictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a District.
     * @param {DistrictDeleteArgs} args - Arguments to delete one District.
     * @example
     * // Delete one District
     * const District = await prisma.district.delete({
     *   where: {
     *     // ... filter to delete one District
     *   }
     * })
     * 
     */
    delete<T extends DistrictDeleteArgs>(args: SelectSubset<T, DistrictDeleteArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one District.
     * @param {DistrictUpdateArgs} args - Arguments to update one District.
     * @example
     * // Update one District
     * const district = await prisma.district.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistrictUpdateArgs>(args: SelectSubset<T, DistrictUpdateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Districts.
     * @param {DistrictDeleteManyArgs} args - Arguments to filter Districts to delete.
     * @example
     * // Delete a few Districts
     * const { count } = await prisma.district.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistrictDeleteManyArgs>(args?: SelectSubset<T, DistrictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Districts
     * const district = await prisma.district.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistrictUpdateManyArgs>(args: SelectSubset<T, DistrictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts and returns the data updated in the database.
     * @param {DistrictUpdateManyAndReturnArgs} args - Arguments to update many Districts.
     * @example
     * // Update many Districts
     * const district = await prisma.district.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Districts and only return the `id`
     * const districtWithIdOnly = await prisma.district.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DistrictUpdateManyAndReturnArgs>(args: SelectSubset<T, DistrictUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one District.
     * @param {DistrictUpsertArgs} args - Arguments to update or create a District.
     * @example
     * // Update or create a District
     * const district = await prisma.district.upsert({
     *   create: {
     *     // ... data to create a District
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the District we want to update
     *   }
     * })
     */
    upsert<T extends DistrictUpsertArgs>(args: SelectSubset<T, DistrictUpsertArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictCountArgs} args - Arguments to filter Districts to count.
     * @example
     * // Count the number of Districts
     * const count = await prisma.district.count({
     *   where: {
     *     // ... the filter for the Districts we want to count
     *   }
     * })
    **/
    count<T extends DistrictCountArgs>(
      args?: Subset<T, DistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistrictAggregateArgs>(args: Subset<T, DistrictAggregateArgs>): Prisma.PrismaPromise<GetDistrictAggregateType<T>>

    /**
     * Group by District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistrictGroupByArgs['orderBy'] }
        : { orderBy?: DistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the District model
   */
  readonly fields: DistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for District.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends District$customersArgs<ExtArgs> = {}>(args?: Subset<T, District$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the District model
   */
  interface DistrictFieldRefs {
    readonly id: FieldRef<"District", 'Int'>
    readonly code: FieldRef<"District", 'String'>
    readonly name: FieldRef<"District", 'String'>
  }
    

  // Custom InputTypes
  /**
   * District findUnique
   */
  export type DistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findUniqueOrThrow
   */
  export type DistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findFirst
   */
  export type DistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findFirstOrThrow
   */
  export type DistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findMany
   */
  export type DistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which Districts to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District create
   */
  export type DistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a District.
     */
    data: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
  }

  /**
   * District createMany
   */
  export type DistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * District createManyAndReturn
   */
  export type DistrictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * District update
   */
  export type DistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a District.
     */
    data: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
    /**
     * Choose, which District to update.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District updateMany
   */
  export type DistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Districts.
     */
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyInput>
    /**
     * Filter which Districts to update
     */
    where?: DistrictWhereInput
    /**
     * Limit how many Districts to update.
     */
    limit?: number
  }

  /**
   * District updateManyAndReturn
   */
  export type DistrictUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * The data used to update Districts.
     */
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyInput>
    /**
     * Filter which Districts to update
     */
    where?: DistrictWhereInput
    /**
     * Limit how many Districts to update.
     */
    limit?: number
  }

  /**
   * District upsert
   */
  export type DistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the District to update in case it exists.
     */
    where: DistrictWhereUniqueInput
    /**
     * In case the District found by the `where` argument doesn't exist, create a new District with this data.
     */
    create: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
    /**
     * In case the District was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
  }

  /**
   * District delete
   */
  export type DistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter which District to delete.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District deleteMany
   */
  export type DistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Districts to delete
     */
    where?: DistrictWhereInput
    /**
     * Limit how many Districts to delete.
     */
    limit?: number
  }

  /**
   * District.customers
   */
  export type District$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * District without action
   */
  export type DistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
  }


  /**
   * Model Manager
   */

  export type AggregateManager = {
    _count: ManagerCountAggregateOutputType | null
    _avg: ManagerAvgAggregateOutputType | null
    _sum: ManagerSumAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerAvgAggregateOutputType = {
    id: number | null
  }

  export type ManagerSumAggregateOutputType = {
    id: number | null
  }

  export type ManagerMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    phone: string | null
  }

  export type ManagerMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    phone: string | null
  }

  export type ManagerCountAggregateOutputType = {
    id: number
    code: number
    name: number
    phone: number
    _all: number
  }


  export type ManagerAvgAggregateInputType = {
    id?: true
  }

  export type ManagerSumAggregateInputType = {
    id?: true
  }

  export type ManagerMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    phone?: true
  }

  export type ManagerMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    phone?: true
  }

  export type ManagerCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    phone?: true
    _all?: true
  }

  export type ManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manager to aggregate.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    _count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }




  export type ManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithAggregationInput | ManagerOrderByWithAggregationInput[]
    by: ManagerScalarFieldEnum[] | ManagerScalarFieldEnum
    having?: ManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCountAggregateInputType | true
    _avg?: ManagerAvgAggregateInputType
    _sum?: ManagerSumAggregateInputType
    _min?: ManagerMinAggregateInputType
    _max?: ManagerMaxAggregateInputType
  }

  export type ManagerGroupByOutputType = {
    id: number
    code: string
    name: string
    phone: string | null
    _count: ManagerCountAggregateOutputType | null
    _avg: ManagerAvgAggregateOutputType | null
    _sum: ManagerSumAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  type GetManagerGroupByPayload<T extends ManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerGroupByOutputType[P]>
        }
      >
    >


  export type ManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    phone?: boolean
    customers?: boolean | Manager$customersArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    phone?: boolean
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    phone?: boolean
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    phone?: boolean
  }

  export type ManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "phone", ExtArgs["result"]["manager"]>
  export type ManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | Manager$customersArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Manager"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      phone: string | null
    }, ExtArgs["result"]["manager"]>
    composites: {}
  }

  type ManagerGetPayload<S extends boolean | null | undefined | ManagerDefaultArgs> = $Result.GetResult<Prisma.$ManagerPayload, S>

  type ManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManagerCountAggregateInputType | true
    }

  export interface ManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manager'], meta: { name: 'Manager' } }
    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManagerFindUniqueArgs>(args: SelectSubset<T, ManagerFindUniqueArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManagerFindUniqueOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, ManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManagerFindFirstArgs>(args?: SelectSubset<T, ManagerFindFirstArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, ManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerWithIdOnly = await prisma.manager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManagerFindManyArgs>(args?: SelectSubset<T, ManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
     */
    create<T extends ManagerCreateArgs>(args: SelectSubset<T, ManagerCreateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Managers.
     * @param {ManagerCreateManyArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManagerCreateManyArgs>(args?: SelectSubset<T, ManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Managers and returns the data saved in the database.
     * @param {ManagerCreateManyAndReturnArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Managers and only return the `id`
     * const managerWithIdOnly = await prisma.manager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, ManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
     */
    delete<T extends ManagerDeleteArgs>(args: SelectSubset<T, ManagerDeleteArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManagerUpdateArgs>(args: SelectSubset<T, ManagerUpdateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManagerDeleteManyArgs>(args?: SelectSubset<T, ManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManagerUpdateManyArgs>(args: SelectSubset<T, ManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers and returns the data updated in the database.
     * @param {ManagerUpdateManyAndReturnArgs} args - Arguments to update many Managers.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Managers and only return the `id`
     * const managerWithIdOnly = await prisma.manager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, ManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
     */
    upsert<T extends ManagerUpsertArgs>(args: SelectSubset<T, ManagerUpsertArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Prisma.PrismaPromise<GetManagerAggregateType<T>>

    /**
     * Group by Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerGroupByArgs['orderBy'] }
        : { orderBy?: ManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manager model
   */
  readonly fields: ManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends Manager$customersArgs<ExtArgs> = {}>(args?: Subset<T, Manager$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Manager model
   */
  interface ManagerFieldRefs {
    readonly id: FieldRef<"Manager", 'Int'>
    readonly code: FieldRef<"Manager", 'String'>
    readonly name: FieldRef<"Manager", 'String'>
    readonly phone: FieldRef<"Manager", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Manager findUnique
   */
  export type ManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findUniqueOrThrow
   */
  export type ManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findFirst
   */
  export type ManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findFirstOrThrow
   */
  export type ManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Managers to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager create
   */
  export type ManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manager.
     */
    data: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
  }

  /**
   * Manager createMany
   */
  export type ManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manager createManyAndReturn
   */
  export type ManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manager update
   */
  export type ManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manager.
     */
    data: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
    /**
     * Choose, which Manager to update.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to update.
     */
    limit?: number
  }

  /**
   * Manager updateManyAndReturn
   */
  export type ManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to update.
     */
    limit?: number
  }

  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manager to update in case it exists.
     */
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
     */
    create: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
  }

  /**
   * Manager delete
   */
  export type ManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter which Manager to delete.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Managers to delete
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to delete.
     */
    limit?: number
  }

  /**
   * Manager.customers
   */
  export type Manager$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Manager without action
   */
  export type ManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    coefficient: number | null
    lossNorm: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    coefficient: number | null
    lossNorm: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    altName: string | null
    priceListName: string | null
    category: string | null
    status: string | null
    coefficient: number | null
    lossNorm: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    altName: string | null
    priceListName: string | null
    category: string | null
    status: string | null
    coefficient: number | null
    lossNorm: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    code: number
    name: number
    altName: number
    priceListName: number
    category: number
    status: number
    coefficient: number
    lossNorm: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    coefficient?: true
    lossNorm?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    coefficient?: true
    lossNorm?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    altName?: true
    priceListName?: true
    category?: true
    status?: true
    coefficient?: true
    lossNorm?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    altName?: true
    priceListName?: true
    category?: true
    status?: true
    coefficient?: true
    lossNorm?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    altName?: true
    priceListName?: true
    category?: true
    status?: true
    coefficient?: true
    lossNorm?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    code: string
    name: string
    altName: string | null
    priceListName: string | null
    category: string | null
    status: string
    coefficient: number
    lossNorm: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    altName?: boolean
    priceListName?: boolean
    category?: boolean
    status?: boolean
    coefficient?: boolean
    lossNorm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    stock?: boolean | Product$stockArgs<ExtArgs>
    stockTransactions?: boolean | Product$stockTransactionsArgs<ExtArgs>
    suppliers?: boolean | Product$suppliersArgs<ExtArgs>
    summaryJournalEntries?: boolean | Product$summaryJournalEntriesArgs<ExtArgs>
    productionItems?: boolean | Product$productionItemsArgs<ExtArgs>
    purchasePriceItems?: boolean | Product$purchasePriceItemsArgs<ExtArgs>
    salesPriceItems?: boolean | Product$salesPriceItemsArgs<ExtArgs>
    productionMmls?: boolean | Product$productionMmlsArgs<ExtArgs>
    mmlNodes?: boolean | Product$mmlNodesArgs<ExtArgs>
    productionRuns?: boolean | Product$productionRunsArgs<ExtArgs>
    runValueSnapshots?: boolean | Product$runValueSnapshotsArgs<ExtArgs>
    purchaseItemsRel?: boolean | Product$purchaseItemsRelArgs<ExtArgs>
    svodLines?: boolean | Product$svodLinesArgs<ExtArgs>
    svodSupplierValues?: boolean | Product$svodSupplierValuesArgs<ExtArgs>
    productionInputs?: boolean | Product$productionInputsArgs<ExtArgs>
    productionOutputs?: boolean | Product$productionOutputsArgs<ExtArgs>
    cuttingLineOutputs?: boolean | Product$cuttingLineOutputsArgs<ExtArgs>
    customerProducts?: boolean | Product$customerProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    altName?: boolean
    priceListName?: boolean
    category?: boolean
    status?: boolean
    coefficient?: boolean
    lossNorm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    altName?: boolean
    priceListName?: boolean
    category?: boolean
    status?: boolean
    coefficient?: boolean
    lossNorm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    altName?: boolean
    priceListName?: boolean
    category?: boolean
    status?: boolean
    coefficient?: boolean
    lossNorm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "altName" | "priceListName" | "category" | "status" | "coefficient" | "lossNorm" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    stock?: boolean | Product$stockArgs<ExtArgs>
    stockTransactions?: boolean | Product$stockTransactionsArgs<ExtArgs>
    suppliers?: boolean | Product$suppliersArgs<ExtArgs>
    summaryJournalEntries?: boolean | Product$summaryJournalEntriesArgs<ExtArgs>
    productionItems?: boolean | Product$productionItemsArgs<ExtArgs>
    purchasePriceItems?: boolean | Product$purchasePriceItemsArgs<ExtArgs>
    salesPriceItems?: boolean | Product$salesPriceItemsArgs<ExtArgs>
    productionMmls?: boolean | Product$productionMmlsArgs<ExtArgs>
    mmlNodes?: boolean | Product$mmlNodesArgs<ExtArgs>
    productionRuns?: boolean | Product$productionRunsArgs<ExtArgs>
    runValueSnapshots?: boolean | Product$runValueSnapshotsArgs<ExtArgs>
    purchaseItemsRel?: boolean | Product$purchaseItemsRelArgs<ExtArgs>
    svodLines?: boolean | Product$svodLinesArgs<ExtArgs>
    svodSupplierValues?: boolean | Product$svodSupplierValuesArgs<ExtArgs>
    productionInputs?: boolean | Product$productionInputsArgs<ExtArgs>
    productionOutputs?: boolean | Product$productionOutputsArgs<ExtArgs>
    cuttingLineOutputs?: boolean | Product$cuttingLineOutputsArgs<ExtArgs>
    customerProducts?: boolean | Product$customerProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      stock: Prisma.$StockPayload<ExtArgs> | null
      stockTransactions: Prisma.$StockTransactionPayload<ExtArgs>[]
      suppliers: Prisma.$SupplierProductPayload<ExtArgs>[]
      summaryJournalEntries: Prisma.$SummaryOrderJournalPayload<ExtArgs>[]
      productionItems: Prisma.$ProductionItemPayload<ExtArgs>[]
      purchasePriceItems: Prisma.$PurchasePriceItemPayload<ExtArgs>[]
      salesPriceItems: Prisma.$SalesPriceItemPayload<ExtArgs>[]
      productionMmls: Prisma.$ProductionMmlPayload<ExtArgs>[]
      mmlNodes: Prisma.$ProductionMmlNodePayload<ExtArgs>[]
      productionRuns: Prisma.$ProductionRunPayload<ExtArgs>[]
      runValueSnapshots: Prisma.$ProductionRunValuePayload<ExtArgs>[]
      purchaseItemsRel: Prisma.$PurchaseItemPayload<ExtArgs>[]
      svodLines: Prisma.$SvodLinePayload<ExtArgs>[]
      svodSupplierValues: Prisma.$SvodSupplierValuePayload<ExtArgs>[]
      productionInputs: Prisma.$ProductionInputPayload<ExtArgs>[]
      productionOutputs: Prisma.$ProductionOutputPayload<ExtArgs>[]
      cuttingLineOutputs: Prisma.$ProductionCuttingLinePayload<ExtArgs>[]
      customerProducts: Prisma.$CustomerProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      altName: string | null
      priceListName: string | null
      category: string | null
      status: string
      coefficient: number
      lossNorm: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stock<T extends Product$stockArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stockTransactions<T extends Product$stockTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suppliers<T extends Product$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Product$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    summaryJournalEntries<T extends Product$summaryJournalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$summaryJournalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionItems<T extends Product$productionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchasePriceItems<T extends Product$purchasePriceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchasePriceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesPriceItems<T extends Product$salesPriceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$salesPriceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionMmls<T extends Product$productionMmlsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productionMmlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mmlNodes<T extends Product$mmlNodesArgs<ExtArgs> = {}>(args?: Subset<T, Product$mmlNodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionRuns<T extends Product$productionRunsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productionRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runValueSnapshots<T extends Product$runValueSnapshotsArgs<ExtArgs> = {}>(args?: Subset<T, Product$runValueSnapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseItemsRel<T extends Product$purchaseItemsRelArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseItemsRelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    svodLines<T extends Product$svodLinesArgs<ExtArgs> = {}>(args?: Subset<T, Product$svodLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    svodSupplierValues<T extends Product$svodSupplierValuesArgs<ExtArgs> = {}>(args?: Subset<T, Product$svodSupplierValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionInputs<T extends Product$productionInputsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productionInputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionOutputs<T extends Product$productionOutputsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productionOutputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cuttingLineOutputs<T extends Product$cuttingLineOutputsArgs<ExtArgs> = {}>(args?: Subset<T, Product$cuttingLineOutputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerProducts<T extends Product$customerProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$customerProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly code: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly altName: FieldRef<"Product", 'String'>
    readonly priceListName: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly status: FieldRef<"Product", 'String'>
    readonly coefficient: FieldRef<"Product", 'Float'>
    readonly lossNorm: FieldRef<"Product", 'Float'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.stock
   */
  export type Product$stockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
  }

  /**
   * Product.stockTransactions
   */
  export type Product$stockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    where?: StockTransactionWhereInput
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    cursor?: StockTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * Product.suppliers
   */
  export type Product$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    where?: SupplierProductWhereInput
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    cursor?: SupplierProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * Product.summaryJournalEntries
   */
  export type Product$summaryJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    where?: SummaryOrderJournalWhereInput
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    cursor?: SummaryOrderJournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SummaryOrderJournalScalarFieldEnum | SummaryOrderJournalScalarFieldEnum[]
  }

  /**
   * Product.productionItems
   */
  export type Product$productionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    where?: ProductionItemWhereInput
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    cursor?: ProductionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionItemScalarFieldEnum | ProductionItemScalarFieldEnum[]
  }

  /**
   * Product.purchasePriceItems
   */
  export type Product$purchasePriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    where?: PurchasePriceItemWhereInput
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    cursor?: PurchasePriceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * Product.salesPriceItems
   */
  export type Product$salesPriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    where?: SalesPriceItemWhereInput
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    cursor?: SalesPriceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesPriceItemScalarFieldEnum | SalesPriceItemScalarFieldEnum[]
  }

  /**
   * Product.productionMmls
   */
  export type Product$productionMmlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    where?: ProductionMmlWhereInput
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    cursor?: ProductionMmlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionMmlScalarFieldEnum | ProductionMmlScalarFieldEnum[]
  }

  /**
   * Product.mmlNodes
   */
  export type Product$mmlNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    where?: ProductionMmlNodeWhereInput
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    cursor?: ProductionMmlNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * Product.productionRuns
   */
  export type Product$productionRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    where?: ProductionRunWhereInput
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    cursor?: ProductionRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * Product.runValueSnapshots
   */
  export type Product$runValueSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    where?: ProductionRunValueWhereInput
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    cursor?: ProductionRunValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRunValueScalarFieldEnum | ProductionRunValueScalarFieldEnum[]
  }

  /**
   * Product.purchaseItemsRel
   */
  export type Product$purchaseItemsRelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Product.svodLines
   */
  export type Product$svodLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
    where?: SvodLineWhereInput
    orderBy?: SvodLineOrderByWithRelationInput | SvodLineOrderByWithRelationInput[]
    cursor?: SvodLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SvodLineScalarFieldEnum | SvodLineScalarFieldEnum[]
  }

  /**
   * Product.svodSupplierValues
   */
  export type Product$svodSupplierValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    where?: SvodSupplierValueWhereInput
    orderBy?: SvodSupplierValueOrderByWithRelationInput | SvodSupplierValueOrderByWithRelationInput[]
    cursor?: SvodSupplierValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SvodSupplierValueScalarFieldEnum | SvodSupplierValueScalarFieldEnum[]
  }

  /**
   * Product.productionInputs
   */
  export type Product$productionInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    where?: ProductionInputWhereInput
    orderBy?: ProductionInputOrderByWithRelationInput | ProductionInputOrderByWithRelationInput[]
    cursor?: ProductionInputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionInputScalarFieldEnum | ProductionInputScalarFieldEnum[]
  }

  /**
   * Product.productionOutputs
   */
  export type Product$productionOutputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
    where?: ProductionOutputWhereInput
    orderBy?: ProductionOutputOrderByWithRelationInput | ProductionOutputOrderByWithRelationInput[]
    cursor?: ProductionOutputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionOutputScalarFieldEnum | ProductionOutputScalarFieldEnum[]
  }

  /**
   * Product.cuttingLineOutputs
   */
  export type Product$cuttingLineOutputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    where?: ProductionCuttingLineWhereInput
    orderBy?: ProductionCuttingLineOrderByWithRelationInput | ProductionCuttingLineOrderByWithRelationInput[]
    cursor?: ProductionCuttingLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionCuttingLineScalarFieldEnum | ProductionCuttingLineScalarFieldEnum[]
  }

  /**
   * Product.customerProducts
   */
  export type Product$customerProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
    where?: CustomerProductWhereInput
    orderBy?: CustomerProductOrderByWithRelationInput | CustomerProductOrderByWithRelationInput[]
    cursor?: CustomerProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerProductScalarFieldEnum | CustomerProductScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    legalName: string | null
    districtId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    legalName: string | null
    districtId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    code: number
    name: number
    legalName: number
    districtId: number
    managerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    districtId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    districtId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    districtId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    code: string
    name: string
    legalName: string | null
    districtId: string | null
    managerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    districtId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    summaryJournalEntries?: boolean | Customer$summaryJournalEntriesArgs<ExtArgs>
    salesPriceLists?: boolean | Customer$salesPriceListsArgs<ExtArgs>
    customerProducts?: boolean | Customer$customerProductsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    districtId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    districtId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    districtId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "legalName" | "districtId" | "managerId" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    summaryJournalEntries?: boolean | Customer$summaryJournalEntriesArgs<ExtArgs>
    salesPriceLists?: boolean | Customer$salesPriceListsArgs<ExtArgs>
    customerProducts?: boolean | Customer$customerProductsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    district?: boolean | Customer$districtArgs<ExtArgs>
    manager?: boolean | Customer$managerArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      district: Prisma.$DistrictPayload<ExtArgs> | null
      manager: Prisma.$ManagerPayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
      summaryJournalEntries: Prisma.$SummaryOrderJournalPayload<ExtArgs>[]
      salesPriceLists: Prisma.$SalesPriceListPayload<ExtArgs>[]
      customerProducts: Prisma.$CustomerProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      legalName: string | null
      districtId: string | null
      managerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    district<T extends Customer$districtArgs<ExtArgs> = {}>(args?: Subset<T, Customer$districtArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    manager<T extends Customer$managerArgs<ExtArgs> = {}>(args?: Subset<T, Customer$managerArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    summaryJournalEntries<T extends Customer$summaryJournalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$summaryJournalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesPriceLists<T extends Customer$salesPriceListsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesPriceListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerProducts<T extends Customer$customerProductsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$customerProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly code: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly legalName: FieldRef<"Customer", 'String'>
    readonly districtId: FieldRef<"Customer", 'String'>
    readonly managerId: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.district
   */
  export type Customer$districtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    where?: DistrictWhereInput
  }

  /**
   * Customer.manager
   */
  export type Customer$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.summaryJournalEntries
   */
  export type Customer$summaryJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    where?: SummaryOrderJournalWhereInput
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    cursor?: SummaryOrderJournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SummaryOrderJournalScalarFieldEnum | SummaryOrderJournalScalarFieldEnum[]
  }

  /**
   * Customer.salesPriceLists
   */
  export type Customer$salesPriceListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    where?: SalesPriceListWhereInput
    orderBy?: SalesPriceListOrderByWithRelationInput | SalesPriceListOrderByWithRelationInput[]
    cursor?: SalesPriceListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesPriceListScalarFieldEnum | SalesPriceListScalarFieldEnum[]
  }

  /**
   * Customer.customerProducts
   */
  export type Customer$customerProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
    where?: CustomerProductWhereInput
    orderBy?: CustomerProductOrderByWithRelationInput | CustomerProductOrderByWithRelationInput[]
    cursor?: CustomerProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerProductScalarFieldEnum | CustomerProductScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerProduct
   */

  export type AggregateCustomerProduct = {
    _count: CustomerProductCountAggregateOutputType | null
    _avg: CustomerProductAvgAggregateOutputType | null
    _sum: CustomerProductSumAggregateOutputType | null
    _min: CustomerProductMinAggregateOutputType | null
    _max: CustomerProductMaxAggregateOutputType | null
  }

  export type CustomerProductAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    productId: number | null
    sortOrder: number | null
  }

  export type CustomerProductSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    productId: number | null
    sortOrder: number | null
  }

  export type CustomerProductMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    productId: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerProductMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    productId: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerProductCountAggregateOutputType = {
    id: number
    customerId: number
    productId: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerProductAvgAggregateInputType = {
    id?: true
    customerId?: true
    productId?: true
    sortOrder?: true
  }

  export type CustomerProductSumAggregateInputType = {
    id?: true
    customerId?: true
    productId?: true
    sortOrder?: true
  }

  export type CustomerProductMinAggregateInputType = {
    id?: true
    customerId?: true
    productId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerProductMaxAggregateInputType = {
    id?: true
    customerId?: true
    productId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerProductCountAggregateInputType = {
    id?: true
    customerId?: true
    productId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerProduct to aggregate.
     */
    where?: CustomerProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProducts to fetch.
     */
    orderBy?: CustomerProductOrderByWithRelationInput | CustomerProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerProducts
    **/
    _count?: true | CustomerProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerProductMaxAggregateInputType
  }

  export type GetCustomerProductAggregateType<T extends CustomerProductAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerProduct[P]>
      : GetScalarType<T[P], AggregateCustomerProduct[P]>
  }




  export type CustomerProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerProductWhereInput
    orderBy?: CustomerProductOrderByWithAggregationInput | CustomerProductOrderByWithAggregationInput[]
    by: CustomerProductScalarFieldEnum[] | CustomerProductScalarFieldEnum
    having?: CustomerProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerProductCountAggregateInputType | true
    _avg?: CustomerProductAvgAggregateInputType
    _sum?: CustomerProductSumAggregateInputType
    _min?: CustomerProductMinAggregateInputType
    _max?: CustomerProductMaxAggregateInputType
  }

  export type CustomerProductGroupByOutputType = {
    id: number
    customerId: number
    productId: number
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: CustomerProductCountAggregateOutputType | null
    _avg: CustomerProductAvgAggregateOutputType | null
    _sum: CustomerProductSumAggregateOutputType | null
    _min: CustomerProductMinAggregateOutputType | null
    _max: CustomerProductMaxAggregateOutputType | null
  }

  type GetCustomerProductGroupByPayload<T extends CustomerProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerProductGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerProductGroupByOutputType[P]>
        }
      >
    >


  export type CustomerProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerProduct"]>

  export type CustomerProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerProduct"]>

  export type CustomerProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerProduct"]>

  export type CustomerProductSelectScalar = {
    id?: boolean
    customerId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "productId" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["customerProduct"]>
  export type CustomerProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CustomerProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CustomerProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CustomerProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerProduct"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number
      productId: number
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerProduct"]>
    composites: {}
  }

  type CustomerProductGetPayload<S extends boolean | null | undefined | CustomerProductDefaultArgs> = $Result.GetResult<Prisma.$CustomerProductPayload, S>

  type CustomerProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerProductCountAggregateInputType | true
    }

  export interface CustomerProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerProduct'], meta: { name: 'CustomerProduct' } }
    /**
     * Find zero or one CustomerProduct that matches the filter.
     * @param {CustomerProductFindUniqueArgs} args - Arguments to find a CustomerProduct
     * @example
     * // Get one CustomerProduct
     * const customerProduct = await prisma.customerProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerProductFindUniqueArgs>(args: SelectSubset<T, CustomerProductFindUniqueArgs<ExtArgs>>): Prisma__CustomerProductClient<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerProductFindUniqueOrThrowArgs} args - Arguments to find a CustomerProduct
     * @example
     * // Get one CustomerProduct
     * const customerProduct = await prisma.customerProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerProductFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerProductClient<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductFindFirstArgs} args - Arguments to find a CustomerProduct
     * @example
     * // Get one CustomerProduct
     * const customerProduct = await prisma.customerProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerProductFindFirstArgs>(args?: SelectSubset<T, CustomerProductFindFirstArgs<ExtArgs>>): Prisma__CustomerProductClient<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductFindFirstOrThrowArgs} args - Arguments to find a CustomerProduct
     * @example
     * // Get one CustomerProduct
     * const customerProduct = await prisma.customerProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerProductFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerProductClient<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerProducts
     * const customerProducts = await prisma.customerProduct.findMany()
     * 
     * // Get first 10 CustomerProducts
     * const customerProducts = await prisma.customerProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerProductWithIdOnly = await prisma.customerProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerProductFindManyArgs>(args?: SelectSubset<T, CustomerProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerProduct.
     * @param {CustomerProductCreateArgs} args - Arguments to create a CustomerProduct.
     * @example
     * // Create one CustomerProduct
     * const CustomerProduct = await prisma.customerProduct.create({
     *   data: {
     *     // ... data to create a CustomerProduct
     *   }
     * })
     * 
     */
    create<T extends CustomerProductCreateArgs>(args: SelectSubset<T, CustomerProductCreateArgs<ExtArgs>>): Prisma__CustomerProductClient<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerProducts.
     * @param {CustomerProductCreateManyArgs} args - Arguments to create many CustomerProducts.
     * @example
     * // Create many CustomerProducts
     * const customerProduct = await prisma.customerProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerProductCreateManyArgs>(args?: SelectSubset<T, CustomerProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerProducts and returns the data saved in the database.
     * @param {CustomerProductCreateManyAndReturnArgs} args - Arguments to create many CustomerProducts.
     * @example
     * // Create many CustomerProducts
     * const customerProduct = await prisma.customerProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerProducts and only return the `id`
     * const customerProductWithIdOnly = await prisma.customerProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerProductCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerProduct.
     * @param {CustomerProductDeleteArgs} args - Arguments to delete one CustomerProduct.
     * @example
     * // Delete one CustomerProduct
     * const CustomerProduct = await prisma.customerProduct.delete({
     *   where: {
     *     // ... filter to delete one CustomerProduct
     *   }
     * })
     * 
     */
    delete<T extends CustomerProductDeleteArgs>(args: SelectSubset<T, CustomerProductDeleteArgs<ExtArgs>>): Prisma__CustomerProductClient<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerProduct.
     * @param {CustomerProductUpdateArgs} args - Arguments to update one CustomerProduct.
     * @example
     * // Update one CustomerProduct
     * const customerProduct = await prisma.customerProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerProductUpdateArgs>(args: SelectSubset<T, CustomerProductUpdateArgs<ExtArgs>>): Prisma__CustomerProductClient<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerProducts.
     * @param {CustomerProductDeleteManyArgs} args - Arguments to filter CustomerProducts to delete.
     * @example
     * // Delete a few CustomerProducts
     * const { count } = await prisma.customerProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerProductDeleteManyArgs>(args?: SelectSubset<T, CustomerProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerProducts
     * const customerProduct = await prisma.customerProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerProductUpdateManyArgs>(args: SelectSubset<T, CustomerProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerProducts and returns the data updated in the database.
     * @param {CustomerProductUpdateManyAndReturnArgs} args - Arguments to update many CustomerProducts.
     * @example
     * // Update many CustomerProducts
     * const customerProduct = await prisma.customerProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerProducts and only return the `id`
     * const customerProductWithIdOnly = await prisma.customerProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerProductUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerProduct.
     * @param {CustomerProductUpsertArgs} args - Arguments to update or create a CustomerProduct.
     * @example
     * // Update or create a CustomerProduct
     * const customerProduct = await prisma.customerProduct.upsert({
     *   create: {
     *     // ... data to create a CustomerProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerProduct we want to update
     *   }
     * })
     */
    upsert<T extends CustomerProductUpsertArgs>(args: SelectSubset<T, CustomerProductUpsertArgs<ExtArgs>>): Prisma__CustomerProductClient<$Result.GetResult<Prisma.$CustomerProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductCountArgs} args - Arguments to filter CustomerProducts to count.
     * @example
     * // Count the number of CustomerProducts
     * const count = await prisma.customerProduct.count({
     *   where: {
     *     // ... the filter for the CustomerProducts we want to count
     *   }
     * })
    **/
    count<T extends CustomerProductCountArgs>(
      args?: Subset<T, CustomerProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerProductAggregateArgs>(args: Subset<T, CustomerProductAggregateArgs>): Prisma.PrismaPromise<GetCustomerProductAggregateType<T>>

    /**
     * Group by CustomerProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerProductGroupByArgs['orderBy'] }
        : { orderBy?: CustomerProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerProduct model
   */
  readonly fields: CustomerProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerProduct model
   */
  interface CustomerProductFieldRefs {
    readonly id: FieldRef<"CustomerProduct", 'Int'>
    readonly customerId: FieldRef<"CustomerProduct", 'Int'>
    readonly productId: FieldRef<"CustomerProduct", 'Int'>
    readonly sortOrder: FieldRef<"CustomerProduct", 'Int'>
    readonly createdAt: FieldRef<"CustomerProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerProduct findUnique
   */
  export type CustomerProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProduct to fetch.
     */
    where: CustomerProductWhereUniqueInput
  }

  /**
   * CustomerProduct findUniqueOrThrow
   */
  export type CustomerProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProduct to fetch.
     */
    where: CustomerProductWhereUniqueInput
  }

  /**
   * CustomerProduct findFirst
   */
  export type CustomerProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProduct to fetch.
     */
    where?: CustomerProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProducts to fetch.
     */
    orderBy?: CustomerProductOrderByWithRelationInput | CustomerProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerProducts.
     */
    cursor?: CustomerProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerProducts.
     */
    distinct?: CustomerProductScalarFieldEnum | CustomerProductScalarFieldEnum[]
  }

  /**
   * CustomerProduct findFirstOrThrow
   */
  export type CustomerProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProduct to fetch.
     */
    where?: CustomerProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProducts to fetch.
     */
    orderBy?: CustomerProductOrderByWithRelationInput | CustomerProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerProducts.
     */
    cursor?: CustomerProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerProducts.
     */
    distinct?: CustomerProductScalarFieldEnum | CustomerProductScalarFieldEnum[]
  }

  /**
   * CustomerProduct findMany
   */
  export type CustomerProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProducts to fetch.
     */
    where?: CustomerProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProducts to fetch.
     */
    orderBy?: CustomerProductOrderByWithRelationInput | CustomerProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerProducts.
     */
    cursor?: CustomerProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProducts.
     */
    skip?: number
    distinct?: CustomerProductScalarFieldEnum | CustomerProductScalarFieldEnum[]
  }

  /**
   * CustomerProduct create
   */
  export type CustomerProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerProduct.
     */
    data: XOR<CustomerProductCreateInput, CustomerProductUncheckedCreateInput>
  }

  /**
   * CustomerProduct createMany
   */
  export type CustomerProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerProducts.
     */
    data: CustomerProductCreateManyInput | CustomerProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerProduct createManyAndReturn
   */
  export type CustomerProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerProducts.
     */
    data: CustomerProductCreateManyInput | CustomerProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerProduct update
   */
  export type CustomerProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerProduct.
     */
    data: XOR<CustomerProductUpdateInput, CustomerProductUncheckedUpdateInput>
    /**
     * Choose, which CustomerProduct to update.
     */
    where: CustomerProductWhereUniqueInput
  }

  /**
   * CustomerProduct updateMany
   */
  export type CustomerProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerProducts.
     */
    data: XOR<CustomerProductUpdateManyMutationInput, CustomerProductUncheckedUpdateManyInput>
    /**
     * Filter which CustomerProducts to update
     */
    where?: CustomerProductWhereInput
    /**
     * Limit how many CustomerProducts to update.
     */
    limit?: number
  }

  /**
   * CustomerProduct updateManyAndReturn
   */
  export type CustomerProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * The data used to update CustomerProducts.
     */
    data: XOR<CustomerProductUpdateManyMutationInput, CustomerProductUncheckedUpdateManyInput>
    /**
     * Filter which CustomerProducts to update
     */
    where?: CustomerProductWhereInput
    /**
     * Limit how many CustomerProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerProduct upsert
   */
  export type CustomerProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerProduct to update in case it exists.
     */
    where: CustomerProductWhereUniqueInput
    /**
     * In case the CustomerProduct found by the `where` argument doesn't exist, create a new CustomerProduct with this data.
     */
    create: XOR<CustomerProductCreateInput, CustomerProductUncheckedCreateInput>
    /**
     * In case the CustomerProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerProductUpdateInput, CustomerProductUncheckedUpdateInput>
  }

  /**
   * CustomerProduct delete
   */
  export type CustomerProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
    /**
     * Filter which CustomerProduct to delete.
     */
    where: CustomerProductWhereUniqueInput
  }

  /**
   * CustomerProduct deleteMany
   */
  export type CustomerProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerProducts to delete
     */
    where?: CustomerProductWhereInput
    /**
     * Limit how many CustomerProducts to delete.
     */
    limit?: number
  }

  /**
   * CustomerProduct without action
   */
  export type CustomerProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProduct
     */
    select?: CustomerProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProduct
     */
    omit?: CustomerProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
    primaryMmlId: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
    primaryMmlId: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    legalName: string | null
    altName: string | null
    phone: string | null
    telegram: string | null
    isActive: boolean | null
    primaryMmlId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    legalName: string | null
    altName: string | null
    phone: string | null
    telegram: string | null
    isActive: boolean | null
    primaryMmlId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    code: number
    name: number
    legalName: number
    altName: number
    phone: number
    telegram: number
    isActive: number
    primaryMmlId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
    primaryMmlId?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
    primaryMmlId?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    altName?: true
    phone?: true
    telegram?: true
    isActive?: true
    primaryMmlId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    altName?: true
    phone?: true
    telegram?: true
    isActive?: true
    primaryMmlId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    legalName?: true
    altName?: true
    phone?: true
    telegram?: true
    isActive?: true
    primaryMmlId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    code: string
    name: string
    legalName: string | null
    altName: string | null
    phone: string | null
    telegram: string | null
    isActive: boolean
    primaryMmlId: number | null
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    altName?: boolean
    phone?: boolean
    telegram?: boolean
    isActive?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
    products?: boolean | Supplier$productsArgs<ExtArgs>
    purchasePriceListSuppliers?: boolean | Supplier$purchasePriceListSuppliersArgs<ExtArgs>
    purchasePriceItems?: boolean | Supplier$purchasePriceItemsArgs<ExtArgs>
    purchases?: boolean | Supplier$purchasesArgs<ExtArgs>
    purchaseItems?: boolean | Supplier$purchaseItemsArgs<ExtArgs>
    svodSupplierCols?: boolean | Supplier$svodSupplierColsArgs<ExtArgs>
    svodSupplierValues?: boolean | Supplier$svodSupplierValuesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    altName?: boolean
    phone?: boolean
    telegram?: boolean
    isActive?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    altName?: boolean
    phone?: boolean
    telegram?: boolean
    isActive?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    legalName?: boolean
    altName?: boolean
    phone?: boolean
    telegram?: boolean
    isActive?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "legalName" | "altName" | "phone" | "telegram" | "isActive" | "primaryMmlId" | "createdAt" | "updatedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
    products?: boolean | Supplier$productsArgs<ExtArgs>
    purchasePriceListSuppliers?: boolean | Supplier$purchasePriceListSuppliersArgs<ExtArgs>
    purchasePriceItems?: boolean | Supplier$purchasePriceItemsArgs<ExtArgs>
    purchases?: boolean | Supplier$purchasesArgs<ExtArgs>
    purchaseItems?: boolean | Supplier$purchaseItemsArgs<ExtArgs>
    svodSupplierCols?: boolean | Supplier$svodSupplierColsArgs<ExtArgs>
    svodSupplierValues?: boolean | Supplier$svodSupplierValuesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
  }
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryMml?: boolean | Supplier$primaryMmlArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      primaryMml: Prisma.$ProductionMmlPayload<ExtArgs> | null
      products: Prisma.$SupplierProductPayload<ExtArgs>[]
      purchasePriceListSuppliers: Prisma.$PurchasePriceListSupplierPayload<ExtArgs>[]
      purchasePriceItems: Prisma.$PurchasePriceItemPayload<ExtArgs>[]
      purchases: Prisma.$PurchaseSupplierPayload<ExtArgs>[]
      purchaseItems: Prisma.$PurchaseItemPayload<ExtArgs>[]
      svodSupplierCols: Prisma.$SvodSupplierColPayload<ExtArgs>[]
      svodSupplierValues: Prisma.$SvodSupplierValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      legalName: string | null
      altName: string | null
      phone: string | null
      telegram: string | null
      isActive: boolean
      primaryMmlId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    primaryMml<T extends Supplier$primaryMmlArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$primaryMmlArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends Supplier$productsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchasePriceListSuppliers<T extends Supplier$purchasePriceListSuppliersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchasePriceListSuppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchasePriceItems<T extends Supplier$purchasePriceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchasePriceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchases<T extends Supplier$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseItems<T extends Supplier$purchaseItemsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchaseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    svodSupplierCols<T extends Supplier$svodSupplierColsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$svodSupplierColsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    svodSupplierValues<T extends Supplier$svodSupplierValuesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$svodSupplierValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'Int'>
    readonly code: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly legalName: FieldRef<"Supplier", 'String'>
    readonly altName: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly telegram: FieldRef<"Supplier", 'String'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly primaryMmlId: FieldRef<"Supplier", 'Int'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.primaryMml
   */
  export type Supplier$primaryMmlArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    where?: ProductionMmlWhereInput
  }

  /**
   * Supplier.products
   */
  export type Supplier$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    where?: SupplierProductWhereInput
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    cursor?: SupplierProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * Supplier.purchasePriceListSuppliers
   */
  export type Supplier$purchasePriceListSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    where?: PurchasePriceListSupplierWhereInput
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * Supplier.purchasePriceItems
   */
  export type Supplier$purchasePriceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    where?: PurchasePriceItemWhereInput
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    cursor?: PurchasePriceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * Supplier.purchases
   */
  export type Supplier$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
    where?: PurchaseSupplierWhereInput
    orderBy?: PurchaseSupplierOrderByWithRelationInput | PurchaseSupplierOrderByWithRelationInput[]
    cursor?: PurchaseSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseSupplierScalarFieldEnum | PurchaseSupplierScalarFieldEnum[]
  }

  /**
   * Supplier.purchaseItems
   */
  export type Supplier$purchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Supplier.svodSupplierCols
   */
  export type Supplier$svodSupplierColsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
    where?: SvodSupplierColWhereInput
    orderBy?: SvodSupplierColOrderByWithRelationInput | SvodSupplierColOrderByWithRelationInput[]
    cursor?: SvodSupplierColWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SvodSupplierColScalarFieldEnum | SvodSupplierColScalarFieldEnum[]
  }

  /**
   * Supplier.svodSupplierValues
   */
  export type Supplier$svodSupplierValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    where?: SvodSupplierValueWhereInput
    orderBy?: SvodSupplierValueOrderByWithRelationInput | SvodSupplierValueOrderByWithRelationInput[]
    cursor?: SvodSupplierValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SvodSupplierValueScalarFieldEnum | SvodSupplierValueScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model SupplierProduct
   */

  export type AggregateSupplierProduct = {
    _count: SupplierProductCountAggregateOutputType | null
    _avg: SupplierProductAvgAggregateOutputType | null
    _sum: SupplierProductSumAggregateOutputType | null
    _min: SupplierProductMinAggregateOutputType | null
    _max: SupplierProductMaxAggregateOutputType | null
  }

  export type SupplierProductAvgAggregateOutputType = {
    supplierId: number | null
    productId: number | null
  }

  export type SupplierProductSumAggregateOutputType = {
    supplierId: number | null
    productId: number | null
  }

  export type SupplierProductMinAggregateOutputType = {
    supplierId: number | null
    productId: number | null
  }

  export type SupplierProductMaxAggregateOutputType = {
    supplierId: number | null
    productId: number | null
  }

  export type SupplierProductCountAggregateOutputType = {
    supplierId: number
    productId: number
    _all: number
  }


  export type SupplierProductAvgAggregateInputType = {
    supplierId?: true
    productId?: true
  }

  export type SupplierProductSumAggregateInputType = {
    supplierId?: true
    productId?: true
  }

  export type SupplierProductMinAggregateInputType = {
    supplierId?: true
    productId?: true
  }

  export type SupplierProductMaxAggregateInputType = {
    supplierId?: true
    productId?: true
  }

  export type SupplierProductCountAggregateInputType = {
    supplierId?: true
    productId?: true
    _all?: true
  }

  export type SupplierProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierProduct to aggregate.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierProducts
    **/
    _count?: true | SupplierProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierProductMaxAggregateInputType
  }

  export type GetSupplierProductAggregateType<T extends SupplierProductAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierProduct[P]>
      : GetScalarType<T[P], AggregateSupplierProduct[P]>
  }




  export type SupplierProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierProductWhereInput
    orderBy?: SupplierProductOrderByWithAggregationInput | SupplierProductOrderByWithAggregationInput[]
    by: SupplierProductScalarFieldEnum[] | SupplierProductScalarFieldEnum
    having?: SupplierProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierProductCountAggregateInputType | true
    _avg?: SupplierProductAvgAggregateInputType
    _sum?: SupplierProductSumAggregateInputType
    _min?: SupplierProductMinAggregateInputType
    _max?: SupplierProductMaxAggregateInputType
  }

  export type SupplierProductGroupByOutputType = {
    supplierId: number
    productId: number
    _count: SupplierProductCountAggregateOutputType | null
    _avg: SupplierProductAvgAggregateOutputType | null
    _sum: SupplierProductSumAggregateOutputType | null
    _min: SupplierProductMinAggregateOutputType | null
    _max: SupplierProductMaxAggregateOutputType | null
  }

  type GetSupplierProductGroupByPayload<T extends SupplierProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierProductGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierProductGroupByOutputType[P]>
        }
      >
    >


  export type SupplierProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplierId?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierProduct"]>

  export type SupplierProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplierId?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierProduct"]>

  export type SupplierProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplierId?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierProduct"]>

  export type SupplierProductSelectScalar = {
    supplierId?: boolean
    productId?: boolean
  }

  export type SupplierProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"supplierId" | "productId", ExtArgs["result"]["supplierProduct"]>
  export type SupplierProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $SupplierProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierProduct"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      supplierId: number
      productId: number
    }, ExtArgs["result"]["supplierProduct"]>
    composites: {}
  }

  type SupplierProductGetPayload<S extends boolean | null | undefined | SupplierProductDefaultArgs> = $Result.GetResult<Prisma.$SupplierProductPayload, S>

  type SupplierProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierProductCountAggregateInputType | true
    }

  export interface SupplierProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierProduct'], meta: { name: 'SupplierProduct' } }
    /**
     * Find zero or one SupplierProduct that matches the filter.
     * @param {SupplierProductFindUniqueArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierProductFindUniqueArgs>(args: SelectSubset<T, SupplierProductFindUniqueArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierProductFindUniqueOrThrowArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierProductFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductFindFirstArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierProductFindFirstArgs>(args?: SelectSubset<T, SupplierProductFindFirstArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductFindFirstOrThrowArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierProductFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierProducts
     * const supplierProducts = await prisma.supplierProduct.findMany()
     * 
     * // Get first 10 SupplierProducts
     * const supplierProducts = await prisma.supplierProduct.findMany({ take: 10 })
     * 
     * // Only select the `supplierId`
     * const supplierProductWithSupplierIdOnly = await prisma.supplierProduct.findMany({ select: { supplierId: true } })
     * 
     */
    findMany<T extends SupplierProductFindManyArgs>(args?: SelectSubset<T, SupplierProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierProduct.
     * @param {SupplierProductCreateArgs} args - Arguments to create a SupplierProduct.
     * @example
     * // Create one SupplierProduct
     * const SupplierProduct = await prisma.supplierProduct.create({
     *   data: {
     *     // ... data to create a SupplierProduct
     *   }
     * })
     * 
     */
    create<T extends SupplierProductCreateArgs>(args: SelectSubset<T, SupplierProductCreateArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierProducts.
     * @param {SupplierProductCreateManyArgs} args - Arguments to create many SupplierProducts.
     * @example
     * // Create many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierProductCreateManyArgs>(args?: SelectSubset<T, SupplierProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierProducts and returns the data saved in the database.
     * @param {SupplierProductCreateManyAndReturnArgs} args - Arguments to create many SupplierProducts.
     * @example
     * // Create many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierProducts and only return the `supplierId`
     * const supplierProductWithSupplierIdOnly = await prisma.supplierProduct.createManyAndReturn({
     *   select: { supplierId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierProductCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierProduct.
     * @param {SupplierProductDeleteArgs} args - Arguments to delete one SupplierProduct.
     * @example
     * // Delete one SupplierProduct
     * const SupplierProduct = await prisma.supplierProduct.delete({
     *   where: {
     *     // ... filter to delete one SupplierProduct
     *   }
     * })
     * 
     */
    delete<T extends SupplierProductDeleteArgs>(args: SelectSubset<T, SupplierProductDeleteArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierProduct.
     * @param {SupplierProductUpdateArgs} args - Arguments to update one SupplierProduct.
     * @example
     * // Update one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierProductUpdateArgs>(args: SelectSubset<T, SupplierProductUpdateArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierProducts.
     * @param {SupplierProductDeleteManyArgs} args - Arguments to filter SupplierProducts to delete.
     * @example
     * // Delete a few SupplierProducts
     * const { count } = await prisma.supplierProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierProductDeleteManyArgs>(args?: SelectSubset<T, SupplierProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierProductUpdateManyArgs>(args: SelectSubset<T, SupplierProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierProducts and returns the data updated in the database.
     * @param {SupplierProductUpdateManyAndReturnArgs} args - Arguments to update many SupplierProducts.
     * @example
     * // Update many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierProducts and only return the `supplierId`
     * const supplierProductWithSupplierIdOnly = await prisma.supplierProduct.updateManyAndReturn({
     *   select: { supplierId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierProductUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierProduct.
     * @param {SupplierProductUpsertArgs} args - Arguments to update or create a SupplierProduct.
     * @example
     * // Update or create a SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.upsert({
     *   create: {
     *     // ... data to create a SupplierProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierProduct we want to update
     *   }
     * })
     */
    upsert<T extends SupplierProductUpsertArgs>(args: SelectSubset<T, SupplierProductUpsertArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductCountArgs} args - Arguments to filter SupplierProducts to count.
     * @example
     * // Count the number of SupplierProducts
     * const count = await prisma.supplierProduct.count({
     *   where: {
     *     // ... the filter for the SupplierProducts we want to count
     *   }
     * })
    **/
    count<T extends SupplierProductCountArgs>(
      args?: Subset<T, SupplierProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierProductAggregateArgs>(args: Subset<T, SupplierProductAggregateArgs>): Prisma.PrismaPromise<GetSupplierProductAggregateType<T>>

    /**
     * Group by SupplierProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierProductGroupByArgs['orderBy'] }
        : { orderBy?: SupplierProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierProduct model
   */
  readonly fields: SupplierProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierProduct model
   */
  interface SupplierProductFieldRefs {
    readonly supplierId: FieldRef<"SupplierProduct", 'Int'>
    readonly productId: FieldRef<"SupplierProduct", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SupplierProduct findUnique
   */
  export type SupplierProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct findUniqueOrThrow
   */
  export type SupplierProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct findFirst
   */
  export type SupplierProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierProducts.
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierProducts.
     */
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * SupplierProduct findFirstOrThrow
   */
  export type SupplierProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierProducts.
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierProducts.
     */
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * SupplierProduct findMany
   */
  export type SupplierProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProducts to fetch.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierProducts.
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * SupplierProduct create
   */
  export type SupplierProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierProduct.
     */
    data: XOR<SupplierProductCreateInput, SupplierProductUncheckedCreateInput>
  }

  /**
   * SupplierProduct createMany
   */
  export type SupplierProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierProducts.
     */
    data: SupplierProductCreateManyInput | SupplierProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierProduct createManyAndReturn
   */
  export type SupplierProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierProducts.
     */
    data: SupplierProductCreateManyInput | SupplierProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierProduct update
   */
  export type SupplierProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierProduct.
     */
    data: XOR<SupplierProductUpdateInput, SupplierProductUncheckedUpdateInput>
    /**
     * Choose, which SupplierProduct to update.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct updateMany
   */
  export type SupplierProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierProducts.
     */
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyInput>
    /**
     * Filter which SupplierProducts to update
     */
    where?: SupplierProductWhereInput
    /**
     * Limit how many SupplierProducts to update.
     */
    limit?: number
  }

  /**
   * SupplierProduct updateManyAndReturn
   */
  export type SupplierProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * The data used to update SupplierProducts.
     */
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyInput>
    /**
     * Filter which SupplierProducts to update
     */
    where?: SupplierProductWhereInput
    /**
     * Limit how many SupplierProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierProduct upsert
   */
  export type SupplierProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierProduct to update in case it exists.
     */
    where: SupplierProductWhereUniqueInput
    /**
     * In case the SupplierProduct found by the `where` argument doesn't exist, create a new SupplierProduct with this data.
     */
    create: XOR<SupplierProductCreateInput, SupplierProductUncheckedCreateInput>
    /**
     * In case the SupplierProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierProductUpdateInput, SupplierProductUncheckedUpdateInput>
  }

  /**
   * SupplierProduct delete
   */
  export type SupplierProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter which SupplierProduct to delete.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct deleteMany
   */
  export type SupplierProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierProducts to delete
     */
    where?: SupplierProductWhereInput
    /**
     * Limit how many SupplierProducts to delete.
     */
    limit?: number
  }

  /**
   * SupplierProduct without action
   */
  export type SupplierProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    expeditorId: number | null
    totalAmount: Decimal | null
    totalWeight: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    expeditorId: number | null
    totalAmount: Decimal | null
    totalWeight: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    idn: string | null
    date: Date | null
    status: string | null
    paymentType: string | null
    customerId: number | null
    expeditorId: number | null
    totalAmount: Decimal | null
    totalWeight: number | null
    isDisabled: boolean | null
    deliveryAddress: string | null
    assignedAt: Date | null
    deliveryStatus: string | null
    completedAt: Date | null
    signatureUrl: string | null
    signedInvoiceUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    idn: string | null
    date: Date | null
    status: string | null
    paymentType: string | null
    customerId: number | null
    expeditorId: number | null
    totalAmount: Decimal | null
    totalWeight: number | null
    isDisabled: boolean | null
    deliveryAddress: string | null
    assignedAt: Date | null
    deliveryStatus: string | null
    completedAt: Date | null
    signatureUrl: string | null
    signedInvoiceUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    idn: number
    date: number
    status: number
    paymentType: number
    customerId: number
    expeditorId: number
    totalAmount: number
    totalWeight: number
    isDisabled: number
    deliveryAddress: number
    assignedAt: number
    deliveryStatus: number
    completedAt: number
    signatureUrl: number
    signedInvoiceUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    customerId?: true
    expeditorId?: true
    totalAmount?: true
    totalWeight?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    customerId?: true
    expeditorId?: true
    totalAmount?: true
    totalWeight?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    idn?: true
    date?: true
    status?: true
    paymentType?: true
    customerId?: true
    expeditorId?: true
    totalAmount?: true
    totalWeight?: true
    isDisabled?: true
    deliveryAddress?: true
    assignedAt?: true
    deliveryStatus?: true
    completedAt?: true
    signatureUrl?: true
    signedInvoiceUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    idn?: true
    date?: true
    status?: true
    paymentType?: true
    customerId?: true
    expeditorId?: true
    totalAmount?: true
    totalWeight?: true
    isDisabled?: true
    deliveryAddress?: true
    assignedAt?: true
    deliveryStatus?: true
    completedAt?: true
    signatureUrl?: true
    signedInvoiceUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    idn?: true
    date?: true
    status?: true
    paymentType?: true
    customerId?: true
    expeditorId?: true
    totalAmount?: true
    totalWeight?: true
    isDisabled?: true
    deliveryAddress?: true
    assignedAt?: true
    deliveryStatus?: true
    completedAt?: true
    signatureUrl?: true
    signedInvoiceUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    idn: string | null
    date: Date
    status: string
    paymentType: string | null
    customerId: number
    expeditorId: number | null
    totalAmount: Decimal
    totalWeight: number
    isDisabled: boolean
    deliveryAddress: string | null
    assignedAt: Date | null
    deliveryStatus: string
    completedAt: Date | null
    signatureUrl: string | null
    signedInvoiceUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    date?: boolean
    status?: boolean
    paymentType?: boolean
    customerId?: boolean
    expeditorId?: boolean
    totalAmount?: boolean
    totalWeight?: boolean
    isDisabled?: boolean
    deliveryAddress?: boolean
    assignedAt?: boolean
    deliveryStatus?: boolean
    completedAt?: boolean
    signatureUrl?: boolean
    signedInvoiceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    stockTransactions?: boolean | Order$stockTransactionsArgs<ExtArgs>
    attachments?: boolean | Order$attachmentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    date?: boolean
    status?: boolean
    paymentType?: boolean
    customerId?: boolean
    expeditorId?: boolean
    totalAmount?: boolean
    totalWeight?: boolean
    isDisabled?: boolean
    deliveryAddress?: boolean
    assignedAt?: boolean
    deliveryStatus?: boolean
    completedAt?: boolean
    signatureUrl?: boolean
    signedInvoiceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    date?: boolean
    status?: boolean
    paymentType?: boolean
    customerId?: boolean
    expeditorId?: boolean
    totalAmount?: boolean
    totalWeight?: boolean
    isDisabled?: boolean
    deliveryAddress?: boolean
    assignedAt?: boolean
    deliveryStatus?: boolean
    completedAt?: boolean
    signatureUrl?: boolean
    signedInvoiceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    idn?: boolean
    date?: boolean
    status?: boolean
    paymentType?: boolean
    customerId?: boolean
    expeditorId?: boolean
    totalAmount?: boolean
    totalWeight?: boolean
    isDisabled?: boolean
    deliveryAddress?: boolean
    assignedAt?: boolean
    deliveryStatus?: boolean
    completedAt?: boolean
    signatureUrl?: boolean
    signedInvoiceUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idn" | "date" | "status" | "paymentType" | "customerId" | "expeditorId" | "totalAmount" | "totalWeight" | "isDisabled" | "deliveryAddress" | "assignedAt" | "deliveryStatus" | "completedAt" | "signatureUrl" | "signedInvoiceUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    stockTransactions?: boolean | Order$stockTransactionsArgs<ExtArgs>
    attachments?: boolean | Order$attachmentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    expeditor?: boolean | Order$expeditorArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      expeditor: Prisma.$ExpeditorPayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      stockTransactions: Prisma.$StockTransactionPayload<ExtArgs>[]
      attachments: Prisma.$OrderAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idn: string | null
      date: Date
      status: string
      paymentType: string | null
      customerId: number
      expeditorId: number | null
      totalAmount: Prisma.Decimal
      totalWeight: number
      isDisabled: boolean
      deliveryAddress: string | null
      assignedAt: Date | null
      deliveryStatus: string
      completedAt: Date | null
      signatureUrl: string | null
      signedInvoiceUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    expeditor<T extends Order$expeditorArgs<ExtArgs> = {}>(args?: Subset<T, Order$expeditorArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockTransactions<T extends Order$stockTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Order$stockTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Order$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly idn: FieldRef<"Order", 'String'>
    readonly date: FieldRef<"Order", 'DateTime'>
    readonly status: FieldRef<"Order", 'String'>
    readonly paymentType: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'Int'>
    readonly expeditorId: FieldRef<"Order", 'Int'>
    readonly totalAmount: FieldRef<"Order", 'Decimal'>
    readonly totalWeight: FieldRef<"Order", 'Float'>
    readonly isDisabled: FieldRef<"Order", 'Boolean'>
    readonly deliveryAddress: FieldRef<"Order", 'String'>
    readonly assignedAt: FieldRef<"Order", 'DateTime'>
    readonly deliveryStatus: FieldRef<"Order", 'String'>
    readonly completedAt: FieldRef<"Order", 'DateTime'>
    readonly signatureUrl: FieldRef<"Order", 'String'>
    readonly signedInvoiceUrl: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.expeditor
   */
  export type Order$expeditorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    where?: ExpeditorWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.stockTransactions
   */
  export type Order$stockTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    where?: StockTransactionWhereInput
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    cursor?: StockTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * Order.attachments
   */
  export type Order$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    where?: OrderAttachmentWhereInput
    orderBy?: OrderAttachmentOrderByWithRelationInput | OrderAttachmentOrderByWithRelationInput[]
    cursor?: OrderAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderAttachmentScalarFieldEnum | OrderAttachmentScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderAttachment
   */

  export type AggregateOrderAttachment = {
    _count: OrderAttachmentCountAggregateOutputType | null
    _avg: OrderAttachmentAvgAggregateOutputType | null
    _sum: OrderAttachmentSumAggregateOutputType | null
    _min: OrderAttachmentMinAggregateOutputType | null
    _max: OrderAttachmentMaxAggregateOutputType | null
  }

  export type OrderAttachmentAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type OrderAttachmentSumAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type OrderAttachmentMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    type: string | null
    filename: string | null
    url: string | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type OrderAttachmentMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    type: string | null
    filename: string | null
    url: string | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type OrderAttachmentCountAggregateOutputType = {
    id: number
    orderId: number
    type: number
    filename: number
    url: number
    mimeType: number
    createdAt: number
    _all: number
  }


  export type OrderAttachmentAvgAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type OrderAttachmentSumAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type OrderAttachmentMinAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    filename?: true
    url?: true
    mimeType?: true
    createdAt?: true
  }

  export type OrderAttachmentMaxAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    filename?: true
    url?: true
    mimeType?: true
    createdAt?: true
  }

  export type OrderAttachmentCountAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    filename?: true
    url?: true
    mimeType?: true
    createdAt?: true
    _all?: true
  }

  export type OrderAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderAttachment to aggregate.
     */
    where?: OrderAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAttachments to fetch.
     */
    orderBy?: OrderAttachmentOrderByWithRelationInput | OrderAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderAttachments
    **/
    _count?: true | OrderAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderAttachmentMaxAggregateInputType
  }

  export type GetOrderAttachmentAggregateType<T extends OrderAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderAttachment[P]>
      : GetScalarType<T[P], AggregateOrderAttachment[P]>
  }




  export type OrderAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderAttachmentWhereInput
    orderBy?: OrderAttachmentOrderByWithAggregationInput | OrderAttachmentOrderByWithAggregationInput[]
    by: OrderAttachmentScalarFieldEnum[] | OrderAttachmentScalarFieldEnum
    having?: OrderAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderAttachmentCountAggregateInputType | true
    _avg?: OrderAttachmentAvgAggregateInputType
    _sum?: OrderAttachmentSumAggregateInputType
    _min?: OrderAttachmentMinAggregateInputType
    _max?: OrderAttachmentMaxAggregateInputType
  }

  export type OrderAttachmentGroupByOutputType = {
    id: number
    orderId: number
    type: string
    filename: string
    url: string
    mimeType: string | null
    createdAt: Date
    _count: OrderAttachmentCountAggregateOutputType | null
    _avg: OrderAttachmentAvgAggregateOutputType | null
    _sum: OrderAttachmentSumAggregateOutputType | null
    _min: OrderAttachmentMinAggregateOutputType | null
    _max: OrderAttachmentMaxAggregateOutputType | null
  }

  type GetOrderAttachmentGroupByPayload<T extends OrderAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], OrderAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type OrderAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderAttachment"]>

  export type OrderAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderAttachment"]>

  export type OrderAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderAttachment"]>

  export type OrderAttachmentSelectScalar = {
    id?: boolean
    orderId?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
  }

  export type OrderAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "type" | "filename" | "url" | "mimeType" | "createdAt", ExtArgs["result"]["orderAttachment"]>
  export type OrderAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $OrderAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderAttachment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      type: string
      filename: string
      url: string
      mimeType: string | null
      createdAt: Date
    }, ExtArgs["result"]["orderAttachment"]>
    composites: {}
  }

  type OrderAttachmentGetPayload<S extends boolean | null | undefined | OrderAttachmentDefaultArgs> = $Result.GetResult<Prisma.$OrderAttachmentPayload, S>

  type OrderAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderAttachmentCountAggregateInputType | true
    }

  export interface OrderAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderAttachment'], meta: { name: 'OrderAttachment' } }
    /**
     * Find zero or one OrderAttachment that matches the filter.
     * @param {OrderAttachmentFindUniqueArgs} args - Arguments to find a OrderAttachment
     * @example
     * // Get one OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderAttachmentFindUniqueArgs>(args: SelectSubset<T, OrderAttachmentFindUniqueArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderAttachmentFindUniqueOrThrowArgs} args - Arguments to find a OrderAttachment
     * @example
     * // Get one OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentFindFirstArgs} args - Arguments to find a OrderAttachment
     * @example
     * // Get one OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderAttachmentFindFirstArgs>(args?: SelectSubset<T, OrderAttachmentFindFirstArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentFindFirstOrThrowArgs} args - Arguments to find a OrderAttachment
     * @example
     * // Get one OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderAttachments
     * const orderAttachments = await prisma.orderAttachment.findMany()
     * 
     * // Get first 10 OrderAttachments
     * const orderAttachments = await prisma.orderAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderAttachmentWithIdOnly = await prisma.orderAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderAttachmentFindManyArgs>(args?: SelectSubset<T, OrderAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderAttachment.
     * @param {OrderAttachmentCreateArgs} args - Arguments to create a OrderAttachment.
     * @example
     * // Create one OrderAttachment
     * const OrderAttachment = await prisma.orderAttachment.create({
     *   data: {
     *     // ... data to create a OrderAttachment
     *   }
     * })
     * 
     */
    create<T extends OrderAttachmentCreateArgs>(args: SelectSubset<T, OrderAttachmentCreateArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderAttachments.
     * @param {OrderAttachmentCreateManyArgs} args - Arguments to create many OrderAttachments.
     * @example
     * // Create many OrderAttachments
     * const orderAttachment = await prisma.orderAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderAttachmentCreateManyArgs>(args?: SelectSubset<T, OrderAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderAttachments and returns the data saved in the database.
     * @param {OrderAttachmentCreateManyAndReturnArgs} args - Arguments to create many OrderAttachments.
     * @example
     * // Create many OrderAttachments
     * const orderAttachment = await prisma.orderAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderAttachments and only return the `id`
     * const orderAttachmentWithIdOnly = await prisma.orderAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderAttachment.
     * @param {OrderAttachmentDeleteArgs} args - Arguments to delete one OrderAttachment.
     * @example
     * // Delete one OrderAttachment
     * const OrderAttachment = await prisma.orderAttachment.delete({
     *   where: {
     *     // ... filter to delete one OrderAttachment
     *   }
     * })
     * 
     */
    delete<T extends OrderAttachmentDeleteArgs>(args: SelectSubset<T, OrderAttachmentDeleteArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderAttachment.
     * @param {OrderAttachmentUpdateArgs} args - Arguments to update one OrderAttachment.
     * @example
     * // Update one OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderAttachmentUpdateArgs>(args: SelectSubset<T, OrderAttachmentUpdateArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderAttachments.
     * @param {OrderAttachmentDeleteManyArgs} args - Arguments to filter OrderAttachments to delete.
     * @example
     * // Delete a few OrderAttachments
     * const { count } = await prisma.orderAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderAttachmentDeleteManyArgs>(args?: SelectSubset<T, OrderAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderAttachments
     * const orderAttachment = await prisma.orderAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderAttachmentUpdateManyArgs>(args: SelectSubset<T, OrderAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderAttachments and returns the data updated in the database.
     * @param {OrderAttachmentUpdateManyAndReturnArgs} args - Arguments to update many OrderAttachments.
     * @example
     * // Update many OrderAttachments
     * const orderAttachment = await prisma.orderAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderAttachments and only return the `id`
     * const orderAttachmentWithIdOnly = await prisma.orderAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderAttachment.
     * @param {OrderAttachmentUpsertArgs} args - Arguments to update or create a OrderAttachment.
     * @example
     * // Update or create a OrderAttachment
     * const orderAttachment = await prisma.orderAttachment.upsert({
     *   create: {
     *     // ... data to create a OrderAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderAttachment we want to update
     *   }
     * })
     */
    upsert<T extends OrderAttachmentUpsertArgs>(args: SelectSubset<T, OrderAttachmentUpsertArgs<ExtArgs>>): Prisma__OrderAttachmentClient<$Result.GetResult<Prisma.$OrderAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentCountArgs} args - Arguments to filter OrderAttachments to count.
     * @example
     * // Count the number of OrderAttachments
     * const count = await prisma.orderAttachment.count({
     *   where: {
     *     // ... the filter for the OrderAttachments we want to count
     *   }
     * })
    **/
    count<T extends OrderAttachmentCountArgs>(
      args?: Subset<T, OrderAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAttachmentAggregateArgs>(args: Subset<T, OrderAttachmentAggregateArgs>): Prisma.PrismaPromise<GetOrderAttachmentAggregateType<T>>

    /**
     * Group by OrderAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: OrderAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderAttachment model
   */
  readonly fields: OrderAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderAttachment model
   */
  interface OrderAttachmentFieldRefs {
    readonly id: FieldRef<"OrderAttachment", 'Int'>
    readonly orderId: FieldRef<"OrderAttachment", 'Int'>
    readonly type: FieldRef<"OrderAttachment", 'String'>
    readonly filename: FieldRef<"OrderAttachment", 'String'>
    readonly url: FieldRef<"OrderAttachment", 'String'>
    readonly mimeType: FieldRef<"OrderAttachment", 'String'>
    readonly createdAt: FieldRef<"OrderAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderAttachment findUnique
   */
  export type OrderAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAttachment to fetch.
     */
    where: OrderAttachmentWhereUniqueInput
  }

  /**
   * OrderAttachment findUniqueOrThrow
   */
  export type OrderAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAttachment to fetch.
     */
    where: OrderAttachmentWhereUniqueInput
  }

  /**
   * OrderAttachment findFirst
   */
  export type OrderAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAttachment to fetch.
     */
    where?: OrderAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAttachments to fetch.
     */
    orderBy?: OrderAttachmentOrderByWithRelationInput | OrderAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderAttachments.
     */
    cursor?: OrderAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderAttachments.
     */
    distinct?: OrderAttachmentScalarFieldEnum | OrderAttachmentScalarFieldEnum[]
  }

  /**
   * OrderAttachment findFirstOrThrow
   */
  export type OrderAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAttachment to fetch.
     */
    where?: OrderAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAttachments to fetch.
     */
    orderBy?: OrderAttachmentOrderByWithRelationInput | OrderAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderAttachments.
     */
    cursor?: OrderAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderAttachments.
     */
    distinct?: OrderAttachmentScalarFieldEnum | OrderAttachmentScalarFieldEnum[]
  }

  /**
   * OrderAttachment findMany
   */
  export type OrderAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAttachments to fetch.
     */
    where?: OrderAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAttachments to fetch.
     */
    orderBy?: OrderAttachmentOrderByWithRelationInput | OrderAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderAttachments.
     */
    cursor?: OrderAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAttachments.
     */
    skip?: number
    distinct?: OrderAttachmentScalarFieldEnum | OrderAttachmentScalarFieldEnum[]
  }

  /**
   * OrderAttachment create
   */
  export type OrderAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderAttachment.
     */
    data: XOR<OrderAttachmentCreateInput, OrderAttachmentUncheckedCreateInput>
  }

  /**
   * OrderAttachment createMany
   */
  export type OrderAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderAttachments.
     */
    data: OrderAttachmentCreateManyInput | OrderAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderAttachment createManyAndReturn
   */
  export type OrderAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many OrderAttachments.
     */
    data: OrderAttachmentCreateManyInput | OrderAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderAttachment update
   */
  export type OrderAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderAttachment.
     */
    data: XOR<OrderAttachmentUpdateInput, OrderAttachmentUncheckedUpdateInput>
    /**
     * Choose, which OrderAttachment to update.
     */
    where: OrderAttachmentWhereUniqueInput
  }

  /**
   * OrderAttachment updateMany
   */
  export type OrderAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderAttachments.
     */
    data: XOR<OrderAttachmentUpdateManyMutationInput, OrderAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which OrderAttachments to update
     */
    where?: OrderAttachmentWhereInput
    /**
     * Limit how many OrderAttachments to update.
     */
    limit?: number
  }

  /**
   * OrderAttachment updateManyAndReturn
   */
  export type OrderAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update OrderAttachments.
     */
    data: XOR<OrderAttachmentUpdateManyMutationInput, OrderAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which OrderAttachments to update
     */
    where?: OrderAttachmentWhereInput
    /**
     * Limit how many OrderAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderAttachment upsert
   */
  export type OrderAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderAttachment to update in case it exists.
     */
    where: OrderAttachmentWhereUniqueInput
    /**
     * In case the OrderAttachment found by the `where` argument doesn't exist, create a new OrderAttachment with this data.
     */
    create: XOR<OrderAttachmentCreateInput, OrderAttachmentUncheckedCreateInput>
    /**
     * In case the OrderAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderAttachmentUpdateInput, OrderAttachmentUncheckedUpdateInput>
  }

  /**
   * OrderAttachment delete
   */
  export type OrderAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
    /**
     * Filter which OrderAttachment to delete.
     */
    where: OrderAttachmentWhereUniqueInput
  }

  /**
   * OrderAttachment deleteMany
   */
  export type OrderAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderAttachments to delete
     */
    where?: OrderAttachmentWhereInput
    /**
     * Limit how many OrderAttachments to delete.
     */
    limit?: number
  }

  /**
   * OrderAttachment without action
   */
  export type OrderAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAttachment
     */
    select?: OrderAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAttachment
     */
    omit?: OrderAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
    amount: Decimal | null
    shippedQty: number | null
    distributionCoef: number | null
    sumWithRevaluation: Decimal | null
    weightToDistribute: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
    amount: Decimal | null
    shippedQty: number | null
    distributionCoef: number | null
    sumWithRevaluation: Decimal | null
    weightToDistribute: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
    amount: Decimal | null
    shippedQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
    distributionCoef: number | null
    sumWithRevaluation: Decimal | null
    weightToDistribute: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
    amount: Decimal | null
    shippedQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
    distributionCoef: number | null
    sumWithRevaluation: Decimal | null
    weightToDistribute: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    price: number
    amount: number
    shippedQty: number
    createdAt: number
    updatedAt: number
    distributionCoef: number
    sumWithRevaluation: number
    weightToDistribute: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    amount?: true
    shippedQty?: true
    distributionCoef?: true
    sumWithRevaluation?: true
    weightToDistribute?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    amount?: true
    shippedQty?: true
    distributionCoef?: true
    sumWithRevaluation?: true
    weightToDistribute?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    amount?: true
    shippedQty?: true
    createdAt?: true
    updatedAt?: true
    distributionCoef?: true
    sumWithRevaluation?: true
    weightToDistribute?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    amount?: true
    shippedQty?: true
    createdAt?: true
    updatedAt?: true
    distributionCoef?: true
    sumWithRevaluation?: true
    weightToDistribute?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    amount?: true
    shippedQty?: true
    createdAt?: true
    updatedAt?: true
    distributionCoef?: true
    sumWithRevaluation?: true
    weightToDistribute?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    price: Decimal
    amount: Decimal
    shippedQty: number
    createdAt: Date
    updatedAt: Date
    distributionCoef: number | null
    sumWithRevaluation: Decimal | null
    weightToDistribute: number | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    amount?: boolean
    shippedQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributionCoef?: boolean
    sumWithRevaluation?: boolean
    weightToDistribute?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    amount?: boolean
    shippedQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributionCoef?: boolean
    sumWithRevaluation?: boolean
    weightToDistribute?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    amount?: boolean
    shippedQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributionCoef?: boolean
    sumWithRevaluation?: boolean
    weightToDistribute?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    amount?: boolean
    shippedQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributionCoef?: boolean
    sumWithRevaluation?: boolean
    weightToDistribute?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantity" | "price" | "amount" | "shippedQty" | "createdAt" | "updatedAt" | "distributionCoef" | "sumWithRevaluation" | "weightToDistribute", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      productId: number
      quantity: number
      price: Prisma.Decimal
      amount: Prisma.Decimal
      shippedQty: number
      createdAt: Date
      updatedAt: Date
      distributionCoef: number | null
      sumWithRevaluation: Prisma.Decimal | null
      weightToDistribute: number | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly productId: FieldRef<"OrderItem", 'Int'>
    readonly quantity: FieldRef<"OrderItem", 'Float'>
    readonly price: FieldRef<"OrderItem", 'Decimal'>
    readonly amount: FieldRef<"OrderItem", 'Decimal'>
    readonly shippedQty: FieldRef<"OrderItem", 'Float'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly distributionCoef: FieldRef<"OrderItem", 'Float'>
    readonly sumWithRevaluation: FieldRef<"OrderItem", 'Decimal'>
    readonly weightToDistribute: FieldRef<"OrderItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Expeditor
   */

  export type AggregateExpeditor = {
    _count: ExpeditorCountAggregateOutputType | null
    _avg: ExpeditorAvgAggregateOutputType | null
    _sum: ExpeditorSumAggregateOutputType | null
    _min: ExpeditorMinAggregateOutputType | null
    _max: ExpeditorMaxAggregateOutputType | null
  }

  export type ExpeditorAvgAggregateOutputType = {
    id: number | null
  }

  export type ExpeditorSumAggregateOutputType = {
    id: number | null
  }

  export type ExpeditorMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpeditorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpeditorCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpeditorAvgAggregateInputType = {
    id?: true
  }

  export type ExpeditorSumAggregateInputType = {
    id?: true
  }

  export type ExpeditorMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpeditorMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpeditorCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpeditorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expeditor to aggregate.
     */
    where?: ExpeditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expeditors to fetch.
     */
    orderBy?: ExpeditorOrderByWithRelationInput | ExpeditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpeditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expeditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expeditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expeditors
    **/
    _count?: true | ExpeditorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpeditorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpeditorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpeditorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpeditorMaxAggregateInputType
  }

  export type GetExpeditorAggregateType<T extends ExpeditorAggregateArgs> = {
        [P in keyof T & keyof AggregateExpeditor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpeditor[P]>
      : GetScalarType<T[P], AggregateExpeditor[P]>
  }




  export type ExpeditorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpeditorWhereInput
    orderBy?: ExpeditorOrderByWithAggregationInput | ExpeditorOrderByWithAggregationInput[]
    by: ExpeditorScalarFieldEnum[] | ExpeditorScalarFieldEnum
    having?: ExpeditorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpeditorCountAggregateInputType | true
    _avg?: ExpeditorAvgAggregateInputType
    _sum?: ExpeditorSumAggregateInputType
    _min?: ExpeditorMinAggregateInputType
    _max?: ExpeditorMaxAggregateInputType
  }

  export type ExpeditorGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExpeditorCountAggregateOutputType | null
    _avg: ExpeditorAvgAggregateOutputType | null
    _sum: ExpeditorSumAggregateOutputType | null
    _min: ExpeditorMinAggregateOutputType | null
    _max: ExpeditorMaxAggregateOutputType | null
  }

  type GetExpeditorGroupByPayload<T extends ExpeditorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpeditorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpeditorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpeditorGroupByOutputType[P]>
            : GetScalarType<T[P], ExpeditorGroupByOutputType[P]>
        }
      >
    >


  export type ExpeditorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | Expeditor$ordersArgs<ExtArgs>
    _count?: boolean | ExpeditorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expeditor"]>

  export type ExpeditorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expeditor"]>

  export type ExpeditorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expeditor"]>

  export type ExpeditorSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpeditorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["expeditor"]>
  export type ExpeditorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Expeditor$ordersArgs<ExtArgs>
    _count?: boolean | ExpeditorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpeditorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ExpeditorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExpeditorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expeditor"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expeditor"]>
    composites: {}
  }

  type ExpeditorGetPayload<S extends boolean | null | undefined | ExpeditorDefaultArgs> = $Result.GetResult<Prisma.$ExpeditorPayload, S>

  type ExpeditorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpeditorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpeditorCountAggregateInputType | true
    }

  export interface ExpeditorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expeditor'], meta: { name: 'Expeditor' } }
    /**
     * Find zero or one Expeditor that matches the filter.
     * @param {ExpeditorFindUniqueArgs} args - Arguments to find a Expeditor
     * @example
     * // Get one Expeditor
     * const expeditor = await prisma.expeditor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpeditorFindUniqueArgs>(args: SelectSubset<T, ExpeditorFindUniqueArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expeditor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpeditorFindUniqueOrThrowArgs} args - Arguments to find a Expeditor
     * @example
     * // Get one Expeditor
     * const expeditor = await prisma.expeditor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpeditorFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpeditorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expeditor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorFindFirstArgs} args - Arguments to find a Expeditor
     * @example
     * // Get one Expeditor
     * const expeditor = await prisma.expeditor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpeditorFindFirstArgs>(args?: SelectSubset<T, ExpeditorFindFirstArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expeditor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorFindFirstOrThrowArgs} args - Arguments to find a Expeditor
     * @example
     * // Get one Expeditor
     * const expeditor = await prisma.expeditor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpeditorFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpeditorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expeditors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expeditors
     * const expeditors = await prisma.expeditor.findMany()
     * 
     * // Get first 10 Expeditors
     * const expeditors = await prisma.expeditor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expeditorWithIdOnly = await prisma.expeditor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpeditorFindManyArgs>(args?: SelectSubset<T, ExpeditorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expeditor.
     * @param {ExpeditorCreateArgs} args - Arguments to create a Expeditor.
     * @example
     * // Create one Expeditor
     * const Expeditor = await prisma.expeditor.create({
     *   data: {
     *     // ... data to create a Expeditor
     *   }
     * })
     * 
     */
    create<T extends ExpeditorCreateArgs>(args: SelectSubset<T, ExpeditorCreateArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expeditors.
     * @param {ExpeditorCreateManyArgs} args - Arguments to create many Expeditors.
     * @example
     * // Create many Expeditors
     * const expeditor = await prisma.expeditor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpeditorCreateManyArgs>(args?: SelectSubset<T, ExpeditorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expeditors and returns the data saved in the database.
     * @param {ExpeditorCreateManyAndReturnArgs} args - Arguments to create many Expeditors.
     * @example
     * // Create many Expeditors
     * const expeditor = await prisma.expeditor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expeditors and only return the `id`
     * const expeditorWithIdOnly = await prisma.expeditor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpeditorCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpeditorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expeditor.
     * @param {ExpeditorDeleteArgs} args - Arguments to delete one Expeditor.
     * @example
     * // Delete one Expeditor
     * const Expeditor = await prisma.expeditor.delete({
     *   where: {
     *     // ... filter to delete one Expeditor
     *   }
     * })
     * 
     */
    delete<T extends ExpeditorDeleteArgs>(args: SelectSubset<T, ExpeditorDeleteArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expeditor.
     * @param {ExpeditorUpdateArgs} args - Arguments to update one Expeditor.
     * @example
     * // Update one Expeditor
     * const expeditor = await prisma.expeditor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpeditorUpdateArgs>(args: SelectSubset<T, ExpeditorUpdateArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expeditors.
     * @param {ExpeditorDeleteManyArgs} args - Arguments to filter Expeditors to delete.
     * @example
     * // Delete a few Expeditors
     * const { count } = await prisma.expeditor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpeditorDeleteManyArgs>(args?: SelectSubset<T, ExpeditorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expeditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expeditors
     * const expeditor = await prisma.expeditor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpeditorUpdateManyArgs>(args: SelectSubset<T, ExpeditorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expeditors and returns the data updated in the database.
     * @param {ExpeditorUpdateManyAndReturnArgs} args - Arguments to update many Expeditors.
     * @example
     * // Update many Expeditors
     * const expeditor = await prisma.expeditor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expeditors and only return the `id`
     * const expeditorWithIdOnly = await prisma.expeditor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpeditorUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpeditorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expeditor.
     * @param {ExpeditorUpsertArgs} args - Arguments to update or create a Expeditor.
     * @example
     * // Update or create a Expeditor
     * const expeditor = await prisma.expeditor.upsert({
     *   create: {
     *     // ... data to create a Expeditor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expeditor we want to update
     *   }
     * })
     */
    upsert<T extends ExpeditorUpsertArgs>(args: SelectSubset<T, ExpeditorUpsertArgs<ExtArgs>>): Prisma__ExpeditorClient<$Result.GetResult<Prisma.$ExpeditorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expeditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorCountArgs} args - Arguments to filter Expeditors to count.
     * @example
     * // Count the number of Expeditors
     * const count = await prisma.expeditor.count({
     *   where: {
     *     // ... the filter for the Expeditors we want to count
     *   }
     * })
    **/
    count<T extends ExpeditorCountArgs>(
      args?: Subset<T, ExpeditorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpeditorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expeditor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpeditorAggregateArgs>(args: Subset<T, ExpeditorAggregateArgs>): Prisma.PrismaPromise<GetExpeditorAggregateType<T>>

    /**
     * Group by Expeditor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpeditorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpeditorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpeditorGroupByArgs['orderBy'] }
        : { orderBy?: ExpeditorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpeditorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpeditorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expeditor model
   */
  readonly fields: ExpeditorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expeditor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpeditorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends Expeditor$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Expeditor$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expeditor model
   */
  interface ExpeditorFieldRefs {
    readonly id: FieldRef<"Expeditor", 'Int'>
    readonly name: FieldRef<"Expeditor", 'String'>
    readonly phone: FieldRef<"Expeditor", 'String'>
    readonly isActive: FieldRef<"Expeditor", 'Boolean'>
    readonly createdAt: FieldRef<"Expeditor", 'DateTime'>
    readonly updatedAt: FieldRef<"Expeditor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expeditor findUnique
   */
  export type ExpeditorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter, which Expeditor to fetch.
     */
    where: ExpeditorWhereUniqueInput
  }

  /**
   * Expeditor findUniqueOrThrow
   */
  export type ExpeditorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter, which Expeditor to fetch.
     */
    where: ExpeditorWhereUniqueInput
  }

  /**
   * Expeditor findFirst
   */
  export type ExpeditorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter, which Expeditor to fetch.
     */
    where?: ExpeditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expeditors to fetch.
     */
    orderBy?: ExpeditorOrderByWithRelationInput | ExpeditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expeditors.
     */
    cursor?: ExpeditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expeditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expeditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expeditors.
     */
    distinct?: ExpeditorScalarFieldEnum | ExpeditorScalarFieldEnum[]
  }

  /**
   * Expeditor findFirstOrThrow
   */
  export type ExpeditorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter, which Expeditor to fetch.
     */
    where?: ExpeditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expeditors to fetch.
     */
    orderBy?: ExpeditorOrderByWithRelationInput | ExpeditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expeditors.
     */
    cursor?: ExpeditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expeditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expeditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expeditors.
     */
    distinct?: ExpeditorScalarFieldEnum | ExpeditorScalarFieldEnum[]
  }

  /**
   * Expeditor findMany
   */
  export type ExpeditorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter, which Expeditors to fetch.
     */
    where?: ExpeditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expeditors to fetch.
     */
    orderBy?: ExpeditorOrderByWithRelationInput | ExpeditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expeditors.
     */
    cursor?: ExpeditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expeditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expeditors.
     */
    skip?: number
    distinct?: ExpeditorScalarFieldEnum | ExpeditorScalarFieldEnum[]
  }

  /**
   * Expeditor create
   */
  export type ExpeditorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * The data needed to create a Expeditor.
     */
    data: XOR<ExpeditorCreateInput, ExpeditorUncheckedCreateInput>
  }

  /**
   * Expeditor createMany
   */
  export type ExpeditorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expeditors.
     */
    data: ExpeditorCreateManyInput | ExpeditorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expeditor createManyAndReturn
   */
  export type ExpeditorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * The data used to create many Expeditors.
     */
    data: ExpeditorCreateManyInput | ExpeditorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expeditor update
   */
  export type ExpeditorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * The data needed to update a Expeditor.
     */
    data: XOR<ExpeditorUpdateInput, ExpeditorUncheckedUpdateInput>
    /**
     * Choose, which Expeditor to update.
     */
    where: ExpeditorWhereUniqueInput
  }

  /**
   * Expeditor updateMany
   */
  export type ExpeditorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expeditors.
     */
    data: XOR<ExpeditorUpdateManyMutationInput, ExpeditorUncheckedUpdateManyInput>
    /**
     * Filter which Expeditors to update
     */
    where?: ExpeditorWhereInput
    /**
     * Limit how many Expeditors to update.
     */
    limit?: number
  }

  /**
   * Expeditor updateManyAndReturn
   */
  export type ExpeditorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * The data used to update Expeditors.
     */
    data: XOR<ExpeditorUpdateManyMutationInput, ExpeditorUncheckedUpdateManyInput>
    /**
     * Filter which Expeditors to update
     */
    where?: ExpeditorWhereInput
    /**
     * Limit how many Expeditors to update.
     */
    limit?: number
  }

  /**
   * Expeditor upsert
   */
  export type ExpeditorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * The filter to search for the Expeditor to update in case it exists.
     */
    where: ExpeditorWhereUniqueInput
    /**
     * In case the Expeditor found by the `where` argument doesn't exist, create a new Expeditor with this data.
     */
    create: XOR<ExpeditorCreateInput, ExpeditorUncheckedCreateInput>
    /**
     * In case the Expeditor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpeditorUpdateInput, ExpeditorUncheckedUpdateInput>
  }

  /**
   * Expeditor delete
   */
  export type ExpeditorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
    /**
     * Filter which Expeditor to delete.
     */
    where: ExpeditorWhereUniqueInput
  }

  /**
   * Expeditor deleteMany
   */
  export type ExpeditorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expeditors to delete
     */
    where?: ExpeditorWhereInput
    /**
     * Limit how many Expeditors to delete.
     */
    limit?: number
  }

  /**
   * Expeditor.orders
   */
  export type Expeditor$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Expeditor without action
   */
  export type ExpeditorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expeditor
     */
    select?: ExpeditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expeditor
     */
    omit?: ExpeditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpeditorInclude<ExtArgs> | null
  }


  /**
   * Model Stock
   */

  export type AggregateStock = {
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  export type StockAvgAggregateOutputType = {
    productId: number | null
    quantity: number | null
  }

  export type StockSumAggregateOutputType = {
    productId: number | null
    quantity: number | null
  }

  export type StockMinAggregateOutputType = {
    productId: number | null
    quantity: number | null
    updatedAt: Date | null
  }

  export type StockMaxAggregateOutputType = {
    productId: number | null
    quantity: number | null
    updatedAt: Date | null
  }

  export type StockCountAggregateOutputType = {
    productId: number
    quantity: number
    updatedAt: number
    _all: number
  }


  export type StockAvgAggregateInputType = {
    productId?: true
    quantity?: true
  }

  export type StockSumAggregateInputType = {
    productId?: true
    quantity?: true
  }

  export type StockMinAggregateInputType = {
    productId?: true
    quantity?: true
    updatedAt?: true
  }

  export type StockMaxAggregateInputType = {
    productId?: true
    quantity?: true
    updatedAt?: true
  }

  export type StockCountAggregateInputType = {
    productId?: true
    quantity?: true
    updatedAt?: true
    _all?: true
  }

  export type StockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stock to aggregate.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMaxAggregateInputType
  }

  export type GetStockAggregateType<T extends StockAggregateArgs> = {
        [P in keyof T & keyof AggregateStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock[P]>
      : GetScalarType<T[P], AggregateStock[P]>
  }




  export type StockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
    orderBy?: StockOrderByWithAggregationInput | StockOrderByWithAggregationInput[]
    by: StockScalarFieldEnum[] | StockScalarFieldEnum
    having?: StockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCountAggregateInputType | true
    _avg?: StockAvgAggregateInputType
    _sum?: StockSumAggregateInputType
    _min?: StockMinAggregateInputType
    _max?: StockMaxAggregateInputType
  }

  export type StockGroupByOutputType = {
    productId: number
    quantity: number
    updatedAt: Date
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  type GetStockGroupByPayload<T extends StockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockGroupByOutputType[P]>
            : GetScalarType<T[P], StockGroupByOutputType[P]>
        }
      >
    >


  export type StockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectScalar = {
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
  }

  export type StockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"productId" | "quantity" | "updatedAt", ExtArgs["result"]["stock"]>
  export type StockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $StockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stock"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      productId: number
      quantity: number
      updatedAt: Date
    }, ExtArgs["result"]["stock"]>
    composites: {}
  }

  type StockGetPayload<S extends boolean | null | undefined | StockDefaultArgs> = $Result.GetResult<Prisma.$StockPayload, S>

  type StockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockCountAggregateInputType | true
    }

  export interface StockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stock'], meta: { name: 'Stock' } }
    /**
     * Find zero or one Stock that matches the filter.
     * @param {StockFindUniqueArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockFindUniqueArgs>(args: SelectSubset<T, StockFindUniqueArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockFindUniqueOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockFindUniqueOrThrowArgs>(args: SelectSubset<T, StockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockFindFirstArgs>(args?: SelectSubset<T, StockFindFirstArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockFindFirstOrThrowArgs>(args?: SelectSubset<T, StockFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stock.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stock.findMany({ take: 10 })
     * 
     * // Only select the `productId`
     * const stockWithProductIdOnly = await prisma.stock.findMany({ select: { productId: true } })
     * 
     */
    findMany<T extends StockFindManyArgs>(args?: SelectSubset<T, StockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stock.
     * @param {StockCreateArgs} args - Arguments to create a Stock.
     * @example
     * // Create one Stock
     * const Stock = await prisma.stock.create({
     *   data: {
     *     // ... data to create a Stock
     *   }
     * })
     * 
     */
    create<T extends StockCreateArgs>(args: SelectSubset<T, StockCreateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stocks.
     * @param {StockCreateManyArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockCreateManyArgs>(args?: SelectSubset<T, StockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stocks and returns the data saved in the database.
     * @param {StockCreateManyAndReturnArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stocks and only return the `productId`
     * const stockWithProductIdOnly = await prisma.stock.createManyAndReturn({
     *   select: { productId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockCreateManyAndReturnArgs>(args?: SelectSubset<T, StockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stock.
     * @param {StockDeleteArgs} args - Arguments to delete one Stock.
     * @example
     * // Delete one Stock
     * const Stock = await prisma.stock.delete({
     *   where: {
     *     // ... filter to delete one Stock
     *   }
     * })
     * 
     */
    delete<T extends StockDeleteArgs>(args: SelectSubset<T, StockDeleteArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stock.
     * @param {StockUpdateArgs} args - Arguments to update one Stock.
     * @example
     * // Update one Stock
     * const stock = await prisma.stock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockUpdateArgs>(args: SelectSubset<T, StockUpdateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stocks.
     * @param {StockDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockDeleteManyArgs>(args?: SelectSubset<T, StockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockUpdateManyArgs>(args: SelectSubset<T, StockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks and returns the data updated in the database.
     * @param {StockUpdateManyAndReturnArgs} args - Arguments to update many Stocks.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stocks and only return the `productId`
     * const stockWithProductIdOnly = await prisma.stock.updateManyAndReturn({
     *   select: { productId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockUpdateManyAndReturnArgs>(args: SelectSubset<T, StockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stock.
     * @param {StockUpsertArgs} args - Arguments to update or create a Stock.
     * @example
     * // Update or create a Stock
     * const stock = await prisma.stock.upsert({
     *   create: {
     *     // ... data to create a Stock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock we want to update
     *   }
     * })
     */
    upsert<T extends StockUpsertArgs>(args: SelectSubset<T, StockUpsertArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stock.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StockCountArgs>(
      args?: Subset<T, StockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAggregateArgs>(args: Subset<T, StockAggregateArgs>): Prisma.PrismaPromise<GetStockAggregateType<T>>

    /**
     * Group by Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockGroupByArgs['orderBy'] }
        : { orderBy?: StockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stock model
   */
  readonly fields: StockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stock model
   */
  interface StockFieldRefs {
    readonly productId: FieldRef<"Stock", 'Int'>
    readonly quantity: FieldRef<"Stock", 'Float'>
    readonly updatedAt: FieldRef<"Stock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stock findUnique
   */
  export type StockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findUniqueOrThrow
   */
  export type StockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findFirst
   */
  export type StockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findFirstOrThrow
   */
  export type StockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findMany
   */
  export type StockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock create
   */
  export type StockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to create a Stock.
     */
    data: XOR<StockCreateInput, StockUncheckedCreateInput>
  }

  /**
   * Stock createMany
   */
  export type StockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stock createManyAndReturn
   */
  export type StockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stock update
   */
  export type StockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to update a Stock.
     */
    data: XOR<StockUpdateInput, StockUncheckedUpdateInput>
    /**
     * Choose, which Stock to update.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock updateMany
   */
  export type StockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
  }

  /**
   * Stock updateManyAndReturn
   */
  export type StockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stock upsert
   */
  export type StockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The filter to search for the Stock to update in case it exists.
     */
    where: StockWhereUniqueInput
    /**
     * In case the Stock found by the `where` argument doesn't exist, create a new Stock with this data.
     */
    create: XOR<StockCreateInput, StockUncheckedCreateInput>
    /**
     * In case the Stock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockUpdateInput, StockUncheckedUpdateInput>
  }

  /**
   * Stock delete
   */
  export type StockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter which Stock to delete.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock deleteMany
   */
  export type StockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to delete
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to delete.
     */
    limit?: number
  }

  /**
   * Stock without action
   */
  export type StockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
  }


  /**
   * Model StockTransaction
   */

  export type AggregateStockTransaction = {
    _count: StockTransactionCountAggregateOutputType | null
    _avg: StockTransactionAvgAggregateOutputType | null
    _sum: StockTransactionSumAggregateOutputType | null
    _min: StockTransactionMinAggregateOutputType | null
    _max: StockTransactionMaxAggregateOutputType | null
  }

  export type StockTransactionAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    orderId: number | null
  }

  export type StockTransactionSumAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    orderId: number | null
  }

  export type StockTransactionMinAggregateOutputType = {
    id: number | null
    productId: number | null
    type: string | null
    quantity: number | null
    orderId: number | null
    note: string | null
    createdAt: Date | null
  }

  export type StockTransactionMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    type: string | null
    quantity: number | null
    orderId: number | null
    note: string | null
    createdAt: Date | null
  }

  export type StockTransactionCountAggregateOutputType = {
    id: number
    productId: number
    type: number
    quantity: number
    orderId: number
    note: number
    createdAt: number
    _all: number
  }


  export type StockTransactionAvgAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    orderId?: true
  }

  export type StockTransactionSumAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    orderId?: true
  }

  export type StockTransactionMinAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    quantity?: true
    orderId?: true
    note?: true
    createdAt?: true
  }

  export type StockTransactionMaxAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    quantity?: true
    orderId?: true
    note?: true
    createdAt?: true
  }

  export type StockTransactionCountAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    quantity?: true
    orderId?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type StockTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransaction to aggregate.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockTransactions
    **/
    _count?: true | StockTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockTransactionMaxAggregateInputType
  }

  export type GetStockTransactionAggregateType<T extends StockTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateStockTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockTransaction[P]>
      : GetScalarType<T[P], AggregateStockTransaction[P]>
  }




  export type StockTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransactionWhereInput
    orderBy?: StockTransactionOrderByWithAggregationInput | StockTransactionOrderByWithAggregationInput[]
    by: StockTransactionScalarFieldEnum[] | StockTransactionScalarFieldEnum
    having?: StockTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockTransactionCountAggregateInputType | true
    _avg?: StockTransactionAvgAggregateInputType
    _sum?: StockTransactionSumAggregateInputType
    _min?: StockTransactionMinAggregateInputType
    _max?: StockTransactionMaxAggregateInputType
  }

  export type StockTransactionGroupByOutputType = {
    id: number
    productId: number
    type: string
    quantity: number
    orderId: number | null
    note: string | null
    createdAt: Date
    _count: StockTransactionCountAggregateOutputType | null
    _avg: StockTransactionAvgAggregateOutputType | null
    _sum: StockTransactionSumAggregateOutputType | null
    _min: StockTransactionMinAggregateOutputType | null
    _max: StockTransactionMaxAggregateOutputType | null
  }

  type GetStockTransactionGroupByPayload<T extends StockTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], StockTransactionGroupByOutputType[P]>
        }
      >
    >


  export type StockTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransaction"]>

  export type StockTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransaction"]>

  export type StockTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransaction"]>

  export type StockTransactionSelectScalar = {
    id?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type StockTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "type" | "quantity" | "orderId" | "note" | "createdAt", ExtArgs["result"]["stockTransaction"]>
  export type StockTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | StockTransaction$orderArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $StockTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockTransaction"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      type: string
      quantity: number
      orderId: number | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["stockTransaction"]>
    composites: {}
  }

  type StockTransactionGetPayload<S extends boolean | null | undefined | StockTransactionDefaultArgs> = $Result.GetResult<Prisma.$StockTransactionPayload, S>

  type StockTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockTransactionCountAggregateInputType | true
    }

  export interface StockTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockTransaction'], meta: { name: 'StockTransaction' } }
    /**
     * Find zero or one StockTransaction that matches the filter.
     * @param {StockTransactionFindUniqueArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockTransactionFindUniqueArgs>(args: SelectSubset<T, StockTransactionFindUniqueArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockTransactionFindUniqueOrThrowArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, StockTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionFindFirstArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockTransactionFindFirstArgs>(args?: SelectSubset<T, StockTransactionFindFirstArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionFindFirstOrThrowArgs} args - Arguments to find a StockTransaction
     * @example
     * // Get one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, StockTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockTransactions
     * const stockTransactions = await prisma.stockTransaction.findMany()
     * 
     * // Get first 10 StockTransactions
     * const stockTransactions = await prisma.stockTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockTransactionWithIdOnly = await prisma.stockTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockTransactionFindManyArgs>(args?: SelectSubset<T, StockTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockTransaction.
     * @param {StockTransactionCreateArgs} args - Arguments to create a StockTransaction.
     * @example
     * // Create one StockTransaction
     * const StockTransaction = await prisma.stockTransaction.create({
     *   data: {
     *     // ... data to create a StockTransaction
     *   }
     * })
     * 
     */
    create<T extends StockTransactionCreateArgs>(args: SelectSubset<T, StockTransactionCreateArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockTransactions.
     * @param {StockTransactionCreateManyArgs} args - Arguments to create many StockTransactions.
     * @example
     * // Create many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockTransactionCreateManyArgs>(args?: SelectSubset<T, StockTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockTransactions and returns the data saved in the database.
     * @param {StockTransactionCreateManyAndReturnArgs} args - Arguments to create many StockTransactions.
     * @example
     * // Create many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockTransactions and only return the `id`
     * const stockTransactionWithIdOnly = await prisma.stockTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, StockTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockTransaction.
     * @param {StockTransactionDeleteArgs} args - Arguments to delete one StockTransaction.
     * @example
     * // Delete one StockTransaction
     * const StockTransaction = await prisma.stockTransaction.delete({
     *   where: {
     *     // ... filter to delete one StockTransaction
     *   }
     * })
     * 
     */
    delete<T extends StockTransactionDeleteArgs>(args: SelectSubset<T, StockTransactionDeleteArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockTransaction.
     * @param {StockTransactionUpdateArgs} args - Arguments to update one StockTransaction.
     * @example
     * // Update one StockTransaction
     * const stockTransaction = await prisma.stockTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockTransactionUpdateArgs>(args: SelectSubset<T, StockTransactionUpdateArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockTransactions.
     * @param {StockTransactionDeleteManyArgs} args - Arguments to filter StockTransactions to delete.
     * @example
     * // Delete a few StockTransactions
     * const { count } = await prisma.stockTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockTransactionDeleteManyArgs>(args?: SelectSubset<T, StockTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockTransactionUpdateManyArgs>(args: SelectSubset<T, StockTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransactions and returns the data updated in the database.
     * @param {StockTransactionUpdateManyAndReturnArgs} args - Arguments to update many StockTransactions.
     * @example
     * // Update many StockTransactions
     * const stockTransaction = await prisma.stockTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockTransactions and only return the `id`
     * const stockTransactionWithIdOnly = await prisma.stockTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, StockTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockTransaction.
     * @param {StockTransactionUpsertArgs} args - Arguments to update or create a StockTransaction.
     * @example
     * // Update or create a StockTransaction
     * const stockTransaction = await prisma.stockTransaction.upsert({
     *   create: {
     *     // ... data to create a StockTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockTransaction we want to update
     *   }
     * })
     */
    upsert<T extends StockTransactionUpsertArgs>(args: SelectSubset<T, StockTransactionUpsertArgs<ExtArgs>>): Prisma__StockTransactionClient<$Result.GetResult<Prisma.$StockTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionCountArgs} args - Arguments to filter StockTransactions to count.
     * @example
     * // Count the number of StockTransactions
     * const count = await prisma.stockTransaction.count({
     *   where: {
     *     // ... the filter for the StockTransactions we want to count
     *   }
     * })
    **/
    count<T extends StockTransactionCountArgs>(
      args?: Subset<T, StockTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockTransactionAggregateArgs>(args: Subset<T, StockTransactionAggregateArgs>): Prisma.PrismaPromise<GetStockTransactionAggregateType<T>>

    /**
     * Group by StockTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockTransactionGroupByArgs['orderBy'] }
        : { orderBy?: StockTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockTransaction model
   */
  readonly fields: StockTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends StockTransaction$orderArgs<ExtArgs> = {}>(args?: Subset<T, StockTransaction$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockTransaction model
   */
  interface StockTransactionFieldRefs {
    readonly id: FieldRef<"StockTransaction", 'Int'>
    readonly productId: FieldRef<"StockTransaction", 'Int'>
    readonly type: FieldRef<"StockTransaction", 'String'>
    readonly quantity: FieldRef<"StockTransaction", 'Float'>
    readonly orderId: FieldRef<"StockTransaction", 'Int'>
    readonly note: FieldRef<"StockTransaction", 'String'>
    readonly createdAt: FieldRef<"StockTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockTransaction findUnique
   */
  export type StockTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction findUniqueOrThrow
   */
  export type StockTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction findFirst
   */
  export type StockTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransactions.
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransactions.
     */
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * StockTransaction findFirstOrThrow
   */
  export type StockTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransaction to fetch.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransactions.
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransactions.
     */
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * StockTransaction findMany
   */
  export type StockTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StockTransactions to fetch.
     */
    where?: StockTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransactions to fetch.
     */
    orderBy?: StockTransactionOrderByWithRelationInput | StockTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockTransactions.
     */
    cursor?: StockTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransactions.
     */
    skip?: number
    distinct?: StockTransactionScalarFieldEnum | StockTransactionScalarFieldEnum[]
  }

  /**
   * StockTransaction create
   */
  export type StockTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a StockTransaction.
     */
    data: XOR<StockTransactionCreateInput, StockTransactionUncheckedCreateInput>
  }

  /**
   * StockTransaction createMany
   */
  export type StockTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockTransactions.
     */
    data: StockTransactionCreateManyInput | StockTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockTransaction createManyAndReturn
   */
  export type StockTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many StockTransactions.
     */
    data: StockTransactionCreateManyInput | StockTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransaction update
   */
  export type StockTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a StockTransaction.
     */
    data: XOR<StockTransactionUpdateInput, StockTransactionUncheckedUpdateInput>
    /**
     * Choose, which StockTransaction to update.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction updateMany
   */
  export type StockTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockTransactions.
     */
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyInput>
    /**
     * Filter which StockTransactions to update
     */
    where?: StockTransactionWhereInput
    /**
     * Limit how many StockTransactions to update.
     */
    limit?: number
  }

  /**
   * StockTransaction updateManyAndReturn
   */
  export type StockTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * The data used to update StockTransactions.
     */
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyInput>
    /**
     * Filter which StockTransactions to update
     */
    where?: StockTransactionWhereInput
    /**
     * Limit how many StockTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransaction upsert
   */
  export type StockTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the StockTransaction to update in case it exists.
     */
    where: StockTransactionWhereUniqueInput
    /**
     * In case the StockTransaction found by the `where` argument doesn't exist, create a new StockTransaction with this data.
     */
    create: XOR<StockTransactionCreateInput, StockTransactionUncheckedCreateInput>
    /**
     * In case the StockTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockTransactionUpdateInput, StockTransactionUncheckedUpdateInput>
  }

  /**
   * StockTransaction delete
   */
  export type StockTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
    /**
     * Filter which StockTransaction to delete.
     */
    where: StockTransactionWhereUniqueInput
  }

  /**
   * StockTransaction deleteMany
   */
  export type StockTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransactions to delete
     */
    where?: StockTransactionWhereInput
    /**
     * Limit how many StockTransactions to delete.
     */
    limit?: number
  }

  /**
   * StockTransaction.order
   */
  export type StockTransaction$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * StockTransaction without action
   */
  export type StockTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransaction
     */
    select?: StockTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransaction
     */
    omit?: StockTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransactionInclude<ExtArgs> | null
  }


  /**
   * Model SummaryOrderJournal
   */

  export type AggregateSummaryOrderJournal = {
    _count: SummaryOrderJournalCountAggregateOutputType | null
    _avg: SummaryOrderJournalAvgAggregateOutputType | null
    _sum: SummaryOrderJournalSumAggregateOutputType | null
    _min: SummaryOrderJournalMinAggregateOutputType | null
    _max: SummaryOrderJournalMaxAggregateOutputType | null
  }

  export type SummaryOrderJournalAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    productId: number | null
    price: Decimal | null
    shippedQty: number | null
    orderQty: number | null
    sumWithRevaluation: Decimal | null
    distributionCoef: number | null
    weightToDistribute: number | null
  }

  export type SummaryOrderJournalSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    productId: number | null
    price: Decimal | null
    shippedQty: number | null
    orderQty: number | null
    sumWithRevaluation: Decimal | null
    distributionCoef: number | null
    weightToDistribute: number | null
  }

  export type SummaryOrderJournalMinAggregateOutputType = {
    id: number | null
    idn: string | null
    shipDate: Date | null
    paymentType: string | null
    customerId: number | null
    customerName: string | null
    productId: number | null
    productCode: string | null
    productFullName: string | null
    category: string | null
    shortNameMorning: string | null
    priceType: string | null
    price: Decimal | null
    shippedQty: number | null
    orderQty: number | null
    sumWithRevaluation: Decimal | null
    distributionCoef: number | null
    weightToDistribute: number | null
    managerId: string | null
    managerName: string | null
    district: string | null
    pointAddress: string | null
    status: string | null
    preAssemblyStatus: string | null
    assemblyStartedAt: Date | null
    assemblyStartedBy: string | null
    assemblyReturnedAt: Date | null
    assemblyReturnedBy: string | null
    assemblyReturnReason: string | null
    assemblyReturnComment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SummaryOrderJournalMaxAggregateOutputType = {
    id: number | null
    idn: string | null
    shipDate: Date | null
    paymentType: string | null
    customerId: number | null
    customerName: string | null
    productId: number | null
    productCode: string | null
    productFullName: string | null
    category: string | null
    shortNameMorning: string | null
    priceType: string | null
    price: Decimal | null
    shippedQty: number | null
    orderQty: number | null
    sumWithRevaluation: Decimal | null
    distributionCoef: number | null
    weightToDistribute: number | null
    managerId: string | null
    managerName: string | null
    district: string | null
    pointAddress: string | null
    status: string | null
    preAssemblyStatus: string | null
    assemblyStartedAt: Date | null
    assemblyStartedBy: string | null
    assemblyReturnedAt: Date | null
    assemblyReturnedBy: string | null
    assemblyReturnReason: string | null
    assemblyReturnComment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SummaryOrderJournalCountAggregateOutputType = {
    id: number
    idn: number
    shipDate: number
    paymentType: number
    customerId: number
    customerName: number
    productId: number
    productCode: number
    productFullName: number
    category: number
    shortNameMorning: number
    priceType: number
    price: number
    shippedQty: number
    orderQty: number
    sumWithRevaluation: number
    distributionCoef: number
    weightToDistribute: number
    managerId: number
    managerName: number
    district: number
    pointAddress: number
    status: number
    preAssemblyStatus: number
    assemblyStartedAt: number
    assemblyStartedBy: number
    assemblyReturnedAt: number
    assemblyReturnedBy: number
    assemblyReturnReason: number
    assemblyReturnComment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SummaryOrderJournalAvgAggregateInputType = {
    id?: true
    customerId?: true
    productId?: true
    price?: true
    shippedQty?: true
    orderQty?: true
    sumWithRevaluation?: true
    distributionCoef?: true
    weightToDistribute?: true
  }

  export type SummaryOrderJournalSumAggregateInputType = {
    id?: true
    customerId?: true
    productId?: true
    price?: true
    shippedQty?: true
    orderQty?: true
    sumWithRevaluation?: true
    distributionCoef?: true
    weightToDistribute?: true
  }

  export type SummaryOrderJournalMinAggregateInputType = {
    id?: true
    idn?: true
    shipDate?: true
    paymentType?: true
    customerId?: true
    customerName?: true
    productId?: true
    productCode?: true
    productFullName?: true
    category?: true
    shortNameMorning?: true
    priceType?: true
    price?: true
    shippedQty?: true
    orderQty?: true
    sumWithRevaluation?: true
    distributionCoef?: true
    weightToDistribute?: true
    managerId?: true
    managerName?: true
    district?: true
    pointAddress?: true
    status?: true
    preAssemblyStatus?: true
    assemblyStartedAt?: true
    assemblyStartedBy?: true
    assemblyReturnedAt?: true
    assemblyReturnedBy?: true
    assemblyReturnReason?: true
    assemblyReturnComment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SummaryOrderJournalMaxAggregateInputType = {
    id?: true
    idn?: true
    shipDate?: true
    paymentType?: true
    customerId?: true
    customerName?: true
    productId?: true
    productCode?: true
    productFullName?: true
    category?: true
    shortNameMorning?: true
    priceType?: true
    price?: true
    shippedQty?: true
    orderQty?: true
    sumWithRevaluation?: true
    distributionCoef?: true
    weightToDistribute?: true
    managerId?: true
    managerName?: true
    district?: true
    pointAddress?: true
    status?: true
    preAssemblyStatus?: true
    assemblyStartedAt?: true
    assemblyStartedBy?: true
    assemblyReturnedAt?: true
    assemblyReturnedBy?: true
    assemblyReturnReason?: true
    assemblyReturnComment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SummaryOrderJournalCountAggregateInputType = {
    id?: true
    idn?: true
    shipDate?: true
    paymentType?: true
    customerId?: true
    customerName?: true
    productId?: true
    productCode?: true
    productFullName?: true
    category?: true
    shortNameMorning?: true
    priceType?: true
    price?: true
    shippedQty?: true
    orderQty?: true
    sumWithRevaluation?: true
    distributionCoef?: true
    weightToDistribute?: true
    managerId?: true
    managerName?: true
    district?: true
    pointAddress?: true
    status?: true
    preAssemblyStatus?: true
    assemblyStartedAt?: true
    assemblyStartedBy?: true
    assemblyReturnedAt?: true
    assemblyReturnedBy?: true
    assemblyReturnReason?: true
    assemblyReturnComment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SummaryOrderJournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummaryOrderJournal to aggregate.
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderJournals to fetch.
     */
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SummaryOrderJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SummaryOrderJournals
    **/
    _count?: true | SummaryOrderJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SummaryOrderJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SummaryOrderJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SummaryOrderJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SummaryOrderJournalMaxAggregateInputType
  }

  export type GetSummaryOrderJournalAggregateType<T extends SummaryOrderJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateSummaryOrderJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSummaryOrderJournal[P]>
      : GetScalarType<T[P], AggregateSummaryOrderJournal[P]>
  }




  export type SummaryOrderJournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummaryOrderJournalWhereInput
    orderBy?: SummaryOrderJournalOrderByWithAggregationInput | SummaryOrderJournalOrderByWithAggregationInput[]
    by: SummaryOrderJournalScalarFieldEnum[] | SummaryOrderJournalScalarFieldEnum
    having?: SummaryOrderJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SummaryOrderJournalCountAggregateInputType | true
    _avg?: SummaryOrderJournalAvgAggregateInputType
    _sum?: SummaryOrderJournalSumAggregateInputType
    _min?: SummaryOrderJournalMinAggregateInputType
    _max?: SummaryOrderJournalMaxAggregateInputType
  }

  export type SummaryOrderJournalGroupByOutputType = {
    id: number
    idn: string
    shipDate: Date
    paymentType: string | null
    customerId: number | null
    customerName: string
    productId: number | null
    productCode: string | null
    productFullName: string
    category: string | null
    shortNameMorning: string | null
    priceType: string | null
    price: Decimal
    shippedQty: number
    orderQty: number
    sumWithRevaluation: Decimal | null
    distributionCoef: number | null
    weightToDistribute: number | null
    managerId: string | null
    managerName: string | null
    district: string | null
    pointAddress: string | null
    status: string
    preAssemblyStatus: string | null
    assemblyStartedAt: Date | null
    assemblyStartedBy: string | null
    assemblyReturnedAt: Date | null
    assemblyReturnedBy: string | null
    assemblyReturnReason: string | null
    assemblyReturnComment: string | null
    createdAt: Date
    updatedAt: Date
    _count: SummaryOrderJournalCountAggregateOutputType | null
    _avg: SummaryOrderJournalAvgAggregateOutputType | null
    _sum: SummaryOrderJournalSumAggregateOutputType | null
    _min: SummaryOrderJournalMinAggregateOutputType | null
    _max: SummaryOrderJournalMaxAggregateOutputType | null
  }

  type GetSummaryOrderJournalGroupByPayload<T extends SummaryOrderJournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SummaryOrderJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SummaryOrderJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SummaryOrderJournalGroupByOutputType[P]>
            : GetScalarType<T[P], SummaryOrderJournalGroupByOutputType[P]>
        }
      >
    >


  export type SummaryOrderJournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    shipDate?: boolean
    paymentType?: boolean
    customerId?: boolean
    customerName?: boolean
    productId?: boolean
    productCode?: boolean
    productFullName?: boolean
    category?: boolean
    shortNameMorning?: boolean
    priceType?: boolean
    price?: boolean
    shippedQty?: boolean
    orderQty?: boolean
    sumWithRevaluation?: boolean
    distributionCoef?: boolean
    weightToDistribute?: boolean
    managerId?: boolean
    managerName?: boolean
    district?: boolean
    pointAddress?: boolean
    status?: boolean
    preAssemblyStatus?: boolean
    assemblyStartedAt?: boolean
    assemblyStartedBy?: boolean
    assemblyReturnedAt?: boolean
    assemblyReturnedBy?: boolean
    assemblyReturnReason?: boolean
    assemblyReturnComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
    events?: boolean | SummaryOrderJournal$eventsArgs<ExtArgs>
    _count?: boolean | SummaryOrderJournalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["summaryOrderJournal"]>

  export type SummaryOrderJournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    shipDate?: boolean
    paymentType?: boolean
    customerId?: boolean
    customerName?: boolean
    productId?: boolean
    productCode?: boolean
    productFullName?: boolean
    category?: boolean
    shortNameMorning?: boolean
    priceType?: boolean
    price?: boolean
    shippedQty?: boolean
    orderQty?: boolean
    sumWithRevaluation?: boolean
    distributionCoef?: boolean
    weightToDistribute?: boolean
    managerId?: boolean
    managerName?: boolean
    district?: boolean
    pointAddress?: boolean
    status?: boolean
    preAssemblyStatus?: boolean
    assemblyStartedAt?: boolean
    assemblyStartedBy?: boolean
    assemblyReturnedAt?: boolean
    assemblyReturnedBy?: boolean
    assemblyReturnReason?: boolean
    assemblyReturnComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
  }, ExtArgs["result"]["summaryOrderJournal"]>

  export type SummaryOrderJournalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idn?: boolean
    shipDate?: boolean
    paymentType?: boolean
    customerId?: boolean
    customerName?: boolean
    productId?: boolean
    productCode?: boolean
    productFullName?: boolean
    category?: boolean
    shortNameMorning?: boolean
    priceType?: boolean
    price?: boolean
    shippedQty?: boolean
    orderQty?: boolean
    sumWithRevaluation?: boolean
    distributionCoef?: boolean
    weightToDistribute?: boolean
    managerId?: boolean
    managerName?: boolean
    district?: boolean
    pointAddress?: boolean
    status?: boolean
    preAssemblyStatus?: boolean
    assemblyStartedAt?: boolean
    assemblyStartedBy?: boolean
    assemblyReturnedAt?: boolean
    assemblyReturnedBy?: boolean
    assemblyReturnReason?: boolean
    assemblyReturnComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
  }, ExtArgs["result"]["summaryOrderJournal"]>

  export type SummaryOrderJournalSelectScalar = {
    id?: boolean
    idn?: boolean
    shipDate?: boolean
    paymentType?: boolean
    customerId?: boolean
    customerName?: boolean
    productId?: boolean
    productCode?: boolean
    productFullName?: boolean
    category?: boolean
    shortNameMorning?: boolean
    priceType?: boolean
    price?: boolean
    shippedQty?: boolean
    orderQty?: boolean
    sumWithRevaluation?: boolean
    distributionCoef?: boolean
    weightToDistribute?: boolean
    managerId?: boolean
    managerName?: boolean
    district?: boolean
    pointAddress?: boolean
    status?: boolean
    preAssemblyStatus?: boolean
    assemblyStartedAt?: boolean
    assemblyStartedBy?: boolean
    assemblyReturnedAt?: boolean
    assemblyReturnedBy?: boolean
    assemblyReturnReason?: boolean
    assemblyReturnComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SummaryOrderJournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idn" | "shipDate" | "paymentType" | "customerId" | "customerName" | "productId" | "productCode" | "productFullName" | "category" | "shortNameMorning" | "priceType" | "price" | "shippedQty" | "orderQty" | "sumWithRevaluation" | "distributionCoef" | "weightToDistribute" | "managerId" | "managerName" | "district" | "pointAddress" | "status" | "preAssemblyStatus" | "assemblyStartedAt" | "assemblyStartedBy" | "assemblyReturnedAt" | "assemblyReturnedBy" | "assemblyReturnReason" | "assemblyReturnComment" | "createdAt" | "updatedAt", ExtArgs["result"]["summaryOrderJournal"]>
  export type SummaryOrderJournalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
    events?: boolean | SummaryOrderJournal$eventsArgs<ExtArgs>
    _count?: boolean | SummaryOrderJournalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SummaryOrderJournalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
  }
  export type SummaryOrderJournalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SummaryOrderJournal$customerArgs<ExtArgs>
    product?: boolean | SummaryOrderJournal$productArgs<ExtArgs>
  }

  export type $SummaryOrderJournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SummaryOrderJournal"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
      events: Prisma.$SummaryOrderEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idn: string
      shipDate: Date
      paymentType: string | null
      customerId: number | null
      customerName: string
      productId: number | null
      productCode: string | null
      productFullName: string
      category: string | null
      shortNameMorning: string | null
      priceType: string | null
      price: Prisma.Decimal
      shippedQty: number
      orderQty: number
      sumWithRevaluation: Prisma.Decimal | null
      distributionCoef: number | null
      weightToDistribute: number | null
      managerId: string | null
      managerName: string | null
      district: string | null
      pointAddress: string | null
      status: string
      preAssemblyStatus: string | null
      assemblyStartedAt: Date | null
      assemblyStartedBy: string | null
      assemblyReturnedAt: Date | null
      assemblyReturnedBy: string | null
      assemblyReturnReason: string | null
      assemblyReturnComment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["summaryOrderJournal"]>
    composites: {}
  }

  type SummaryOrderJournalGetPayload<S extends boolean | null | undefined | SummaryOrderJournalDefaultArgs> = $Result.GetResult<Prisma.$SummaryOrderJournalPayload, S>

  type SummaryOrderJournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SummaryOrderJournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SummaryOrderJournalCountAggregateInputType | true
    }

  export interface SummaryOrderJournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SummaryOrderJournal'], meta: { name: 'SummaryOrderJournal' } }
    /**
     * Find zero or one SummaryOrderJournal that matches the filter.
     * @param {SummaryOrderJournalFindUniqueArgs} args - Arguments to find a SummaryOrderJournal
     * @example
     * // Get one SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SummaryOrderJournalFindUniqueArgs>(args: SelectSubset<T, SummaryOrderJournalFindUniqueArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SummaryOrderJournal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SummaryOrderJournalFindUniqueOrThrowArgs} args - Arguments to find a SummaryOrderJournal
     * @example
     * // Get one SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SummaryOrderJournalFindUniqueOrThrowArgs>(args: SelectSubset<T, SummaryOrderJournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummaryOrderJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalFindFirstArgs} args - Arguments to find a SummaryOrderJournal
     * @example
     * // Get one SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SummaryOrderJournalFindFirstArgs>(args?: SelectSubset<T, SummaryOrderJournalFindFirstArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummaryOrderJournal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalFindFirstOrThrowArgs} args - Arguments to find a SummaryOrderJournal
     * @example
     * // Get one SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SummaryOrderJournalFindFirstOrThrowArgs>(args?: SelectSubset<T, SummaryOrderJournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SummaryOrderJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SummaryOrderJournals
     * const summaryOrderJournals = await prisma.summaryOrderJournal.findMany()
     * 
     * // Get first 10 SummaryOrderJournals
     * const summaryOrderJournals = await prisma.summaryOrderJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const summaryOrderJournalWithIdOnly = await prisma.summaryOrderJournal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SummaryOrderJournalFindManyArgs>(args?: SelectSubset<T, SummaryOrderJournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SummaryOrderJournal.
     * @param {SummaryOrderJournalCreateArgs} args - Arguments to create a SummaryOrderJournal.
     * @example
     * // Create one SummaryOrderJournal
     * const SummaryOrderJournal = await prisma.summaryOrderJournal.create({
     *   data: {
     *     // ... data to create a SummaryOrderJournal
     *   }
     * })
     * 
     */
    create<T extends SummaryOrderJournalCreateArgs>(args: SelectSubset<T, SummaryOrderJournalCreateArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SummaryOrderJournals.
     * @param {SummaryOrderJournalCreateManyArgs} args - Arguments to create many SummaryOrderJournals.
     * @example
     * // Create many SummaryOrderJournals
     * const summaryOrderJournal = await prisma.summaryOrderJournal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SummaryOrderJournalCreateManyArgs>(args?: SelectSubset<T, SummaryOrderJournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SummaryOrderJournals and returns the data saved in the database.
     * @param {SummaryOrderJournalCreateManyAndReturnArgs} args - Arguments to create many SummaryOrderJournals.
     * @example
     * // Create many SummaryOrderJournals
     * const summaryOrderJournal = await prisma.summaryOrderJournal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SummaryOrderJournals and only return the `id`
     * const summaryOrderJournalWithIdOnly = await prisma.summaryOrderJournal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SummaryOrderJournalCreateManyAndReturnArgs>(args?: SelectSubset<T, SummaryOrderJournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SummaryOrderJournal.
     * @param {SummaryOrderJournalDeleteArgs} args - Arguments to delete one SummaryOrderJournal.
     * @example
     * // Delete one SummaryOrderJournal
     * const SummaryOrderJournal = await prisma.summaryOrderJournal.delete({
     *   where: {
     *     // ... filter to delete one SummaryOrderJournal
     *   }
     * })
     * 
     */
    delete<T extends SummaryOrderJournalDeleteArgs>(args: SelectSubset<T, SummaryOrderJournalDeleteArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SummaryOrderJournal.
     * @param {SummaryOrderJournalUpdateArgs} args - Arguments to update one SummaryOrderJournal.
     * @example
     * // Update one SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SummaryOrderJournalUpdateArgs>(args: SelectSubset<T, SummaryOrderJournalUpdateArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SummaryOrderJournals.
     * @param {SummaryOrderJournalDeleteManyArgs} args - Arguments to filter SummaryOrderJournals to delete.
     * @example
     * // Delete a few SummaryOrderJournals
     * const { count } = await prisma.summaryOrderJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SummaryOrderJournalDeleteManyArgs>(args?: SelectSubset<T, SummaryOrderJournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummaryOrderJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SummaryOrderJournals
     * const summaryOrderJournal = await prisma.summaryOrderJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SummaryOrderJournalUpdateManyArgs>(args: SelectSubset<T, SummaryOrderJournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummaryOrderJournals and returns the data updated in the database.
     * @param {SummaryOrderJournalUpdateManyAndReturnArgs} args - Arguments to update many SummaryOrderJournals.
     * @example
     * // Update many SummaryOrderJournals
     * const summaryOrderJournal = await prisma.summaryOrderJournal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SummaryOrderJournals and only return the `id`
     * const summaryOrderJournalWithIdOnly = await prisma.summaryOrderJournal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SummaryOrderJournalUpdateManyAndReturnArgs>(args: SelectSubset<T, SummaryOrderJournalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SummaryOrderJournal.
     * @param {SummaryOrderJournalUpsertArgs} args - Arguments to update or create a SummaryOrderJournal.
     * @example
     * // Update or create a SummaryOrderJournal
     * const summaryOrderJournal = await prisma.summaryOrderJournal.upsert({
     *   create: {
     *     // ... data to create a SummaryOrderJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SummaryOrderJournal we want to update
     *   }
     * })
     */
    upsert<T extends SummaryOrderJournalUpsertArgs>(args: SelectSubset<T, SummaryOrderJournalUpsertArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SummaryOrderJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalCountArgs} args - Arguments to filter SummaryOrderJournals to count.
     * @example
     * // Count the number of SummaryOrderJournals
     * const count = await prisma.summaryOrderJournal.count({
     *   where: {
     *     // ... the filter for the SummaryOrderJournals we want to count
     *   }
     * })
    **/
    count<T extends SummaryOrderJournalCountArgs>(
      args?: Subset<T, SummaryOrderJournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SummaryOrderJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SummaryOrderJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SummaryOrderJournalAggregateArgs>(args: Subset<T, SummaryOrderJournalAggregateArgs>): Prisma.PrismaPromise<GetSummaryOrderJournalAggregateType<T>>

    /**
     * Group by SummaryOrderJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SummaryOrderJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SummaryOrderJournalGroupByArgs['orderBy'] }
        : { orderBy?: SummaryOrderJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SummaryOrderJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSummaryOrderJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SummaryOrderJournal model
   */
  readonly fields: SummaryOrderJournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SummaryOrderJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SummaryOrderJournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends SummaryOrderJournal$customerArgs<ExtArgs> = {}>(args?: Subset<T, SummaryOrderJournal$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends SummaryOrderJournal$productArgs<ExtArgs> = {}>(args?: Subset<T, SummaryOrderJournal$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    events<T extends SummaryOrderJournal$eventsArgs<ExtArgs> = {}>(args?: Subset<T, SummaryOrderJournal$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SummaryOrderJournal model
   */
  interface SummaryOrderJournalFieldRefs {
    readonly id: FieldRef<"SummaryOrderJournal", 'Int'>
    readonly idn: FieldRef<"SummaryOrderJournal", 'String'>
    readonly shipDate: FieldRef<"SummaryOrderJournal", 'DateTime'>
    readonly paymentType: FieldRef<"SummaryOrderJournal", 'String'>
    readonly customerId: FieldRef<"SummaryOrderJournal", 'Int'>
    readonly customerName: FieldRef<"SummaryOrderJournal", 'String'>
    readonly productId: FieldRef<"SummaryOrderJournal", 'Int'>
    readonly productCode: FieldRef<"SummaryOrderJournal", 'String'>
    readonly productFullName: FieldRef<"SummaryOrderJournal", 'String'>
    readonly category: FieldRef<"SummaryOrderJournal", 'String'>
    readonly shortNameMorning: FieldRef<"SummaryOrderJournal", 'String'>
    readonly priceType: FieldRef<"SummaryOrderJournal", 'String'>
    readonly price: FieldRef<"SummaryOrderJournal", 'Decimal'>
    readonly shippedQty: FieldRef<"SummaryOrderJournal", 'Float'>
    readonly orderQty: FieldRef<"SummaryOrderJournal", 'Float'>
    readonly sumWithRevaluation: FieldRef<"SummaryOrderJournal", 'Decimal'>
    readonly distributionCoef: FieldRef<"SummaryOrderJournal", 'Float'>
    readonly weightToDistribute: FieldRef<"SummaryOrderJournal", 'Float'>
    readonly managerId: FieldRef<"SummaryOrderJournal", 'String'>
    readonly managerName: FieldRef<"SummaryOrderJournal", 'String'>
    readonly district: FieldRef<"SummaryOrderJournal", 'String'>
    readonly pointAddress: FieldRef<"SummaryOrderJournal", 'String'>
    readonly status: FieldRef<"SummaryOrderJournal", 'String'>
    readonly preAssemblyStatus: FieldRef<"SummaryOrderJournal", 'String'>
    readonly assemblyStartedAt: FieldRef<"SummaryOrderJournal", 'DateTime'>
    readonly assemblyStartedBy: FieldRef<"SummaryOrderJournal", 'String'>
    readonly assemblyReturnedAt: FieldRef<"SummaryOrderJournal", 'DateTime'>
    readonly assemblyReturnedBy: FieldRef<"SummaryOrderJournal", 'String'>
    readonly assemblyReturnReason: FieldRef<"SummaryOrderJournal", 'String'>
    readonly assemblyReturnComment: FieldRef<"SummaryOrderJournal", 'String'>
    readonly createdAt: FieldRef<"SummaryOrderJournal", 'DateTime'>
    readonly updatedAt: FieldRef<"SummaryOrderJournal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SummaryOrderJournal findUnique
   */
  export type SummaryOrderJournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderJournal to fetch.
     */
    where: SummaryOrderJournalWhereUniqueInput
  }

  /**
   * SummaryOrderJournal findUniqueOrThrow
   */
  export type SummaryOrderJournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderJournal to fetch.
     */
    where: SummaryOrderJournalWhereUniqueInput
  }

  /**
   * SummaryOrderJournal findFirst
   */
  export type SummaryOrderJournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderJournal to fetch.
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderJournals to fetch.
     */
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummaryOrderJournals.
     */
    cursor?: SummaryOrderJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummaryOrderJournals.
     */
    distinct?: SummaryOrderJournalScalarFieldEnum | SummaryOrderJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrderJournal findFirstOrThrow
   */
  export type SummaryOrderJournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderJournal to fetch.
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderJournals to fetch.
     */
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummaryOrderJournals.
     */
    cursor?: SummaryOrderJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummaryOrderJournals.
     */
    distinct?: SummaryOrderJournalScalarFieldEnum | SummaryOrderJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrderJournal findMany
   */
  export type SummaryOrderJournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderJournals to fetch.
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderJournals to fetch.
     */
    orderBy?: SummaryOrderJournalOrderByWithRelationInput | SummaryOrderJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SummaryOrderJournals.
     */
    cursor?: SummaryOrderJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderJournals.
     */
    skip?: number
    distinct?: SummaryOrderJournalScalarFieldEnum | SummaryOrderJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrderJournal create
   */
  export type SummaryOrderJournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * The data needed to create a SummaryOrderJournal.
     */
    data: XOR<SummaryOrderJournalCreateInput, SummaryOrderJournalUncheckedCreateInput>
  }

  /**
   * SummaryOrderJournal createMany
   */
  export type SummaryOrderJournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SummaryOrderJournals.
     */
    data: SummaryOrderJournalCreateManyInput | SummaryOrderJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SummaryOrderJournal createManyAndReturn
   */
  export type SummaryOrderJournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * The data used to create many SummaryOrderJournals.
     */
    data: SummaryOrderJournalCreateManyInput | SummaryOrderJournalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SummaryOrderJournal update
   */
  export type SummaryOrderJournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * The data needed to update a SummaryOrderJournal.
     */
    data: XOR<SummaryOrderJournalUpdateInput, SummaryOrderJournalUncheckedUpdateInput>
    /**
     * Choose, which SummaryOrderJournal to update.
     */
    where: SummaryOrderJournalWhereUniqueInput
  }

  /**
   * SummaryOrderJournal updateMany
   */
  export type SummaryOrderJournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SummaryOrderJournals.
     */
    data: XOR<SummaryOrderJournalUpdateManyMutationInput, SummaryOrderJournalUncheckedUpdateManyInput>
    /**
     * Filter which SummaryOrderJournals to update
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * Limit how many SummaryOrderJournals to update.
     */
    limit?: number
  }

  /**
   * SummaryOrderJournal updateManyAndReturn
   */
  export type SummaryOrderJournalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * The data used to update SummaryOrderJournals.
     */
    data: XOR<SummaryOrderJournalUpdateManyMutationInput, SummaryOrderJournalUncheckedUpdateManyInput>
    /**
     * Filter which SummaryOrderJournals to update
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * Limit how many SummaryOrderJournals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SummaryOrderJournal upsert
   */
  export type SummaryOrderJournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * The filter to search for the SummaryOrderJournal to update in case it exists.
     */
    where: SummaryOrderJournalWhereUniqueInput
    /**
     * In case the SummaryOrderJournal found by the `where` argument doesn't exist, create a new SummaryOrderJournal with this data.
     */
    create: XOR<SummaryOrderJournalCreateInput, SummaryOrderJournalUncheckedCreateInput>
    /**
     * In case the SummaryOrderJournal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SummaryOrderJournalUpdateInput, SummaryOrderJournalUncheckedUpdateInput>
  }

  /**
   * SummaryOrderJournal delete
   */
  export type SummaryOrderJournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
    /**
     * Filter which SummaryOrderJournal to delete.
     */
    where: SummaryOrderJournalWhereUniqueInput
  }

  /**
   * SummaryOrderJournal deleteMany
   */
  export type SummaryOrderJournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummaryOrderJournals to delete
     */
    where?: SummaryOrderJournalWhereInput
    /**
     * Limit how many SummaryOrderJournals to delete.
     */
    limit?: number
  }

  /**
   * SummaryOrderJournal.customer
   */
  export type SummaryOrderJournal$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * SummaryOrderJournal.product
   */
  export type SummaryOrderJournal$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * SummaryOrderJournal.events
   */
  export type SummaryOrderJournal$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventInclude<ExtArgs> | null
    where?: SummaryOrderEventWhereInput
    orderBy?: SummaryOrderEventOrderByWithRelationInput | SummaryOrderEventOrderByWithRelationInput[]
    cursor?: SummaryOrderEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SummaryOrderEventScalarFieldEnum | SummaryOrderEventScalarFieldEnum[]
  }

  /**
   * SummaryOrderJournal without action
   */
  export type SummaryOrderJournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderJournal
     */
    select?: SummaryOrderJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderJournal
     */
    omit?: SummaryOrderJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderJournalInclude<ExtArgs> | null
  }


  /**
   * Model SummaryOrderEvent
   */

  export type AggregateSummaryOrderEvent = {
    _count: SummaryOrderEventCountAggregateOutputType | null
    _avg: SummaryOrderEventAvgAggregateOutputType | null
    _sum: SummaryOrderEventSumAggregateOutputType | null
    _min: SummaryOrderEventMinAggregateOutputType | null
    _max: SummaryOrderEventMaxAggregateOutputType | null
  }

  export type SummaryOrderEventAvgAggregateOutputType = {
    id: number | null
    summaryOrderId: number | null
  }

  export type SummaryOrderEventSumAggregateOutputType = {
    id: number | null
    summaryOrderId: number | null
  }

  export type SummaryOrderEventMinAggregateOutputType = {
    id: number | null
    summaryOrderId: number | null
    eventType: string | null
    fromStatus: string | null
    toStatus: string | null
    reason: string | null
    comment: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type SummaryOrderEventMaxAggregateOutputType = {
    id: number | null
    summaryOrderId: number | null
    eventType: string | null
    fromStatus: string | null
    toStatus: string | null
    reason: string | null
    comment: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type SummaryOrderEventCountAggregateOutputType = {
    id: number
    summaryOrderId: number
    eventType: number
    fromStatus: number
    toStatus: number
    reason: number
    comment: number
    createdAt: number
    createdBy: number
    payload: number
    _all: number
  }


  export type SummaryOrderEventAvgAggregateInputType = {
    id?: true
    summaryOrderId?: true
  }

  export type SummaryOrderEventSumAggregateInputType = {
    id?: true
    summaryOrderId?: true
  }

  export type SummaryOrderEventMinAggregateInputType = {
    id?: true
    summaryOrderId?: true
    eventType?: true
    fromStatus?: true
    toStatus?: true
    reason?: true
    comment?: true
    createdAt?: true
    createdBy?: true
  }

  export type SummaryOrderEventMaxAggregateInputType = {
    id?: true
    summaryOrderId?: true
    eventType?: true
    fromStatus?: true
    toStatus?: true
    reason?: true
    comment?: true
    createdAt?: true
    createdBy?: true
  }

  export type SummaryOrderEventCountAggregateInputType = {
    id?: true
    summaryOrderId?: true
    eventType?: true
    fromStatus?: true
    toStatus?: true
    reason?: true
    comment?: true
    createdAt?: true
    createdBy?: true
    payload?: true
    _all?: true
  }

  export type SummaryOrderEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummaryOrderEvent to aggregate.
     */
    where?: SummaryOrderEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderEvents to fetch.
     */
    orderBy?: SummaryOrderEventOrderByWithRelationInput | SummaryOrderEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SummaryOrderEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SummaryOrderEvents
    **/
    _count?: true | SummaryOrderEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SummaryOrderEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SummaryOrderEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SummaryOrderEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SummaryOrderEventMaxAggregateInputType
  }

  export type GetSummaryOrderEventAggregateType<T extends SummaryOrderEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSummaryOrderEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSummaryOrderEvent[P]>
      : GetScalarType<T[P], AggregateSummaryOrderEvent[P]>
  }




  export type SummaryOrderEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummaryOrderEventWhereInput
    orderBy?: SummaryOrderEventOrderByWithAggregationInput | SummaryOrderEventOrderByWithAggregationInput[]
    by: SummaryOrderEventScalarFieldEnum[] | SummaryOrderEventScalarFieldEnum
    having?: SummaryOrderEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SummaryOrderEventCountAggregateInputType | true
    _avg?: SummaryOrderEventAvgAggregateInputType
    _sum?: SummaryOrderEventSumAggregateInputType
    _min?: SummaryOrderEventMinAggregateInputType
    _max?: SummaryOrderEventMaxAggregateInputType
  }

  export type SummaryOrderEventGroupByOutputType = {
    id: number
    summaryOrderId: number
    eventType: string
    fromStatus: string | null
    toStatus: string | null
    reason: string | null
    comment: string | null
    createdAt: Date
    createdBy: string
    payload: JsonValue | null
    _count: SummaryOrderEventCountAggregateOutputType | null
    _avg: SummaryOrderEventAvgAggregateOutputType | null
    _sum: SummaryOrderEventSumAggregateOutputType | null
    _min: SummaryOrderEventMinAggregateOutputType | null
    _max: SummaryOrderEventMaxAggregateOutputType | null
  }

  type GetSummaryOrderEventGroupByPayload<T extends SummaryOrderEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SummaryOrderEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SummaryOrderEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SummaryOrderEventGroupByOutputType[P]>
            : GetScalarType<T[P], SummaryOrderEventGroupByOutputType[P]>
        }
      >
    >


  export type SummaryOrderEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    summaryOrderId?: boolean
    eventType?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    comment?: boolean
    createdAt?: boolean
    createdBy?: boolean
    payload?: boolean
    summaryOrder?: boolean | SummaryOrderJournalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["summaryOrderEvent"]>

  export type SummaryOrderEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    summaryOrderId?: boolean
    eventType?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    comment?: boolean
    createdAt?: boolean
    createdBy?: boolean
    payload?: boolean
    summaryOrder?: boolean | SummaryOrderJournalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["summaryOrderEvent"]>

  export type SummaryOrderEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    summaryOrderId?: boolean
    eventType?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    comment?: boolean
    createdAt?: boolean
    createdBy?: boolean
    payload?: boolean
    summaryOrder?: boolean | SummaryOrderJournalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["summaryOrderEvent"]>

  export type SummaryOrderEventSelectScalar = {
    id?: boolean
    summaryOrderId?: boolean
    eventType?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    comment?: boolean
    createdAt?: boolean
    createdBy?: boolean
    payload?: boolean
  }

  export type SummaryOrderEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "summaryOrderId" | "eventType" | "fromStatus" | "toStatus" | "reason" | "comment" | "createdAt" | "createdBy" | "payload", ExtArgs["result"]["summaryOrderEvent"]>
  export type SummaryOrderEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    summaryOrder?: boolean | SummaryOrderJournalDefaultArgs<ExtArgs>
  }
  export type SummaryOrderEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    summaryOrder?: boolean | SummaryOrderJournalDefaultArgs<ExtArgs>
  }
  export type SummaryOrderEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    summaryOrder?: boolean | SummaryOrderJournalDefaultArgs<ExtArgs>
  }

  export type $SummaryOrderEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SummaryOrderEvent"
    objects: {
      summaryOrder: Prisma.$SummaryOrderJournalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      summaryOrderId: number
      eventType: string
      fromStatus: string | null
      toStatus: string | null
      reason: string | null
      comment: string | null
      createdAt: Date
      createdBy: string
      payload: Prisma.JsonValue | null
    }, ExtArgs["result"]["summaryOrderEvent"]>
    composites: {}
  }

  type SummaryOrderEventGetPayload<S extends boolean | null | undefined | SummaryOrderEventDefaultArgs> = $Result.GetResult<Prisma.$SummaryOrderEventPayload, S>

  type SummaryOrderEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SummaryOrderEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SummaryOrderEventCountAggregateInputType | true
    }

  export interface SummaryOrderEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SummaryOrderEvent'], meta: { name: 'SummaryOrderEvent' } }
    /**
     * Find zero or one SummaryOrderEvent that matches the filter.
     * @param {SummaryOrderEventFindUniqueArgs} args - Arguments to find a SummaryOrderEvent
     * @example
     * // Get one SummaryOrderEvent
     * const summaryOrderEvent = await prisma.summaryOrderEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SummaryOrderEventFindUniqueArgs>(args: SelectSubset<T, SummaryOrderEventFindUniqueArgs<ExtArgs>>): Prisma__SummaryOrderEventClient<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SummaryOrderEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SummaryOrderEventFindUniqueOrThrowArgs} args - Arguments to find a SummaryOrderEvent
     * @example
     * // Get one SummaryOrderEvent
     * const summaryOrderEvent = await prisma.summaryOrderEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SummaryOrderEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SummaryOrderEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SummaryOrderEventClient<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummaryOrderEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderEventFindFirstArgs} args - Arguments to find a SummaryOrderEvent
     * @example
     * // Get one SummaryOrderEvent
     * const summaryOrderEvent = await prisma.summaryOrderEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SummaryOrderEventFindFirstArgs>(args?: SelectSubset<T, SummaryOrderEventFindFirstArgs<ExtArgs>>): Prisma__SummaryOrderEventClient<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummaryOrderEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderEventFindFirstOrThrowArgs} args - Arguments to find a SummaryOrderEvent
     * @example
     * // Get one SummaryOrderEvent
     * const summaryOrderEvent = await prisma.summaryOrderEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SummaryOrderEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SummaryOrderEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SummaryOrderEventClient<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SummaryOrderEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SummaryOrderEvents
     * const summaryOrderEvents = await prisma.summaryOrderEvent.findMany()
     * 
     * // Get first 10 SummaryOrderEvents
     * const summaryOrderEvents = await prisma.summaryOrderEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const summaryOrderEventWithIdOnly = await prisma.summaryOrderEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SummaryOrderEventFindManyArgs>(args?: SelectSubset<T, SummaryOrderEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SummaryOrderEvent.
     * @param {SummaryOrderEventCreateArgs} args - Arguments to create a SummaryOrderEvent.
     * @example
     * // Create one SummaryOrderEvent
     * const SummaryOrderEvent = await prisma.summaryOrderEvent.create({
     *   data: {
     *     // ... data to create a SummaryOrderEvent
     *   }
     * })
     * 
     */
    create<T extends SummaryOrderEventCreateArgs>(args: SelectSubset<T, SummaryOrderEventCreateArgs<ExtArgs>>): Prisma__SummaryOrderEventClient<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SummaryOrderEvents.
     * @param {SummaryOrderEventCreateManyArgs} args - Arguments to create many SummaryOrderEvents.
     * @example
     * // Create many SummaryOrderEvents
     * const summaryOrderEvent = await prisma.summaryOrderEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SummaryOrderEventCreateManyArgs>(args?: SelectSubset<T, SummaryOrderEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SummaryOrderEvents and returns the data saved in the database.
     * @param {SummaryOrderEventCreateManyAndReturnArgs} args - Arguments to create many SummaryOrderEvents.
     * @example
     * // Create many SummaryOrderEvents
     * const summaryOrderEvent = await prisma.summaryOrderEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SummaryOrderEvents and only return the `id`
     * const summaryOrderEventWithIdOnly = await prisma.summaryOrderEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SummaryOrderEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SummaryOrderEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SummaryOrderEvent.
     * @param {SummaryOrderEventDeleteArgs} args - Arguments to delete one SummaryOrderEvent.
     * @example
     * // Delete one SummaryOrderEvent
     * const SummaryOrderEvent = await prisma.summaryOrderEvent.delete({
     *   where: {
     *     // ... filter to delete one SummaryOrderEvent
     *   }
     * })
     * 
     */
    delete<T extends SummaryOrderEventDeleteArgs>(args: SelectSubset<T, SummaryOrderEventDeleteArgs<ExtArgs>>): Prisma__SummaryOrderEventClient<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SummaryOrderEvent.
     * @param {SummaryOrderEventUpdateArgs} args - Arguments to update one SummaryOrderEvent.
     * @example
     * // Update one SummaryOrderEvent
     * const summaryOrderEvent = await prisma.summaryOrderEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SummaryOrderEventUpdateArgs>(args: SelectSubset<T, SummaryOrderEventUpdateArgs<ExtArgs>>): Prisma__SummaryOrderEventClient<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SummaryOrderEvents.
     * @param {SummaryOrderEventDeleteManyArgs} args - Arguments to filter SummaryOrderEvents to delete.
     * @example
     * // Delete a few SummaryOrderEvents
     * const { count } = await prisma.summaryOrderEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SummaryOrderEventDeleteManyArgs>(args?: SelectSubset<T, SummaryOrderEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummaryOrderEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SummaryOrderEvents
     * const summaryOrderEvent = await prisma.summaryOrderEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SummaryOrderEventUpdateManyArgs>(args: SelectSubset<T, SummaryOrderEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummaryOrderEvents and returns the data updated in the database.
     * @param {SummaryOrderEventUpdateManyAndReturnArgs} args - Arguments to update many SummaryOrderEvents.
     * @example
     * // Update many SummaryOrderEvents
     * const summaryOrderEvent = await prisma.summaryOrderEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SummaryOrderEvents and only return the `id`
     * const summaryOrderEventWithIdOnly = await prisma.summaryOrderEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SummaryOrderEventUpdateManyAndReturnArgs>(args: SelectSubset<T, SummaryOrderEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SummaryOrderEvent.
     * @param {SummaryOrderEventUpsertArgs} args - Arguments to update or create a SummaryOrderEvent.
     * @example
     * // Update or create a SummaryOrderEvent
     * const summaryOrderEvent = await prisma.summaryOrderEvent.upsert({
     *   create: {
     *     // ... data to create a SummaryOrderEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SummaryOrderEvent we want to update
     *   }
     * })
     */
    upsert<T extends SummaryOrderEventUpsertArgs>(args: SelectSubset<T, SummaryOrderEventUpsertArgs<ExtArgs>>): Prisma__SummaryOrderEventClient<$Result.GetResult<Prisma.$SummaryOrderEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SummaryOrderEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderEventCountArgs} args - Arguments to filter SummaryOrderEvents to count.
     * @example
     * // Count the number of SummaryOrderEvents
     * const count = await prisma.summaryOrderEvent.count({
     *   where: {
     *     // ... the filter for the SummaryOrderEvents we want to count
     *   }
     * })
    **/
    count<T extends SummaryOrderEventCountArgs>(
      args?: Subset<T, SummaryOrderEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SummaryOrderEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SummaryOrderEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SummaryOrderEventAggregateArgs>(args: Subset<T, SummaryOrderEventAggregateArgs>): Prisma.PrismaPromise<GetSummaryOrderEventAggregateType<T>>

    /**
     * Group by SummaryOrderEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrderEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SummaryOrderEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SummaryOrderEventGroupByArgs['orderBy'] }
        : { orderBy?: SummaryOrderEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SummaryOrderEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSummaryOrderEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SummaryOrderEvent model
   */
  readonly fields: SummaryOrderEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SummaryOrderEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SummaryOrderEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    summaryOrder<T extends SummaryOrderJournalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SummaryOrderJournalDefaultArgs<ExtArgs>>): Prisma__SummaryOrderJournalClient<$Result.GetResult<Prisma.$SummaryOrderJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SummaryOrderEvent model
   */
  interface SummaryOrderEventFieldRefs {
    readonly id: FieldRef<"SummaryOrderEvent", 'Int'>
    readonly summaryOrderId: FieldRef<"SummaryOrderEvent", 'Int'>
    readonly eventType: FieldRef<"SummaryOrderEvent", 'String'>
    readonly fromStatus: FieldRef<"SummaryOrderEvent", 'String'>
    readonly toStatus: FieldRef<"SummaryOrderEvent", 'String'>
    readonly reason: FieldRef<"SummaryOrderEvent", 'String'>
    readonly comment: FieldRef<"SummaryOrderEvent", 'String'>
    readonly createdAt: FieldRef<"SummaryOrderEvent", 'DateTime'>
    readonly createdBy: FieldRef<"SummaryOrderEvent", 'String'>
    readonly payload: FieldRef<"SummaryOrderEvent", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SummaryOrderEvent findUnique
   */
  export type SummaryOrderEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderEvent to fetch.
     */
    where: SummaryOrderEventWhereUniqueInput
  }

  /**
   * SummaryOrderEvent findUniqueOrThrow
   */
  export type SummaryOrderEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderEvent to fetch.
     */
    where: SummaryOrderEventWhereUniqueInput
  }

  /**
   * SummaryOrderEvent findFirst
   */
  export type SummaryOrderEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderEvent to fetch.
     */
    where?: SummaryOrderEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderEvents to fetch.
     */
    orderBy?: SummaryOrderEventOrderByWithRelationInput | SummaryOrderEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummaryOrderEvents.
     */
    cursor?: SummaryOrderEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummaryOrderEvents.
     */
    distinct?: SummaryOrderEventScalarFieldEnum | SummaryOrderEventScalarFieldEnum[]
  }

  /**
   * SummaryOrderEvent findFirstOrThrow
   */
  export type SummaryOrderEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderEvent to fetch.
     */
    where?: SummaryOrderEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderEvents to fetch.
     */
    orderBy?: SummaryOrderEventOrderByWithRelationInput | SummaryOrderEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummaryOrderEvents.
     */
    cursor?: SummaryOrderEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummaryOrderEvents.
     */
    distinct?: SummaryOrderEventScalarFieldEnum | SummaryOrderEventScalarFieldEnum[]
  }

  /**
   * SummaryOrderEvent findMany
   */
  export type SummaryOrderEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventInclude<ExtArgs> | null
    /**
     * Filter, which SummaryOrderEvents to fetch.
     */
    where?: SummaryOrderEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrderEvents to fetch.
     */
    orderBy?: SummaryOrderEventOrderByWithRelationInput | SummaryOrderEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SummaryOrderEvents.
     */
    cursor?: SummaryOrderEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrderEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrderEvents.
     */
    skip?: number
    distinct?: SummaryOrderEventScalarFieldEnum | SummaryOrderEventScalarFieldEnum[]
  }

  /**
   * SummaryOrderEvent create
   */
  export type SummaryOrderEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventInclude<ExtArgs> | null
    /**
     * The data needed to create a SummaryOrderEvent.
     */
    data: XOR<SummaryOrderEventCreateInput, SummaryOrderEventUncheckedCreateInput>
  }

  /**
   * SummaryOrderEvent createMany
   */
  export type SummaryOrderEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SummaryOrderEvents.
     */
    data: SummaryOrderEventCreateManyInput | SummaryOrderEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SummaryOrderEvent createManyAndReturn
   */
  export type SummaryOrderEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * The data used to create many SummaryOrderEvents.
     */
    data: SummaryOrderEventCreateManyInput | SummaryOrderEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SummaryOrderEvent update
   */
  export type SummaryOrderEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventInclude<ExtArgs> | null
    /**
     * The data needed to update a SummaryOrderEvent.
     */
    data: XOR<SummaryOrderEventUpdateInput, SummaryOrderEventUncheckedUpdateInput>
    /**
     * Choose, which SummaryOrderEvent to update.
     */
    where: SummaryOrderEventWhereUniqueInput
  }

  /**
   * SummaryOrderEvent updateMany
   */
  export type SummaryOrderEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SummaryOrderEvents.
     */
    data: XOR<SummaryOrderEventUpdateManyMutationInput, SummaryOrderEventUncheckedUpdateManyInput>
    /**
     * Filter which SummaryOrderEvents to update
     */
    where?: SummaryOrderEventWhereInput
    /**
     * Limit how many SummaryOrderEvents to update.
     */
    limit?: number
  }

  /**
   * SummaryOrderEvent updateManyAndReturn
   */
  export type SummaryOrderEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * The data used to update SummaryOrderEvents.
     */
    data: XOR<SummaryOrderEventUpdateManyMutationInput, SummaryOrderEventUncheckedUpdateManyInput>
    /**
     * Filter which SummaryOrderEvents to update
     */
    where?: SummaryOrderEventWhereInput
    /**
     * Limit how many SummaryOrderEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SummaryOrderEvent upsert
   */
  export type SummaryOrderEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventInclude<ExtArgs> | null
    /**
     * The filter to search for the SummaryOrderEvent to update in case it exists.
     */
    where: SummaryOrderEventWhereUniqueInput
    /**
     * In case the SummaryOrderEvent found by the `where` argument doesn't exist, create a new SummaryOrderEvent with this data.
     */
    create: XOR<SummaryOrderEventCreateInput, SummaryOrderEventUncheckedCreateInput>
    /**
     * In case the SummaryOrderEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SummaryOrderEventUpdateInput, SummaryOrderEventUncheckedUpdateInput>
  }

  /**
   * SummaryOrderEvent delete
   */
  export type SummaryOrderEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventInclude<ExtArgs> | null
    /**
     * Filter which SummaryOrderEvent to delete.
     */
    where: SummaryOrderEventWhereUniqueInput
  }

  /**
   * SummaryOrderEvent deleteMany
   */
  export type SummaryOrderEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummaryOrderEvents to delete
     */
    where?: SummaryOrderEventWhereInput
    /**
     * Limit how many SummaryOrderEvents to delete.
     */
    limit?: number
  }

  /**
   * SummaryOrderEvent without action
   */
  export type SummaryOrderEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrderEvent
     */
    select?: SummaryOrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrderEvent
     */
    omit?: SummaryOrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummaryOrderEventInclude<ExtArgs> | null
  }


  /**
   * Model SummaryOrdersJournal
   */

  export type AggregateSummaryOrdersJournal = {
    _count: SummaryOrdersJournalCountAggregateOutputType | null
    _avg: SummaryOrdersJournalAvgAggregateOutputType | null
    _sum: SummaryOrdersJournalSumAggregateOutputType | null
    _min: SummaryOrdersJournalMinAggregateOutputType | null
    _max: SummaryOrdersJournalMaxAggregateOutputType | null
  }

  export type SummaryOrdersJournalAvgAggregateOutputType = {
    id: number | null
  }

  export type SummaryOrdersJournalSumAggregateOutputType = {
    id: number | null
  }

  export type SummaryOrdersJournalMinAggregateOutputType = {
    id: number | null
    summaryDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    isHidden: boolean | null
  }

  export type SummaryOrdersJournalMaxAggregateOutputType = {
    id: number | null
    summaryDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    isHidden: boolean | null
  }

  export type SummaryOrdersJournalCountAggregateOutputType = {
    id: number
    summaryDate: number
    createdAt: number
    createdBy: number
    isHidden: number
    data: number
    _all: number
  }


  export type SummaryOrdersJournalAvgAggregateInputType = {
    id?: true
  }

  export type SummaryOrdersJournalSumAggregateInputType = {
    id?: true
  }

  export type SummaryOrdersJournalMinAggregateInputType = {
    id?: true
    summaryDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
  }

  export type SummaryOrdersJournalMaxAggregateInputType = {
    id?: true
    summaryDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
  }

  export type SummaryOrdersJournalCountAggregateInputType = {
    id?: true
    summaryDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
    data?: true
    _all?: true
  }

  export type SummaryOrdersJournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummaryOrdersJournal to aggregate.
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrdersJournals to fetch.
     */
    orderBy?: SummaryOrdersJournalOrderByWithRelationInput | SummaryOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SummaryOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SummaryOrdersJournals
    **/
    _count?: true | SummaryOrdersJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SummaryOrdersJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SummaryOrdersJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SummaryOrdersJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SummaryOrdersJournalMaxAggregateInputType
  }

  export type GetSummaryOrdersJournalAggregateType<T extends SummaryOrdersJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateSummaryOrdersJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSummaryOrdersJournal[P]>
      : GetScalarType<T[P], AggregateSummaryOrdersJournal[P]>
  }




  export type SummaryOrdersJournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummaryOrdersJournalWhereInput
    orderBy?: SummaryOrdersJournalOrderByWithAggregationInput | SummaryOrdersJournalOrderByWithAggregationInput[]
    by: SummaryOrdersJournalScalarFieldEnum[] | SummaryOrdersJournalScalarFieldEnum
    having?: SummaryOrdersJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SummaryOrdersJournalCountAggregateInputType | true
    _avg?: SummaryOrdersJournalAvgAggregateInputType
    _sum?: SummaryOrdersJournalSumAggregateInputType
    _min?: SummaryOrdersJournalMinAggregateInputType
    _max?: SummaryOrdersJournalMaxAggregateInputType
  }

  export type SummaryOrdersJournalGroupByOutputType = {
    id: number
    summaryDate: Date
    createdAt: Date
    createdBy: string
    isHidden: boolean
    data: JsonValue
    _count: SummaryOrdersJournalCountAggregateOutputType | null
    _avg: SummaryOrdersJournalAvgAggregateOutputType | null
    _sum: SummaryOrdersJournalSumAggregateOutputType | null
    _min: SummaryOrdersJournalMinAggregateOutputType | null
    _max: SummaryOrdersJournalMaxAggregateOutputType | null
  }

  type GetSummaryOrdersJournalGroupByPayload<T extends SummaryOrdersJournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SummaryOrdersJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SummaryOrdersJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SummaryOrdersJournalGroupByOutputType[P]>
            : GetScalarType<T[P], SummaryOrdersJournalGroupByOutputType[P]>
        }
      >
    >


  export type SummaryOrdersJournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    summaryDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    data?: boolean
  }, ExtArgs["result"]["summaryOrdersJournal"]>

  export type SummaryOrdersJournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    summaryDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    data?: boolean
  }, ExtArgs["result"]["summaryOrdersJournal"]>

  export type SummaryOrdersJournalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    summaryDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    data?: boolean
  }, ExtArgs["result"]["summaryOrdersJournal"]>

  export type SummaryOrdersJournalSelectScalar = {
    id?: boolean
    summaryDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    data?: boolean
  }

  export type SummaryOrdersJournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "summaryDate" | "createdAt" | "createdBy" | "isHidden" | "data", ExtArgs["result"]["summaryOrdersJournal"]>

  export type $SummaryOrdersJournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SummaryOrdersJournal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      summaryDate: Date
      createdAt: Date
      createdBy: string
      isHidden: boolean
      data: Prisma.JsonValue
    }, ExtArgs["result"]["summaryOrdersJournal"]>
    composites: {}
  }

  type SummaryOrdersJournalGetPayload<S extends boolean | null | undefined | SummaryOrdersJournalDefaultArgs> = $Result.GetResult<Prisma.$SummaryOrdersJournalPayload, S>

  type SummaryOrdersJournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SummaryOrdersJournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SummaryOrdersJournalCountAggregateInputType | true
    }

  export interface SummaryOrdersJournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SummaryOrdersJournal'], meta: { name: 'SummaryOrdersJournal' } }
    /**
     * Find zero or one SummaryOrdersJournal that matches the filter.
     * @param {SummaryOrdersJournalFindUniqueArgs} args - Arguments to find a SummaryOrdersJournal
     * @example
     * // Get one SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SummaryOrdersJournalFindUniqueArgs>(args: SelectSubset<T, SummaryOrdersJournalFindUniqueArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SummaryOrdersJournal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SummaryOrdersJournalFindUniqueOrThrowArgs} args - Arguments to find a SummaryOrdersJournal
     * @example
     * // Get one SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SummaryOrdersJournalFindUniqueOrThrowArgs>(args: SelectSubset<T, SummaryOrdersJournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummaryOrdersJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalFindFirstArgs} args - Arguments to find a SummaryOrdersJournal
     * @example
     * // Get one SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SummaryOrdersJournalFindFirstArgs>(args?: SelectSubset<T, SummaryOrdersJournalFindFirstArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummaryOrdersJournal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalFindFirstOrThrowArgs} args - Arguments to find a SummaryOrdersJournal
     * @example
     * // Get one SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SummaryOrdersJournalFindFirstOrThrowArgs>(args?: SelectSubset<T, SummaryOrdersJournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SummaryOrdersJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SummaryOrdersJournals
     * const summaryOrdersJournals = await prisma.summaryOrdersJournal.findMany()
     * 
     * // Get first 10 SummaryOrdersJournals
     * const summaryOrdersJournals = await prisma.summaryOrdersJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const summaryOrdersJournalWithIdOnly = await prisma.summaryOrdersJournal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SummaryOrdersJournalFindManyArgs>(args?: SelectSubset<T, SummaryOrdersJournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SummaryOrdersJournal.
     * @param {SummaryOrdersJournalCreateArgs} args - Arguments to create a SummaryOrdersJournal.
     * @example
     * // Create one SummaryOrdersJournal
     * const SummaryOrdersJournal = await prisma.summaryOrdersJournal.create({
     *   data: {
     *     // ... data to create a SummaryOrdersJournal
     *   }
     * })
     * 
     */
    create<T extends SummaryOrdersJournalCreateArgs>(args: SelectSubset<T, SummaryOrdersJournalCreateArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SummaryOrdersJournals.
     * @param {SummaryOrdersJournalCreateManyArgs} args - Arguments to create many SummaryOrdersJournals.
     * @example
     * // Create many SummaryOrdersJournals
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SummaryOrdersJournalCreateManyArgs>(args?: SelectSubset<T, SummaryOrdersJournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SummaryOrdersJournals and returns the data saved in the database.
     * @param {SummaryOrdersJournalCreateManyAndReturnArgs} args - Arguments to create many SummaryOrdersJournals.
     * @example
     * // Create many SummaryOrdersJournals
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SummaryOrdersJournals and only return the `id`
     * const summaryOrdersJournalWithIdOnly = await prisma.summaryOrdersJournal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SummaryOrdersJournalCreateManyAndReturnArgs>(args?: SelectSubset<T, SummaryOrdersJournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SummaryOrdersJournal.
     * @param {SummaryOrdersJournalDeleteArgs} args - Arguments to delete one SummaryOrdersJournal.
     * @example
     * // Delete one SummaryOrdersJournal
     * const SummaryOrdersJournal = await prisma.summaryOrdersJournal.delete({
     *   where: {
     *     // ... filter to delete one SummaryOrdersJournal
     *   }
     * })
     * 
     */
    delete<T extends SummaryOrdersJournalDeleteArgs>(args: SelectSubset<T, SummaryOrdersJournalDeleteArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SummaryOrdersJournal.
     * @param {SummaryOrdersJournalUpdateArgs} args - Arguments to update one SummaryOrdersJournal.
     * @example
     * // Update one SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SummaryOrdersJournalUpdateArgs>(args: SelectSubset<T, SummaryOrdersJournalUpdateArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SummaryOrdersJournals.
     * @param {SummaryOrdersJournalDeleteManyArgs} args - Arguments to filter SummaryOrdersJournals to delete.
     * @example
     * // Delete a few SummaryOrdersJournals
     * const { count } = await prisma.summaryOrdersJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SummaryOrdersJournalDeleteManyArgs>(args?: SelectSubset<T, SummaryOrdersJournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummaryOrdersJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SummaryOrdersJournals
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SummaryOrdersJournalUpdateManyArgs>(args: SelectSubset<T, SummaryOrdersJournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummaryOrdersJournals and returns the data updated in the database.
     * @param {SummaryOrdersJournalUpdateManyAndReturnArgs} args - Arguments to update many SummaryOrdersJournals.
     * @example
     * // Update many SummaryOrdersJournals
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SummaryOrdersJournals and only return the `id`
     * const summaryOrdersJournalWithIdOnly = await prisma.summaryOrdersJournal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SummaryOrdersJournalUpdateManyAndReturnArgs>(args: SelectSubset<T, SummaryOrdersJournalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SummaryOrdersJournal.
     * @param {SummaryOrdersJournalUpsertArgs} args - Arguments to update or create a SummaryOrdersJournal.
     * @example
     * // Update or create a SummaryOrdersJournal
     * const summaryOrdersJournal = await prisma.summaryOrdersJournal.upsert({
     *   create: {
     *     // ... data to create a SummaryOrdersJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SummaryOrdersJournal we want to update
     *   }
     * })
     */
    upsert<T extends SummaryOrdersJournalUpsertArgs>(args: SelectSubset<T, SummaryOrdersJournalUpsertArgs<ExtArgs>>): Prisma__SummaryOrdersJournalClient<$Result.GetResult<Prisma.$SummaryOrdersJournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SummaryOrdersJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalCountArgs} args - Arguments to filter SummaryOrdersJournals to count.
     * @example
     * // Count the number of SummaryOrdersJournals
     * const count = await prisma.summaryOrdersJournal.count({
     *   where: {
     *     // ... the filter for the SummaryOrdersJournals we want to count
     *   }
     * })
    **/
    count<T extends SummaryOrdersJournalCountArgs>(
      args?: Subset<T, SummaryOrdersJournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SummaryOrdersJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SummaryOrdersJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SummaryOrdersJournalAggregateArgs>(args: Subset<T, SummaryOrdersJournalAggregateArgs>): Prisma.PrismaPromise<GetSummaryOrdersJournalAggregateType<T>>

    /**
     * Group by SummaryOrdersJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummaryOrdersJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SummaryOrdersJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SummaryOrdersJournalGroupByArgs['orderBy'] }
        : { orderBy?: SummaryOrdersJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SummaryOrdersJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSummaryOrdersJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SummaryOrdersJournal model
   */
  readonly fields: SummaryOrdersJournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SummaryOrdersJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SummaryOrdersJournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SummaryOrdersJournal model
   */
  interface SummaryOrdersJournalFieldRefs {
    readonly id: FieldRef<"SummaryOrdersJournal", 'Int'>
    readonly summaryDate: FieldRef<"SummaryOrdersJournal", 'DateTime'>
    readonly createdAt: FieldRef<"SummaryOrdersJournal", 'DateTime'>
    readonly createdBy: FieldRef<"SummaryOrdersJournal", 'String'>
    readonly isHidden: FieldRef<"SummaryOrdersJournal", 'Boolean'>
    readonly data: FieldRef<"SummaryOrdersJournal", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SummaryOrdersJournal findUnique
   */
  export type SummaryOrdersJournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which SummaryOrdersJournal to fetch.
     */
    where: SummaryOrdersJournalWhereUniqueInput
  }

  /**
   * SummaryOrdersJournal findUniqueOrThrow
   */
  export type SummaryOrdersJournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which SummaryOrdersJournal to fetch.
     */
    where: SummaryOrdersJournalWhereUniqueInput
  }

  /**
   * SummaryOrdersJournal findFirst
   */
  export type SummaryOrdersJournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which SummaryOrdersJournal to fetch.
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrdersJournals to fetch.
     */
    orderBy?: SummaryOrdersJournalOrderByWithRelationInput | SummaryOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummaryOrdersJournals.
     */
    cursor?: SummaryOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummaryOrdersJournals.
     */
    distinct?: SummaryOrdersJournalScalarFieldEnum | SummaryOrdersJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrdersJournal findFirstOrThrow
   */
  export type SummaryOrdersJournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which SummaryOrdersJournal to fetch.
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrdersJournals to fetch.
     */
    orderBy?: SummaryOrdersJournalOrderByWithRelationInput | SummaryOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummaryOrdersJournals.
     */
    cursor?: SummaryOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummaryOrdersJournals.
     */
    distinct?: SummaryOrdersJournalScalarFieldEnum | SummaryOrdersJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrdersJournal findMany
   */
  export type SummaryOrdersJournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which SummaryOrdersJournals to fetch.
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummaryOrdersJournals to fetch.
     */
    orderBy?: SummaryOrdersJournalOrderByWithRelationInput | SummaryOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SummaryOrdersJournals.
     */
    cursor?: SummaryOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummaryOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummaryOrdersJournals.
     */
    skip?: number
    distinct?: SummaryOrdersJournalScalarFieldEnum | SummaryOrdersJournalScalarFieldEnum[]
  }

  /**
   * SummaryOrdersJournal create
   */
  export type SummaryOrdersJournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * The data needed to create a SummaryOrdersJournal.
     */
    data: XOR<SummaryOrdersJournalCreateInput, SummaryOrdersJournalUncheckedCreateInput>
  }

  /**
   * SummaryOrdersJournal createMany
   */
  export type SummaryOrdersJournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SummaryOrdersJournals.
     */
    data: SummaryOrdersJournalCreateManyInput | SummaryOrdersJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SummaryOrdersJournal createManyAndReturn
   */
  export type SummaryOrdersJournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * The data used to create many SummaryOrdersJournals.
     */
    data: SummaryOrdersJournalCreateManyInput | SummaryOrdersJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SummaryOrdersJournal update
   */
  export type SummaryOrdersJournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * The data needed to update a SummaryOrdersJournal.
     */
    data: XOR<SummaryOrdersJournalUpdateInput, SummaryOrdersJournalUncheckedUpdateInput>
    /**
     * Choose, which SummaryOrdersJournal to update.
     */
    where: SummaryOrdersJournalWhereUniqueInput
  }

  /**
   * SummaryOrdersJournal updateMany
   */
  export type SummaryOrdersJournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SummaryOrdersJournals.
     */
    data: XOR<SummaryOrdersJournalUpdateManyMutationInput, SummaryOrdersJournalUncheckedUpdateManyInput>
    /**
     * Filter which SummaryOrdersJournals to update
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * Limit how many SummaryOrdersJournals to update.
     */
    limit?: number
  }

  /**
   * SummaryOrdersJournal updateManyAndReturn
   */
  export type SummaryOrdersJournalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * The data used to update SummaryOrdersJournals.
     */
    data: XOR<SummaryOrdersJournalUpdateManyMutationInput, SummaryOrdersJournalUncheckedUpdateManyInput>
    /**
     * Filter which SummaryOrdersJournals to update
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * Limit how many SummaryOrdersJournals to update.
     */
    limit?: number
  }

  /**
   * SummaryOrdersJournal upsert
   */
  export type SummaryOrdersJournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * The filter to search for the SummaryOrdersJournal to update in case it exists.
     */
    where: SummaryOrdersJournalWhereUniqueInput
    /**
     * In case the SummaryOrdersJournal found by the `where` argument doesn't exist, create a new SummaryOrdersJournal with this data.
     */
    create: XOR<SummaryOrdersJournalCreateInput, SummaryOrdersJournalUncheckedCreateInput>
    /**
     * In case the SummaryOrdersJournal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SummaryOrdersJournalUpdateInput, SummaryOrdersJournalUncheckedUpdateInput>
  }

  /**
   * SummaryOrdersJournal delete
   */
  export type SummaryOrdersJournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter which SummaryOrdersJournal to delete.
     */
    where: SummaryOrdersJournalWhereUniqueInput
  }

  /**
   * SummaryOrdersJournal deleteMany
   */
  export type SummaryOrdersJournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummaryOrdersJournals to delete
     */
    where?: SummaryOrdersJournalWhereInput
    /**
     * Limit how many SummaryOrdersJournals to delete.
     */
    limit?: number
  }

  /**
   * SummaryOrdersJournal without action
   */
  export type SummaryOrdersJournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummaryOrdersJournal
     */
    select?: SummaryOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummaryOrdersJournal
     */
    omit?: SummaryOrdersJournalOmit<ExtArgs> | null
  }


  /**
   * Model AssemblyOrdersJournal
   */

  export type AggregateAssemblyOrdersJournal = {
    _count: AssemblyOrdersJournalCountAggregateOutputType | null
    _avg: AssemblyOrdersJournalAvgAggregateOutputType | null
    _sum: AssemblyOrdersJournalSumAggregateOutputType | null
    _min: AssemblyOrdersJournalMinAggregateOutputType | null
    _max: AssemblyOrdersJournalMaxAggregateOutputType | null
  }

  export type AssemblyOrdersJournalAvgAggregateOutputType = {
    id: number | null
    sourceSummaryId: number | null
  }

  export type AssemblyOrdersJournalSumAggregateOutputType = {
    id: number | null
    sourceSummaryId: number | null
  }

  export type AssemblyOrdersJournalMinAggregateOutputType = {
    id: number | null
    assemblyDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    isHidden: boolean | null
    sourceSummaryId: number | null
  }

  export type AssemblyOrdersJournalMaxAggregateOutputType = {
    id: number | null
    assemblyDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    isHidden: boolean | null
    sourceSummaryId: number | null
  }

  export type AssemblyOrdersJournalCountAggregateOutputType = {
    id: number
    assemblyDate: number
    createdAt: number
    createdBy: number
    isHidden: number
    sourceSummaryId: number
    data: number
    _all: number
  }


  export type AssemblyOrdersJournalAvgAggregateInputType = {
    id?: true
    sourceSummaryId?: true
  }

  export type AssemblyOrdersJournalSumAggregateInputType = {
    id?: true
    sourceSummaryId?: true
  }

  export type AssemblyOrdersJournalMinAggregateInputType = {
    id?: true
    assemblyDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
    sourceSummaryId?: true
  }

  export type AssemblyOrdersJournalMaxAggregateInputType = {
    id?: true
    assemblyDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
    sourceSummaryId?: true
  }

  export type AssemblyOrdersJournalCountAggregateInputType = {
    id?: true
    assemblyDate?: true
    createdAt?: true
    createdBy?: true
    isHidden?: true
    sourceSummaryId?: true
    data?: true
    _all?: true
  }

  export type AssemblyOrdersJournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssemblyOrdersJournal to aggregate.
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssemblyOrdersJournals to fetch.
     */
    orderBy?: AssemblyOrdersJournalOrderByWithRelationInput | AssemblyOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssemblyOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssemblyOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssemblyOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssemblyOrdersJournals
    **/
    _count?: true | AssemblyOrdersJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssemblyOrdersJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssemblyOrdersJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssemblyOrdersJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssemblyOrdersJournalMaxAggregateInputType
  }

  export type GetAssemblyOrdersJournalAggregateType<T extends AssemblyOrdersJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateAssemblyOrdersJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssemblyOrdersJournal[P]>
      : GetScalarType<T[P], AggregateAssemblyOrdersJournal[P]>
  }




  export type AssemblyOrdersJournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssemblyOrdersJournalWhereInput
    orderBy?: AssemblyOrdersJournalOrderByWithAggregationInput | AssemblyOrdersJournalOrderByWithAggregationInput[]
    by: AssemblyOrdersJournalScalarFieldEnum[] | AssemblyOrdersJournalScalarFieldEnum
    having?: AssemblyOrdersJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssemblyOrdersJournalCountAggregateInputType | true
    _avg?: AssemblyOrdersJournalAvgAggregateInputType
    _sum?: AssemblyOrdersJournalSumAggregateInputType
    _min?: AssemblyOrdersJournalMinAggregateInputType
    _max?: AssemblyOrdersJournalMaxAggregateInputType
  }

  export type AssemblyOrdersJournalGroupByOutputType = {
    id: number
    assemblyDate: Date
    createdAt: Date
    createdBy: string
    isHidden: boolean
    sourceSummaryId: number | null
    data: JsonValue
    _count: AssemblyOrdersJournalCountAggregateOutputType | null
    _avg: AssemblyOrdersJournalAvgAggregateOutputType | null
    _sum: AssemblyOrdersJournalSumAggregateOutputType | null
    _min: AssemblyOrdersJournalMinAggregateOutputType | null
    _max: AssemblyOrdersJournalMaxAggregateOutputType | null
  }

  type GetAssemblyOrdersJournalGroupByPayload<T extends AssemblyOrdersJournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssemblyOrdersJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssemblyOrdersJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssemblyOrdersJournalGroupByOutputType[P]>
            : GetScalarType<T[P], AssemblyOrdersJournalGroupByOutputType[P]>
        }
      >
    >


  export type AssemblyOrdersJournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assemblyDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    sourceSummaryId?: boolean
    data?: boolean
  }, ExtArgs["result"]["assemblyOrdersJournal"]>

  export type AssemblyOrdersJournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assemblyDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    sourceSummaryId?: boolean
    data?: boolean
  }, ExtArgs["result"]["assemblyOrdersJournal"]>

  export type AssemblyOrdersJournalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assemblyDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    sourceSummaryId?: boolean
    data?: boolean
  }, ExtArgs["result"]["assemblyOrdersJournal"]>

  export type AssemblyOrdersJournalSelectScalar = {
    id?: boolean
    assemblyDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isHidden?: boolean
    sourceSummaryId?: boolean
    data?: boolean
  }

  export type AssemblyOrdersJournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assemblyDate" | "createdAt" | "createdBy" | "isHidden" | "sourceSummaryId" | "data", ExtArgs["result"]["assemblyOrdersJournal"]>

  export type $AssemblyOrdersJournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssemblyOrdersJournal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assemblyDate: Date
      createdAt: Date
      createdBy: string
      isHidden: boolean
      sourceSummaryId: number | null
      data: Prisma.JsonValue
    }, ExtArgs["result"]["assemblyOrdersJournal"]>
    composites: {}
  }

  type AssemblyOrdersJournalGetPayload<S extends boolean | null | undefined | AssemblyOrdersJournalDefaultArgs> = $Result.GetResult<Prisma.$AssemblyOrdersJournalPayload, S>

  type AssemblyOrdersJournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssemblyOrdersJournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssemblyOrdersJournalCountAggregateInputType | true
    }

  export interface AssemblyOrdersJournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssemblyOrdersJournal'], meta: { name: 'AssemblyOrdersJournal' } }
    /**
     * Find zero or one AssemblyOrdersJournal that matches the filter.
     * @param {AssemblyOrdersJournalFindUniqueArgs} args - Arguments to find a AssemblyOrdersJournal
     * @example
     * // Get one AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssemblyOrdersJournalFindUniqueArgs>(args: SelectSubset<T, AssemblyOrdersJournalFindUniqueArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssemblyOrdersJournal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssemblyOrdersJournalFindUniqueOrThrowArgs} args - Arguments to find a AssemblyOrdersJournal
     * @example
     * // Get one AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssemblyOrdersJournalFindUniqueOrThrowArgs>(args: SelectSubset<T, AssemblyOrdersJournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssemblyOrdersJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalFindFirstArgs} args - Arguments to find a AssemblyOrdersJournal
     * @example
     * // Get one AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssemblyOrdersJournalFindFirstArgs>(args?: SelectSubset<T, AssemblyOrdersJournalFindFirstArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssemblyOrdersJournal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalFindFirstOrThrowArgs} args - Arguments to find a AssemblyOrdersJournal
     * @example
     * // Get one AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssemblyOrdersJournalFindFirstOrThrowArgs>(args?: SelectSubset<T, AssemblyOrdersJournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssemblyOrdersJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssemblyOrdersJournals
     * const assemblyOrdersJournals = await prisma.assemblyOrdersJournal.findMany()
     * 
     * // Get first 10 AssemblyOrdersJournals
     * const assemblyOrdersJournals = await prisma.assemblyOrdersJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assemblyOrdersJournalWithIdOnly = await prisma.assemblyOrdersJournal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssemblyOrdersJournalFindManyArgs>(args?: SelectSubset<T, AssemblyOrdersJournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssemblyOrdersJournal.
     * @param {AssemblyOrdersJournalCreateArgs} args - Arguments to create a AssemblyOrdersJournal.
     * @example
     * // Create one AssemblyOrdersJournal
     * const AssemblyOrdersJournal = await prisma.assemblyOrdersJournal.create({
     *   data: {
     *     // ... data to create a AssemblyOrdersJournal
     *   }
     * })
     * 
     */
    create<T extends AssemblyOrdersJournalCreateArgs>(args: SelectSubset<T, AssemblyOrdersJournalCreateArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssemblyOrdersJournals.
     * @param {AssemblyOrdersJournalCreateManyArgs} args - Arguments to create many AssemblyOrdersJournals.
     * @example
     * // Create many AssemblyOrdersJournals
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssemblyOrdersJournalCreateManyArgs>(args?: SelectSubset<T, AssemblyOrdersJournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssemblyOrdersJournals and returns the data saved in the database.
     * @param {AssemblyOrdersJournalCreateManyAndReturnArgs} args - Arguments to create many AssemblyOrdersJournals.
     * @example
     * // Create many AssemblyOrdersJournals
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssemblyOrdersJournals and only return the `id`
     * const assemblyOrdersJournalWithIdOnly = await prisma.assemblyOrdersJournal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssemblyOrdersJournalCreateManyAndReturnArgs>(args?: SelectSubset<T, AssemblyOrdersJournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssemblyOrdersJournal.
     * @param {AssemblyOrdersJournalDeleteArgs} args - Arguments to delete one AssemblyOrdersJournal.
     * @example
     * // Delete one AssemblyOrdersJournal
     * const AssemblyOrdersJournal = await prisma.assemblyOrdersJournal.delete({
     *   where: {
     *     // ... filter to delete one AssemblyOrdersJournal
     *   }
     * })
     * 
     */
    delete<T extends AssemblyOrdersJournalDeleteArgs>(args: SelectSubset<T, AssemblyOrdersJournalDeleteArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssemblyOrdersJournal.
     * @param {AssemblyOrdersJournalUpdateArgs} args - Arguments to update one AssemblyOrdersJournal.
     * @example
     * // Update one AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssemblyOrdersJournalUpdateArgs>(args: SelectSubset<T, AssemblyOrdersJournalUpdateArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssemblyOrdersJournals.
     * @param {AssemblyOrdersJournalDeleteManyArgs} args - Arguments to filter AssemblyOrdersJournals to delete.
     * @example
     * // Delete a few AssemblyOrdersJournals
     * const { count } = await prisma.assemblyOrdersJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssemblyOrdersJournalDeleteManyArgs>(args?: SelectSubset<T, AssemblyOrdersJournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssemblyOrdersJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssemblyOrdersJournals
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssemblyOrdersJournalUpdateManyArgs>(args: SelectSubset<T, AssemblyOrdersJournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssemblyOrdersJournals and returns the data updated in the database.
     * @param {AssemblyOrdersJournalUpdateManyAndReturnArgs} args - Arguments to update many AssemblyOrdersJournals.
     * @example
     * // Update many AssemblyOrdersJournals
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssemblyOrdersJournals and only return the `id`
     * const assemblyOrdersJournalWithIdOnly = await prisma.assemblyOrdersJournal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssemblyOrdersJournalUpdateManyAndReturnArgs>(args: SelectSubset<T, AssemblyOrdersJournalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssemblyOrdersJournal.
     * @param {AssemblyOrdersJournalUpsertArgs} args - Arguments to update or create a AssemblyOrdersJournal.
     * @example
     * // Update or create a AssemblyOrdersJournal
     * const assemblyOrdersJournal = await prisma.assemblyOrdersJournal.upsert({
     *   create: {
     *     // ... data to create a AssemblyOrdersJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssemblyOrdersJournal we want to update
     *   }
     * })
     */
    upsert<T extends AssemblyOrdersJournalUpsertArgs>(args: SelectSubset<T, AssemblyOrdersJournalUpsertArgs<ExtArgs>>): Prisma__AssemblyOrdersJournalClient<$Result.GetResult<Prisma.$AssemblyOrdersJournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssemblyOrdersJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalCountArgs} args - Arguments to filter AssemblyOrdersJournals to count.
     * @example
     * // Count the number of AssemblyOrdersJournals
     * const count = await prisma.assemblyOrdersJournal.count({
     *   where: {
     *     // ... the filter for the AssemblyOrdersJournals we want to count
     *   }
     * })
    **/
    count<T extends AssemblyOrdersJournalCountArgs>(
      args?: Subset<T, AssemblyOrdersJournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssemblyOrdersJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssemblyOrdersJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssemblyOrdersJournalAggregateArgs>(args: Subset<T, AssemblyOrdersJournalAggregateArgs>): Prisma.PrismaPromise<GetAssemblyOrdersJournalAggregateType<T>>

    /**
     * Group by AssemblyOrdersJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssemblyOrdersJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssemblyOrdersJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssemblyOrdersJournalGroupByArgs['orderBy'] }
        : { orderBy?: AssemblyOrdersJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssemblyOrdersJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssemblyOrdersJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssemblyOrdersJournal model
   */
  readonly fields: AssemblyOrdersJournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssemblyOrdersJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssemblyOrdersJournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssemblyOrdersJournal model
   */
  interface AssemblyOrdersJournalFieldRefs {
    readonly id: FieldRef<"AssemblyOrdersJournal", 'Int'>
    readonly assemblyDate: FieldRef<"AssemblyOrdersJournal", 'DateTime'>
    readonly createdAt: FieldRef<"AssemblyOrdersJournal", 'DateTime'>
    readonly createdBy: FieldRef<"AssemblyOrdersJournal", 'String'>
    readonly isHidden: FieldRef<"AssemblyOrdersJournal", 'Boolean'>
    readonly sourceSummaryId: FieldRef<"AssemblyOrdersJournal", 'Int'>
    readonly data: FieldRef<"AssemblyOrdersJournal", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AssemblyOrdersJournal findUnique
   */
  export type AssemblyOrdersJournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which AssemblyOrdersJournal to fetch.
     */
    where: AssemblyOrdersJournalWhereUniqueInput
  }

  /**
   * AssemblyOrdersJournal findUniqueOrThrow
   */
  export type AssemblyOrdersJournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which AssemblyOrdersJournal to fetch.
     */
    where: AssemblyOrdersJournalWhereUniqueInput
  }

  /**
   * AssemblyOrdersJournal findFirst
   */
  export type AssemblyOrdersJournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which AssemblyOrdersJournal to fetch.
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssemblyOrdersJournals to fetch.
     */
    orderBy?: AssemblyOrdersJournalOrderByWithRelationInput | AssemblyOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssemblyOrdersJournals.
     */
    cursor?: AssemblyOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssemblyOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssemblyOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssemblyOrdersJournals.
     */
    distinct?: AssemblyOrdersJournalScalarFieldEnum | AssemblyOrdersJournalScalarFieldEnum[]
  }

  /**
   * AssemblyOrdersJournal findFirstOrThrow
   */
  export type AssemblyOrdersJournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which AssemblyOrdersJournal to fetch.
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssemblyOrdersJournals to fetch.
     */
    orderBy?: AssemblyOrdersJournalOrderByWithRelationInput | AssemblyOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssemblyOrdersJournals.
     */
    cursor?: AssemblyOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssemblyOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssemblyOrdersJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssemblyOrdersJournals.
     */
    distinct?: AssemblyOrdersJournalScalarFieldEnum | AssemblyOrdersJournalScalarFieldEnum[]
  }

  /**
   * AssemblyOrdersJournal findMany
   */
  export type AssemblyOrdersJournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter, which AssemblyOrdersJournals to fetch.
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssemblyOrdersJournals to fetch.
     */
    orderBy?: AssemblyOrdersJournalOrderByWithRelationInput | AssemblyOrdersJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssemblyOrdersJournals.
     */
    cursor?: AssemblyOrdersJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssemblyOrdersJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssemblyOrdersJournals.
     */
    skip?: number
    distinct?: AssemblyOrdersJournalScalarFieldEnum | AssemblyOrdersJournalScalarFieldEnum[]
  }

  /**
   * AssemblyOrdersJournal create
   */
  export type AssemblyOrdersJournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * The data needed to create a AssemblyOrdersJournal.
     */
    data: XOR<AssemblyOrdersJournalCreateInput, AssemblyOrdersJournalUncheckedCreateInput>
  }

  /**
   * AssemblyOrdersJournal createMany
   */
  export type AssemblyOrdersJournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssemblyOrdersJournals.
     */
    data: AssemblyOrdersJournalCreateManyInput | AssemblyOrdersJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssemblyOrdersJournal createManyAndReturn
   */
  export type AssemblyOrdersJournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * The data used to create many AssemblyOrdersJournals.
     */
    data: AssemblyOrdersJournalCreateManyInput | AssemblyOrdersJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssemblyOrdersJournal update
   */
  export type AssemblyOrdersJournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * The data needed to update a AssemblyOrdersJournal.
     */
    data: XOR<AssemblyOrdersJournalUpdateInput, AssemblyOrdersJournalUncheckedUpdateInput>
    /**
     * Choose, which AssemblyOrdersJournal to update.
     */
    where: AssemblyOrdersJournalWhereUniqueInput
  }

  /**
   * AssemblyOrdersJournal updateMany
   */
  export type AssemblyOrdersJournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssemblyOrdersJournals.
     */
    data: XOR<AssemblyOrdersJournalUpdateManyMutationInput, AssemblyOrdersJournalUncheckedUpdateManyInput>
    /**
     * Filter which AssemblyOrdersJournals to update
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * Limit how many AssemblyOrdersJournals to update.
     */
    limit?: number
  }

  /**
   * AssemblyOrdersJournal updateManyAndReturn
   */
  export type AssemblyOrdersJournalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * The data used to update AssemblyOrdersJournals.
     */
    data: XOR<AssemblyOrdersJournalUpdateManyMutationInput, AssemblyOrdersJournalUncheckedUpdateManyInput>
    /**
     * Filter which AssemblyOrdersJournals to update
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * Limit how many AssemblyOrdersJournals to update.
     */
    limit?: number
  }

  /**
   * AssemblyOrdersJournal upsert
   */
  export type AssemblyOrdersJournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * The filter to search for the AssemblyOrdersJournal to update in case it exists.
     */
    where: AssemblyOrdersJournalWhereUniqueInput
    /**
     * In case the AssemblyOrdersJournal found by the `where` argument doesn't exist, create a new AssemblyOrdersJournal with this data.
     */
    create: XOR<AssemblyOrdersJournalCreateInput, AssemblyOrdersJournalUncheckedCreateInput>
    /**
     * In case the AssemblyOrdersJournal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssemblyOrdersJournalUpdateInput, AssemblyOrdersJournalUncheckedUpdateInput>
  }

  /**
   * AssemblyOrdersJournal delete
   */
  export type AssemblyOrdersJournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
    /**
     * Filter which AssemblyOrdersJournal to delete.
     */
    where: AssemblyOrdersJournalWhereUniqueInput
  }

  /**
   * AssemblyOrdersJournal deleteMany
   */
  export type AssemblyOrdersJournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssemblyOrdersJournals to delete
     */
    where?: AssemblyOrdersJournalWhereInput
    /**
     * Limit how many AssemblyOrdersJournals to delete.
     */
    limit?: number
  }

  /**
   * AssemblyOrdersJournal without action
   */
  export type AssemblyOrdersJournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssemblyOrdersJournal
     */
    select?: AssemblyOrdersJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssemblyOrdersJournal
     */
    omit?: AssemblyOrdersJournalOmit<ExtArgs> | null
  }


  /**
   * Model ProductionStaff
   */

  export type AggregateProductionStaff = {
    _count: ProductionStaffCountAggregateOutputType | null
    _avg: ProductionStaffAvgAggregateOutputType | null
    _sum: ProductionStaffSumAggregateOutputType | null
    _min: ProductionStaffMinAggregateOutputType | null
    _max: ProductionStaffMaxAggregateOutputType | null
  }

  export type ProductionStaffAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProductionStaffSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProductionStaffMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    phone: string | null
    userId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionStaffMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    phone: string | null
    userId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionStaffCountAggregateOutputType = {
    id: number
    fullName: number
    phone: number
    userId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionStaffAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProductionStaffSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProductionStaffMinAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionStaffMaxAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionStaffCountAggregateInputType = {
    id?: true
    fullName?: true
    phone?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionStaff to aggregate.
     */
    where?: ProductionStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionStaffs to fetch.
     */
    orderBy?: ProductionStaffOrderByWithRelationInput | ProductionStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionStaffs
    **/
    _count?: true | ProductionStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionStaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionStaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionStaffMaxAggregateInputType
  }

  export type GetProductionStaffAggregateType<T extends ProductionStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionStaff[P]>
      : GetScalarType<T[P], AggregateProductionStaff[P]>
  }




  export type ProductionStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionStaffWhereInput
    orderBy?: ProductionStaffOrderByWithAggregationInput | ProductionStaffOrderByWithAggregationInput[]
    by: ProductionStaffScalarFieldEnum[] | ProductionStaffScalarFieldEnum
    having?: ProductionStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionStaffCountAggregateInputType | true
    _avg?: ProductionStaffAvgAggregateInputType
    _sum?: ProductionStaffSumAggregateInputType
    _min?: ProductionStaffMinAggregateInputType
    _max?: ProductionStaffMaxAggregateInputType
  }

  export type ProductionStaffGroupByOutputType = {
    id: number
    fullName: string
    phone: string | null
    userId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductionStaffCountAggregateOutputType | null
    _avg: ProductionStaffAvgAggregateOutputType | null
    _sum: ProductionStaffSumAggregateOutputType | null
    _min: ProductionStaffMinAggregateOutputType | null
    _max: ProductionStaffMaxAggregateOutputType | null
  }

  type GetProductionStaffGroupByPayload<T extends ProductionStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionStaffGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionStaffGroupByOutputType[P]>
        }
      >
    >


  export type ProductionStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    phone?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    journals?: boolean | ProductionStaff$journalsArgs<ExtArgs>
    _count?: boolean | ProductionStaffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionStaff"]>

  export type ProductionStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    phone?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionStaff"]>

  export type ProductionStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    phone?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionStaff"]>

  export type ProductionStaffSelectScalar = {
    id?: boolean
    fullName?: boolean
    phone?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "phone" | "userId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["productionStaff"]>
  export type ProductionStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    journals?: boolean | ProductionStaff$journalsArgs<ExtArgs>
    _count?: boolean | ProductionStaffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductionStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductionStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionStaff"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      journals: Prisma.$ProductionJournalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      phone: string | null
      userId: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionStaff"]>
    composites: {}
  }

  type ProductionStaffGetPayload<S extends boolean | null | undefined | ProductionStaffDefaultArgs> = $Result.GetResult<Prisma.$ProductionStaffPayload, S>

  type ProductionStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionStaffCountAggregateInputType | true
    }

  export interface ProductionStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionStaff'], meta: { name: 'ProductionStaff' } }
    /**
     * Find zero or one ProductionStaff that matches the filter.
     * @param {ProductionStaffFindUniqueArgs} args - Arguments to find a ProductionStaff
     * @example
     * // Get one ProductionStaff
     * const productionStaff = await prisma.productionStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionStaffFindUniqueArgs>(args: SelectSubset<T, ProductionStaffFindUniqueArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionStaffFindUniqueOrThrowArgs} args - Arguments to find a ProductionStaff
     * @example
     * // Get one ProductionStaff
     * const productionStaff = await prisma.productionStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffFindFirstArgs} args - Arguments to find a ProductionStaff
     * @example
     * // Get one ProductionStaff
     * const productionStaff = await prisma.productionStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionStaffFindFirstArgs>(args?: SelectSubset<T, ProductionStaffFindFirstArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffFindFirstOrThrowArgs} args - Arguments to find a ProductionStaff
     * @example
     * // Get one ProductionStaff
     * const productionStaff = await prisma.productionStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionStaffs
     * const productionStaffs = await prisma.productionStaff.findMany()
     * 
     * // Get first 10 ProductionStaffs
     * const productionStaffs = await prisma.productionStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionStaffWithIdOnly = await prisma.productionStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionStaffFindManyArgs>(args?: SelectSubset<T, ProductionStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionStaff.
     * @param {ProductionStaffCreateArgs} args - Arguments to create a ProductionStaff.
     * @example
     * // Create one ProductionStaff
     * const ProductionStaff = await prisma.productionStaff.create({
     *   data: {
     *     // ... data to create a ProductionStaff
     *   }
     * })
     * 
     */
    create<T extends ProductionStaffCreateArgs>(args: SelectSubset<T, ProductionStaffCreateArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionStaffs.
     * @param {ProductionStaffCreateManyArgs} args - Arguments to create many ProductionStaffs.
     * @example
     * // Create many ProductionStaffs
     * const productionStaff = await prisma.productionStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionStaffCreateManyArgs>(args?: SelectSubset<T, ProductionStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionStaffs and returns the data saved in the database.
     * @param {ProductionStaffCreateManyAndReturnArgs} args - Arguments to create many ProductionStaffs.
     * @example
     * // Create many ProductionStaffs
     * const productionStaff = await prisma.productionStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionStaffs and only return the `id`
     * const productionStaffWithIdOnly = await prisma.productionStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionStaff.
     * @param {ProductionStaffDeleteArgs} args - Arguments to delete one ProductionStaff.
     * @example
     * // Delete one ProductionStaff
     * const ProductionStaff = await prisma.productionStaff.delete({
     *   where: {
     *     // ... filter to delete one ProductionStaff
     *   }
     * })
     * 
     */
    delete<T extends ProductionStaffDeleteArgs>(args: SelectSubset<T, ProductionStaffDeleteArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionStaff.
     * @param {ProductionStaffUpdateArgs} args - Arguments to update one ProductionStaff.
     * @example
     * // Update one ProductionStaff
     * const productionStaff = await prisma.productionStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionStaffUpdateArgs>(args: SelectSubset<T, ProductionStaffUpdateArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionStaffs.
     * @param {ProductionStaffDeleteManyArgs} args - Arguments to filter ProductionStaffs to delete.
     * @example
     * // Delete a few ProductionStaffs
     * const { count } = await prisma.productionStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionStaffDeleteManyArgs>(args?: SelectSubset<T, ProductionStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionStaffs
     * const productionStaff = await prisma.productionStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionStaffUpdateManyArgs>(args: SelectSubset<T, ProductionStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionStaffs and returns the data updated in the database.
     * @param {ProductionStaffUpdateManyAndReturnArgs} args - Arguments to update many ProductionStaffs.
     * @example
     * // Update many ProductionStaffs
     * const productionStaff = await prisma.productionStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionStaffs and only return the `id`
     * const productionStaffWithIdOnly = await prisma.productionStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionStaff.
     * @param {ProductionStaffUpsertArgs} args - Arguments to update or create a ProductionStaff.
     * @example
     * // Update or create a ProductionStaff
     * const productionStaff = await prisma.productionStaff.upsert({
     *   create: {
     *     // ... data to create a ProductionStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionStaff we want to update
     *   }
     * })
     */
    upsert<T extends ProductionStaffUpsertArgs>(args: SelectSubset<T, ProductionStaffUpsertArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffCountArgs} args - Arguments to filter ProductionStaffs to count.
     * @example
     * // Count the number of ProductionStaffs
     * const count = await prisma.productionStaff.count({
     *   where: {
     *     // ... the filter for the ProductionStaffs we want to count
     *   }
     * })
    **/
    count<T extends ProductionStaffCountArgs>(
      args?: Subset<T, ProductionStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionStaffAggregateArgs>(args: Subset<T, ProductionStaffAggregateArgs>): Prisma.PrismaPromise<GetProductionStaffAggregateType<T>>

    /**
     * Group by ProductionStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionStaffGroupByArgs['orderBy'] }
        : { orderBy?: ProductionStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionStaff model
   */
  readonly fields: ProductionStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    journals<T extends ProductionStaff$journalsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionStaff$journalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionStaff model
   */
  interface ProductionStaffFieldRefs {
    readonly id: FieldRef<"ProductionStaff", 'Int'>
    readonly fullName: FieldRef<"ProductionStaff", 'String'>
    readonly phone: FieldRef<"ProductionStaff", 'String'>
    readonly userId: FieldRef<"ProductionStaff", 'Int'>
    readonly isActive: FieldRef<"ProductionStaff", 'Boolean'>
    readonly createdAt: FieldRef<"ProductionStaff", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionStaff findUnique
   */
  export type ProductionStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProductionStaff to fetch.
     */
    where: ProductionStaffWhereUniqueInput
  }

  /**
   * ProductionStaff findUniqueOrThrow
   */
  export type ProductionStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProductionStaff to fetch.
     */
    where: ProductionStaffWhereUniqueInput
  }

  /**
   * ProductionStaff findFirst
   */
  export type ProductionStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProductionStaff to fetch.
     */
    where?: ProductionStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionStaffs to fetch.
     */
    orderBy?: ProductionStaffOrderByWithRelationInput | ProductionStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionStaffs.
     */
    cursor?: ProductionStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionStaffs.
     */
    distinct?: ProductionStaffScalarFieldEnum | ProductionStaffScalarFieldEnum[]
  }

  /**
   * ProductionStaff findFirstOrThrow
   */
  export type ProductionStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProductionStaff to fetch.
     */
    where?: ProductionStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionStaffs to fetch.
     */
    orderBy?: ProductionStaffOrderByWithRelationInput | ProductionStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionStaffs.
     */
    cursor?: ProductionStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionStaffs.
     */
    distinct?: ProductionStaffScalarFieldEnum | ProductionStaffScalarFieldEnum[]
  }

  /**
   * ProductionStaff findMany
   */
  export type ProductionStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProductionStaffs to fetch.
     */
    where?: ProductionStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionStaffs to fetch.
     */
    orderBy?: ProductionStaffOrderByWithRelationInput | ProductionStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionStaffs.
     */
    cursor?: ProductionStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionStaffs.
     */
    skip?: number
    distinct?: ProductionStaffScalarFieldEnum | ProductionStaffScalarFieldEnum[]
  }

  /**
   * ProductionStaff create
   */
  export type ProductionStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionStaff.
     */
    data: XOR<ProductionStaffCreateInput, ProductionStaffUncheckedCreateInput>
  }

  /**
   * ProductionStaff createMany
   */
  export type ProductionStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionStaffs.
     */
    data: ProductionStaffCreateManyInput | ProductionStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionStaff createManyAndReturn
   */
  export type ProductionStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionStaffs.
     */
    data: ProductionStaffCreateManyInput | ProductionStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionStaff update
   */
  export type ProductionStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionStaff.
     */
    data: XOR<ProductionStaffUpdateInput, ProductionStaffUncheckedUpdateInput>
    /**
     * Choose, which ProductionStaff to update.
     */
    where: ProductionStaffWhereUniqueInput
  }

  /**
   * ProductionStaff updateMany
   */
  export type ProductionStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionStaffs.
     */
    data: XOR<ProductionStaffUpdateManyMutationInput, ProductionStaffUncheckedUpdateManyInput>
    /**
     * Filter which ProductionStaffs to update
     */
    where?: ProductionStaffWhereInput
    /**
     * Limit how many ProductionStaffs to update.
     */
    limit?: number
  }

  /**
   * ProductionStaff updateManyAndReturn
   */
  export type ProductionStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * The data used to update ProductionStaffs.
     */
    data: XOR<ProductionStaffUpdateManyMutationInput, ProductionStaffUncheckedUpdateManyInput>
    /**
     * Filter which ProductionStaffs to update
     */
    where?: ProductionStaffWhereInput
    /**
     * Limit how many ProductionStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionStaff upsert
   */
  export type ProductionStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionStaff to update in case it exists.
     */
    where: ProductionStaffWhereUniqueInput
    /**
     * In case the ProductionStaff found by the `where` argument doesn't exist, create a new ProductionStaff with this data.
     */
    create: XOR<ProductionStaffCreateInput, ProductionStaffUncheckedCreateInput>
    /**
     * In case the ProductionStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionStaffUpdateInput, ProductionStaffUncheckedUpdateInput>
  }

  /**
   * ProductionStaff delete
   */
  export type ProductionStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
    /**
     * Filter which ProductionStaff to delete.
     */
    where: ProductionStaffWhereUniqueInput
  }

  /**
   * ProductionStaff deleteMany
   */
  export type ProductionStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionStaffs to delete
     */
    where?: ProductionStaffWhereInput
    /**
     * Limit how many ProductionStaffs to delete.
     */
    limit?: number
  }

  /**
   * ProductionStaff.journals
   */
  export type ProductionStaff$journalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    where?: ProductionJournalWhereInput
    orderBy?: ProductionJournalOrderByWithRelationInput | ProductionJournalOrderByWithRelationInput[]
    cursor?: ProductionJournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionJournalScalarFieldEnum | ProductionJournalScalarFieldEnum[]
  }

  /**
   * ProductionStaff without action
   */
  export type ProductionStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionStaff
     */
    select?: ProductionStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionStaff
     */
    omit?: ProductionStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionStaffInclude<ExtArgs> | null
  }


  /**
   * Model ProductionJournal
   */

  export type AggregateProductionJournal = {
    _count: ProductionJournalCountAggregateOutputType | null
    _avg: ProductionJournalAvgAggregateOutputType | null
    _sum: ProductionJournalSumAggregateOutputType | null
    _min: ProductionJournalMinAggregateOutputType | null
    _max: ProductionJournalMaxAggregateOutputType | null
  }

  export type ProductionJournalAvgAggregateOutputType = {
    id: number | null
    staffId: number | null
  }

  export type ProductionJournalSumAggregateOutputType = {
    id: number | null
    staffId: number | null
  }

  export type ProductionJournalMinAggregateOutputType = {
    id: number | null
    productionDate: Date | null
    staffId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ProductionJournalMaxAggregateOutputType = {
    id: number | null
    productionDate: Date | null
    staffId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ProductionJournalCountAggregateOutputType = {
    id: number
    productionDate: number
    staffId: number
    status: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type ProductionJournalAvgAggregateInputType = {
    id?: true
    staffId?: true
  }

  export type ProductionJournalSumAggregateInputType = {
    id?: true
    staffId?: true
  }

  export type ProductionJournalMinAggregateInputType = {
    id?: true
    productionDate?: true
    staffId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ProductionJournalMaxAggregateInputType = {
    id?: true
    productionDate?: true
    staffId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ProductionJournalCountAggregateInputType = {
    id?: true
    productionDate?: true
    staffId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type ProductionJournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionJournal to aggregate.
     */
    where?: ProductionJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionJournals to fetch.
     */
    orderBy?: ProductionJournalOrderByWithRelationInput | ProductionJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionJournals
    **/
    _count?: true | ProductionJournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionJournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionJournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionJournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionJournalMaxAggregateInputType
  }

  export type GetProductionJournalAggregateType<T extends ProductionJournalAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionJournal[P]>
      : GetScalarType<T[P], AggregateProductionJournal[P]>
  }




  export type ProductionJournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionJournalWhereInput
    orderBy?: ProductionJournalOrderByWithAggregationInput | ProductionJournalOrderByWithAggregationInput[]
    by: ProductionJournalScalarFieldEnum[] | ProductionJournalScalarFieldEnum
    having?: ProductionJournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionJournalCountAggregateInputType | true
    _avg?: ProductionJournalAvgAggregateInputType
    _sum?: ProductionJournalSumAggregateInputType
    _min?: ProductionJournalMinAggregateInputType
    _max?: ProductionJournalMaxAggregateInputType
  }

  export type ProductionJournalGroupByOutputType = {
    id: number
    productionDate: Date
    staffId: number
    status: string
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    _count: ProductionJournalCountAggregateOutputType | null
    _avg: ProductionJournalAvgAggregateOutputType | null
    _sum: ProductionJournalSumAggregateOutputType | null
    _min: ProductionJournalMinAggregateOutputType | null
    _max: ProductionJournalMaxAggregateOutputType | null
  }

  type GetProductionJournalGroupByPayload<T extends ProductionJournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionJournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionJournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionJournalGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionJournalGroupByOutputType[P]>
        }
      >
    >


  export type ProductionJournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDate?: boolean
    staffId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
    items?: boolean | ProductionJournal$itemsArgs<ExtArgs>
    _count?: boolean | ProductionJournalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionJournal"]>

  export type ProductionJournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDate?: boolean
    staffId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionJournal"]>

  export type ProductionJournalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDate?: boolean
    staffId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionJournal"]>

  export type ProductionJournalSelectScalar = {
    id?: boolean
    productionDate?: boolean
    staffId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type ProductionJournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionDate" | "staffId" | "status" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["productionJournal"]>
  export type ProductionJournalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
    items?: boolean | ProductionJournal$itemsArgs<ExtArgs>
    _count?: boolean | ProductionJournalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionJournalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
  }
  export type ProductionJournalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | ProductionStaffDefaultArgs<ExtArgs>
  }

  export type $ProductionJournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionJournal"
    objects: {
      staff: Prisma.$ProductionStaffPayload<ExtArgs>
      items: Prisma.$ProductionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionDate: Date
      staffId: number
      status: string
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
    }, ExtArgs["result"]["productionJournal"]>
    composites: {}
  }

  type ProductionJournalGetPayload<S extends boolean | null | undefined | ProductionJournalDefaultArgs> = $Result.GetResult<Prisma.$ProductionJournalPayload, S>

  type ProductionJournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionJournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionJournalCountAggregateInputType | true
    }

  export interface ProductionJournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionJournal'], meta: { name: 'ProductionJournal' } }
    /**
     * Find zero or one ProductionJournal that matches the filter.
     * @param {ProductionJournalFindUniqueArgs} args - Arguments to find a ProductionJournal
     * @example
     * // Get one ProductionJournal
     * const productionJournal = await prisma.productionJournal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionJournalFindUniqueArgs>(args: SelectSubset<T, ProductionJournalFindUniqueArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionJournal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionJournalFindUniqueOrThrowArgs} args - Arguments to find a ProductionJournal
     * @example
     * // Get one ProductionJournal
     * const productionJournal = await prisma.productionJournal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionJournalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionJournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionJournal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalFindFirstArgs} args - Arguments to find a ProductionJournal
     * @example
     * // Get one ProductionJournal
     * const productionJournal = await prisma.productionJournal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionJournalFindFirstArgs>(args?: SelectSubset<T, ProductionJournalFindFirstArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionJournal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalFindFirstOrThrowArgs} args - Arguments to find a ProductionJournal
     * @example
     * // Get one ProductionJournal
     * const productionJournal = await prisma.productionJournal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionJournalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionJournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionJournals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionJournals
     * const productionJournals = await prisma.productionJournal.findMany()
     * 
     * // Get first 10 ProductionJournals
     * const productionJournals = await prisma.productionJournal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionJournalWithIdOnly = await prisma.productionJournal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionJournalFindManyArgs>(args?: SelectSubset<T, ProductionJournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionJournal.
     * @param {ProductionJournalCreateArgs} args - Arguments to create a ProductionJournal.
     * @example
     * // Create one ProductionJournal
     * const ProductionJournal = await prisma.productionJournal.create({
     *   data: {
     *     // ... data to create a ProductionJournal
     *   }
     * })
     * 
     */
    create<T extends ProductionJournalCreateArgs>(args: SelectSubset<T, ProductionJournalCreateArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionJournals.
     * @param {ProductionJournalCreateManyArgs} args - Arguments to create many ProductionJournals.
     * @example
     * // Create many ProductionJournals
     * const productionJournal = await prisma.productionJournal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionJournalCreateManyArgs>(args?: SelectSubset<T, ProductionJournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionJournals and returns the data saved in the database.
     * @param {ProductionJournalCreateManyAndReturnArgs} args - Arguments to create many ProductionJournals.
     * @example
     * // Create many ProductionJournals
     * const productionJournal = await prisma.productionJournal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionJournals and only return the `id`
     * const productionJournalWithIdOnly = await prisma.productionJournal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionJournalCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionJournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionJournal.
     * @param {ProductionJournalDeleteArgs} args - Arguments to delete one ProductionJournal.
     * @example
     * // Delete one ProductionJournal
     * const ProductionJournal = await prisma.productionJournal.delete({
     *   where: {
     *     // ... filter to delete one ProductionJournal
     *   }
     * })
     * 
     */
    delete<T extends ProductionJournalDeleteArgs>(args: SelectSubset<T, ProductionJournalDeleteArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionJournal.
     * @param {ProductionJournalUpdateArgs} args - Arguments to update one ProductionJournal.
     * @example
     * // Update one ProductionJournal
     * const productionJournal = await prisma.productionJournal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionJournalUpdateArgs>(args: SelectSubset<T, ProductionJournalUpdateArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionJournals.
     * @param {ProductionJournalDeleteManyArgs} args - Arguments to filter ProductionJournals to delete.
     * @example
     * // Delete a few ProductionJournals
     * const { count } = await prisma.productionJournal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionJournalDeleteManyArgs>(args?: SelectSubset<T, ProductionJournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionJournals
     * const productionJournal = await prisma.productionJournal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionJournalUpdateManyArgs>(args: SelectSubset<T, ProductionJournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionJournals and returns the data updated in the database.
     * @param {ProductionJournalUpdateManyAndReturnArgs} args - Arguments to update many ProductionJournals.
     * @example
     * // Update many ProductionJournals
     * const productionJournal = await prisma.productionJournal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionJournals and only return the `id`
     * const productionJournalWithIdOnly = await prisma.productionJournal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionJournalUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionJournalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionJournal.
     * @param {ProductionJournalUpsertArgs} args - Arguments to update or create a ProductionJournal.
     * @example
     * // Update or create a ProductionJournal
     * const productionJournal = await prisma.productionJournal.upsert({
     *   create: {
     *     // ... data to create a ProductionJournal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionJournal we want to update
     *   }
     * })
     */
    upsert<T extends ProductionJournalUpsertArgs>(args: SelectSubset<T, ProductionJournalUpsertArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionJournals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalCountArgs} args - Arguments to filter ProductionJournals to count.
     * @example
     * // Count the number of ProductionJournals
     * const count = await prisma.productionJournal.count({
     *   where: {
     *     // ... the filter for the ProductionJournals we want to count
     *   }
     * })
    **/
    count<T extends ProductionJournalCountArgs>(
      args?: Subset<T, ProductionJournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionJournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionJournalAggregateArgs>(args: Subset<T, ProductionJournalAggregateArgs>): Prisma.PrismaPromise<GetProductionJournalAggregateType<T>>

    /**
     * Group by ProductionJournal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionJournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionJournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionJournalGroupByArgs['orderBy'] }
        : { orderBy?: ProductionJournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionJournal model
   */
  readonly fields: ProductionJournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionJournal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionJournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends ProductionStaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionStaffDefaultArgs<ExtArgs>>): Prisma__ProductionStaffClient<$Result.GetResult<Prisma.$ProductionStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends ProductionJournal$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionJournal$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionJournal model
   */
  interface ProductionJournalFieldRefs {
    readonly id: FieldRef<"ProductionJournal", 'Int'>
    readonly productionDate: FieldRef<"ProductionJournal", 'DateTime'>
    readonly staffId: FieldRef<"ProductionJournal", 'Int'>
    readonly status: FieldRef<"ProductionJournal", 'String'>
    readonly createdAt: FieldRef<"ProductionJournal", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionJournal", 'DateTime'>
    readonly createdBy: FieldRef<"ProductionJournal", 'String'>
    readonly updatedBy: FieldRef<"ProductionJournal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductionJournal findUnique
   */
  export type ProductionJournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter, which ProductionJournal to fetch.
     */
    where: ProductionJournalWhereUniqueInput
  }

  /**
   * ProductionJournal findUniqueOrThrow
   */
  export type ProductionJournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter, which ProductionJournal to fetch.
     */
    where: ProductionJournalWhereUniqueInput
  }

  /**
   * ProductionJournal findFirst
   */
  export type ProductionJournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter, which ProductionJournal to fetch.
     */
    where?: ProductionJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionJournals to fetch.
     */
    orderBy?: ProductionJournalOrderByWithRelationInput | ProductionJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionJournals.
     */
    cursor?: ProductionJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionJournals.
     */
    distinct?: ProductionJournalScalarFieldEnum | ProductionJournalScalarFieldEnum[]
  }

  /**
   * ProductionJournal findFirstOrThrow
   */
  export type ProductionJournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter, which ProductionJournal to fetch.
     */
    where?: ProductionJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionJournals to fetch.
     */
    orderBy?: ProductionJournalOrderByWithRelationInput | ProductionJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionJournals.
     */
    cursor?: ProductionJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionJournals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionJournals.
     */
    distinct?: ProductionJournalScalarFieldEnum | ProductionJournalScalarFieldEnum[]
  }

  /**
   * ProductionJournal findMany
   */
  export type ProductionJournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter, which ProductionJournals to fetch.
     */
    where?: ProductionJournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionJournals to fetch.
     */
    orderBy?: ProductionJournalOrderByWithRelationInput | ProductionJournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionJournals.
     */
    cursor?: ProductionJournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionJournals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionJournals.
     */
    skip?: number
    distinct?: ProductionJournalScalarFieldEnum | ProductionJournalScalarFieldEnum[]
  }

  /**
   * ProductionJournal create
   */
  export type ProductionJournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionJournal.
     */
    data: XOR<ProductionJournalCreateInput, ProductionJournalUncheckedCreateInput>
  }

  /**
   * ProductionJournal createMany
   */
  export type ProductionJournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionJournals.
     */
    data: ProductionJournalCreateManyInput | ProductionJournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionJournal createManyAndReturn
   */
  export type ProductionJournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionJournals.
     */
    data: ProductionJournalCreateManyInput | ProductionJournalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionJournal update
   */
  export type ProductionJournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionJournal.
     */
    data: XOR<ProductionJournalUpdateInput, ProductionJournalUncheckedUpdateInput>
    /**
     * Choose, which ProductionJournal to update.
     */
    where: ProductionJournalWhereUniqueInput
  }

  /**
   * ProductionJournal updateMany
   */
  export type ProductionJournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionJournals.
     */
    data: XOR<ProductionJournalUpdateManyMutationInput, ProductionJournalUncheckedUpdateManyInput>
    /**
     * Filter which ProductionJournals to update
     */
    where?: ProductionJournalWhereInput
    /**
     * Limit how many ProductionJournals to update.
     */
    limit?: number
  }

  /**
   * ProductionJournal updateManyAndReturn
   */
  export type ProductionJournalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * The data used to update ProductionJournals.
     */
    data: XOR<ProductionJournalUpdateManyMutationInput, ProductionJournalUncheckedUpdateManyInput>
    /**
     * Filter which ProductionJournals to update
     */
    where?: ProductionJournalWhereInput
    /**
     * Limit how many ProductionJournals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionJournal upsert
   */
  export type ProductionJournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionJournal to update in case it exists.
     */
    where: ProductionJournalWhereUniqueInput
    /**
     * In case the ProductionJournal found by the `where` argument doesn't exist, create a new ProductionJournal with this data.
     */
    create: XOR<ProductionJournalCreateInput, ProductionJournalUncheckedCreateInput>
    /**
     * In case the ProductionJournal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionJournalUpdateInput, ProductionJournalUncheckedUpdateInput>
  }

  /**
   * ProductionJournal delete
   */
  export type ProductionJournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
    /**
     * Filter which ProductionJournal to delete.
     */
    where: ProductionJournalWhereUniqueInput
  }

  /**
   * ProductionJournal deleteMany
   */
  export type ProductionJournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionJournals to delete
     */
    where?: ProductionJournalWhereInput
    /**
     * Limit how many ProductionJournals to delete.
     */
    limit?: number
  }

  /**
   * ProductionJournal.items
   */
  export type ProductionJournal$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    where?: ProductionItemWhereInput
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    cursor?: ProductionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionItemScalarFieldEnum | ProductionItemScalarFieldEnum[]
  }

  /**
   * ProductionJournal without action
   */
  export type ProductionJournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionJournal
     */
    select?: ProductionJournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionJournal
     */
    omit?: ProductionJournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionJournalInclude<ExtArgs> | null
  }


  /**
   * Model ProductionItem
   */

  export type AggregateProductionItem = {
    _count: ProductionItemCountAggregateOutputType | null
    _avg: ProductionItemAvgAggregateOutputType | null
    _sum: ProductionItemSumAggregateOutputType | null
    _min: ProductionItemMinAggregateOutputType | null
    _max: ProductionItemMaxAggregateOutputType | null
  }

  export type ProductionItemAvgAggregateOutputType = {
    id: number | null
    journalId: number | null
    productId: number | null
    sortOrder: number | null
  }

  export type ProductionItemSumAggregateOutputType = {
    id: number | null
    journalId: number | null
    productId: number | null
    sortOrder: number | null
  }

  export type ProductionItemMinAggregateOutputType = {
    id: number | null
    journalId: number | null
    productId: number | null
    productName: string | null
    state: string | null
    sortOrder: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ProductionItemMaxAggregateOutputType = {
    id: number | null
    journalId: number | null
    productId: number | null
    productName: string | null
    state: string | null
    sortOrder: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ProductionItemCountAggregateOutputType = {
    id: number
    journalId: number
    productId: number
    productName: number
    state: number
    sortOrder: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type ProductionItemAvgAggregateInputType = {
    id?: true
    journalId?: true
    productId?: true
    sortOrder?: true
  }

  export type ProductionItemSumAggregateInputType = {
    id?: true
    journalId?: true
    productId?: true
    sortOrder?: true
  }

  export type ProductionItemMinAggregateInputType = {
    id?: true
    journalId?: true
    productId?: true
    productName?: true
    state?: true
    sortOrder?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ProductionItemMaxAggregateInputType = {
    id?: true
    journalId?: true
    productId?: true
    productName?: true
    state?: true
    sortOrder?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ProductionItemCountAggregateInputType = {
    id?: true
    journalId?: true
    productId?: true
    productName?: true
    state?: true
    sortOrder?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type ProductionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionItem to aggregate.
     */
    where?: ProductionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItems to fetch.
     */
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionItems
    **/
    _count?: true | ProductionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionItemMaxAggregateInputType
  }

  export type GetProductionItemAggregateType<T extends ProductionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionItem[P]>
      : GetScalarType<T[P], AggregateProductionItem[P]>
  }




  export type ProductionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionItemWhereInput
    orderBy?: ProductionItemOrderByWithAggregationInput | ProductionItemOrderByWithAggregationInput[]
    by: ProductionItemScalarFieldEnum[] | ProductionItemScalarFieldEnum
    having?: ProductionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionItemCountAggregateInputType | true
    _avg?: ProductionItemAvgAggregateInputType
    _sum?: ProductionItemSumAggregateInputType
    _min?: ProductionItemMinAggregateInputType
    _max?: ProductionItemMaxAggregateInputType
  }

  export type ProductionItemGroupByOutputType = {
    id: number
    journalId: number
    productId: number | null
    productName: string | null
    state: string
    sortOrder: number
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    _count: ProductionItemCountAggregateOutputType | null
    _avg: ProductionItemAvgAggregateOutputType | null
    _sum: ProductionItemSumAggregateOutputType | null
    _min: ProductionItemMinAggregateOutputType | null
    _max: ProductionItemMaxAggregateOutputType | null
  }

  type GetProductionItemGroupByPayload<T extends ProductionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionItemGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionItemGroupByOutputType[P]>
        }
      >
    >


  export type ProductionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    productId?: boolean
    productName?: boolean
    state?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
    values?: boolean | ProductionItem$valuesArgs<ExtArgs>
    _count?: boolean | ProductionItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionItem"]>

  export type ProductionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    productId?: boolean
    productName?: boolean
    state?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["productionItem"]>

  export type ProductionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    productId?: boolean
    productName?: boolean
    state?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["productionItem"]>

  export type ProductionItemSelectScalar = {
    id?: boolean
    journalId?: boolean
    productId?: boolean
    productName?: boolean
    state?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type ProductionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalId" | "productId" | "productName" | "state" | "sortOrder" | "isDeleted" | "deletedAt" | "deletedBy" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["productionItem"]>
  export type ProductionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
    values?: boolean | ProductionItem$valuesArgs<ExtArgs>
    _count?: boolean | ProductionItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
  }
  export type ProductionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | ProductionJournalDefaultArgs<ExtArgs>
    product?: boolean | ProductionItem$productArgs<ExtArgs>
  }

  export type $ProductionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionItem"
    objects: {
      journal: Prisma.$ProductionJournalPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
      values: Prisma.$ProductionItemValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      journalId: number
      productId: number | null
      productName: string | null
      state: string
      sortOrder: number
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
    }, ExtArgs["result"]["productionItem"]>
    composites: {}
  }

  type ProductionItemGetPayload<S extends boolean | null | undefined | ProductionItemDefaultArgs> = $Result.GetResult<Prisma.$ProductionItemPayload, S>

  type ProductionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionItemCountAggregateInputType | true
    }

  export interface ProductionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionItem'], meta: { name: 'ProductionItem' } }
    /**
     * Find zero or one ProductionItem that matches the filter.
     * @param {ProductionItemFindUniqueArgs} args - Arguments to find a ProductionItem
     * @example
     * // Get one ProductionItem
     * const productionItem = await prisma.productionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionItemFindUniqueArgs>(args: SelectSubset<T, ProductionItemFindUniqueArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionItemFindUniqueOrThrowArgs} args - Arguments to find a ProductionItem
     * @example
     * // Get one ProductionItem
     * const productionItem = await prisma.productionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemFindFirstArgs} args - Arguments to find a ProductionItem
     * @example
     * // Get one ProductionItem
     * const productionItem = await prisma.productionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionItemFindFirstArgs>(args?: SelectSubset<T, ProductionItemFindFirstArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemFindFirstOrThrowArgs} args - Arguments to find a ProductionItem
     * @example
     * // Get one ProductionItem
     * const productionItem = await prisma.productionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionItems
     * const productionItems = await prisma.productionItem.findMany()
     * 
     * // Get first 10 ProductionItems
     * const productionItems = await prisma.productionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionItemWithIdOnly = await prisma.productionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionItemFindManyArgs>(args?: SelectSubset<T, ProductionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionItem.
     * @param {ProductionItemCreateArgs} args - Arguments to create a ProductionItem.
     * @example
     * // Create one ProductionItem
     * const ProductionItem = await prisma.productionItem.create({
     *   data: {
     *     // ... data to create a ProductionItem
     *   }
     * })
     * 
     */
    create<T extends ProductionItemCreateArgs>(args: SelectSubset<T, ProductionItemCreateArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionItems.
     * @param {ProductionItemCreateManyArgs} args - Arguments to create many ProductionItems.
     * @example
     * // Create many ProductionItems
     * const productionItem = await prisma.productionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionItemCreateManyArgs>(args?: SelectSubset<T, ProductionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionItems and returns the data saved in the database.
     * @param {ProductionItemCreateManyAndReturnArgs} args - Arguments to create many ProductionItems.
     * @example
     * // Create many ProductionItems
     * const productionItem = await prisma.productionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionItems and only return the `id`
     * const productionItemWithIdOnly = await prisma.productionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionItem.
     * @param {ProductionItemDeleteArgs} args - Arguments to delete one ProductionItem.
     * @example
     * // Delete one ProductionItem
     * const ProductionItem = await prisma.productionItem.delete({
     *   where: {
     *     // ... filter to delete one ProductionItem
     *   }
     * })
     * 
     */
    delete<T extends ProductionItemDeleteArgs>(args: SelectSubset<T, ProductionItemDeleteArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionItem.
     * @param {ProductionItemUpdateArgs} args - Arguments to update one ProductionItem.
     * @example
     * // Update one ProductionItem
     * const productionItem = await prisma.productionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionItemUpdateArgs>(args: SelectSubset<T, ProductionItemUpdateArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionItems.
     * @param {ProductionItemDeleteManyArgs} args - Arguments to filter ProductionItems to delete.
     * @example
     * // Delete a few ProductionItems
     * const { count } = await prisma.productionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionItemDeleteManyArgs>(args?: SelectSubset<T, ProductionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionItems
     * const productionItem = await prisma.productionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionItemUpdateManyArgs>(args: SelectSubset<T, ProductionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionItems and returns the data updated in the database.
     * @param {ProductionItemUpdateManyAndReturnArgs} args - Arguments to update many ProductionItems.
     * @example
     * // Update many ProductionItems
     * const productionItem = await prisma.productionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionItems and only return the `id`
     * const productionItemWithIdOnly = await prisma.productionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionItem.
     * @param {ProductionItemUpsertArgs} args - Arguments to update or create a ProductionItem.
     * @example
     * // Update or create a ProductionItem
     * const productionItem = await prisma.productionItem.upsert({
     *   create: {
     *     // ... data to create a ProductionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionItem we want to update
     *   }
     * })
     */
    upsert<T extends ProductionItemUpsertArgs>(args: SelectSubset<T, ProductionItemUpsertArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemCountArgs} args - Arguments to filter ProductionItems to count.
     * @example
     * // Count the number of ProductionItems
     * const count = await prisma.productionItem.count({
     *   where: {
     *     // ... the filter for the ProductionItems we want to count
     *   }
     * })
    **/
    count<T extends ProductionItemCountArgs>(
      args?: Subset<T, ProductionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionItemAggregateArgs>(args: Subset<T, ProductionItemAggregateArgs>): Prisma.PrismaPromise<GetProductionItemAggregateType<T>>

    /**
     * Group by ProductionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionItemGroupByArgs['orderBy'] }
        : { orderBy?: ProductionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionItem model
   */
  readonly fields: ProductionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journal<T extends ProductionJournalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionJournalDefaultArgs<ExtArgs>>): Prisma__ProductionJournalClient<$Result.GetResult<Prisma.$ProductionJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductionItem$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductionItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    values<T extends ProductionItem$valuesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionItem$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionItem model
   */
  interface ProductionItemFieldRefs {
    readonly id: FieldRef<"ProductionItem", 'Int'>
    readonly journalId: FieldRef<"ProductionItem", 'Int'>
    readonly productId: FieldRef<"ProductionItem", 'Int'>
    readonly productName: FieldRef<"ProductionItem", 'String'>
    readonly state: FieldRef<"ProductionItem", 'String'>
    readonly sortOrder: FieldRef<"ProductionItem", 'Int'>
    readonly isDeleted: FieldRef<"ProductionItem", 'Boolean'>
    readonly deletedAt: FieldRef<"ProductionItem", 'DateTime'>
    readonly deletedBy: FieldRef<"ProductionItem", 'String'>
    readonly createdAt: FieldRef<"ProductionItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionItem", 'DateTime'>
    readonly createdBy: FieldRef<"ProductionItem", 'String'>
    readonly updatedBy: FieldRef<"ProductionItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductionItem findUnique
   */
  export type ProductionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItem to fetch.
     */
    where: ProductionItemWhereUniqueInput
  }

  /**
   * ProductionItem findUniqueOrThrow
   */
  export type ProductionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItem to fetch.
     */
    where: ProductionItemWhereUniqueInput
  }

  /**
   * ProductionItem findFirst
   */
  export type ProductionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItem to fetch.
     */
    where?: ProductionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItems to fetch.
     */
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionItems.
     */
    cursor?: ProductionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionItems.
     */
    distinct?: ProductionItemScalarFieldEnum | ProductionItemScalarFieldEnum[]
  }

  /**
   * ProductionItem findFirstOrThrow
   */
  export type ProductionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItem to fetch.
     */
    where?: ProductionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItems to fetch.
     */
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionItems.
     */
    cursor?: ProductionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionItems.
     */
    distinct?: ProductionItemScalarFieldEnum | ProductionItemScalarFieldEnum[]
  }

  /**
   * ProductionItem findMany
   */
  export type ProductionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItems to fetch.
     */
    where?: ProductionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItems to fetch.
     */
    orderBy?: ProductionItemOrderByWithRelationInput | ProductionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionItems.
     */
    cursor?: ProductionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItems.
     */
    skip?: number
    distinct?: ProductionItemScalarFieldEnum | ProductionItemScalarFieldEnum[]
  }

  /**
   * ProductionItem create
   */
  export type ProductionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionItem.
     */
    data: XOR<ProductionItemCreateInput, ProductionItemUncheckedCreateInput>
  }

  /**
   * ProductionItem createMany
   */
  export type ProductionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionItems.
     */
    data: ProductionItemCreateManyInput | ProductionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionItem createManyAndReturn
   */
  export type ProductionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionItems.
     */
    data: ProductionItemCreateManyInput | ProductionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionItem update
   */
  export type ProductionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionItem.
     */
    data: XOR<ProductionItemUpdateInput, ProductionItemUncheckedUpdateInput>
    /**
     * Choose, which ProductionItem to update.
     */
    where: ProductionItemWhereUniqueInput
  }

  /**
   * ProductionItem updateMany
   */
  export type ProductionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionItems.
     */
    data: XOR<ProductionItemUpdateManyMutationInput, ProductionItemUncheckedUpdateManyInput>
    /**
     * Filter which ProductionItems to update
     */
    where?: ProductionItemWhereInput
    /**
     * Limit how many ProductionItems to update.
     */
    limit?: number
  }

  /**
   * ProductionItem updateManyAndReturn
   */
  export type ProductionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * The data used to update ProductionItems.
     */
    data: XOR<ProductionItemUpdateManyMutationInput, ProductionItemUncheckedUpdateManyInput>
    /**
     * Filter which ProductionItems to update
     */
    where?: ProductionItemWhereInput
    /**
     * Limit how many ProductionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionItem upsert
   */
  export type ProductionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionItem to update in case it exists.
     */
    where: ProductionItemWhereUniqueInput
    /**
     * In case the ProductionItem found by the `where` argument doesn't exist, create a new ProductionItem with this data.
     */
    create: XOR<ProductionItemCreateInput, ProductionItemUncheckedCreateInput>
    /**
     * In case the ProductionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionItemUpdateInput, ProductionItemUncheckedUpdateInput>
  }

  /**
   * ProductionItem delete
   */
  export type ProductionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
    /**
     * Filter which ProductionItem to delete.
     */
    where: ProductionItemWhereUniqueInput
  }

  /**
   * ProductionItem deleteMany
   */
  export type ProductionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionItems to delete
     */
    where?: ProductionItemWhereInput
    /**
     * Limit how many ProductionItems to delete.
     */
    limit?: number
  }

  /**
   * ProductionItem.product
   */
  export type ProductionItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * ProductionItem.values
   */
  export type ProductionItem$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    where?: ProductionItemValueWhereInput
    orderBy?: ProductionItemValueOrderByWithRelationInput | ProductionItemValueOrderByWithRelationInput[]
    cursor?: ProductionItemValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionItemValueScalarFieldEnum | ProductionItemValueScalarFieldEnum[]
  }

  /**
   * ProductionItem without action
   */
  export type ProductionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItem
     */
    select?: ProductionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItem
     */
    omit?: ProductionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemInclude<ExtArgs> | null
  }


  /**
   * Model ProductionItemValue
   */

  export type AggregateProductionItemValue = {
    _count: ProductionItemValueCountAggregateOutputType | null
    _avg: ProductionItemValueAvgAggregateOutputType | null
    _sum: ProductionItemValueSumAggregateOutputType | null
    _min: ProductionItemValueMinAggregateOutputType | null
    _max: ProductionItemValueMaxAggregateOutputType | null
  }

  export type ProductionItemValueAvgAggregateOutputType = {
    id: number | null
    productionItemId: number | null
  }

  export type ProductionItemValueSumAggregateOutputType = {
    id: number | null
    productionItemId: number | null
  }

  export type ProductionItemValueMinAggregateOutputType = {
    id: number | null
    productionItemId: number | null
    fieldKey: string | null
    fieldValue: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ProductionItemValueMaxAggregateOutputType = {
    id: number | null
    productionItemId: number | null
    fieldKey: string | null
    fieldValue: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ProductionItemValueCountAggregateOutputType = {
    id: number
    productionItemId: number
    fieldKey: number
    fieldValue: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ProductionItemValueAvgAggregateInputType = {
    id?: true
    productionItemId?: true
  }

  export type ProductionItemValueSumAggregateInputType = {
    id?: true
    productionItemId?: true
  }

  export type ProductionItemValueMinAggregateInputType = {
    id?: true
    productionItemId?: true
    fieldKey?: true
    fieldValue?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProductionItemValueMaxAggregateInputType = {
    id?: true
    productionItemId?: true
    fieldKey?: true
    fieldValue?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProductionItemValueCountAggregateInputType = {
    id?: true
    productionItemId?: true
    fieldKey?: true
    fieldValue?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ProductionItemValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionItemValue to aggregate.
     */
    where?: ProductionItemValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItemValues to fetch.
     */
    orderBy?: ProductionItemValueOrderByWithRelationInput | ProductionItemValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionItemValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItemValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItemValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionItemValues
    **/
    _count?: true | ProductionItemValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionItemValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionItemValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionItemValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionItemValueMaxAggregateInputType
  }

  export type GetProductionItemValueAggregateType<T extends ProductionItemValueAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionItemValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionItemValue[P]>
      : GetScalarType<T[P], AggregateProductionItemValue[P]>
  }




  export type ProductionItemValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionItemValueWhereInput
    orderBy?: ProductionItemValueOrderByWithAggregationInput | ProductionItemValueOrderByWithAggregationInput[]
    by: ProductionItemValueScalarFieldEnum[] | ProductionItemValueScalarFieldEnum
    having?: ProductionItemValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionItemValueCountAggregateInputType | true
    _avg?: ProductionItemValueAvgAggregateInputType
    _sum?: ProductionItemValueSumAggregateInputType
    _min?: ProductionItemValueMinAggregateInputType
    _max?: ProductionItemValueMaxAggregateInputType
  }

  export type ProductionItemValueGroupByOutputType = {
    id: number
    productionItemId: number
    fieldKey: string
    fieldValue: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: ProductionItemValueCountAggregateOutputType | null
    _avg: ProductionItemValueAvgAggregateOutputType | null
    _sum: ProductionItemValueSumAggregateOutputType | null
    _min: ProductionItemValueMinAggregateOutputType | null
    _max: ProductionItemValueMaxAggregateOutputType | null
  }

  type GetProductionItemValueGroupByPayload<T extends ProductionItemValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionItemValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionItemValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionItemValueGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionItemValueGroupByOutputType[P]>
        }
      >
    >


  export type ProductionItemValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionItemId?: boolean
    fieldKey?: boolean
    fieldValue?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionItemValue"]>

  export type ProductionItemValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionItemId?: boolean
    fieldKey?: boolean
    fieldValue?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionItemValue"]>

  export type ProductionItemValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionItemId?: boolean
    fieldKey?: boolean
    fieldValue?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionItemValue"]>

  export type ProductionItemValueSelectScalar = {
    id?: boolean
    productionItemId?: boolean
    fieldKey?: boolean
    fieldValue?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ProductionItemValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionItemId" | "fieldKey" | "fieldValue" | "updatedAt" | "updatedBy", ExtArgs["result"]["productionItemValue"]>
  export type ProductionItemValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }
  export type ProductionItemValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }
  export type ProductionItemValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionItem?: boolean | ProductionItemDefaultArgs<ExtArgs>
  }

  export type $ProductionItemValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionItemValue"
    objects: {
      productionItem: Prisma.$ProductionItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionItemId: number
      fieldKey: string
      fieldValue: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["productionItemValue"]>
    composites: {}
  }

  type ProductionItemValueGetPayload<S extends boolean | null | undefined | ProductionItemValueDefaultArgs> = $Result.GetResult<Prisma.$ProductionItemValuePayload, S>

  type ProductionItemValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionItemValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionItemValueCountAggregateInputType | true
    }

  export interface ProductionItemValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionItemValue'], meta: { name: 'ProductionItemValue' } }
    /**
     * Find zero or one ProductionItemValue that matches the filter.
     * @param {ProductionItemValueFindUniqueArgs} args - Arguments to find a ProductionItemValue
     * @example
     * // Get one ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionItemValueFindUniqueArgs>(args: SelectSubset<T, ProductionItemValueFindUniqueArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionItemValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionItemValueFindUniqueOrThrowArgs} args - Arguments to find a ProductionItemValue
     * @example
     * // Get one ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionItemValueFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionItemValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionItemValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueFindFirstArgs} args - Arguments to find a ProductionItemValue
     * @example
     * // Get one ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionItemValueFindFirstArgs>(args?: SelectSubset<T, ProductionItemValueFindFirstArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionItemValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueFindFirstOrThrowArgs} args - Arguments to find a ProductionItemValue
     * @example
     * // Get one ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionItemValueFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionItemValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionItemValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionItemValues
     * const productionItemValues = await prisma.productionItemValue.findMany()
     * 
     * // Get first 10 ProductionItemValues
     * const productionItemValues = await prisma.productionItemValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionItemValueWithIdOnly = await prisma.productionItemValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionItemValueFindManyArgs>(args?: SelectSubset<T, ProductionItemValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionItemValue.
     * @param {ProductionItemValueCreateArgs} args - Arguments to create a ProductionItemValue.
     * @example
     * // Create one ProductionItemValue
     * const ProductionItemValue = await prisma.productionItemValue.create({
     *   data: {
     *     // ... data to create a ProductionItemValue
     *   }
     * })
     * 
     */
    create<T extends ProductionItemValueCreateArgs>(args: SelectSubset<T, ProductionItemValueCreateArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionItemValues.
     * @param {ProductionItemValueCreateManyArgs} args - Arguments to create many ProductionItemValues.
     * @example
     * // Create many ProductionItemValues
     * const productionItemValue = await prisma.productionItemValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionItemValueCreateManyArgs>(args?: SelectSubset<T, ProductionItemValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionItemValues and returns the data saved in the database.
     * @param {ProductionItemValueCreateManyAndReturnArgs} args - Arguments to create many ProductionItemValues.
     * @example
     * // Create many ProductionItemValues
     * const productionItemValue = await prisma.productionItemValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionItemValues and only return the `id`
     * const productionItemValueWithIdOnly = await prisma.productionItemValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionItemValueCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionItemValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionItemValue.
     * @param {ProductionItemValueDeleteArgs} args - Arguments to delete one ProductionItemValue.
     * @example
     * // Delete one ProductionItemValue
     * const ProductionItemValue = await prisma.productionItemValue.delete({
     *   where: {
     *     // ... filter to delete one ProductionItemValue
     *   }
     * })
     * 
     */
    delete<T extends ProductionItemValueDeleteArgs>(args: SelectSubset<T, ProductionItemValueDeleteArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionItemValue.
     * @param {ProductionItemValueUpdateArgs} args - Arguments to update one ProductionItemValue.
     * @example
     * // Update one ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionItemValueUpdateArgs>(args: SelectSubset<T, ProductionItemValueUpdateArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionItemValues.
     * @param {ProductionItemValueDeleteManyArgs} args - Arguments to filter ProductionItemValues to delete.
     * @example
     * // Delete a few ProductionItemValues
     * const { count } = await prisma.productionItemValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionItemValueDeleteManyArgs>(args?: SelectSubset<T, ProductionItemValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionItemValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionItemValues
     * const productionItemValue = await prisma.productionItemValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionItemValueUpdateManyArgs>(args: SelectSubset<T, ProductionItemValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionItemValues and returns the data updated in the database.
     * @param {ProductionItemValueUpdateManyAndReturnArgs} args - Arguments to update many ProductionItemValues.
     * @example
     * // Update many ProductionItemValues
     * const productionItemValue = await prisma.productionItemValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionItemValues and only return the `id`
     * const productionItemValueWithIdOnly = await prisma.productionItemValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionItemValueUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionItemValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionItemValue.
     * @param {ProductionItemValueUpsertArgs} args - Arguments to update or create a ProductionItemValue.
     * @example
     * // Update or create a ProductionItemValue
     * const productionItemValue = await prisma.productionItemValue.upsert({
     *   create: {
     *     // ... data to create a ProductionItemValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionItemValue we want to update
     *   }
     * })
     */
    upsert<T extends ProductionItemValueUpsertArgs>(args: SelectSubset<T, ProductionItemValueUpsertArgs<ExtArgs>>): Prisma__ProductionItemValueClient<$Result.GetResult<Prisma.$ProductionItemValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionItemValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueCountArgs} args - Arguments to filter ProductionItemValues to count.
     * @example
     * // Count the number of ProductionItemValues
     * const count = await prisma.productionItemValue.count({
     *   where: {
     *     // ... the filter for the ProductionItemValues we want to count
     *   }
     * })
    **/
    count<T extends ProductionItemValueCountArgs>(
      args?: Subset<T, ProductionItemValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionItemValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionItemValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionItemValueAggregateArgs>(args: Subset<T, ProductionItemValueAggregateArgs>): Prisma.PrismaPromise<GetProductionItemValueAggregateType<T>>

    /**
     * Group by ProductionItemValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionItemValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionItemValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionItemValueGroupByArgs['orderBy'] }
        : { orderBy?: ProductionItemValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionItemValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionItemValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionItemValue model
   */
  readonly fields: ProductionItemValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionItemValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionItemValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionItem<T extends ProductionItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionItemDefaultArgs<ExtArgs>>): Prisma__ProductionItemClient<$Result.GetResult<Prisma.$ProductionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionItemValue model
   */
  interface ProductionItemValueFieldRefs {
    readonly id: FieldRef<"ProductionItemValue", 'Int'>
    readonly productionItemId: FieldRef<"ProductionItemValue", 'Int'>
    readonly fieldKey: FieldRef<"ProductionItemValue", 'String'>
    readonly fieldValue: FieldRef<"ProductionItemValue", 'String'>
    readonly updatedAt: FieldRef<"ProductionItemValue", 'DateTime'>
    readonly updatedBy: FieldRef<"ProductionItemValue", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductionItemValue findUnique
   */
  export type ProductionItemValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItemValue to fetch.
     */
    where: ProductionItemValueWhereUniqueInput
  }

  /**
   * ProductionItemValue findUniqueOrThrow
   */
  export type ProductionItemValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItemValue to fetch.
     */
    where: ProductionItemValueWhereUniqueInput
  }

  /**
   * ProductionItemValue findFirst
   */
  export type ProductionItemValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItemValue to fetch.
     */
    where?: ProductionItemValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItemValues to fetch.
     */
    orderBy?: ProductionItemValueOrderByWithRelationInput | ProductionItemValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionItemValues.
     */
    cursor?: ProductionItemValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItemValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItemValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionItemValues.
     */
    distinct?: ProductionItemValueScalarFieldEnum | ProductionItemValueScalarFieldEnum[]
  }

  /**
   * ProductionItemValue findFirstOrThrow
   */
  export type ProductionItemValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItemValue to fetch.
     */
    where?: ProductionItemValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItemValues to fetch.
     */
    orderBy?: ProductionItemValueOrderByWithRelationInput | ProductionItemValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionItemValues.
     */
    cursor?: ProductionItemValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItemValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItemValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionItemValues.
     */
    distinct?: ProductionItemValueScalarFieldEnum | ProductionItemValueScalarFieldEnum[]
  }

  /**
   * ProductionItemValue findMany
   */
  export type ProductionItemValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionItemValues to fetch.
     */
    where?: ProductionItemValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionItemValues to fetch.
     */
    orderBy?: ProductionItemValueOrderByWithRelationInput | ProductionItemValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionItemValues.
     */
    cursor?: ProductionItemValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionItemValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionItemValues.
     */
    skip?: number
    distinct?: ProductionItemValueScalarFieldEnum | ProductionItemValueScalarFieldEnum[]
  }

  /**
   * ProductionItemValue create
   */
  export type ProductionItemValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionItemValue.
     */
    data: XOR<ProductionItemValueCreateInput, ProductionItemValueUncheckedCreateInput>
  }

  /**
   * ProductionItemValue createMany
   */
  export type ProductionItemValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionItemValues.
     */
    data: ProductionItemValueCreateManyInput | ProductionItemValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionItemValue createManyAndReturn
   */
  export type ProductionItemValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionItemValues.
     */
    data: ProductionItemValueCreateManyInput | ProductionItemValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionItemValue update
   */
  export type ProductionItemValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionItemValue.
     */
    data: XOR<ProductionItemValueUpdateInput, ProductionItemValueUncheckedUpdateInput>
    /**
     * Choose, which ProductionItemValue to update.
     */
    where: ProductionItemValueWhereUniqueInput
  }

  /**
   * ProductionItemValue updateMany
   */
  export type ProductionItemValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionItemValues.
     */
    data: XOR<ProductionItemValueUpdateManyMutationInput, ProductionItemValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductionItemValues to update
     */
    where?: ProductionItemValueWhereInput
    /**
     * Limit how many ProductionItemValues to update.
     */
    limit?: number
  }

  /**
   * ProductionItemValue updateManyAndReturn
   */
  export type ProductionItemValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * The data used to update ProductionItemValues.
     */
    data: XOR<ProductionItemValueUpdateManyMutationInput, ProductionItemValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductionItemValues to update
     */
    where?: ProductionItemValueWhereInput
    /**
     * Limit how many ProductionItemValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionItemValue upsert
   */
  export type ProductionItemValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionItemValue to update in case it exists.
     */
    where: ProductionItemValueWhereUniqueInput
    /**
     * In case the ProductionItemValue found by the `where` argument doesn't exist, create a new ProductionItemValue with this data.
     */
    create: XOR<ProductionItemValueCreateInput, ProductionItemValueUncheckedCreateInput>
    /**
     * In case the ProductionItemValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionItemValueUpdateInput, ProductionItemValueUncheckedUpdateInput>
  }

  /**
   * ProductionItemValue delete
   */
  export type ProductionItemValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
    /**
     * Filter which ProductionItemValue to delete.
     */
    where: ProductionItemValueWhereUniqueInput
  }

  /**
   * ProductionItemValue deleteMany
   */
  export type ProductionItemValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionItemValues to delete
     */
    where?: ProductionItemValueWhereInput
    /**
     * Limit how many ProductionItemValues to delete.
     */
    limit?: number
  }

  /**
   * ProductionItemValue without action
   */
  export type ProductionItemValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionItemValue
     */
    select?: ProductionItemValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionItemValue
     */
    omit?: ProductionItemValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionItemValueInclude<ExtArgs> | null
  }


  /**
   * Model PurchasePriceList
   */

  export type AggregatePurchasePriceList = {
    _count: PurchasePriceListCountAggregateOutputType | null
    _avg: PurchasePriceListAvgAggregateOutputType | null
    _sum: PurchasePriceListSumAggregateOutputType | null
    _min: PurchasePriceListMinAggregateOutputType | null
    _max: PurchasePriceListMaxAggregateOutputType | null
  }

  export type PurchasePriceListAvgAggregateOutputType = {
    id: number | null
  }

  export type PurchasePriceListSumAggregateOutputType = {
    id: number | null
  }

  export type PurchasePriceListMinAggregateOutputType = {
    id: number | null
    date: Date | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type PurchasePriceListMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type PurchasePriceListCountAggregateOutputType = {
    id: number
    date: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type PurchasePriceListAvgAggregateInputType = {
    id?: true
  }

  export type PurchasePriceListSumAggregateInputType = {
    id?: true
  }

  export type PurchasePriceListMinAggregateInputType = {
    id?: true
    date?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type PurchasePriceListMaxAggregateInputType = {
    id?: true
    date?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type PurchasePriceListCountAggregateInputType = {
    id?: true
    date?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type PurchasePriceListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceList to aggregate.
     */
    where?: PurchasePriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceLists to fetch.
     */
    orderBy?: PurchasePriceListOrderByWithRelationInput | PurchasePriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasePriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasePriceLists
    **/
    _count?: true | PurchasePriceListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasePriceListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasePriceListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasePriceListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasePriceListMaxAggregateInputType
  }

  export type GetPurchasePriceListAggregateType<T extends PurchasePriceListAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasePriceList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasePriceList[P]>
      : GetScalarType<T[P], AggregatePurchasePriceList[P]>
  }




  export type PurchasePriceListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceListWhereInput
    orderBy?: PurchasePriceListOrderByWithAggregationInput | PurchasePriceListOrderByWithAggregationInput[]
    by: PurchasePriceListScalarFieldEnum[] | PurchasePriceListScalarFieldEnum
    having?: PurchasePriceListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasePriceListCountAggregateInputType | true
    _avg?: PurchasePriceListAvgAggregateInputType
    _sum?: PurchasePriceListSumAggregateInputType
    _min?: PurchasePriceListMinAggregateInputType
    _max?: PurchasePriceListMaxAggregateInputType
  }

  export type PurchasePriceListGroupByOutputType = {
    id: number
    date: Date
    name: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    _count: PurchasePriceListCountAggregateOutputType | null
    _avg: PurchasePriceListAvgAggregateOutputType | null
    _sum: PurchasePriceListSumAggregateOutputType | null
    _min: PurchasePriceListMinAggregateOutputType | null
    _max: PurchasePriceListMaxAggregateOutputType | null
  }

  type GetPurchasePriceListGroupByPayload<T extends PurchasePriceListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasePriceListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasePriceListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasePriceListGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasePriceListGroupByOutputType[P]>
        }
      >
    >


  export type PurchasePriceListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    suppliers?: boolean | PurchasePriceList$suppliersArgs<ExtArgs>
    items?: boolean | PurchasePriceList$itemsArgs<ExtArgs>
    _count?: boolean | PurchasePriceListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceList"]>

  export type PurchasePriceListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["purchasePriceList"]>

  export type PurchasePriceListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["purchasePriceList"]>

  export type PurchasePriceListSelectScalar = {
    id?: boolean
    date?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type PurchasePriceListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "name" | "isActive" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["purchasePriceList"]>
  export type PurchasePriceListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suppliers?: boolean | PurchasePriceList$suppliersArgs<ExtArgs>
    items?: boolean | PurchasePriceList$itemsArgs<ExtArgs>
    _count?: boolean | PurchasePriceListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchasePriceListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PurchasePriceListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PurchasePriceListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasePriceList"
    objects: {
      suppliers: Prisma.$PurchasePriceListSupplierPayload<ExtArgs>[]
      items: Prisma.$PurchasePriceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      name: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
    }, ExtArgs["result"]["purchasePriceList"]>
    composites: {}
  }

  type PurchasePriceListGetPayload<S extends boolean | null | undefined | PurchasePriceListDefaultArgs> = $Result.GetResult<Prisma.$PurchasePriceListPayload, S>

  type PurchasePriceListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchasePriceListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchasePriceListCountAggregateInputType | true
    }

  export interface PurchasePriceListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasePriceList'], meta: { name: 'PurchasePriceList' } }
    /**
     * Find zero or one PurchasePriceList that matches the filter.
     * @param {PurchasePriceListFindUniqueArgs} args - Arguments to find a PurchasePriceList
     * @example
     * // Get one PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasePriceListFindUniqueArgs>(args: SelectSubset<T, PurchasePriceListFindUniqueArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchasePriceList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchasePriceListFindUniqueOrThrowArgs} args - Arguments to find a PurchasePriceList
     * @example
     * // Get one PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasePriceListFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasePriceListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListFindFirstArgs} args - Arguments to find a PurchasePriceList
     * @example
     * // Get one PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasePriceListFindFirstArgs>(args?: SelectSubset<T, PurchasePriceListFindFirstArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListFindFirstOrThrowArgs} args - Arguments to find a PurchasePriceList
     * @example
     * // Get one PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasePriceListFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasePriceListFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchasePriceLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasePriceLists
     * const purchasePriceLists = await prisma.purchasePriceList.findMany()
     * 
     * // Get first 10 PurchasePriceLists
     * const purchasePriceLists = await prisma.purchasePriceList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasePriceListWithIdOnly = await prisma.purchasePriceList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasePriceListFindManyArgs>(args?: SelectSubset<T, PurchasePriceListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchasePriceList.
     * @param {PurchasePriceListCreateArgs} args - Arguments to create a PurchasePriceList.
     * @example
     * // Create one PurchasePriceList
     * const PurchasePriceList = await prisma.purchasePriceList.create({
     *   data: {
     *     // ... data to create a PurchasePriceList
     *   }
     * })
     * 
     */
    create<T extends PurchasePriceListCreateArgs>(args: SelectSubset<T, PurchasePriceListCreateArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchasePriceLists.
     * @param {PurchasePriceListCreateManyArgs} args - Arguments to create many PurchasePriceLists.
     * @example
     * // Create many PurchasePriceLists
     * const purchasePriceList = await prisma.purchasePriceList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasePriceListCreateManyArgs>(args?: SelectSubset<T, PurchasePriceListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasePriceLists and returns the data saved in the database.
     * @param {PurchasePriceListCreateManyAndReturnArgs} args - Arguments to create many PurchasePriceLists.
     * @example
     * // Create many PurchasePriceLists
     * const purchasePriceList = await prisma.purchasePriceList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasePriceLists and only return the `id`
     * const purchasePriceListWithIdOnly = await prisma.purchasePriceList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasePriceListCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasePriceListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchasePriceList.
     * @param {PurchasePriceListDeleteArgs} args - Arguments to delete one PurchasePriceList.
     * @example
     * // Delete one PurchasePriceList
     * const PurchasePriceList = await prisma.purchasePriceList.delete({
     *   where: {
     *     // ... filter to delete one PurchasePriceList
     *   }
     * })
     * 
     */
    delete<T extends PurchasePriceListDeleteArgs>(args: SelectSubset<T, PurchasePriceListDeleteArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchasePriceList.
     * @param {PurchasePriceListUpdateArgs} args - Arguments to update one PurchasePriceList.
     * @example
     * // Update one PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasePriceListUpdateArgs>(args: SelectSubset<T, PurchasePriceListUpdateArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchasePriceLists.
     * @param {PurchasePriceListDeleteManyArgs} args - Arguments to filter PurchasePriceLists to delete.
     * @example
     * // Delete a few PurchasePriceLists
     * const { count } = await prisma.purchasePriceList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasePriceListDeleteManyArgs>(args?: SelectSubset<T, PurchasePriceListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasePriceLists
     * const purchasePriceList = await prisma.purchasePriceList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasePriceListUpdateManyArgs>(args: SelectSubset<T, PurchasePriceListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceLists and returns the data updated in the database.
     * @param {PurchasePriceListUpdateManyAndReturnArgs} args - Arguments to update many PurchasePriceLists.
     * @example
     * // Update many PurchasePriceLists
     * const purchasePriceList = await prisma.purchasePriceList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchasePriceLists and only return the `id`
     * const purchasePriceListWithIdOnly = await prisma.purchasePriceList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchasePriceListUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchasePriceListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchasePriceList.
     * @param {PurchasePriceListUpsertArgs} args - Arguments to update or create a PurchasePriceList.
     * @example
     * // Update or create a PurchasePriceList
     * const purchasePriceList = await prisma.purchasePriceList.upsert({
     *   create: {
     *     // ... data to create a PurchasePriceList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasePriceList we want to update
     *   }
     * })
     */
    upsert<T extends PurchasePriceListUpsertArgs>(args: SelectSubset<T, PurchasePriceListUpsertArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchasePriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListCountArgs} args - Arguments to filter PurchasePriceLists to count.
     * @example
     * // Count the number of PurchasePriceLists
     * const count = await prisma.purchasePriceList.count({
     *   where: {
     *     // ... the filter for the PurchasePriceLists we want to count
     *   }
     * })
    **/
    count<T extends PurchasePriceListCountArgs>(
      args?: Subset<T, PurchasePriceListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasePriceListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasePriceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasePriceListAggregateArgs>(args: Subset<T, PurchasePriceListAggregateArgs>): Prisma.PrismaPromise<GetPurchasePriceListAggregateType<T>>

    /**
     * Group by PurchasePriceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasePriceListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasePriceListGroupByArgs['orderBy'] }
        : { orderBy?: PurchasePriceListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasePriceListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasePriceListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasePriceList model
   */
  readonly fields: PurchasePriceListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasePriceList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasePriceListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    suppliers<T extends PurchasePriceList$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, PurchasePriceList$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends PurchasePriceList$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchasePriceList$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasePriceList model
   */
  interface PurchasePriceListFieldRefs {
    readonly id: FieldRef<"PurchasePriceList", 'Int'>
    readonly date: FieldRef<"PurchasePriceList", 'DateTime'>
    readonly name: FieldRef<"PurchasePriceList", 'String'>
    readonly isActive: FieldRef<"PurchasePriceList", 'Boolean'>
    readonly createdAt: FieldRef<"PurchasePriceList", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchasePriceList", 'DateTime'>
    readonly createdBy: FieldRef<"PurchasePriceList", 'String'>
    readonly updatedBy: FieldRef<"PurchasePriceList", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchasePriceList findUnique
   */
  export type PurchasePriceListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceList to fetch.
     */
    where: PurchasePriceListWhereUniqueInput
  }

  /**
   * PurchasePriceList findUniqueOrThrow
   */
  export type PurchasePriceListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceList to fetch.
     */
    where: PurchasePriceListWhereUniqueInput
  }

  /**
   * PurchasePriceList findFirst
   */
  export type PurchasePriceListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceList to fetch.
     */
    where?: PurchasePriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceLists to fetch.
     */
    orderBy?: PurchasePriceListOrderByWithRelationInput | PurchasePriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceLists.
     */
    cursor?: PurchasePriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceLists.
     */
    distinct?: PurchasePriceListScalarFieldEnum | PurchasePriceListScalarFieldEnum[]
  }

  /**
   * PurchasePriceList findFirstOrThrow
   */
  export type PurchasePriceListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceList to fetch.
     */
    where?: PurchasePriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceLists to fetch.
     */
    orderBy?: PurchasePriceListOrderByWithRelationInput | PurchasePriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceLists.
     */
    cursor?: PurchasePriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceLists.
     */
    distinct?: PurchasePriceListScalarFieldEnum | PurchasePriceListScalarFieldEnum[]
  }

  /**
   * PurchasePriceList findMany
   */
  export type PurchasePriceListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceLists to fetch.
     */
    where?: PurchasePriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceLists to fetch.
     */
    orderBy?: PurchasePriceListOrderByWithRelationInput | PurchasePriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasePriceLists.
     */
    cursor?: PurchasePriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceLists.
     */
    skip?: number
    distinct?: PurchasePriceListScalarFieldEnum | PurchasePriceListScalarFieldEnum[]
  }

  /**
   * PurchasePriceList create
   */
  export type PurchasePriceListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasePriceList.
     */
    data: XOR<PurchasePriceListCreateInput, PurchasePriceListUncheckedCreateInput>
  }

  /**
   * PurchasePriceList createMany
   */
  export type PurchasePriceListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasePriceLists.
     */
    data: PurchasePriceListCreateManyInput | PurchasePriceListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasePriceList createManyAndReturn
   */
  export type PurchasePriceListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * The data used to create many PurchasePriceLists.
     */
    data: PurchasePriceListCreateManyInput | PurchasePriceListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasePriceList update
   */
  export type PurchasePriceListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasePriceList.
     */
    data: XOR<PurchasePriceListUpdateInput, PurchasePriceListUncheckedUpdateInput>
    /**
     * Choose, which PurchasePriceList to update.
     */
    where: PurchasePriceListWhereUniqueInput
  }

  /**
   * PurchasePriceList updateMany
   */
  export type PurchasePriceListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasePriceLists.
     */
    data: XOR<PurchasePriceListUpdateManyMutationInput, PurchasePriceListUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceLists to update
     */
    where?: PurchasePriceListWhereInput
    /**
     * Limit how many PurchasePriceLists to update.
     */
    limit?: number
  }

  /**
   * PurchasePriceList updateManyAndReturn
   */
  export type PurchasePriceListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * The data used to update PurchasePriceLists.
     */
    data: XOR<PurchasePriceListUpdateManyMutationInput, PurchasePriceListUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceLists to update
     */
    where?: PurchasePriceListWhereInput
    /**
     * Limit how many PurchasePriceLists to update.
     */
    limit?: number
  }

  /**
   * PurchasePriceList upsert
   */
  export type PurchasePriceListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasePriceList to update in case it exists.
     */
    where: PurchasePriceListWhereUniqueInput
    /**
     * In case the PurchasePriceList found by the `where` argument doesn't exist, create a new PurchasePriceList with this data.
     */
    create: XOR<PurchasePriceListCreateInput, PurchasePriceListUncheckedCreateInput>
    /**
     * In case the PurchasePriceList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasePriceListUpdateInput, PurchasePriceListUncheckedUpdateInput>
  }

  /**
   * PurchasePriceList delete
   */
  export type PurchasePriceListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
    /**
     * Filter which PurchasePriceList to delete.
     */
    where: PurchasePriceListWhereUniqueInput
  }

  /**
   * PurchasePriceList deleteMany
   */
  export type PurchasePriceListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceLists to delete
     */
    where?: PurchasePriceListWhereInput
    /**
     * Limit how many PurchasePriceLists to delete.
     */
    limit?: number
  }

  /**
   * PurchasePriceList.suppliers
   */
  export type PurchasePriceList$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    where?: PurchasePriceListSupplierWhereInput
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * PurchasePriceList.items
   */
  export type PurchasePriceList$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    where?: PurchasePriceItemWhereInput
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    cursor?: PurchasePriceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * PurchasePriceList without action
   */
  export type PurchasePriceListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceList
     */
    select?: PurchasePriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceList
     */
    omit?: PurchasePriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListInclude<ExtArgs> | null
  }


  /**
   * Model PurchasePriceListSupplier
   */

  export type AggregatePurchasePriceListSupplier = {
    _count: PurchasePriceListSupplierCountAggregateOutputType | null
    _avg: PurchasePriceListSupplierAvgAggregateOutputType | null
    _sum: PurchasePriceListSupplierSumAggregateOutputType | null
    _min: PurchasePriceListSupplierMinAggregateOutputType | null
    _max: PurchasePriceListSupplierMaxAggregateOutputType | null
  }

  export type PurchasePriceListSupplierAvgAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    primaryMmlId: number | null
  }

  export type PurchasePriceListSupplierSumAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    primaryMmlId: number | null
  }

  export type PurchasePriceListSupplierMinAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    primaryMmlId: number | null
    createdAt: Date | null
  }

  export type PurchasePriceListSupplierMaxAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    primaryMmlId: number | null
    createdAt: Date | null
  }

  export type PurchasePriceListSupplierCountAggregateOutputType = {
    id: number
    priceListId: number
    supplierId: number
    primaryMmlId: number
    createdAt: number
    _all: number
  }


  export type PurchasePriceListSupplierAvgAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    primaryMmlId?: true
  }

  export type PurchasePriceListSupplierSumAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    primaryMmlId?: true
  }

  export type PurchasePriceListSupplierMinAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    primaryMmlId?: true
    createdAt?: true
  }

  export type PurchasePriceListSupplierMaxAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    primaryMmlId?: true
    createdAt?: true
  }

  export type PurchasePriceListSupplierCountAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    primaryMmlId?: true
    createdAt?: true
    _all?: true
  }

  export type PurchasePriceListSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceListSupplier to aggregate.
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceListSuppliers to fetch.
     */
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceListSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceListSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasePriceListSuppliers
    **/
    _count?: true | PurchasePriceListSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasePriceListSupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasePriceListSupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasePriceListSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasePriceListSupplierMaxAggregateInputType
  }

  export type GetPurchasePriceListSupplierAggregateType<T extends PurchasePriceListSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasePriceListSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasePriceListSupplier[P]>
      : GetScalarType<T[P], AggregatePurchasePriceListSupplier[P]>
  }




  export type PurchasePriceListSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceListSupplierWhereInput
    orderBy?: PurchasePriceListSupplierOrderByWithAggregationInput | PurchasePriceListSupplierOrderByWithAggregationInput[]
    by: PurchasePriceListSupplierScalarFieldEnum[] | PurchasePriceListSupplierScalarFieldEnum
    having?: PurchasePriceListSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasePriceListSupplierCountAggregateInputType | true
    _avg?: PurchasePriceListSupplierAvgAggregateInputType
    _sum?: PurchasePriceListSupplierSumAggregateInputType
    _min?: PurchasePriceListSupplierMinAggregateInputType
    _max?: PurchasePriceListSupplierMaxAggregateInputType
  }

  export type PurchasePriceListSupplierGroupByOutputType = {
    id: number
    priceListId: number
    supplierId: number
    primaryMmlId: number | null
    createdAt: Date
    _count: PurchasePriceListSupplierCountAggregateOutputType | null
    _avg: PurchasePriceListSupplierAvgAggregateOutputType | null
    _sum: PurchasePriceListSupplierSumAggregateOutputType | null
    _min: PurchasePriceListSupplierMinAggregateOutputType | null
    _max: PurchasePriceListSupplierMaxAggregateOutputType | null
  }

  type GetPurchasePriceListSupplierGroupByPayload<T extends PurchasePriceListSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasePriceListSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasePriceListSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasePriceListSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasePriceListSupplierGroupByOutputType[P]>
        }
      >
    >


  export type PurchasePriceListSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceListSupplier"]>

  export type PurchasePriceListSupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceListSupplier"]>

  export type PurchasePriceListSupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceListSupplier"]>

  export type PurchasePriceListSupplierSelectScalar = {
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    primaryMmlId?: boolean
    createdAt?: boolean
  }

  export type PurchasePriceListSupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "priceListId" | "supplierId" | "primaryMmlId" | "createdAt", ExtArgs["result"]["purchasePriceListSupplier"]>
  export type PurchasePriceListSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }
  export type PurchasePriceListSupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }
  export type PurchasePriceListSupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    primaryMml?: boolean | PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>
  }

  export type $PurchasePriceListSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasePriceListSupplier"
    objects: {
      priceList: Prisma.$PurchasePriceListPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      primaryMml: Prisma.$ProductionMmlPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      priceListId: number
      supplierId: number
      primaryMmlId: number | null
      createdAt: Date
    }, ExtArgs["result"]["purchasePriceListSupplier"]>
    composites: {}
  }

  type PurchasePriceListSupplierGetPayload<S extends boolean | null | undefined | PurchasePriceListSupplierDefaultArgs> = $Result.GetResult<Prisma.$PurchasePriceListSupplierPayload, S>

  type PurchasePriceListSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchasePriceListSupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchasePriceListSupplierCountAggregateInputType | true
    }

  export interface PurchasePriceListSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasePriceListSupplier'], meta: { name: 'PurchasePriceListSupplier' } }
    /**
     * Find zero or one PurchasePriceListSupplier that matches the filter.
     * @param {PurchasePriceListSupplierFindUniqueArgs} args - Arguments to find a PurchasePriceListSupplier
     * @example
     * // Get one PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasePriceListSupplierFindUniqueArgs>(args: SelectSubset<T, PurchasePriceListSupplierFindUniqueArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchasePriceListSupplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchasePriceListSupplierFindUniqueOrThrowArgs} args - Arguments to find a PurchasePriceListSupplier
     * @example
     * // Get one PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasePriceListSupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasePriceListSupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceListSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierFindFirstArgs} args - Arguments to find a PurchasePriceListSupplier
     * @example
     * // Get one PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasePriceListSupplierFindFirstArgs>(args?: SelectSubset<T, PurchasePriceListSupplierFindFirstArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceListSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierFindFirstOrThrowArgs} args - Arguments to find a PurchasePriceListSupplier
     * @example
     * // Get one PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasePriceListSupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasePriceListSupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchasePriceListSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasePriceListSuppliers
     * const purchasePriceListSuppliers = await prisma.purchasePriceListSupplier.findMany()
     * 
     * // Get first 10 PurchasePriceListSuppliers
     * const purchasePriceListSuppliers = await prisma.purchasePriceListSupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasePriceListSupplierWithIdOnly = await prisma.purchasePriceListSupplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasePriceListSupplierFindManyArgs>(args?: SelectSubset<T, PurchasePriceListSupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchasePriceListSupplier.
     * @param {PurchasePriceListSupplierCreateArgs} args - Arguments to create a PurchasePriceListSupplier.
     * @example
     * // Create one PurchasePriceListSupplier
     * const PurchasePriceListSupplier = await prisma.purchasePriceListSupplier.create({
     *   data: {
     *     // ... data to create a PurchasePriceListSupplier
     *   }
     * })
     * 
     */
    create<T extends PurchasePriceListSupplierCreateArgs>(args: SelectSubset<T, PurchasePriceListSupplierCreateArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchasePriceListSuppliers.
     * @param {PurchasePriceListSupplierCreateManyArgs} args - Arguments to create many PurchasePriceListSuppliers.
     * @example
     * // Create many PurchasePriceListSuppliers
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasePriceListSupplierCreateManyArgs>(args?: SelectSubset<T, PurchasePriceListSupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasePriceListSuppliers and returns the data saved in the database.
     * @param {PurchasePriceListSupplierCreateManyAndReturnArgs} args - Arguments to create many PurchasePriceListSuppliers.
     * @example
     * // Create many PurchasePriceListSuppliers
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasePriceListSuppliers and only return the `id`
     * const purchasePriceListSupplierWithIdOnly = await prisma.purchasePriceListSupplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasePriceListSupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasePriceListSupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchasePriceListSupplier.
     * @param {PurchasePriceListSupplierDeleteArgs} args - Arguments to delete one PurchasePriceListSupplier.
     * @example
     * // Delete one PurchasePriceListSupplier
     * const PurchasePriceListSupplier = await prisma.purchasePriceListSupplier.delete({
     *   where: {
     *     // ... filter to delete one PurchasePriceListSupplier
     *   }
     * })
     * 
     */
    delete<T extends PurchasePriceListSupplierDeleteArgs>(args: SelectSubset<T, PurchasePriceListSupplierDeleteArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchasePriceListSupplier.
     * @param {PurchasePriceListSupplierUpdateArgs} args - Arguments to update one PurchasePriceListSupplier.
     * @example
     * // Update one PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasePriceListSupplierUpdateArgs>(args: SelectSubset<T, PurchasePriceListSupplierUpdateArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchasePriceListSuppliers.
     * @param {PurchasePriceListSupplierDeleteManyArgs} args - Arguments to filter PurchasePriceListSuppliers to delete.
     * @example
     * // Delete a few PurchasePriceListSuppliers
     * const { count } = await prisma.purchasePriceListSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasePriceListSupplierDeleteManyArgs>(args?: SelectSubset<T, PurchasePriceListSupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceListSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasePriceListSuppliers
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasePriceListSupplierUpdateManyArgs>(args: SelectSubset<T, PurchasePriceListSupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceListSuppliers and returns the data updated in the database.
     * @param {PurchasePriceListSupplierUpdateManyAndReturnArgs} args - Arguments to update many PurchasePriceListSuppliers.
     * @example
     * // Update many PurchasePriceListSuppliers
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchasePriceListSuppliers and only return the `id`
     * const purchasePriceListSupplierWithIdOnly = await prisma.purchasePriceListSupplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchasePriceListSupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchasePriceListSupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchasePriceListSupplier.
     * @param {PurchasePriceListSupplierUpsertArgs} args - Arguments to update or create a PurchasePriceListSupplier.
     * @example
     * // Update or create a PurchasePriceListSupplier
     * const purchasePriceListSupplier = await prisma.purchasePriceListSupplier.upsert({
     *   create: {
     *     // ... data to create a PurchasePriceListSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasePriceListSupplier we want to update
     *   }
     * })
     */
    upsert<T extends PurchasePriceListSupplierUpsertArgs>(args: SelectSubset<T, PurchasePriceListSupplierUpsertArgs<ExtArgs>>): Prisma__PurchasePriceListSupplierClient<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchasePriceListSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierCountArgs} args - Arguments to filter PurchasePriceListSuppliers to count.
     * @example
     * // Count the number of PurchasePriceListSuppliers
     * const count = await prisma.purchasePriceListSupplier.count({
     *   where: {
     *     // ... the filter for the PurchasePriceListSuppliers we want to count
     *   }
     * })
    **/
    count<T extends PurchasePriceListSupplierCountArgs>(
      args?: Subset<T, PurchasePriceListSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasePriceListSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasePriceListSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasePriceListSupplierAggregateArgs>(args: Subset<T, PurchasePriceListSupplierAggregateArgs>): Prisma.PrismaPromise<GetPurchasePriceListSupplierAggregateType<T>>

    /**
     * Group by PurchasePriceListSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceListSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasePriceListSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasePriceListSupplierGroupByArgs['orderBy'] }
        : { orderBy?: PurchasePriceListSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasePriceListSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasePriceListSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasePriceListSupplier model
   */
  readonly fields: PurchasePriceListSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasePriceListSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasePriceListSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    priceList<T extends PurchasePriceListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchasePriceListDefaultArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    primaryMml<T extends PurchasePriceListSupplier$primaryMmlArgs<ExtArgs> = {}>(args?: Subset<T, PurchasePriceListSupplier$primaryMmlArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasePriceListSupplier model
   */
  interface PurchasePriceListSupplierFieldRefs {
    readonly id: FieldRef<"PurchasePriceListSupplier", 'Int'>
    readonly priceListId: FieldRef<"PurchasePriceListSupplier", 'Int'>
    readonly supplierId: FieldRef<"PurchasePriceListSupplier", 'Int'>
    readonly primaryMmlId: FieldRef<"PurchasePriceListSupplier", 'Int'>
    readonly createdAt: FieldRef<"PurchasePriceListSupplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchasePriceListSupplier findUnique
   */
  export type PurchasePriceListSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceListSupplier to fetch.
     */
    where: PurchasePriceListSupplierWhereUniqueInput
  }

  /**
   * PurchasePriceListSupplier findUniqueOrThrow
   */
  export type PurchasePriceListSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceListSupplier to fetch.
     */
    where: PurchasePriceListSupplierWhereUniqueInput
  }

  /**
   * PurchasePriceListSupplier findFirst
   */
  export type PurchasePriceListSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceListSupplier to fetch.
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceListSuppliers to fetch.
     */
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceListSuppliers.
     */
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceListSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceListSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceListSuppliers.
     */
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * PurchasePriceListSupplier findFirstOrThrow
   */
  export type PurchasePriceListSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceListSupplier to fetch.
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceListSuppliers to fetch.
     */
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceListSuppliers.
     */
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceListSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceListSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceListSuppliers.
     */
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * PurchasePriceListSupplier findMany
   */
  export type PurchasePriceListSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceListSuppliers to fetch.
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceListSuppliers to fetch.
     */
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasePriceListSuppliers.
     */
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceListSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceListSuppliers.
     */
    skip?: number
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * PurchasePriceListSupplier create
   */
  export type PurchasePriceListSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasePriceListSupplier.
     */
    data: XOR<PurchasePriceListSupplierCreateInput, PurchasePriceListSupplierUncheckedCreateInput>
  }

  /**
   * PurchasePriceListSupplier createMany
   */
  export type PurchasePriceListSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasePriceListSuppliers.
     */
    data: PurchasePriceListSupplierCreateManyInput | PurchasePriceListSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasePriceListSupplier createManyAndReturn
   */
  export type PurchasePriceListSupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * The data used to create many PurchasePriceListSuppliers.
     */
    data: PurchasePriceListSupplierCreateManyInput | PurchasePriceListSupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasePriceListSupplier update
   */
  export type PurchasePriceListSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasePriceListSupplier.
     */
    data: XOR<PurchasePriceListSupplierUpdateInput, PurchasePriceListSupplierUncheckedUpdateInput>
    /**
     * Choose, which PurchasePriceListSupplier to update.
     */
    where: PurchasePriceListSupplierWhereUniqueInput
  }

  /**
   * PurchasePriceListSupplier updateMany
   */
  export type PurchasePriceListSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasePriceListSuppliers.
     */
    data: XOR<PurchasePriceListSupplierUpdateManyMutationInput, PurchasePriceListSupplierUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceListSuppliers to update
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * Limit how many PurchasePriceListSuppliers to update.
     */
    limit?: number
  }

  /**
   * PurchasePriceListSupplier updateManyAndReturn
   */
  export type PurchasePriceListSupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * The data used to update PurchasePriceListSuppliers.
     */
    data: XOR<PurchasePriceListSupplierUpdateManyMutationInput, PurchasePriceListSupplierUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceListSuppliers to update
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * Limit how many PurchasePriceListSuppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasePriceListSupplier upsert
   */
  export type PurchasePriceListSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasePriceListSupplier to update in case it exists.
     */
    where: PurchasePriceListSupplierWhereUniqueInput
    /**
     * In case the PurchasePriceListSupplier found by the `where` argument doesn't exist, create a new PurchasePriceListSupplier with this data.
     */
    create: XOR<PurchasePriceListSupplierCreateInput, PurchasePriceListSupplierUncheckedCreateInput>
    /**
     * In case the PurchasePriceListSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasePriceListSupplierUpdateInput, PurchasePriceListSupplierUncheckedUpdateInput>
  }

  /**
   * PurchasePriceListSupplier delete
   */
  export type PurchasePriceListSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    /**
     * Filter which PurchasePriceListSupplier to delete.
     */
    where: PurchasePriceListSupplierWhereUniqueInput
  }

  /**
   * PurchasePriceListSupplier deleteMany
   */
  export type PurchasePriceListSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceListSuppliers to delete
     */
    where?: PurchasePriceListSupplierWhereInput
    /**
     * Limit how many PurchasePriceListSuppliers to delete.
     */
    limit?: number
  }

  /**
   * PurchasePriceListSupplier.primaryMml
   */
  export type PurchasePriceListSupplier$primaryMmlArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    where?: ProductionMmlWhereInput
  }

  /**
   * PurchasePriceListSupplier without action
   */
  export type PurchasePriceListSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
  }


  /**
   * Model PurchasePriceItem
   */

  export type AggregatePurchasePriceItem = {
    _count: PurchasePriceItemCountAggregateOutputType | null
    _avg: PurchasePriceItemAvgAggregateOutputType | null
    _sum: PurchasePriceItemSumAggregateOutputType | null
    _min: PurchasePriceItemMinAggregateOutputType | null
    _max: PurchasePriceItemMaxAggregateOutputType | null
  }

  export type PurchasePriceItemAvgAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    productId: number | null
    purchasePrice: Decimal | null
  }

  export type PurchasePriceItemSumAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    productId: number | null
    purchasePrice: Decimal | null
  }

  export type PurchasePriceItemMinAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    productId: number | null
    purchasePrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasePriceItemMaxAggregateOutputType = {
    id: number | null
    priceListId: number | null
    supplierId: number | null
    productId: number | null
    purchasePrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasePriceItemCountAggregateOutputType = {
    id: number
    priceListId: number
    supplierId: number
    productId: number
    purchasePrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchasePriceItemAvgAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    productId?: true
    purchasePrice?: true
  }

  export type PurchasePriceItemSumAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    productId?: true
    purchasePrice?: true
  }

  export type PurchasePriceItemMinAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    productId?: true
    purchasePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasePriceItemMaxAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    productId?: true
    purchasePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasePriceItemCountAggregateInputType = {
    id?: true
    priceListId?: true
    supplierId?: true
    productId?: true
    purchasePrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchasePriceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceItem to aggregate.
     */
    where?: PurchasePriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceItems to fetch.
     */
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasePriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasePriceItems
    **/
    _count?: true | PurchasePriceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasePriceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasePriceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasePriceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasePriceItemMaxAggregateInputType
  }

  export type GetPurchasePriceItemAggregateType<T extends PurchasePriceItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasePriceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasePriceItem[P]>
      : GetScalarType<T[P], AggregatePurchasePriceItem[P]>
  }




  export type PurchasePriceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePriceItemWhereInput
    orderBy?: PurchasePriceItemOrderByWithAggregationInput | PurchasePriceItemOrderByWithAggregationInput[]
    by: PurchasePriceItemScalarFieldEnum[] | PurchasePriceItemScalarFieldEnum
    having?: PurchasePriceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasePriceItemCountAggregateInputType | true
    _avg?: PurchasePriceItemAvgAggregateInputType
    _sum?: PurchasePriceItemSumAggregateInputType
    _min?: PurchasePriceItemMinAggregateInputType
    _max?: PurchasePriceItemMaxAggregateInputType
  }

  export type PurchasePriceItemGroupByOutputType = {
    id: number
    priceListId: number
    supplierId: number
    productId: number
    purchasePrice: Decimal
    createdAt: Date
    updatedAt: Date
    _count: PurchasePriceItemCountAggregateOutputType | null
    _avg: PurchasePriceItemAvgAggregateOutputType | null
    _sum: PurchasePriceItemSumAggregateOutputType | null
    _min: PurchasePriceItemMinAggregateOutputType | null
    _max: PurchasePriceItemMaxAggregateOutputType | null
  }

  type GetPurchasePriceItemGroupByPayload<T extends PurchasePriceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasePriceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasePriceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasePriceItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasePriceItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchasePriceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    productId?: boolean
    purchasePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceItem"]>

  export type PurchasePriceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    productId?: boolean
    purchasePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceItem"]>

  export type PurchasePriceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    productId?: boolean
    purchasePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePriceItem"]>

  export type PurchasePriceItemSelectScalar = {
    id?: boolean
    priceListId?: boolean
    supplierId?: boolean
    productId?: boolean
    purchasePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchasePriceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "priceListId" | "supplierId" | "productId" | "purchasePrice" | "createdAt" | "updatedAt", ExtArgs["result"]["purchasePriceItem"]>
  export type PurchasePriceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchasePriceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchasePriceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | PurchasePriceListDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PurchasePriceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasePriceItem"
    objects: {
      priceList: Prisma.$PurchasePriceListPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      priceListId: number
      supplierId: number
      productId: number
      purchasePrice: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchasePriceItem"]>
    composites: {}
  }

  type PurchasePriceItemGetPayload<S extends boolean | null | undefined | PurchasePriceItemDefaultArgs> = $Result.GetResult<Prisma.$PurchasePriceItemPayload, S>

  type PurchasePriceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchasePriceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchasePriceItemCountAggregateInputType | true
    }

  export interface PurchasePriceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasePriceItem'], meta: { name: 'PurchasePriceItem' } }
    /**
     * Find zero or one PurchasePriceItem that matches the filter.
     * @param {PurchasePriceItemFindUniqueArgs} args - Arguments to find a PurchasePriceItem
     * @example
     * // Get one PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasePriceItemFindUniqueArgs>(args: SelectSubset<T, PurchasePriceItemFindUniqueArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchasePriceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchasePriceItemFindUniqueOrThrowArgs} args - Arguments to find a PurchasePriceItem
     * @example
     * // Get one PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasePriceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasePriceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemFindFirstArgs} args - Arguments to find a PurchasePriceItem
     * @example
     * // Get one PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasePriceItemFindFirstArgs>(args?: SelectSubset<T, PurchasePriceItemFindFirstArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasePriceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemFindFirstOrThrowArgs} args - Arguments to find a PurchasePriceItem
     * @example
     * // Get one PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasePriceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasePriceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchasePriceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasePriceItems
     * const purchasePriceItems = await prisma.purchasePriceItem.findMany()
     * 
     * // Get first 10 PurchasePriceItems
     * const purchasePriceItems = await prisma.purchasePriceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasePriceItemWithIdOnly = await prisma.purchasePriceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasePriceItemFindManyArgs>(args?: SelectSubset<T, PurchasePriceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchasePriceItem.
     * @param {PurchasePriceItemCreateArgs} args - Arguments to create a PurchasePriceItem.
     * @example
     * // Create one PurchasePriceItem
     * const PurchasePriceItem = await prisma.purchasePriceItem.create({
     *   data: {
     *     // ... data to create a PurchasePriceItem
     *   }
     * })
     * 
     */
    create<T extends PurchasePriceItemCreateArgs>(args: SelectSubset<T, PurchasePriceItemCreateArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchasePriceItems.
     * @param {PurchasePriceItemCreateManyArgs} args - Arguments to create many PurchasePriceItems.
     * @example
     * // Create many PurchasePriceItems
     * const purchasePriceItem = await prisma.purchasePriceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasePriceItemCreateManyArgs>(args?: SelectSubset<T, PurchasePriceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasePriceItems and returns the data saved in the database.
     * @param {PurchasePriceItemCreateManyAndReturnArgs} args - Arguments to create many PurchasePriceItems.
     * @example
     * // Create many PurchasePriceItems
     * const purchasePriceItem = await prisma.purchasePriceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasePriceItems and only return the `id`
     * const purchasePriceItemWithIdOnly = await prisma.purchasePriceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasePriceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasePriceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchasePriceItem.
     * @param {PurchasePriceItemDeleteArgs} args - Arguments to delete one PurchasePriceItem.
     * @example
     * // Delete one PurchasePriceItem
     * const PurchasePriceItem = await prisma.purchasePriceItem.delete({
     *   where: {
     *     // ... filter to delete one PurchasePriceItem
     *   }
     * })
     * 
     */
    delete<T extends PurchasePriceItemDeleteArgs>(args: SelectSubset<T, PurchasePriceItemDeleteArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchasePriceItem.
     * @param {PurchasePriceItemUpdateArgs} args - Arguments to update one PurchasePriceItem.
     * @example
     * // Update one PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasePriceItemUpdateArgs>(args: SelectSubset<T, PurchasePriceItemUpdateArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchasePriceItems.
     * @param {PurchasePriceItemDeleteManyArgs} args - Arguments to filter PurchasePriceItems to delete.
     * @example
     * // Delete a few PurchasePriceItems
     * const { count } = await prisma.purchasePriceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasePriceItemDeleteManyArgs>(args?: SelectSubset<T, PurchasePriceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasePriceItems
     * const purchasePriceItem = await prisma.purchasePriceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasePriceItemUpdateManyArgs>(args: SelectSubset<T, PurchasePriceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePriceItems and returns the data updated in the database.
     * @param {PurchasePriceItemUpdateManyAndReturnArgs} args - Arguments to update many PurchasePriceItems.
     * @example
     * // Update many PurchasePriceItems
     * const purchasePriceItem = await prisma.purchasePriceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchasePriceItems and only return the `id`
     * const purchasePriceItemWithIdOnly = await prisma.purchasePriceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchasePriceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchasePriceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchasePriceItem.
     * @param {PurchasePriceItemUpsertArgs} args - Arguments to update or create a PurchasePriceItem.
     * @example
     * // Update or create a PurchasePriceItem
     * const purchasePriceItem = await prisma.purchasePriceItem.upsert({
     *   create: {
     *     // ... data to create a PurchasePriceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasePriceItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchasePriceItemUpsertArgs>(args: SelectSubset<T, PurchasePriceItemUpsertArgs<ExtArgs>>): Prisma__PurchasePriceItemClient<$Result.GetResult<Prisma.$PurchasePriceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchasePriceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemCountArgs} args - Arguments to filter PurchasePriceItems to count.
     * @example
     * // Count the number of PurchasePriceItems
     * const count = await prisma.purchasePriceItem.count({
     *   where: {
     *     // ... the filter for the PurchasePriceItems we want to count
     *   }
     * })
    **/
    count<T extends PurchasePriceItemCountArgs>(
      args?: Subset<T, PurchasePriceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasePriceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasePriceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasePriceItemAggregateArgs>(args: Subset<T, PurchasePriceItemAggregateArgs>): Prisma.PrismaPromise<GetPurchasePriceItemAggregateType<T>>

    /**
     * Group by PurchasePriceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePriceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasePriceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasePriceItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchasePriceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasePriceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasePriceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasePriceItem model
   */
  readonly fields: PurchasePriceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasePriceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasePriceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    priceList<T extends PurchasePriceListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchasePriceListDefaultArgs<ExtArgs>>): Prisma__PurchasePriceListClient<$Result.GetResult<Prisma.$PurchasePriceListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasePriceItem model
   */
  interface PurchasePriceItemFieldRefs {
    readonly id: FieldRef<"PurchasePriceItem", 'Int'>
    readonly priceListId: FieldRef<"PurchasePriceItem", 'Int'>
    readonly supplierId: FieldRef<"PurchasePriceItem", 'Int'>
    readonly productId: FieldRef<"PurchasePriceItem", 'Int'>
    readonly purchasePrice: FieldRef<"PurchasePriceItem", 'Decimal'>
    readonly createdAt: FieldRef<"PurchasePriceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchasePriceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchasePriceItem findUnique
   */
  export type PurchasePriceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceItem to fetch.
     */
    where: PurchasePriceItemWhereUniqueInput
  }

  /**
   * PurchasePriceItem findUniqueOrThrow
   */
  export type PurchasePriceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceItem to fetch.
     */
    where: PurchasePriceItemWhereUniqueInput
  }

  /**
   * PurchasePriceItem findFirst
   */
  export type PurchasePriceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceItem to fetch.
     */
    where?: PurchasePriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceItems to fetch.
     */
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceItems.
     */
    cursor?: PurchasePriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceItems.
     */
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * PurchasePriceItem findFirstOrThrow
   */
  export type PurchasePriceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceItem to fetch.
     */
    where?: PurchasePriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceItems to fetch.
     */
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePriceItems.
     */
    cursor?: PurchasePriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePriceItems.
     */
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * PurchasePriceItem findMany
   */
  export type PurchasePriceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePriceItems to fetch.
     */
    where?: PurchasePriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePriceItems to fetch.
     */
    orderBy?: PurchasePriceItemOrderByWithRelationInput | PurchasePriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasePriceItems.
     */
    cursor?: PurchasePriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePriceItems.
     */
    skip?: number
    distinct?: PurchasePriceItemScalarFieldEnum | PurchasePriceItemScalarFieldEnum[]
  }

  /**
   * PurchasePriceItem create
   */
  export type PurchasePriceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasePriceItem.
     */
    data: XOR<PurchasePriceItemCreateInput, PurchasePriceItemUncheckedCreateInput>
  }

  /**
   * PurchasePriceItem createMany
   */
  export type PurchasePriceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasePriceItems.
     */
    data: PurchasePriceItemCreateManyInput | PurchasePriceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasePriceItem createManyAndReturn
   */
  export type PurchasePriceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchasePriceItems.
     */
    data: PurchasePriceItemCreateManyInput | PurchasePriceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasePriceItem update
   */
  export type PurchasePriceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasePriceItem.
     */
    data: XOR<PurchasePriceItemUpdateInput, PurchasePriceItemUncheckedUpdateInput>
    /**
     * Choose, which PurchasePriceItem to update.
     */
    where: PurchasePriceItemWhereUniqueInput
  }

  /**
   * PurchasePriceItem updateMany
   */
  export type PurchasePriceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasePriceItems.
     */
    data: XOR<PurchasePriceItemUpdateManyMutationInput, PurchasePriceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceItems to update
     */
    where?: PurchasePriceItemWhereInput
    /**
     * Limit how many PurchasePriceItems to update.
     */
    limit?: number
  }

  /**
   * PurchasePriceItem updateManyAndReturn
   */
  export type PurchasePriceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchasePriceItems.
     */
    data: XOR<PurchasePriceItemUpdateManyMutationInput, PurchasePriceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePriceItems to update
     */
    where?: PurchasePriceItemWhereInput
    /**
     * Limit how many PurchasePriceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasePriceItem upsert
   */
  export type PurchasePriceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasePriceItem to update in case it exists.
     */
    where: PurchasePriceItemWhereUniqueInput
    /**
     * In case the PurchasePriceItem found by the `where` argument doesn't exist, create a new PurchasePriceItem with this data.
     */
    create: XOR<PurchasePriceItemCreateInput, PurchasePriceItemUncheckedCreateInput>
    /**
     * In case the PurchasePriceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasePriceItemUpdateInput, PurchasePriceItemUncheckedUpdateInput>
  }

  /**
   * PurchasePriceItem delete
   */
  export type PurchasePriceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
    /**
     * Filter which PurchasePriceItem to delete.
     */
    where: PurchasePriceItemWhereUniqueInput
  }

  /**
   * PurchasePriceItem deleteMany
   */
  export type PurchasePriceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePriceItems to delete
     */
    where?: PurchasePriceItemWhereInput
    /**
     * Limit how many PurchasePriceItems to delete.
     */
    limit?: number
  }

  /**
   * PurchasePriceItem without action
   */
  export type PurchasePriceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceItem
     */
    select?: PurchasePriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceItem
     */
    omit?: PurchasePriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceItemInclude<ExtArgs> | null
  }


  /**
   * Model SalesPriceList
   */

  export type AggregateSalesPriceList = {
    _count: SalesPriceListCountAggregateOutputType | null
    _avg: SalesPriceListAvgAggregateOutputType | null
    _sum: SalesPriceListSumAggregateOutputType | null
    _min: SalesPriceListMinAggregateOutputType | null
    _max: SalesPriceListMaxAggregateOutputType | null
  }

  export type SalesPriceListAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type SalesPriceListSumAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type SalesPriceListMinAggregateOutputType = {
    id: number | null
    listType: string | null
    customerId: number | null
    title: string | null
    effectiveDate: Date | null
    status: string | null
    isCurrent: boolean | null
    isHidden: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type SalesPriceListMaxAggregateOutputType = {
    id: number | null
    listType: string | null
    customerId: number | null
    title: string | null
    effectiveDate: Date | null
    status: string | null
    isCurrent: boolean | null
    isHidden: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type SalesPriceListCountAggregateOutputType = {
    id: number
    listType: number
    customerId: number
    title: number
    effectiveDate: number
    status: number
    isCurrent: number
    isHidden: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type SalesPriceListAvgAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type SalesPriceListSumAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type SalesPriceListMinAggregateInputType = {
    id?: true
    listType?: true
    customerId?: true
    title?: true
    effectiveDate?: true
    status?: true
    isCurrent?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SalesPriceListMaxAggregateInputType = {
    id?: true
    listType?: true
    customerId?: true
    title?: true
    effectiveDate?: true
    status?: true
    isCurrent?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SalesPriceListCountAggregateInputType = {
    id?: true
    listType?: true
    customerId?: true
    title?: true
    effectiveDate?: true
    status?: true
    isCurrent?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type SalesPriceListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesPriceList to aggregate.
     */
    where?: SalesPriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceLists to fetch.
     */
    orderBy?: SalesPriceListOrderByWithRelationInput | SalesPriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesPriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesPriceLists
    **/
    _count?: true | SalesPriceListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesPriceListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesPriceListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesPriceListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesPriceListMaxAggregateInputType
  }

  export type GetSalesPriceListAggregateType<T extends SalesPriceListAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesPriceList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesPriceList[P]>
      : GetScalarType<T[P], AggregateSalesPriceList[P]>
  }




  export type SalesPriceListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesPriceListWhereInput
    orderBy?: SalesPriceListOrderByWithAggregationInput | SalesPriceListOrderByWithAggregationInput[]
    by: SalesPriceListScalarFieldEnum[] | SalesPriceListScalarFieldEnum
    having?: SalesPriceListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesPriceListCountAggregateInputType | true
    _avg?: SalesPriceListAvgAggregateInputType
    _sum?: SalesPriceListSumAggregateInputType
    _min?: SalesPriceListMinAggregateInputType
    _max?: SalesPriceListMaxAggregateInputType
  }

  export type SalesPriceListGroupByOutputType = {
    id: number
    listType: string
    customerId: number | null
    title: string | null
    effectiveDate: Date
    status: string
    isCurrent: boolean
    isHidden: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    _count: SalesPriceListCountAggregateOutputType | null
    _avg: SalesPriceListAvgAggregateOutputType | null
    _sum: SalesPriceListSumAggregateOutputType | null
    _min: SalesPriceListMinAggregateOutputType | null
    _max: SalesPriceListMaxAggregateOutputType | null
  }

  type GetSalesPriceListGroupByPayload<T extends SalesPriceListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesPriceListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesPriceListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesPriceListGroupByOutputType[P]>
            : GetScalarType<T[P], SalesPriceListGroupByOutputType[P]>
        }
      >
    >


  export type SalesPriceListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    customerId?: boolean
    title?: boolean
    effectiveDate?: boolean
    status?: boolean
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
    items?: boolean | SalesPriceList$itemsArgs<ExtArgs>
    _count?: boolean | SalesPriceListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceList"]>

  export type SalesPriceListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    customerId?: boolean
    title?: boolean
    effectiveDate?: boolean
    status?: boolean
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceList"]>

  export type SalesPriceListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listType?: boolean
    customerId?: boolean
    title?: boolean
    effectiveDate?: boolean
    status?: boolean
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceList"]>

  export type SalesPriceListSelectScalar = {
    id?: boolean
    listType?: boolean
    customerId?: boolean
    title?: boolean
    effectiveDate?: boolean
    status?: boolean
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type SalesPriceListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listType" | "customerId" | "title" | "effectiveDate" | "status" | "isCurrent" | "isHidden" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["salesPriceList"]>
  export type SalesPriceListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
    items?: boolean | SalesPriceList$itemsArgs<ExtArgs>
    _count?: boolean | SalesPriceListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesPriceListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
  }
  export type SalesPriceListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesPriceList$customerArgs<ExtArgs>
  }

  export type $SalesPriceListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesPriceList"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      items: Prisma.$SalesPriceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      listType: string
      customerId: number | null
      title: string | null
      effectiveDate: Date
      status: string
      isCurrent: boolean
      isHidden: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
    }, ExtArgs["result"]["salesPriceList"]>
    composites: {}
  }

  type SalesPriceListGetPayload<S extends boolean | null | undefined | SalesPriceListDefaultArgs> = $Result.GetResult<Prisma.$SalesPriceListPayload, S>

  type SalesPriceListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesPriceListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesPriceListCountAggregateInputType | true
    }

  export interface SalesPriceListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesPriceList'], meta: { name: 'SalesPriceList' } }
    /**
     * Find zero or one SalesPriceList that matches the filter.
     * @param {SalesPriceListFindUniqueArgs} args - Arguments to find a SalesPriceList
     * @example
     * // Get one SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesPriceListFindUniqueArgs>(args: SelectSubset<T, SalesPriceListFindUniqueArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesPriceList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesPriceListFindUniqueOrThrowArgs} args - Arguments to find a SalesPriceList
     * @example
     * // Get one SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesPriceListFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesPriceListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesPriceList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListFindFirstArgs} args - Arguments to find a SalesPriceList
     * @example
     * // Get one SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesPriceListFindFirstArgs>(args?: SelectSubset<T, SalesPriceListFindFirstArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesPriceList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListFindFirstOrThrowArgs} args - Arguments to find a SalesPriceList
     * @example
     * // Get one SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesPriceListFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesPriceListFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesPriceLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesPriceLists
     * const salesPriceLists = await prisma.salesPriceList.findMany()
     * 
     * // Get first 10 SalesPriceLists
     * const salesPriceLists = await prisma.salesPriceList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesPriceListWithIdOnly = await prisma.salesPriceList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesPriceListFindManyArgs>(args?: SelectSubset<T, SalesPriceListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesPriceList.
     * @param {SalesPriceListCreateArgs} args - Arguments to create a SalesPriceList.
     * @example
     * // Create one SalesPriceList
     * const SalesPriceList = await prisma.salesPriceList.create({
     *   data: {
     *     // ... data to create a SalesPriceList
     *   }
     * })
     * 
     */
    create<T extends SalesPriceListCreateArgs>(args: SelectSubset<T, SalesPriceListCreateArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesPriceLists.
     * @param {SalesPriceListCreateManyArgs} args - Arguments to create many SalesPriceLists.
     * @example
     * // Create many SalesPriceLists
     * const salesPriceList = await prisma.salesPriceList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesPriceListCreateManyArgs>(args?: SelectSubset<T, SalesPriceListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesPriceLists and returns the data saved in the database.
     * @param {SalesPriceListCreateManyAndReturnArgs} args - Arguments to create many SalesPriceLists.
     * @example
     * // Create many SalesPriceLists
     * const salesPriceList = await prisma.salesPriceList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesPriceLists and only return the `id`
     * const salesPriceListWithIdOnly = await prisma.salesPriceList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesPriceListCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesPriceListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesPriceList.
     * @param {SalesPriceListDeleteArgs} args - Arguments to delete one SalesPriceList.
     * @example
     * // Delete one SalesPriceList
     * const SalesPriceList = await prisma.salesPriceList.delete({
     *   where: {
     *     // ... filter to delete one SalesPriceList
     *   }
     * })
     * 
     */
    delete<T extends SalesPriceListDeleteArgs>(args: SelectSubset<T, SalesPriceListDeleteArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesPriceList.
     * @param {SalesPriceListUpdateArgs} args - Arguments to update one SalesPriceList.
     * @example
     * // Update one SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesPriceListUpdateArgs>(args: SelectSubset<T, SalesPriceListUpdateArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesPriceLists.
     * @param {SalesPriceListDeleteManyArgs} args - Arguments to filter SalesPriceLists to delete.
     * @example
     * // Delete a few SalesPriceLists
     * const { count } = await prisma.salesPriceList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesPriceListDeleteManyArgs>(args?: SelectSubset<T, SalesPriceListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesPriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesPriceLists
     * const salesPriceList = await prisma.salesPriceList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesPriceListUpdateManyArgs>(args: SelectSubset<T, SalesPriceListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesPriceLists and returns the data updated in the database.
     * @param {SalesPriceListUpdateManyAndReturnArgs} args - Arguments to update many SalesPriceLists.
     * @example
     * // Update many SalesPriceLists
     * const salesPriceList = await prisma.salesPriceList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesPriceLists and only return the `id`
     * const salesPriceListWithIdOnly = await prisma.salesPriceList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesPriceListUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesPriceListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesPriceList.
     * @param {SalesPriceListUpsertArgs} args - Arguments to update or create a SalesPriceList.
     * @example
     * // Update or create a SalesPriceList
     * const salesPriceList = await prisma.salesPriceList.upsert({
     *   create: {
     *     // ... data to create a SalesPriceList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesPriceList we want to update
     *   }
     * })
     */
    upsert<T extends SalesPriceListUpsertArgs>(args: SelectSubset<T, SalesPriceListUpsertArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesPriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListCountArgs} args - Arguments to filter SalesPriceLists to count.
     * @example
     * // Count the number of SalesPriceLists
     * const count = await prisma.salesPriceList.count({
     *   where: {
     *     // ... the filter for the SalesPriceLists we want to count
     *   }
     * })
    **/
    count<T extends SalesPriceListCountArgs>(
      args?: Subset<T, SalesPriceListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesPriceListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesPriceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesPriceListAggregateArgs>(args: Subset<T, SalesPriceListAggregateArgs>): Prisma.PrismaPromise<GetSalesPriceListAggregateType<T>>

    /**
     * Group by SalesPriceList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesPriceListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesPriceListGroupByArgs['orderBy'] }
        : { orderBy?: SalesPriceListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesPriceListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesPriceListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesPriceList model
   */
  readonly fields: SalesPriceListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesPriceList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesPriceListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends SalesPriceList$customerArgs<ExtArgs> = {}>(args?: Subset<T, SalesPriceList$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends SalesPriceList$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SalesPriceList$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesPriceList model
   */
  interface SalesPriceListFieldRefs {
    readonly id: FieldRef<"SalesPriceList", 'Int'>
    readonly listType: FieldRef<"SalesPriceList", 'String'>
    readonly customerId: FieldRef<"SalesPriceList", 'Int'>
    readonly title: FieldRef<"SalesPriceList", 'String'>
    readonly effectiveDate: FieldRef<"SalesPriceList", 'DateTime'>
    readonly status: FieldRef<"SalesPriceList", 'String'>
    readonly isCurrent: FieldRef<"SalesPriceList", 'Boolean'>
    readonly isHidden: FieldRef<"SalesPriceList", 'Boolean'>
    readonly createdAt: FieldRef<"SalesPriceList", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesPriceList", 'DateTime'>
    readonly createdBy: FieldRef<"SalesPriceList", 'String'>
    readonly updatedBy: FieldRef<"SalesPriceList", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SalesPriceList findUnique
   */
  export type SalesPriceListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceList to fetch.
     */
    where: SalesPriceListWhereUniqueInput
  }

  /**
   * SalesPriceList findUniqueOrThrow
   */
  export type SalesPriceListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceList to fetch.
     */
    where: SalesPriceListWhereUniqueInput
  }

  /**
   * SalesPriceList findFirst
   */
  export type SalesPriceListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceList to fetch.
     */
    where?: SalesPriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceLists to fetch.
     */
    orderBy?: SalesPriceListOrderByWithRelationInput | SalesPriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesPriceLists.
     */
    cursor?: SalesPriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesPriceLists.
     */
    distinct?: SalesPriceListScalarFieldEnum | SalesPriceListScalarFieldEnum[]
  }

  /**
   * SalesPriceList findFirstOrThrow
   */
  export type SalesPriceListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceList to fetch.
     */
    where?: SalesPriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceLists to fetch.
     */
    orderBy?: SalesPriceListOrderByWithRelationInput | SalesPriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesPriceLists.
     */
    cursor?: SalesPriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesPriceLists.
     */
    distinct?: SalesPriceListScalarFieldEnum | SalesPriceListScalarFieldEnum[]
  }

  /**
   * SalesPriceList findMany
   */
  export type SalesPriceListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceLists to fetch.
     */
    where?: SalesPriceListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceLists to fetch.
     */
    orderBy?: SalesPriceListOrderByWithRelationInput | SalesPriceListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesPriceLists.
     */
    cursor?: SalesPriceListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceLists.
     */
    skip?: number
    distinct?: SalesPriceListScalarFieldEnum | SalesPriceListScalarFieldEnum[]
  }

  /**
   * SalesPriceList create
   */
  export type SalesPriceListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesPriceList.
     */
    data: XOR<SalesPriceListCreateInput, SalesPriceListUncheckedCreateInput>
  }

  /**
   * SalesPriceList createMany
   */
  export type SalesPriceListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesPriceLists.
     */
    data: SalesPriceListCreateManyInput | SalesPriceListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesPriceList createManyAndReturn
   */
  export type SalesPriceListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * The data used to create many SalesPriceLists.
     */
    data: SalesPriceListCreateManyInput | SalesPriceListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesPriceList update
   */
  export type SalesPriceListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesPriceList.
     */
    data: XOR<SalesPriceListUpdateInput, SalesPriceListUncheckedUpdateInput>
    /**
     * Choose, which SalesPriceList to update.
     */
    where: SalesPriceListWhereUniqueInput
  }

  /**
   * SalesPriceList updateMany
   */
  export type SalesPriceListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesPriceLists.
     */
    data: XOR<SalesPriceListUpdateManyMutationInput, SalesPriceListUncheckedUpdateManyInput>
    /**
     * Filter which SalesPriceLists to update
     */
    where?: SalesPriceListWhereInput
    /**
     * Limit how many SalesPriceLists to update.
     */
    limit?: number
  }

  /**
   * SalesPriceList updateManyAndReturn
   */
  export type SalesPriceListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * The data used to update SalesPriceLists.
     */
    data: XOR<SalesPriceListUpdateManyMutationInput, SalesPriceListUncheckedUpdateManyInput>
    /**
     * Filter which SalesPriceLists to update
     */
    where?: SalesPriceListWhereInput
    /**
     * Limit how many SalesPriceLists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesPriceList upsert
   */
  export type SalesPriceListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesPriceList to update in case it exists.
     */
    where: SalesPriceListWhereUniqueInput
    /**
     * In case the SalesPriceList found by the `where` argument doesn't exist, create a new SalesPriceList with this data.
     */
    create: XOR<SalesPriceListCreateInput, SalesPriceListUncheckedCreateInput>
    /**
     * In case the SalesPriceList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesPriceListUpdateInput, SalesPriceListUncheckedUpdateInput>
  }

  /**
   * SalesPriceList delete
   */
  export type SalesPriceListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
    /**
     * Filter which SalesPriceList to delete.
     */
    where: SalesPriceListWhereUniqueInput
  }

  /**
   * SalesPriceList deleteMany
   */
  export type SalesPriceListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesPriceLists to delete
     */
    where?: SalesPriceListWhereInput
    /**
     * Limit how many SalesPriceLists to delete.
     */
    limit?: number
  }

  /**
   * SalesPriceList.customer
   */
  export type SalesPriceList$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * SalesPriceList.items
   */
  export type SalesPriceList$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    where?: SalesPriceItemWhereInput
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    cursor?: SalesPriceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesPriceItemScalarFieldEnum | SalesPriceItemScalarFieldEnum[]
  }

  /**
   * SalesPriceList without action
   */
  export type SalesPriceListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceList
     */
    select?: SalesPriceListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceList
     */
    omit?: SalesPriceListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceListInclude<ExtArgs> | null
  }


  /**
   * Model SalesPriceItem
   */

  export type AggregateSalesPriceItem = {
    _count: SalesPriceItemCountAggregateOutputType | null
    _avg: SalesPriceItemAvgAggregateOutputType | null
    _sum: SalesPriceItemSumAggregateOutputType | null
    _min: SalesPriceItemMinAggregateOutputType | null
    _max: SalesPriceItemMaxAggregateOutputType | null
  }

  export type SalesPriceItemAvgAggregateOutputType = {
    id: number | null
    priceListId: number | null
    productId: number | null
    salePrice: Decimal | null
  }

  export type SalesPriceItemSumAggregateOutputType = {
    id: number | null
    priceListId: number | null
    productId: number | null
    salePrice: Decimal | null
  }

  export type SalesPriceItemMinAggregateOutputType = {
    id: number | null
    priceListId: number | null
    productId: number | null
    salePrice: Decimal | null
    rowDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SalesPriceItemMaxAggregateOutputType = {
    id: number | null
    priceListId: number | null
    productId: number | null
    salePrice: Decimal | null
    rowDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SalesPriceItemCountAggregateOutputType = {
    id: number
    priceListId: number
    productId: number
    salePrice: number
    rowDate: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SalesPriceItemAvgAggregateInputType = {
    id?: true
    priceListId?: true
    productId?: true
    salePrice?: true
  }

  export type SalesPriceItemSumAggregateInputType = {
    id?: true
    priceListId?: true
    productId?: true
    salePrice?: true
  }

  export type SalesPriceItemMinAggregateInputType = {
    id?: true
    priceListId?: true
    productId?: true
    salePrice?: true
    rowDate?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SalesPriceItemMaxAggregateInputType = {
    id?: true
    priceListId?: true
    productId?: true
    salePrice?: true
    rowDate?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SalesPriceItemCountAggregateInputType = {
    id?: true
    priceListId?: true
    productId?: true
    salePrice?: true
    rowDate?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SalesPriceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesPriceItem to aggregate.
     */
    where?: SalesPriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceItems to fetch.
     */
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesPriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesPriceItems
    **/
    _count?: true | SalesPriceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesPriceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesPriceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesPriceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesPriceItemMaxAggregateInputType
  }

  export type GetSalesPriceItemAggregateType<T extends SalesPriceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesPriceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesPriceItem[P]>
      : GetScalarType<T[P], AggregateSalesPriceItem[P]>
  }




  export type SalesPriceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesPriceItemWhereInput
    orderBy?: SalesPriceItemOrderByWithAggregationInput | SalesPriceItemOrderByWithAggregationInput[]
    by: SalesPriceItemScalarFieldEnum[] | SalesPriceItemScalarFieldEnum
    having?: SalesPriceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesPriceItemCountAggregateInputType | true
    _avg?: SalesPriceItemAvgAggregateInputType
    _sum?: SalesPriceItemSumAggregateInputType
    _min?: SalesPriceItemMinAggregateInputType
    _max?: SalesPriceItemMaxAggregateInputType
  }

  export type SalesPriceItemGroupByOutputType = {
    id: number
    priceListId: number
    productId: number
    salePrice: Decimal
    rowDate: Date
    createdAt: Date
    updatedAt: Date
    updatedBy: string | null
    _count: SalesPriceItemCountAggregateOutputType | null
    _avg: SalesPriceItemAvgAggregateOutputType | null
    _sum: SalesPriceItemSumAggregateOutputType | null
    _min: SalesPriceItemMinAggregateOutputType | null
    _max: SalesPriceItemMaxAggregateOutputType | null
  }

  type GetSalesPriceItemGroupByPayload<T extends SalesPriceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesPriceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesPriceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesPriceItemGroupByOutputType[P]>
            : GetScalarType<T[P], SalesPriceItemGroupByOutputType[P]>
        }
      >
    >


  export type SalesPriceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    productId?: boolean
    salePrice?: boolean
    rowDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceItem"]>

  export type SalesPriceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    productId?: boolean
    salePrice?: boolean
    rowDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceItem"]>

  export type SalesPriceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priceListId?: boolean
    productId?: boolean
    salePrice?: boolean
    rowDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesPriceItem"]>

  export type SalesPriceItemSelectScalar = {
    id?: boolean
    priceListId?: boolean
    productId?: boolean
    salePrice?: boolean
    rowDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type SalesPriceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "priceListId" | "productId" | "salePrice" | "rowDate" | "createdAt" | "updatedAt" | "updatedBy", ExtArgs["result"]["salesPriceItem"]>
  export type SalesPriceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SalesPriceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SalesPriceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceList?: boolean | SalesPriceListDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $SalesPriceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesPriceItem"
    objects: {
      priceList: Prisma.$SalesPriceListPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      priceListId: number
      productId: number
      salePrice: Prisma.Decimal
      rowDate: Date
      createdAt: Date
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["salesPriceItem"]>
    composites: {}
  }

  type SalesPriceItemGetPayload<S extends boolean | null | undefined | SalesPriceItemDefaultArgs> = $Result.GetResult<Prisma.$SalesPriceItemPayload, S>

  type SalesPriceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesPriceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesPriceItemCountAggregateInputType | true
    }

  export interface SalesPriceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesPriceItem'], meta: { name: 'SalesPriceItem' } }
    /**
     * Find zero or one SalesPriceItem that matches the filter.
     * @param {SalesPriceItemFindUniqueArgs} args - Arguments to find a SalesPriceItem
     * @example
     * // Get one SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesPriceItemFindUniqueArgs>(args: SelectSubset<T, SalesPriceItemFindUniqueArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesPriceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesPriceItemFindUniqueOrThrowArgs} args - Arguments to find a SalesPriceItem
     * @example
     * // Get one SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesPriceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesPriceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesPriceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemFindFirstArgs} args - Arguments to find a SalesPriceItem
     * @example
     * // Get one SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesPriceItemFindFirstArgs>(args?: SelectSubset<T, SalesPriceItemFindFirstArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesPriceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemFindFirstOrThrowArgs} args - Arguments to find a SalesPriceItem
     * @example
     * // Get one SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesPriceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesPriceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesPriceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesPriceItems
     * const salesPriceItems = await prisma.salesPriceItem.findMany()
     * 
     * // Get first 10 SalesPriceItems
     * const salesPriceItems = await prisma.salesPriceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesPriceItemWithIdOnly = await prisma.salesPriceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesPriceItemFindManyArgs>(args?: SelectSubset<T, SalesPriceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesPriceItem.
     * @param {SalesPriceItemCreateArgs} args - Arguments to create a SalesPriceItem.
     * @example
     * // Create one SalesPriceItem
     * const SalesPriceItem = await prisma.salesPriceItem.create({
     *   data: {
     *     // ... data to create a SalesPriceItem
     *   }
     * })
     * 
     */
    create<T extends SalesPriceItemCreateArgs>(args: SelectSubset<T, SalesPriceItemCreateArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesPriceItems.
     * @param {SalesPriceItemCreateManyArgs} args - Arguments to create many SalesPriceItems.
     * @example
     * // Create many SalesPriceItems
     * const salesPriceItem = await prisma.salesPriceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesPriceItemCreateManyArgs>(args?: SelectSubset<T, SalesPriceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesPriceItems and returns the data saved in the database.
     * @param {SalesPriceItemCreateManyAndReturnArgs} args - Arguments to create many SalesPriceItems.
     * @example
     * // Create many SalesPriceItems
     * const salesPriceItem = await prisma.salesPriceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesPriceItems and only return the `id`
     * const salesPriceItemWithIdOnly = await prisma.salesPriceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesPriceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesPriceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesPriceItem.
     * @param {SalesPriceItemDeleteArgs} args - Arguments to delete one SalesPriceItem.
     * @example
     * // Delete one SalesPriceItem
     * const SalesPriceItem = await prisma.salesPriceItem.delete({
     *   where: {
     *     // ... filter to delete one SalesPriceItem
     *   }
     * })
     * 
     */
    delete<T extends SalesPriceItemDeleteArgs>(args: SelectSubset<T, SalesPriceItemDeleteArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesPriceItem.
     * @param {SalesPriceItemUpdateArgs} args - Arguments to update one SalesPriceItem.
     * @example
     * // Update one SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesPriceItemUpdateArgs>(args: SelectSubset<T, SalesPriceItemUpdateArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesPriceItems.
     * @param {SalesPriceItemDeleteManyArgs} args - Arguments to filter SalesPriceItems to delete.
     * @example
     * // Delete a few SalesPriceItems
     * const { count } = await prisma.salesPriceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesPriceItemDeleteManyArgs>(args?: SelectSubset<T, SalesPriceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesPriceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesPriceItems
     * const salesPriceItem = await prisma.salesPriceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesPriceItemUpdateManyArgs>(args: SelectSubset<T, SalesPriceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesPriceItems and returns the data updated in the database.
     * @param {SalesPriceItemUpdateManyAndReturnArgs} args - Arguments to update many SalesPriceItems.
     * @example
     * // Update many SalesPriceItems
     * const salesPriceItem = await prisma.salesPriceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesPriceItems and only return the `id`
     * const salesPriceItemWithIdOnly = await prisma.salesPriceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesPriceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesPriceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesPriceItem.
     * @param {SalesPriceItemUpsertArgs} args - Arguments to update or create a SalesPriceItem.
     * @example
     * // Update or create a SalesPriceItem
     * const salesPriceItem = await prisma.salesPriceItem.upsert({
     *   create: {
     *     // ... data to create a SalesPriceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesPriceItem we want to update
     *   }
     * })
     */
    upsert<T extends SalesPriceItemUpsertArgs>(args: SelectSubset<T, SalesPriceItemUpsertArgs<ExtArgs>>): Prisma__SalesPriceItemClient<$Result.GetResult<Prisma.$SalesPriceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesPriceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemCountArgs} args - Arguments to filter SalesPriceItems to count.
     * @example
     * // Count the number of SalesPriceItems
     * const count = await prisma.salesPriceItem.count({
     *   where: {
     *     // ... the filter for the SalesPriceItems we want to count
     *   }
     * })
    **/
    count<T extends SalesPriceItemCountArgs>(
      args?: Subset<T, SalesPriceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesPriceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesPriceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesPriceItemAggregateArgs>(args: Subset<T, SalesPriceItemAggregateArgs>): Prisma.PrismaPromise<GetSalesPriceItemAggregateType<T>>

    /**
     * Group by SalesPriceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesPriceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesPriceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesPriceItemGroupByArgs['orderBy'] }
        : { orderBy?: SalesPriceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesPriceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesPriceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesPriceItem model
   */
  readonly fields: SalesPriceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesPriceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesPriceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    priceList<T extends SalesPriceListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesPriceListDefaultArgs<ExtArgs>>): Prisma__SalesPriceListClient<$Result.GetResult<Prisma.$SalesPriceListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesPriceItem model
   */
  interface SalesPriceItemFieldRefs {
    readonly id: FieldRef<"SalesPriceItem", 'Int'>
    readonly priceListId: FieldRef<"SalesPriceItem", 'Int'>
    readonly productId: FieldRef<"SalesPriceItem", 'Int'>
    readonly salePrice: FieldRef<"SalesPriceItem", 'Decimal'>
    readonly rowDate: FieldRef<"SalesPriceItem", 'DateTime'>
    readonly createdAt: FieldRef<"SalesPriceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesPriceItem", 'DateTime'>
    readonly updatedBy: FieldRef<"SalesPriceItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SalesPriceItem findUnique
   */
  export type SalesPriceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceItem to fetch.
     */
    where: SalesPriceItemWhereUniqueInput
  }

  /**
   * SalesPriceItem findUniqueOrThrow
   */
  export type SalesPriceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceItem to fetch.
     */
    where: SalesPriceItemWhereUniqueInput
  }

  /**
   * SalesPriceItem findFirst
   */
  export type SalesPriceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceItem to fetch.
     */
    where?: SalesPriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceItems to fetch.
     */
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesPriceItems.
     */
    cursor?: SalesPriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesPriceItems.
     */
    distinct?: SalesPriceItemScalarFieldEnum | SalesPriceItemScalarFieldEnum[]
  }

  /**
   * SalesPriceItem findFirstOrThrow
   */
  export type SalesPriceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceItem to fetch.
     */
    where?: SalesPriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceItems to fetch.
     */
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesPriceItems.
     */
    cursor?: SalesPriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesPriceItems.
     */
    distinct?: SalesPriceItemScalarFieldEnum | SalesPriceItemScalarFieldEnum[]
  }

  /**
   * SalesPriceItem findMany
   */
  export type SalesPriceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesPriceItems to fetch.
     */
    where?: SalesPriceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesPriceItems to fetch.
     */
    orderBy?: SalesPriceItemOrderByWithRelationInput | SalesPriceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesPriceItems.
     */
    cursor?: SalesPriceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesPriceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesPriceItems.
     */
    skip?: number
    distinct?: SalesPriceItemScalarFieldEnum | SalesPriceItemScalarFieldEnum[]
  }

  /**
   * SalesPriceItem create
   */
  export type SalesPriceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesPriceItem.
     */
    data: XOR<SalesPriceItemCreateInput, SalesPriceItemUncheckedCreateInput>
  }

  /**
   * SalesPriceItem createMany
   */
  export type SalesPriceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesPriceItems.
     */
    data: SalesPriceItemCreateManyInput | SalesPriceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesPriceItem createManyAndReturn
   */
  export type SalesPriceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * The data used to create many SalesPriceItems.
     */
    data: SalesPriceItemCreateManyInput | SalesPriceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesPriceItem update
   */
  export type SalesPriceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesPriceItem.
     */
    data: XOR<SalesPriceItemUpdateInput, SalesPriceItemUncheckedUpdateInput>
    /**
     * Choose, which SalesPriceItem to update.
     */
    where: SalesPriceItemWhereUniqueInput
  }

  /**
   * SalesPriceItem updateMany
   */
  export type SalesPriceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesPriceItems.
     */
    data: XOR<SalesPriceItemUpdateManyMutationInput, SalesPriceItemUncheckedUpdateManyInput>
    /**
     * Filter which SalesPriceItems to update
     */
    where?: SalesPriceItemWhereInput
    /**
     * Limit how many SalesPriceItems to update.
     */
    limit?: number
  }

  /**
   * SalesPriceItem updateManyAndReturn
   */
  export type SalesPriceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * The data used to update SalesPriceItems.
     */
    data: XOR<SalesPriceItemUpdateManyMutationInput, SalesPriceItemUncheckedUpdateManyInput>
    /**
     * Filter which SalesPriceItems to update
     */
    where?: SalesPriceItemWhereInput
    /**
     * Limit how many SalesPriceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesPriceItem upsert
   */
  export type SalesPriceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesPriceItem to update in case it exists.
     */
    where: SalesPriceItemWhereUniqueInput
    /**
     * In case the SalesPriceItem found by the `where` argument doesn't exist, create a new SalesPriceItem with this data.
     */
    create: XOR<SalesPriceItemCreateInput, SalesPriceItemUncheckedCreateInput>
    /**
     * In case the SalesPriceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesPriceItemUpdateInput, SalesPriceItemUncheckedUpdateInput>
  }

  /**
   * SalesPriceItem delete
   */
  export type SalesPriceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
    /**
     * Filter which SalesPriceItem to delete.
     */
    where: SalesPriceItemWhereUniqueInput
  }

  /**
   * SalesPriceItem deleteMany
   */
  export type SalesPriceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesPriceItems to delete
     */
    where?: SalesPriceItemWhereInput
    /**
     * Limit how many SalesPriceItems to delete.
     */
    limit?: number
  }

  /**
   * SalesPriceItem without action
   */
  export type SalesPriceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesPriceItem
     */
    select?: SalesPriceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesPriceItem
     */
    omit?: SalesPriceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesPriceItemInclude<ExtArgs> | null
  }


  /**
   * Model ProductionMml
   */

  export type AggregateProductionMml = {
    _count: ProductionMmlCountAggregateOutputType | null
    _avg: ProductionMmlAvgAggregateOutputType | null
    _sum: ProductionMmlSumAggregateOutputType | null
    _min: ProductionMmlMinAggregateOutputType | null
    _max: ProductionMmlMaxAggregateOutputType | null
  }

  export type ProductionMmlAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    createdBy: number | null
  }

  export type ProductionMmlSumAggregateOutputType = {
    id: number | null
    productId: number | null
    createdBy: number | null
  }

  export type ProductionMmlMinAggregateOutputType = {
    id: number | null
    productId: number | null
    createdBy: number | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionMmlMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    createdBy: number | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionMmlCountAggregateOutputType = {
    id: number
    productId: number
    createdBy: number
    isLocked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionMmlAvgAggregateInputType = {
    id?: true
    productId?: true
    createdBy?: true
  }

  export type ProductionMmlSumAggregateInputType = {
    id?: true
    productId?: true
    createdBy?: true
  }

  export type ProductionMmlMinAggregateInputType = {
    id?: true
    productId?: true
    createdBy?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionMmlMaxAggregateInputType = {
    id?: true
    productId?: true
    createdBy?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionMmlCountAggregateInputType = {
    id?: true
    productId?: true
    createdBy?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionMmlAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionMml to aggregate.
     */
    where?: ProductionMmlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmls to fetch.
     */
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionMmlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionMmls
    **/
    _count?: true | ProductionMmlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionMmlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionMmlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionMmlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionMmlMaxAggregateInputType
  }

  export type GetProductionMmlAggregateType<T extends ProductionMmlAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionMml]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionMml[P]>
      : GetScalarType<T[P], AggregateProductionMml[P]>
  }




  export type ProductionMmlGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlWhereInput
    orderBy?: ProductionMmlOrderByWithAggregationInput | ProductionMmlOrderByWithAggregationInput[]
    by: ProductionMmlScalarFieldEnum[] | ProductionMmlScalarFieldEnum
    having?: ProductionMmlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionMmlCountAggregateInputType | true
    _avg?: ProductionMmlAvgAggregateInputType
    _sum?: ProductionMmlSumAggregateInputType
    _min?: ProductionMmlMinAggregateInputType
    _max?: ProductionMmlMaxAggregateInputType
  }

  export type ProductionMmlGroupByOutputType = {
    id: number
    productId: number
    createdBy: number
    isLocked: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductionMmlCountAggregateOutputType | null
    _avg: ProductionMmlAvgAggregateOutputType | null
    _sum: ProductionMmlSumAggregateOutputType | null
    _min: ProductionMmlMinAggregateOutputType | null
    _max: ProductionMmlMaxAggregateOutputType | null
  }

  type GetProductionMmlGroupByPayload<T extends ProductionMmlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionMmlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionMmlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionMmlGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionMmlGroupByOutputType[P]>
        }
      >
    >


  export type ProductionMmlSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    createdBy?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    nodes?: boolean | ProductionMml$nodesArgs<ExtArgs>
    runs?: boolean | ProductionMml$runsArgs<ExtArgs>
    suppliersWithPrimaryMml?: boolean | ProductionMml$suppliersWithPrimaryMmlArgs<ExtArgs>
    priceListSuppliers?: boolean | ProductionMml$priceListSuppliersArgs<ExtArgs>
    cuttingLines?: boolean | ProductionMml$cuttingLinesArgs<ExtArgs>
    _count?: boolean | ProductionMmlCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMml"]>

  export type ProductionMmlSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    createdBy?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMml"]>

  export type ProductionMmlSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    createdBy?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMml"]>

  export type ProductionMmlSelectScalar = {
    id?: boolean
    productId?: boolean
    createdBy?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionMmlOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "createdBy" | "isLocked" | "createdAt" | "updatedAt", ExtArgs["result"]["productionMml"]>
  export type ProductionMmlInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    nodes?: boolean | ProductionMml$nodesArgs<ExtArgs>
    runs?: boolean | ProductionMml$runsArgs<ExtArgs>
    suppliersWithPrimaryMml?: boolean | ProductionMml$suppliersWithPrimaryMmlArgs<ExtArgs>
    priceListSuppliers?: boolean | ProductionMml$priceListSuppliersArgs<ExtArgs>
    cuttingLines?: boolean | ProductionMml$cuttingLinesArgs<ExtArgs>
    _count?: boolean | ProductionMmlCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionMmlIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductionMmlIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductionMmlPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionMml"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      nodes: Prisma.$ProductionMmlNodePayload<ExtArgs>[]
      runs: Prisma.$ProductionRunPayload<ExtArgs>[]
      suppliersWithPrimaryMml: Prisma.$SupplierPayload<ExtArgs>[]
      priceListSuppliers: Prisma.$PurchasePriceListSupplierPayload<ExtArgs>[]
      cuttingLines: Prisma.$ProductionCuttingLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      createdBy: number
      isLocked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionMml"]>
    composites: {}
  }

  type ProductionMmlGetPayload<S extends boolean | null | undefined | ProductionMmlDefaultArgs> = $Result.GetResult<Prisma.$ProductionMmlPayload, S>

  type ProductionMmlCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionMmlFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionMmlCountAggregateInputType | true
    }

  export interface ProductionMmlDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionMml'], meta: { name: 'ProductionMml' } }
    /**
     * Find zero or one ProductionMml that matches the filter.
     * @param {ProductionMmlFindUniqueArgs} args - Arguments to find a ProductionMml
     * @example
     * // Get one ProductionMml
     * const productionMml = await prisma.productionMml.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionMmlFindUniqueArgs>(args: SelectSubset<T, ProductionMmlFindUniqueArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionMml that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionMmlFindUniqueOrThrowArgs} args - Arguments to find a ProductionMml
     * @example
     * // Get one ProductionMml
     * const productionMml = await prisma.productionMml.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionMmlFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionMmlFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionMml that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlFindFirstArgs} args - Arguments to find a ProductionMml
     * @example
     * // Get one ProductionMml
     * const productionMml = await prisma.productionMml.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionMmlFindFirstArgs>(args?: SelectSubset<T, ProductionMmlFindFirstArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionMml that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlFindFirstOrThrowArgs} args - Arguments to find a ProductionMml
     * @example
     * // Get one ProductionMml
     * const productionMml = await prisma.productionMml.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionMmlFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionMmlFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionMmls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionMmls
     * const productionMmls = await prisma.productionMml.findMany()
     * 
     * // Get first 10 ProductionMmls
     * const productionMmls = await prisma.productionMml.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionMmlWithIdOnly = await prisma.productionMml.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionMmlFindManyArgs>(args?: SelectSubset<T, ProductionMmlFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionMml.
     * @param {ProductionMmlCreateArgs} args - Arguments to create a ProductionMml.
     * @example
     * // Create one ProductionMml
     * const ProductionMml = await prisma.productionMml.create({
     *   data: {
     *     // ... data to create a ProductionMml
     *   }
     * })
     * 
     */
    create<T extends ProductionMmlCreateArgs>(args: SelectSubset<T, ProductionMmlCreateArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionMmls.
     * @param {ProductionMmlCreateManyArgs} args - Arguments to create many ProductionMmls.
     * @example
     * // Create many ProductionMmls
     * const productionMml = await prisma.productionMml.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionMmlCreateManyArgs>(args?: SelectSubset<T, ProductionMmlCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionMmls and returns the data saved in the database.
     * @param {ProductionMmlCreateManyAndReturnArgs} args - Arguments to create many ProductionMmls.
     * @example
     * // Create many ProductionMmls
     * const productionMml = await prisma.productionMml.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionMmls and only return the `id`
     * const productionMmlWithIdOnly = await prisma.productionMml.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionMmlCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionMmlCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionMml.
     * @param {ProductionMmlDeleteArgs} args - Arguments to delete one ProductionMml.
     * @example
     * // Delete one ProductionMml
     * const ProductionMml = await prisma.productionMml.delete({
     *   where: {
     *     // ... filter to delete one ProductionMml
     *   }
     * })
     * 
     */
    delete<T extends ProductionMmlDeleteArgs>(args: SelectSubset<T, ProductionMmlDeleteArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionMml.
     * @param {ProductionMmlUpdateArgs} args - Arguments to update one ProductionMml.
     * @example
     * // Update one ProductionMml
     * const productionMml = await prisma.productionMml.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionMmlUpdateArgs>(args: SelectSubset<T, ProductionMmlUpdateArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionMmls.
     * @param {ProductionMmlDeleteManyArgs} args - Arguments to filter ProductionMmls to delete.
     * @example
     * // Delete a few ProductionMmls
     * const { count } = await prisma.productionMml.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionMmlDeleteManyArgs>(args?: SelectSubset<T, ProductionMmlDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionMmls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionMmls
     * const productionMml = await prisma.productionMml.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionMmlUpdateManyArgs>(args: SelectSubset<T, ProductionMmlUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionMmls and returns the data updated in the database.
     * @param {ProductionMmlUpdateManyAndReturnArgs} args - Arguments to update many ProductionMmls.
     * @example
     * // Update many ProductionMmls
     * const productionMml = await prisma.productionMml.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionMmls and only return the `id`
     * const productionMmlWithIdOnly = await prisma.productionMml.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionMmlUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionMmlUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionMml.
     * @param {ProductionMmlUpsertArgs} args - Arguments to update or create a ProductionMml.
     * @example
     * // Update or create a ProductionMml
     * const productionMml = await prisma.productionMml.upsert({
     *   create: {
     *     // ... data to create a ProductionMml
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionMml we want to update
     *   }
     * })
     */
    upsert<T extends ProductionMmlUpsertArgs>(args: SelectSubset<T, ProductionMmlUpsertArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionMmls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlCountArgs} args - Arguments to filter ProductionMmls to count.
     * @example
     * // Count the number of ProductionMmls
     * const count = await prisma.productionMml.count({
     *   where: {
     *     // ... the filter for the ProductionMmls we want to count
     *   }
     * })
    **/
    count<T extends ProductionMmlCountArgs>(
      args?: Subset<T, ProductionMmlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionMmlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionMml.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionMmlAggregateArgs>(args: Subset<T, ProductionMmlAggregateArgs>): Prisma.PrismaPromise<GetProductionMmlAggregateType<T>>

    /**
     * Group by ProductionMml.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionMmlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionMmlGroupByArgs['orderBy'] }
        : { orderBy?: ProductionMmlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionMmlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionMmlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionMml model
   */
  readonly fields: ProductionMmlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionMml.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionMmlClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nodes<T extends ProductionMml$nodesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMml$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runs<T extends ProductionMml$runsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMml$runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suppliersWithPrimaryMml<T extends ProductionMml$suppliersWithPrimaryMmlArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMml$suppliersWithPrimaryMmlArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceListSuppliers<T extends ProductionMml$priceListSuppliersArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMml$priceListSuppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePriceListSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cuttingLines<T extends ProductionMml$cuttingLinesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMml$cuttingLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionMml model
   */
  interface ProductionMmlFieldRefs {
    readonly id: FieldRef<"ProductionMml", 'Int'>
    readonly productId: FieldRef<"ProductionMml", 'Int'>
    readonly createdBy: FieldRef<"ProductionMml", 'Int'>
    readonly isLocked: FieldRef<"ProductionMml", 'Boolean'>
    readonly createdAt: FieldRef<"ProductionMml", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionMml", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionMml findUnique
   */
  export type ProductionMmlFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMml to fetch.
     */
    where: ProductionMmlWhereUniqueInput
  }

  /**
   * ProductionMml findUniqueOrThrow
   */
  export type ProductionMmlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMml to fetch.
     */
    where: ProductionMmlWhereUniqueInput
  }

  /**
   * ProductionMml findFirst
   */
  export type ProductionMmlFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMml to fetch.
     */
    where?: ProductionMmlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmls to fetch.
     */
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionMmls.
     */
    cursor?: ProductionMmlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionMmls.
     */
    distinct?: ProductionMmlScalarFieldEnum | ProductionMmlScalarFieldEnum[]
  }

  /**
   * ProductionMml findFirstOrThrow
   */
  export type ProductionMmlFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMml to fetch.
     */
    where?: ProductionMmlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmls to fetch.
     */
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionMmls.
     */
    cursor?: ProductionMmlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionMmls.
     */
    distinct?: ProductionMmlScalarFieldEnum | ProductionMmlScalarFieldEnum[]
  }

  /**
   * ProductionMml findMany
   */
  export type ProductionMmlFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmls to fetch.
     */
    where?: ProductionMmlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmls to fetch.
     */
    orderBy?: ProductionMmlOrderByWithRelationInput | ProductionMmlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionMmls.
     */
    cursor?: ProductionMmlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmls.
     */
    skip?: number
    distinct?: ProductionMmlScalarFieldEnum | ProductionMmlScalarFieldEnum[]
  }

  /**
   * ProductionMml create
   */
  export type ProductionMmlCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionMml.
     */
    data: XOR<ProductionMmlCreateInput, ProductionMmlUncheckedCreateInput>
  }

  /**
   * ProductionMml createMany
   */
  export type ProductionMmlCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionMmls.
     */
    data: ProductionMmlCreateManyInput | ProductionMmlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionMml createManyAndReturn
   */
  export type ProductionMmlCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionMmls.
     */
    data: ProductionMmlCreateManyInput | ProductionMmlCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionMml update
   */
  export type ProductionMmlUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionMml.
     */
    data: XOR<ProductionMmlUpdateInput, ProductionMmlUncheckedUpdateInput>
    /**
     * Choose, which ProductionMml to update.
     */
    where: ProductionMmlWhereUniqueInput
  }

  /**
   * ProductionMml updateMany
   */
  export type ProductionMmlUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionMmls.
     */
    data: XOR<ProductionMmlUpdateManyMutationInput, ProductionMmlUncheckedUpdateManyInput>
    /**
     * Filter which ProductionMmls to update
     */
    where?: ProductionMmlWhereInput
    /**
     * Limit how many ProductionMmls to update.
     */
    limit?: number
  }

  /**
   * ProductionMml updateManyAndReturn
   */
  export type ProductionMmlUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * The data used to update ProductionMmls.
     */
    data: XOR<ProductionMmlUpdateManyMutationInput, ProductionMmlUncheckedUpdateManyInput>
    /**
     * Filter which ProductionMmls to update
     */
    where?: ProductionMmlWhereInput
    /**
     * Limit how many ProductionMmls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionMml upsert
   */
  export type ProductionMmlUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionMml to update in case it exists.
     */
    where: ProductionMmlWhereUniqueInput
    /**
     * In case the ProductionMml found by the `where` argument doesn't exist, create a new ProductionMml with this data.
     */
    create: XOR<ProductionMmlCreateInput, ProductionMmlUncheckedCreateInput>
    /**
     * In case the ProductionMml was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionMmlUpdateInput, ProductionMmlUncheckedUpdateInput>
  }

  /**
   * ProductionMml delete
   */
  export type ProductionMmlDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
    /**
     * Filter which ProductionMml to delete.
     */
    where: ProductionMmlWhereUniqueInput
  }

  /**
   * ProductionMml deleteMany
   */
  export type ProductionMmlDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionMmls to delete
     */
    where?: ProductionMmlWhereInput
    /**
     * Limit how many ProductionMmls to delete.
     */
    limit?: number
  }

  /**
   * ProductionMml.nodes
   */
  export type ProductionMml$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    where?: ProductionMmlNodeWhereInput
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    cursor?: ProductionMmlNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * ProductionMml.runs
   */
  export type ProductionMml$runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    where?: ProductionRunWhereInput
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    cursor?: ProductionRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * ProductionMml.suppliersWithPrimaryMml
   */
  export type ProductionMml$suppliersWithPrimaryMmlArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * ProductionMml.priceListSuppliers
   */
  export type ProductionMml$priceListSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePriceListSupplier
     */
    select?: PurchasePriceListSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasePriceListSupplier
     */
    omit?: PurchasePriceListSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePriceListSupplierInclude<ExtArgs> | null
    where?: PurchasePriceListSupplierWhereInput
    orderBy?: PurchasePriceListSupplierOrderByWithRelationInput | PurchasePriceListSupplierOrderByWithRelationInput[]
    cursor?: PurchasePriceListSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePriceListSupplierScalarFieldEnum | PurchasePriceListSupplierScalarFieldEnum[]
  }

  /**
   * ProductionMml.cuttingLines
   */
  export type ProductionMml$cuttingLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    where?: ProductionCuttingLineWhereInput
    orderBy?: ProductionCuttingLineOrderByWithRelationInput | ProductionCuttingLineOrderByWithRelationInput[]
    cursor?: ProductionCuttingLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionCuttingLineScalarFieldEnum | ProductionCuttingLineScalarFieldEnum[]
  }

  /**
   * ProductionMml without action
   */
  export type ProductionMmlDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMml
     */
    select?: ProductionMmlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMml
     */
    omit?: ProductionMmlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlInclude<ExtArgs> | null
  }


  /**
   * Model ProductionMmlNode
   */

  export type AggregateProductionMmlNode = {
    _count: ProductionMmlNodeCountAggregateOutputType | null
    _avg: ProductionMmlNodeAvgAggregateOutputType | null
    _sum: ProductionMmlNodeSumAggregateOutputType | null
    _min: ProductionMmlNodeMinAggregateOutputType | null
    _max: ProductionMmlNodeMaxAggregateOutputType | null
  }

  export type ProductionMmlNodeAvgAggregateOutputType = {
    id: number | null
    mmlId: number | null
    parentNodeId: number | null
    productId: number | null
    sortOrder: number | null
  }

  export type ProductionMmlNodeSumAggregateOutputType = {
    id: number | null
    mmlId: number | null
    parentNodeId: number | null
    productId: number | null
    sortOrder: number | null
  }

  export type ProductionMmlNodeMinAggregateOutputType = {
    id: number | null
    mmlId: number | null
    parentNodeId: number | null
    productId: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionMmlNodeMaxAggregateOutputType = {
    id: number | null
    mmlId: number | null
    parentNodeId: number | null
    productId: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionMmlNodeCountAggregateOutputType = {
    id: number
    mmlId: number
    parentNodeId: number
    productId: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionMmlNodeAvgAggregateInputType = {
    id?: true
    mmlId?: true
    parentNodeId?: true
    productId?: true
    sortOrder?: true
  }

  export type ProductionMmlNodeSumAggregateInputType = {
    id?: true
    mmlId?: true
    parentNodeId?: true
    productId?: true
    sortOrder?: true
  }

  export type ProductionMmlNodeMinAggregateInputType = {
    id?: true
    mmlId?: true
    parentNodeId?: true
    productId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionMmlNodeMaxAggregateInputType = {
    id?: true
    mmlId?: true
    parentNodeId?: true
    productId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionMmlNodeCountAggregateInputType = {
    id?: true
    mmlId?: true
    parentNodeId?: true
    productId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionMmlNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionMmlNode to aggregate.
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmlNodes to fetch.
     */
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionMmlNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmlNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmlNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionMmlNodes
    **/
    _count?: true | ProductionMmlNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionMmlNodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionMmlNodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionMmlNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionMmlNodeMaxAggregateInputType
  }

  export type GetProductionMmlNodeAggregateType<T extends ProductionMmlNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionMmlNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionMmlNode[P]>
      : GetScalarType<T[P], AggregateProductionMmlNode[P]>
  }




  export type ProductionMmlNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionMmlNodeWhereInput
    orderBy?: ProductionMmlNodeOrderByWithAggregationInput | ProductionMmlNodeOrderByWithAggregationInput[]
    by: ProductionMmlNodeScalarFieldEnum[] | ProductionMmlNodeScalarFieldEnum
    having?: ProductionMmlNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionMmlNodeCountAggregateInputType | true
    _avg?: ProductionMmlNodeAvgAggregateInputType
    _sum?: ProductionMmlNodeSumAggregateInputType
    _min?: ProductionMmlNodeMinAggregateInputType
    _max?: ProductionMmlNodeMaxAggregateInputType
  }

  export type ProductionMmlNodeGroupByOutputType = {
    id: number
    mmlId: number
    parentNodeId: number | null
    productId: number
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ProductionMmlNodeCountAggregateOutputType | null
    _avg: ProductionMmlNodeAvgAggregateOutputType | null
    _sum: ProductionMmlNodeSumAggregateOutputType | null
    _min: ProductionMmlNodeMinAggregateOutputType | null
    _max: ProductionMmlNodeMaxAggregateOutputType | null
  }

  type GetProductionMmlNodeGroupByPayload<T extends ProductionMmlNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionMmlNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionMmlNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionMmlNodeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionMmlNodeGroupByOutputType[P]>
        }
      >
    >


  export type ProductionMmlNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mmlId?: boolean
    parentNodeId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    children?: boolean | ProductionMmlNode$childrenArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    runValues?: boolean | ProductionMmlNode$runValuesArgs<ExtArgs>
    _count?: boolean | ProductionMmlNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMmlNode"]>

  export type ProductionMmlNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mmlId?: boolean
    parentNodeId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMmlNode"]>

  export type ProductionMmlNodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mmlId?: boolean
    parentNodeId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionMmlNode"]>

  export type ProductionMmlNodeSelectScalar = {
    id?: boolean
    mmlId?: boolean
    parentNodeId?: boolean
    productId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionMmlNodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mmlId" | "parentNodeId" | "productId" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["productionMmlNode"]>
  export type ProductionMmlNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    children?: boolean | ProductionMmlNode$childrenArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    runValues?: boolean | ProductionMmlNode$runValuesArgs<ExtArgs>
    _count?: boolean | ProductionMmlNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionMmlNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductionMmlNodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    parentNode?: boolean | ProductionMmlNode$parentNodeArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductionMmlNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionMmlNode"
    objects: {
      mml: Prisma.$ProductionMmlPayload<ExtArgs>
      parentNode: Prisma.$ProductionMmlNodePayload<ExtArgs> | null
      children: Prisma.$ProductionMmlNodePayload<ExtArgs>[]
      product: Prisma.$ProductPayload<ExtArgs>
      runValues: Prisma.$ProductionRunValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mmlId: number
      parentNodeId: number | null
      productId: number
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionMmlNode"]>
    composites: {}
  }

  type ProductionMmlNodeGetPayload<S extends boolean | null | undefined | ProductionMmlNodeDefaultArgs> = $Result.GetResult<Prisma.$ProductionMmlNodePayload, S>

  type ProductionMmlNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionMmlNodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionMmlNodeCountAggregateInputType | true
    }

  export interface ProductionMmlNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionMmlNode'], meta: { name: 'ProductionMmlNode' } }
    /**
     * Find zero or one ProductionMmlNode that matches the filter.
     * @param {ProductionMmlNodeFindUniqueArgs} args - Arguments to find a ProductionMmlNode
     * @example
     * // Get one ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionMmlNodeFindUniqueArgs>(args: SelectSubset<T, ProductionMmlNodeFindUniqueArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionMmlNode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionMmlNodeFindUniqueOrThrowArgs} args - Arguments to find a ProductionMmlNode
     * @example
     * // Get one ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionMmlNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionMmlNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionMmlNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeFindFirstArgs} args - Arguments to find a ProductionMmlNode
     * @example
     * // Get one ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionMmlNodeFindFirstArgs>(args?: SelectSubset<T, ProductionMmlNodeFindFirstArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionMmlNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeFindFirstOrThrowArgs} args - Arguments to find a ProductionMmlNode
     * @example
     * // Get one ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionMmlNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionMmlNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionMmlNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionMmlNodes
     * const productionMmlNodes = await prisma.productionMmlNode.findMany()
     * 
     * // Get first 10 ProductionMmlNodes
     * const productionMmlNodes = await prisma.productionMmlNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionMmlNodeWithIdOnly = await prisma.productionMmlNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionMmlNodeFindManyArgs>(args?: SelectSubset<T, ProductionMmlNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionMmlNode.
     * @param {ProductionMmlNodeCreateArgs} args - Arguments to create a ProductionMmlNode.
     * @example
     * // Create one ProductionMmlNode
     * const ProductionMmlNode = await prisma.productionMmlNode.create({
     *   data: {
     *     // ... data to create a ProductionMmlNode
     *   }
     * })
     * 
     */
    create<T extends ProductionMmlNodeCreateArgs>(args: SelectSubset<T, ProductionMmlNodeCreateArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionMmlNodes.
     * @param {ProductionMmlNodeCreateManyArgs} args - Arguments to create many ProductionMmlNodes.
     * @example
     * // Create many ProductionMmlNodes
     * const productionMmlNode = await prisma.productionMmlNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionMmlNodeCreateManyArgs>(args?: SelectSubset<T, ProductionMmlNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionMmlNodes and returns the data saved in the database.
     * @param {ProductionMmlNodeCreateManyAndReturnArgs} args - Arguments to create many ProductionMmlNodes.
     * @example
     * // Create many ProductionMmlNodes
     * const productionMmlNode = await prisma.productionMmlNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionMmlNodes and only return the `id`
     * const productionMmlNodeWithIdOnly = await prisma.productionMmlNode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionMmlNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionMmlNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionMmlNode.
     * @param {ProductionMmlNodeDeleteArgs} args - Arguments to delete one ProductionMmlNode.
     * @example
     * // Delete one ProductionMmlNode
     * const ProductionMmlNode = await prisma.productionMmlNode.delete({
     *   where: {
     *     // ... filter to delete one ProductionMmlNode
     *   }
     * })
     * 
     */
    delete<T extends ProductionMmlNodeDeleteArgs>(args: SelectSubset<T, ProductionMmlNodeDeleteArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionMmlNode.
     * @param {ProductionMmlNodeUpdateArgs} args - Arguments to update one ProductionMmlNode.
     * @example
     * // Update one ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionMmlNodeUpdateArgs>(args: SelectSubset<T, ProductionMmlNodeUpdateArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionMmlNodes.
     * @param {ProductionMmlNodeDeleteManyArgs} args - Arguments to filter ProductionMmlNodes to delete.
     * @example
     * // Delete a few ProductionMmlNodes
     * const { count } = await prisma.productionMmlNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionMmlNodeDeleteManyArgs>(args?: SelectSubset<T, ProductionMmlNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionMmlNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionMmlNodes
     * const productionMmlNode = await prisma.productionMmlNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionMmlNodeUpdateManyArgs>(args: SelectSubset<T, ProductionMmlNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionMmlNodes and returns the data updated in the database.
     * @param {ProductionMmlNodeUpdateManyAndReturnArgs} args - Arguments to update many ProductionMmlNodes.
     * @example
     * // Update many ProductionMmlNodes
     * const productionMmlNode = await prisma.productionMmlNode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionMmlNodes and only return the `id`
     * const productionMmlNodeWithIdOnly = await prisma.productionMmlNode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionMmlNodeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionMmlNodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionMmlNode.
     * @param {ProductionMmlNodeUpsertArgs} args - Arguments to update or create a ProductionMmlNode.
     * @example
     * // Update or create a ProductionMmlNode
     * const productionMmlNode = await prisma.productionMmlNode.upsert({
     *   create: {
     *     // ... data to create a ProductionMmlNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionMmlNode we want to update
     *   }
     * })
     */
    upsert<T extends ProductionMmlNodeUpsertArgs>(args: SelectSubset<T, ProductionMmlNodeUpsertArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionMmlNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeCountArgs} args - Arguments to filter ProductionMmlNodes to count.
     * @example
     * // Count the number of ProductionMmlNodes
     * const count = await prisma.productionMmlNode.count({
     *   where: {
     *     // ... the filter for the ProductionMmlNodes we want to count
     *   }
     * })
    **/
    count<T extends ProductionMmlNodeCountArgs>(
      args?: Subset<T, ProductionMmlNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionMmlNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionMmlNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionMmlNodeAggregateArgs>(args: Subset<T, ProductionMmlNodeAggregateArgs>): Prisma.PrismaPromise<GetProductionMmlNodeAggregateType<T>>

    /**
     * Group by ProductionMmlNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionMmlNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionMmlNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionMmlNodeGroupByArgs['orderBy'] }
        : { orderBy?: ProductionMmlNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionMmlNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionMmlNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionMmlNode model
   */
  readonly fields: ProductionMmlNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionMmlNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionMmlNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mml<T extends ProductionMmlDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlDefaultArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentNode<T extends ProductionMmlNode$parentNodeArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlNode$parentNodeArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends ProductionMmlNode$childrenArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlNode$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    runValues<T extends ProductionMmlNode$runValuesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlNode$runValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionMmlNode model
   */
  interface ProductionMmlNodeFieldRefs {
    readonly id: FieldRef<"ProductionMmlNode", 'Int'>
    readonly mmlId: FieldRef<"ProductionMmlNode", 'Int'>
    readonly parentNodeId: FieldRef<"ProductionMmlNode", 'Int'>
    readonly productId: FieldRef<"ProductionMmlNode", 'Int'>
    readonly sortOrder: FieldRef<"ProductionMmlNode", 'Int'>
    readonly createdAt: FieldRef<"ProductionMmlNode", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionMmlNode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionMmlNode findUnique
   */
  export type ProductionMmlNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmlNode to fetch.
     */
    where: ProductionMmlNodeWhereUniqueInput
  }

  /**
   * ProductionMmlNode findUniqueOrThrow
   */
  export type ProductionMmlNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmlNode to fetch.
     */
    where: ProductionMmlNodeWhereUniqueInput
  }

  /**
   * ProductionMmlNode findFirst
   */
  export type ProductionMmlNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmlNode to fetch.
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmlNodes to fetch.
     */
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionMmlNodes.
     */
    cursor?: ProductionMmlNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmlNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmlNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionMmlNodes.
     */
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * ProductionMmlNode findFirstOrThrow
   */
  export type ProductionMmlNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmlNode to fetch.
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmlNodes to fetch.
     */
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionMmlNodes.
     */
    cursor?: ProductionMmlNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmlNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmlNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionMmlNodes.
     */
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * ProductionMmlNode findMany
   */
  export type ProductionMmlNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter, which ProductionMmlNodes to fetch.
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionMmlNodes to fetch.
     */
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionMmlNodes.
     */
    cursor?: ProductionMmlNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionMmlNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionMmlNodes.
     */
    skip?: number
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * ProductionMmlNode create
   */
  export type ProductionMmlNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionMmlNode.
     */
    data: XOR<ProductionMmlNodeCreateInput, ProductionMmlNodeUncheckedCreateInput>
  }

  /**
   * ProductionMmlNode createMany
   */
  export type ProductionMmlNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionMmlNodes.
     */
    data: ProductionMmlNodeCreateManyInput | ProductionMmlNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionMmlNode createManyAndReturn
   */
  export type ProductionMmlNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionMmlNodes.
     */
    data: ProductionMmlNodeCreateManyInput | ProductionMmlNodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionMmlNode update
   */
  export type ProductionMmlNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionMmlNode.
     */
    data: XOR<ProductionMmlNodeUpdateInput, ProductionMmlNodeUncheckedUpdateInput>
    /**
     * Choose, which ProductionMmlNode to update.
     */
    where: ProductionMmlNodeWhereUniqueInput
  }

  /**
   * ProductionMmlNode updateMany
   */
  export type ProductionMmlNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionMmlNodes.
     */
    data: XOR<ProductionMmlNodeUpdateManyMutationInput, ProductionMmlNodeUncheckedUpdateManyInput>
    /**
     * Filter which ProductionMmlNodes to update
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * Limit how many ProductionMmlNodes to update.
     */
    limit?: number
  }

  /**
   * ProductionMmlNode updateManyAndReturn
   */
  export type ProductionMmlNodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * The data used to update ProductionMmlNodes.
     */
    data: XOR<ProductionMmlNodeUpdateManyMutationInput, ProductionMmlNodeUncheckedUpdateManyInput>
    /**
     * Filter which ProductionMmlNodes to update
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * Limit how many ProductionMmlNodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionMmlNode upsert
   */
  export type ProductionMmlNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionMmlNode to update in case it exists.
     */
    where: ProductionMmlNodeWhereUniqueInput
    /**
     * In case the ProductionMmlNode found by the `where` argument doesn't exist, create a new ProductionMmlNode with this data.
     */
    create: XOR<ProductionMmlNodeCreateInput, ProductionMmlNodeUncheckedCreateInput>
    /**
     * In case the ProductionMmlNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionMmlNodeUpdateInput, ProductionMmlNodeUncheckedUpdateInput>
  }

  /**
   * ProductionMmlNode delete
   */
  export type ProductionMmlNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    /**
     * Filter which ProductionMmlNode to delete.
     */
    where: ProductionMmlNodeWhereUniqueInput
  }

  /**
   * ProductionMmlNode deleteMany
   */
  export type ProductionMmlNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionMmlNodes to delete
     */
    where?: ProductionMmlNodeWhereInput
    /**
     * Limit how many ProductionMmlNodes to delete.
     */
    limit?: number
  }

  /**
   * ProductionMmlNode.parentNode
   */
  export type ProductionMmlNode$parentNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    where?: ProductionMmlNodeWhereInput
  }

  /**
   * ProductionMmlNode.children
   */
  export type ProductionMmlNode$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
    where?: ProductionMmlNodeWhereInput
    orderBy?: ProductionMmlNodeOrderByWithRelationInput | ProductionMmlNodeOrderByWithRelationInput[]
    cursor?: ProductionMmlNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionMmlNodeScalarFieldEnum | ProductionMmlNodeScalarFieldEnum[]
  }

  /**
   * ProductionMmlNode.runValues
   */
  export type ProductionMmlNode$runValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    where?: ProductionRunValueWhereInput
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    cursor?: ProductionRunValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRunValueScalarFieldEnum | ProductionRunValueScalarFieldEnum[]
  }

  /**
   * ProductionMmlNode without action
   */
  export type ProductionMmlNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionMmlNode
     */
    select?: ProductionMmlNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionMmlNode
     */
    omit?: ProductionMmlNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionMmlNodeInclude<ExtArgs> | null
  }


  /**
   * Model ProductionRun
   */

  export type AggregateProductionRun = {
    _count: ProductionRunCountAggregateOutputType | null
    _avg: ProductionRunAvgAggregateOutputType | null
    _sum: ProductionRunSumAggregateOutputType | null
    _min: ProductionRunMinAggregateOutputType | null
    _max: ProductionRunMaxAggregateOutputType | null
  }

  export type ProductionRunAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    mmlId: number | null
    userId: number | null
    plannedWeight: Decimal | null
    actualWeight: Decimal | null
  }

  export type ProductionRunSumAggregateOutputType = {
    id: number | null
    productId: number | null
    mmlId: number | null
    userId: number | null
    plannedWeight: Decimal | null
    actualWeight: Decimal | null
  }

  export type ProductionRunMinAggregateOutputType = {
    id: number | null
    productId: number | null
    mmlId: number | null
    userId: number | null
    productionDate: Date | null
    plannedWeight: Decimal | null
    actualWeight: Decimal | null
    isLocked: boolean | null
    isHidden: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionRunMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    mmlId: number | null
    userId: number | null
    productionDate: Date | null
    plannedWeight: Decimal | null
    actualWeight: Decimal | null
    isLocked: boolean | null
    isHidden: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionRunCountAggregateOutputType = {
    id: number
    productId: number
    mmlId: number
    userId: number
    productionDate: number
    plannedWeight: number
    actualWeight: number
    isLocked: number
    isHidden: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionRunAvgAggregateInputType = {
    id?: true
    productId?: true
    mmlId?: true
    userId?: true
    plannedWeight?: true
    actualWeight?: true
  }

  export type ProductionRunSumAggregateInputType = {
    id?: true
    productId?: true
    mmlId?: true
    userId?: true
    plannedWeight?: true
    actualWeight?: true
  }

  export type ProductionRunMinAggregateInputType = {
    id?: true
    productId?: true
    mmlId?: true
    userId?: true
    productionDate?: true
    plannedWeight?: true
    actualWeight?: true
    isLocked?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionRunMaxAggregateInputType = {
    id?: true
    productId?: true
    mmlId?: true
    userId?: true
    productionDate?: true
    plannedWeight?: true
    actualWeight?: true
    isLocked?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionRunCountAggregateInputType = {
    id?: true
    productId?: true
    mmlId?: true
    userId?: true
    productionDate?: true
    plannedWeight?: true
    actualWeight?: true
    isLocked?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionRun to aggregate.
     */
    where?: ProductionRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRuns to fetch.
     */
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionRuns
    **/
    _count?: true | ProductionRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionRunMaxAggregateInputType
  }

  export type GetProductionRunAggregateType<T extends ProductionRunAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionRun[P]>
      : GetScalarType<T[P], AggregateProductionRun[P]>
  }




  export type ProductionRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunWhereInput
    orderBy?: ProductionRunOrderByWithAggregationInput | ProductionRunOrderByWithAggregationInput[]
    by: ProductionRunScalarFieldEnum[] | ProductionRunScalarFieldEnum
    having?: ProductionRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionRunCountAggregateInputType | true
    _avg?: ProductionRunAvgAggregateInputType
    _sum?: ProductionRunSumAggregateInputType
    _min?: ProductionRunMinAggregateInputType
    _max?: ProductionRunMaxAggregateInputType
  }

  export type ProductionRunGroupByOutputType = {
    id: number
    productId: number
    mmlId: number
    userId: number
    productionDate: Date
    plannedWeight: Decimal | null
    actualWeight: Decimal | null
    isLocked: boolean
    isHidden: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductionRunCountAggregateOutputType | null
    _avg: ProductionRunAvgAggregateOutputType | null
    _sum: ProductionRunSumAggregateOutputType | null
    _min: ProductionRunMinAggregateOutputType | null
    _max: ProductionRunMaxAggregateOutputType | null
  }

  type GetProductionRunGroupByPayload<T extends ProductionRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionRunGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionRunGroupByOutputType[P]>
        }
      >
    >


  export type ProductionRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    mmlId?: boolean
    userId?: boolean
    productionDate?: boolean
    plannedWeight?: boolean
    actualWeight?: boolean
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    values?: boolean | ProductionRun$valuesArgs<ExtArgs>
    _count?: boolean | ProductionRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionRun"]>

  export type ProductionRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    mmlId?: boolean
    userId?: boolean
    productionDate?: boolean
    plannedWeight?: boolean
    actualWeight?: boolean
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionRun"]>

  export type ProductionRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    mmlId?: boolean
    userId?: boolean
    productionDate?: boolean
    plannedWeight?: boolean
    actualWeight?: boolean
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionRun"]>

  export type ProductionRunSelectScalar = {
    id?: boolean
    productId?: boolean
    mmlId?: boolean
    userId?: boolean
    productionDate?: boolean
    plannedWeight?: boolean
    actualWeight?: boolean
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "mmlId" | "userId" | "productionDate" | "plannedWeight" | "actualWeight" | "isLocked" | "isHidden" | "createdAt" | "updatedAt", ExtArgs["result"]["productionRun"]>
  export type ProductionRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    values?: boolean | ProductionRun$valuesArgs<ExtArgs>
    _count?: boolean | ProductionRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductionRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductionRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionRun"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      mml: Prisma.$ProductionMmlPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      values: Prisma.$ProductionRunValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      mmlId: number
      userId: number
      productionDate: Date
      plannedWeight: Prisma.Decimal | null
      actualWeight: Prisma.Decimal | null
      isLocked: boolean
      isHidden: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionRun"]>
    composites: {}
  }

  type ProductionRunGetPayload<S extends boolean | null | undefined | ProductionRunDefaultArgs> = $Result.GetResult<Prisma.$ProductionRunPayload, S>

  type ProductionRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionRunCountAggregateInputType | true
    }

  export interface ProductionRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionRun'], meta: { name: 'ProductionRun' } }
    /**
     * Find zero or one ProductionRun that matches the filter.
     * @param {ProductionRunFindUniqueArgs} args - Arguments to find a ProductionRun
     * @example
     * // Get one ProductionRun
     * const productionRun = await prisma.productionRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionRunFindUniqueArgs>(args: SelectSubset<T, ProductionRunFindUniqueArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionRunFindUniqueOrThrowArgs} args - Arguments to find a ProductionRun
     * @example
     * // Get one ProductionRun
     * const productionRun = await prisma.productionRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionRunFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunFindFirstArgs} args - Arguments to find a ProductionRun
     * @example
     * // Get one ProductionRun
     * const productionRun = await prisma.productionRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionRunFindFirstArgs>(args?: SelectSubset<T, ProductionRunFindFirstArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunFindFirstOrThrowArgs} args - Arguments to find a ProductionRun
     * @example
     * // Get one ProductionRun
     * const productionRun = await prisma.productionRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionRunFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionRuns
     * const productionRuns = await prisma.productionRun.findMany()
     * 
     * // Get first 10 ProductionRuns
     * const productionRuns = await prisma.productionRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionRunWithIdOnly = await prisma.productionRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionRunFindManyArgs>(args?: SelectSubset<T, ProductionRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionRun.
     * @param {ProductionRunCreateArgs} args - Arguments to create a ProductionRun.
     * @example
     * // Create one ProductionRun
     * const ProductionRun = await prisma.productionRun.create({
     *   data: {
     *     // ... data to create a ProductionRun
     *   }
     * })
     * 
     */
    create<T extends ProductionRunCreateArgs>(args: SelectSubset<T, ProductionRunCreateArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionRuns.
     * @param {ProductionRunCreateManyArgs} args - Arguments to create many ProductionRuns.
     * @example
     * // Create many ProductionRuns
     * const productionRun = await prisma.productionRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionRunCreateManyArgs>(args?: SelectSubset<T, ProductionRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionRuns and returns the data saved in the database.
     * @param {ProductionRunCreateManyAndReturnArgs} args - Arguments to create many ProductionRuns.
     * @example
     * // Create many ProductionRuns
     * const productionRun = await prisma.productionRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionRuns and only return the `id`
     * const productionRunWithIdOnly = await prisma.productionRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionRunCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionRun.
     * @param {ProductionRunDeleteArgs} args - Arguments to delete one ProductionRun.
     * @example
     * // Delete one ProductionRun
     * const ProductionRun = await prisma.productionRun.delete({
     *   where: {
     *     // ... filter to delete one ProductionRun
     *   }
     * })
     * 
     */
    delete<T extends ProductionRunDeleteArgs>(args: SelectSubset<T, ProductionRunDeleteArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionRun.
     * @param {ProductionRunUpdateArgs} args - Arguments to update one ProductionRun.
     * @example
     * // Update one ProductionRun
     * const productionRun = await prisma.productionRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionRunUpdateArgs>(args: SelectSubset<T, ProductionRunUpdateArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionRuns.
     * @param {ProductionRunDeleteManyArgs} args - Arguments to filter ProductionRuns to delete.
     * @example
     * // Delete a few ProductionRuns
     * const { count } = await prisma.productionRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionRunDeleteManyArgs>(args?: SelectSubset<T, ProductionRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionRuns
     * const productionRun = await prisma.productionRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionRunUpdateManyArgs>(args: SelectSubset<T, ProductionRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionRuns and returns the data updated in the database.
     * @param {ProductionRunUpdateManyAndReturnArgs} args - Arguments to update many ProductionRuns.
     * @example
     * // Update many ProductionRuns
     * const productionRun = await prisma.productionRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionRuns and only return the `id`
     * const productionRunWithIdOnly = await prisma.productionRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionRunUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionRun.
     * @param {ProductionRunUpsertArgs} args - Arguments to update or create a ProductionRun.
     * @example
     * // Update or create a ProductionRun
     * const productionRun = await prisma.productionRun.upsert({
     *   create: {
     *     // ... data to create a ProductionRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionRun we want to update
     *   }
     * })
     */
    upsert<T extends ProductionRunUpsertArgs>(args: SelectSubset<T, ProductionRunUpsertArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunCountArgs} args - Arguments to filter ProductionRuns to count.
     * @example
     * // Count the number of ProductionRuns
     * const count = await prisma.productionRun.count({
     *   where: {
     *     // ... the filter for the ProductionRuns we want to count
     *   }
     * })
    **/
    count<T extends ProductionRunCountArgs>(
      args?: Subset<T, ProductionRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionRunAggregateArgs>(args: Subset<T, ProductionRunAggregateArgs>): Prisma.PrismaPromise<GetProductionRunAggregateType<T>>

    /**
     * Group by ProductionRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionRunGroupByArgs['orderBy'] }
        : { orderBy?: ProductionRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionRun model
   */
  readonly fields: ProductionRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mml<T extends ProductionMmlDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlDefaultArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    values<T extends ProductionRun$valuesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionRun$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionRun model
   */
  interface ProductionRunFieldRefs {
    readonly id: FieldRef<"ProductionRun", 'Int'>
    readonly productId: FieldRef<"ProductionRun", 'Int'>
    readonly mmlId: FieldRef<"ProductionRun", 'Int'>
    readonly userId: FieldRef<"ProductionRun", 'Int'>
    readonly productionDate: FieldRef<"ProductionRun", 'DateTime'>
    readonly plannedWeight: FieldRef<"ProductionRun", 'Decimal'>
    readonly actualWeight: FieldRef<"ProductionRun", 'Decimal'>
    readonly isLocked: FieldRef<"ProductionRun", 'Boolean'>
    readonly isHidden: FieldRef<"ProductionRun", 'Boolean'>
    readonly createdAt: FieldRef<"ProductionRun", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionRun findUnique
   */
  export type ProductionRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRun to fetch.
     */
    where: ProductionRunWhereUniqueInput
  }

  /**
   * ProductionRun findUniqueOrThrow
   */
  export type ProductionRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRun to fetch.
     */
    where: ProductionRunWhereUniqueInput
  }

  /**
   * ProductionRun findFirst
   */
  export type ProductionRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRun to fetch.
     */
    where?: ProductionRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRuns to fetch.
     */
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionRuns.
     */
    cursor?: ProductionRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionRuns.
     */
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * ProductionRun findFirstOrThrow
   */
  export type ProductionRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRun to fetch.
     */
    where?: ProductionRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRuns to fetch.
     */
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionRuns.
     */
    cursor?: ProductionRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionRuns.
     */
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * ProductionRun findMany
   */
  export type ProductionRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRuns to fetch.
     */
    where?: ProductionRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRuns to fetch.
     */
    orderBy?: ProductionRunOrderByWithRelationInput | ProductionRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionRuns.
     */
    cursor?: ProductionRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRuns.
     */
    skip?: number
    distinct?: ProductionRunScalarFieldEnum | ProductionRunScalarFieldEnum[]
  }

  /**
   * ProductionRun create
   */
  export type ProductionRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionRun.
     */
    data: XOR<ProductionRunCreateInput, ProductionRunUncheckedCreateInput>
  }

  /**
   * ProductionRun createMany
   */
  export type ProductionRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionRuns.
     */
    data: ProductionRunCreateManyInput | ProductionRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionRun createManyAndReturn
   */
  export type ProductionRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionRuns.
     */
    data: ProductionRunCreateManyInput | ProductionRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionRun update
   */
  export type ProductionRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionRun.
     */
    data: XOR<ProductionRunUpdateInput, ProductionRunUncheckedUpdateInput>
    /**
     * Choose, which ProductionRun to update.
     */
    where: ProductionRunWhereUniqueInput
  }

  /**
   * ProductionRun updateMany
   */
  export type ProductionRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionRuns.
     */
    data: XOR<ProductionRunUpdateManyMutationInput, ProductionRunUncheckedUpdateManyInput>
    /**
     * Filter which ProductionRuns to update
     */
    where?: ProductionRunWhereInput
    /**
     * Limit how many ProductionRuns to update.
     */
    limit?: number
  }

  /**
   * ProductionRun updateManyAndReturn
   */
  export type ProductionRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * The data used to update ProductionRuns.
     */
    data: XOR<ProductionRunUpdateManyMutationInput, ProductionRunUncheckedUpdateManyInput>
    /**
     * Filter which ProductionRuns to update
     */
    where?: ProductionRunWhereInput
    /**
     * Limit how many ProductionRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionRun upsert
   */
  export type ProductionRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionRun to update in case it exists.
     */
    where: ProductionRunWhereUniqueInput
    /**
     * In case the ProductionRun found by the `where` argument doesn't exist, create a new ProductionRun with this data.
     */
    create: XOR<ProductionRunCreateInput, ProductionRunUncheckedCreateInput>
    /**
     * In case the ProductionRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionRunUpdateInput, ProductionRunUncheckedUpdateInput>
  }

  /**
   * ProductionRun delete
   */
  export type ProductionRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
    /**
     * Filter which ProductionRun to delete.
     */
    where: ProductionRunWhereUniqueInput
  }

  /**
   * ProductionRun deleteMany
   */
  export type ProductionRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionRuns to delete
     */
    where?: ProductionRunWhereInput
    /**
     * Limit how many ProductionRuns to delete.
     */
    limit?: number
  }

  /**
   * ProductionRun.values
   */
  export type ProductionRun$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    where?: ProductionRunValueWhereInput
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    cursor?: ProductionRunValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRunValueScalarFieldEnum | ProductionRunValueScalarFieldEnum[]
  }

  /**
   * ProductionRun without action
   */
  export type ProductionRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRun
     */
    select?: ProductionRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRun
     */
    omit?: ProductionRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunInclude<ExtArgs> | null
  }


  /**
   * Model ProductionRunValue
   */

  export type AggregateProductionRunValue = {
    _count: ProductionRunValueCountAggregateOutputType | null
    _avg: ProductionRunValueAvgAggregateOutputType | null
    _sum: ProductionRunValueSumAggregateOutputType | null
    _min: ProductionRunValueMinAggregateOutputType | null
    _max: ProductionRunValueMaxAggregateOutputType | null
  }

  export type ProductionRunValueAvgAggregateOutputType = {
    id: number | null
    productionRunId: number | null
    mmlNodeId: number | null
    snapshotProductId: number | null
    value: Decimal | null
  }

  export type ProductionRunValueSumAggregateOutputType = {
    id: number | null
    productionRunId: number | null
    mmlNodeId: number | null
    snapshotProductId: number | null
    value: Decimal | null
  }

  export type ProductionRunValueMinAggregateOutputType = {
    id: number | null
    productionRunId: number | null
    mmlNodeId: number | null
    snapshotProductId: number | null
    value: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionRunValueMaxAggregateOutputType = {
    id: number | null
    productionRunId: number | null
    mmlNodeId: number | null
    snapshotProductId: number | null
    value: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionRunValueCountAggregateOutputType = {
    id: number
    productionRunId: number
    mmlNodeId: number
    snapshotProductId: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionRunValueAvgAggregateInputType = {
    id?: true
    productionRunId?: true
    mmlNodeId?: true
    snapshotProductId?: true
    value?: true
  }

  export type ProductionRunValueSumAggregateInputType = {
    id?: true
    productionRunId?: true
    mmlNodeId?: true
    snapshotProductId?: true
    value?: true
  }

  export type ProductionRunValueMinAggregateInputType = {
    id?: true
    productionRunId?: true
    mmlNodeId?: true
    snapshotProductId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionRunValueMaxAggregateInputType = {
    id?: true
    productionRunId?: true
    mmlNodeId?: true
    snapshotProductId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionRunValueCountAggregateInputType = {
    id?: true
    productionRunId?: true
    mmlNodeId?: true
    snapshotProductId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionRunValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionRunValue to aggregate.
     */
    where?: ProductionRunValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRunValues to fetch.
     */
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionRunValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRunValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRunValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionRunValues
    **/
    _count?: true | ProductionRunValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionRunValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionRunValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionRunValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionRunValueMaxAggregateInputType
  }

  export type GetProductionRunValueAggregateType<T extends ProductionRunValueAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionRunValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionRunValue[P]>
      : GetScalarType<T[P], AggregateProductionRunValue[P]>
  }




  export type ProductionRunValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRunValueWhereInput
    orderBy?: ProductionRunValueOrderByWithAggregationInput | ProductionRunValueOrderByWithAggregationInput[]
    by: ProductionRunValueScalarFieldEnum[] | ProductionRunValueScalarFieldEnum
    having?: ProductionRunValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionRunValueCountAggregateInputType | true
    _avg?: ProductionRunValueAvgAggregateInputType
    _sum?: ProductionRunValueSumAggregateInputType
    _min?: ProductionRunValueMinAggregateInputType
    _max?: ProductionRunValueMaxAggregateInputType
  }

  export type ProductionRunValueGroupByOutputType = {
    id: number
    productionRunId: number
    mmlNodeId: number
    snapshotProductId: number | null
    value: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: ProductionRunValueCountAggregateOutputType | null
    _avg: ProductionRunValueAvgAggregateOutputType | null
    _sum: ProductionRunValueSumAggregateOutputType | null
    _min: ProductionRunValueMinAggregateOutputType | null
    _max: ProductionRunValueMaxAggregateOutputType | null
  }

  type GetProductionRunValueGroupByPayload<T extends ProductionRunValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionRunValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionRunValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionRunValueGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionRunValueGroupByOutputType[P]>
        }
      >
    >


  export type ProductionRunValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionRunId?: boolean
    mmlNodeId?: boolean
    snapshotProductId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
    snapshotProduct?: boolean | ProductionRunValue$snapshotProductArgs<ExtArgs>
  }, ExtArgs["result"]["productionRunValue"]>

  export type ProductionRunValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionRunId?: boolean
    mmlNodeId?: boolean
    snapshotProductId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
    snapshotProduct?: boolean | ProductionRunValue$snapshotProductArgs<ExtArgs>
  }, ExtArgs["result"]["productionRunValue"]>

  export type ProductionRunValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionRunId?: boolean
    mmlNodeId?: boolean
    snapshotProductId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
    snapshotProduct?: boolean | ProductionRunValue$snapshotProductArgs<ExtArgs>
  }, ExtArgs["result"]["productionRunValue"]>

  export type ProductionRunValueSelectScalar = {
    id?: boolean
    productionRunId?: boolean
    mmlNodeId?: boolean
    snapshotProductId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionRunValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionRunId" | "mmlNodeId" | "snapshotProductId" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["productionRunValue"]>
  export type ProductionRunValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
    snapshotProduct?: boolean | ProductionRunValue$snapshotProductArgs<ExtArgs>
  }
  export type ProductionRunValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
    snapshotProduct?: boolean | ProductionRunValue$snapshotProductArgs<ExtArgs>
  }
  export type ProductionRunValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | ProductionRunDefaultArgs<ExtArgs>
    node?: boolean | ProductionMmlNodeDefaultArgs<ExtArgs>
    snapshotProduct?: boolean | ProductionRunValue$snapshotProductArgs<ExtArgs>
  }

  export type $ProductionRunValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionRunValue"
    objects: {
      run: Prisma.$ProductionRunPayload<ExtArgs>
      node: Prisma.$ProductionMmlNodePayload<ExtArgs>
      snapshotProduct: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionRunId: number
      mmlNodeId: number
      snapshotProductId: number | null
      value: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionRunValue"]>
    composites: {}
  }

  type ProductionRunValueGetPayload<S extends boolean | null | undefined | ProductionRunValueDefaultArgs> = $Result.GetResult<Prisma.$ProductionRunValuePayload, S>

  type ProductionRunValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionRunValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionRunValueCountAggregateInputType | true
    }

  export interface ProductionRunValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionRunValue'], meta: { name: 'ProductionRunValue' } }
    /**
     * Find zero or one ProductionRunValue that matches the filter.
     * @param {ProductionRunValueFindUniqueArgs} args - Arguments to find a ProductionRunValue
     * @example
     * // Get one ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionRunValueFindUniqueArgs>(args: SelectSubset<T, ProductionRunValueFindUniqueArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionRunValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionRunValueFindUniqueOrThrowArgs} args - Arguments to find a ProductionRunValue
     * @example
     * // Get one ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionRunValueFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionRunValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionRunValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueFindFirstArgs} args - Arguments to find a ProductionRunValue
     * @example
     * // Get one ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionRunValueFindFirstArgs>(args?: SelectSubset<T, ProductionRunValueFindFirstArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionRunValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueFindFirstOrThrowArgs} args - Arguments to find a ProductionRunValue
     * @example
     * // Get one ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionRunValueFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionRunValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionRunValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionRunValues
     * const productionRunValues = await prisma.productionRunValue.findMany()
     * 
     * // Get first 10 ProductionRunValues
     * const productionRunValues = await prisma.productionRunValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionRunValueWithIdOnly = await prisma.productionRunValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionRunValueFindManyArgs>(args?: SelectSubset<T, ProductionRunValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionRunValue.
     * @param {ProductionRunValueCreateArgs} args - Arguments to create a ProductionRunValue.
     * @example
     * // Create one ProductionRunValue
     * const ProductionRunValue = await prisma.productionRunValue.create({
     *   data: {
     *     // ... data to create a ProductionRunValue
     *   }
     * })
     * 
     */
    create<T extends ProductionRunValueCreateArgs>(args: SelectSubset<T, ProductionRunValueCreateArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionRunValues.
     * @param {ProductionRunValueCreateManyArgs} args - Arguments to create many ProductionRunValues.
     * @example
     * // Create many ProductionRunValues
     * const productionRunValue = await prisma.productionRunValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionRunValueCreateManyArgs>(args?: SelectSubset<T, ProductionRunValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionRunValues and returns the data saved in the database.
     * @param {ProductionRunValueCreateManyAndReturnArgs} args - Arguments to create many ProductionRunValues.
     * @example
     * // Create many ProductionRunValues
     * const productionRunValue = await prisma.productionRunValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionRunValues and only return the `id`
     * const productionRunValueWithIdOnly = await prisma.productionRunValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionRunValueCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionRunValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionRunValue.
     * @param {ProductionRunValueDeleteArgs} args - Arguments to delete one ProductionRunValue.
     * @example
     * // Delete one ProductionRunValue
     * const ProductionRunValue = await prisma.productionRunValue.delete({
     *   where: {
     *     // ... filter to delete one ProductionRunValue
     *   }
     * })
     * 
     */
    delete<T extends ProductionRunValueDeleteArgs>(args: SelectSubset<T, ProductionRunValueDeleteArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionRunValue.
     * @param {ProductionRunValueUpdateArgs} args - Arguments to update one ProductionRunValue.
     * @example
     * // Update one ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionRunValueUpdateArgs>(args: SelectSubset<T, ProductionRunValueUpdateArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionRunValues.
     * @param {ProductionRunValueDeleteManyArgs} args - Arguments to filter ProductionRunValues to delete.
     * @example
     * // Delete a few ProductionRunValues
     * const { count } = await prisma.productionRunValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionRunValueDeleteManyArgs>(args?: SelectSubset<T, ProductionRunValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionRunValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionRunValues
     * const productionRunValue = await prisma.productionRunValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionRunValueUpdateManyArgs>(args: SelectSubset<T, ProductionRunValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionRunValues and returns the data updated in the database.
     * @param {ProductionRunValueUpdateManyAndReturnArgs} args - Arguments to update many ProductionRunValues.
     * @example
     * // Update many ProductionRunValues
     * const productionRunValue = await prisma.productionRunValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionRunValues and only return the `id`
     * const productionRunValueWithIdOnly = await prisma.productionRunValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionRunValueUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionRunValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionRunValue.
     * @param {ProductionRunValueUpsertArgs} args - Arguments to update or create a ProductionRunValue.
     * @example
     * // Update or create a ProductionRunValue
     * const productionRunValue = await prisma.productionRunValue.upsert({
     *   create: {
     *     // ... data to create a ProductionRunValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionRunValue we want to update
     *   }
     * })
     */
    upsert<T extends ProductionRunValueUpsertArgs>(args: SelectSubset<T, ProductionRunValueUpsertArgs<ExtArgs>>): Prisma__ProductionRunValueClient<$Result.GetResult<Prisma.$ProductionRunValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionRunValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueCountArgs} args - Arguments to filter ProductionRunValues to count.
     * @example
     * // Count the number of ProductionRunValues
     * const count = await prisma.productionRunValue.count({
     *   where: {
     *     // ... the filter for the ProductionRunValues we want to count
     *   }
     * })
    **/
    count<T extends ProductionRunValueCountArgs>(
      args?: Subset<T, ProductionRunValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionRunValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionRunValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionRunValueAggregateArgs>(args: Subset<T, ProductionRunValueAggregateArgs>): Prisma.PrismaPromise<GetProductionRunValueAggregateType<T>>

    /**
     * Group by ProductionRunValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRunValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionRunValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionRunValueGroupByArgs['orderBy'] }
        : { orderBy?: ProductionRunValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionRunValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionRunValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionRunValue model
   */
  readonly fields: ProductionRunValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionRunValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionRunValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    run<T extends ProductionRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionRunDefaultArgs<ExtArgs>>): Prisma__ProductionRunClient<$Result.GetResult<Prisma.$ProductionRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    node<T extends ProductionMmlNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlNodeDefaultArgs<ExtArgs>>): Prisma__ProductionMmlNodeClient<$Result.GetResult<Prisma.$ProductionMmlNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    snapshotProduct<T extends ProductionRunValue$snapshotProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductionRunValue$snapshotProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionRunValue model
   */
  interface ProductionRunValueFieldRefs {
    readonly id: FieldRef<"ProductionRunValue", 'Int'>
    readonly productionRunId: FieldRef<"ProductionRunValue", 'Int'>
    readonly mmlNodeId: FieldRef<"ProductionRunValue", 'Int'>
    readonly snapshotProductId: FieldRef<"ProductionRunValue", 'Int'>
    readonly value: FieldRef<"ProductionRunValue", 'Decimal'>
    readonly createdAt: FieldRef<"ProductionRunValue", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionRunValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionRunValue findUnique
   */
  export type ProductionRunValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRunValue to fetch.
     */
    where: ProductionRunValueWhereUniqueInput
  }

  /**
   * ProductionRunValue findUniqueOrThrow
   */
  export type ProductionRunValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRunValue to fetch.
     */
    where: ProductionRunValueWhereUniqueInput
  }

  /**
   * ProductionRunValue findFirst
   */
  export type ProductionRunValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRunValue to fetch.
     */
    where?: ProductionRunValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRunValues to fetch.
     */
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionRunValues.
     */
    cursor?: ProductionRunValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRunValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRunValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionRunValues.
     */
    distinct?: ProductionRunValueScalarFieldEnum | ProductionRunValueScalarFieldEnum[]
  }

  /**
   * ProductionRunValue findFirstOrThrow
   */
  export type ProductionRunValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRunValue to fetch.
     */
    where?: ProductionRunValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRunValues to fetch.
     */
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionRunValues.
     */
    cursor?: ProductionRunValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRunValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRunValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionRunValues.
     */
    distinct?: ProductionRunValueScalarFieldEnum | ProductionRunValueScalarFieldEnum[]
  }

  /**
   * ProductionRunValue findMany
   */
  export type ProductionRunValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRunValues to fetch.
     */
    where?: ProductionRunValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRunValues to fetch.
     */
    orderBy?: ProductionRunValueOrderByWithRelationInput | ProductionRunValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionRunValues.
     */
    cursor?: ProductionRunValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRunValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRunValues.
     */
    skip?: number
    distinct?: ProductionRunValueScalarFieldEnum | ProductionRunValueScalarFieldEnum[]
  }

  /**
   * ProductionRunValue create
   */
  export type ProductionRunValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionRunValue.
     */
    data: XOR<ProductionRunValueCreateInput, ProductionRunValueUncheckedCreateInput>
  }

  /**
   * ProductionRunValue createMany
   */
  export type ProductionRunValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionRunValues.
     */
    data: ProductionRunValueCreateManyInput | ProductionRunValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionRunValue createManyAndReturn
   */
  export type ProductionRunValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionRunValues.
     */
    data: ProductionRunValueCreateManyInput | ProductionRunValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionRunValue update
   */
  export type ProductionRunValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionRunValue.
     */
    data: XOR<ProductionRunValueUpdateInput, ProductionRunValueUncheckedUpdateInput>
    /**
     * Choose, which ProductionRunValue to update.
     */
    where: ProductionRunValueWhereUniqueInput
  }

  /**
   * ProductionRunValue updateMany
   */
  export type ProductionRunValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionRunValues.
     */
    data: XOR<ProductionRunValueUpdateManyMutationInput, ProductionRunValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductionRunValues to update
     */
    where?: ProductionRunValueWhereInput
    /**
     * Limit how many ProductionRunValues to update.
     */
    limit?: number
  }

  /**
   * ProductionRunValue updateManyAndReturn
   */
  export type ProductionRunValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * The data used to update ProductionRunValues.
     */
    data: XOR<ProductionRunValueUpdateManyMutationInput, ProductionRunValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductionRunValues to update
     */
    where?: ProductionRunValueWhereInput
    /**
     * Limit how many ProductionRunValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionRunValue upsert
   */
  export type ProductionRunValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionRunValue to update in case it exists.
     */
    where: ProductionRunValueWhereUniqueInput
    /**
     * In case the ProductionRunValue found by the `where` argument doesn't exist, create a new ProductionRunValue with this data.
     */
    create: XOR<ProductionRunValueCreateInput, ProductionRunValueUncheckedCreateInput>
    /**
     * In case the ProductionRunValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionRunValueUpdateInput, ProductionRunValueUncheckedUpdateInput>
  }

  /**
   * ProductionRunValue delete
   */
  export type ProductionRunValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
    /**
     * Filter which ProductionRunValue to delete.
     */
    where: ProductionRunValueWhereUniqueInput
  }

  /**
   * ProductionRunValue deleteMany
   */
  export type ProductionRunValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionRunValues to delete
     */
    where?: ProductionRunValueWhereInput
    /**
     * Limit how many ProductionRunValues to delete.
     */
    limit?: number
  }

  /**
   * ProductionRunValue.snapshotProduct
   */
  export type ProductionRunValue$snapshotProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * ProductionRunValue without action
   */
  export type ProductionRunValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRunValue
     */
    select?: ProductionRunValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionRunValue
     */
    omit?: ProductionRunValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRunValueInclude<ExtArgs> | null
  }


  /**
   * Model PaymentType
   */

  export type AggregatePaymentType = {
    _count: PaymentTypeCountAggregateOutputType | null
    _avg: PaymentTypeAvgAggregateOutputType | null
    _sum: PaymentTypeSumAggregateOutputType | null
    _min: PaymentTypeMinAggregateOutputType | null
    _max: PaymentTypeMaxAggregateOutputType | null
  }

  export type PaymentTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type PaymentTypeSumAggregateOutputType = {
    id: number | null
  }

  export type PaymentTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    isDefault: boolean | null
    isDisabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isDefault: boolean | null
    isDisabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentTypeCountAggregateOutputType = {
    id: number
    name: number
    isDefault: number
    isDisabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentTypeAvgAggregateInputType = {
    id?: true
  }

  export type PaymentTypeSumAggregateInputType = {
    id?: true
  }

  export type PaymentTypeMinAggregateInputType = {
    id?: true
    name?: true
    isDefault?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentTypeMaxAggregateInputType = {
    id?: true
    name?: true
    isDefault?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentTypeCountAggregateInputType = {
    id?: true
    name?: true
    isDefault?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentType to aggregate.
     */
    where?: PaymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTypes to fetch.
     */
    orderBy?: PaymentTypeOrderByWithRelationInput | PaymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentTypes
    **/
    _count?: true | PaymentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentTypeMaxAggregateInputType
  }

  export type GetPaymentTypeAggregateType<T extends PaymentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentType[P]>
      : GetScalarType<T[P], AggregatePaymentType[P]>
  }




  export type PaymentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTypeWhereInput
    orderBy?: PaymentTypeOrderByWithAggregationInput | PaymentTypeOrderByWithAggregationInput[]
    by: PaymentTypeScalarFieldEnum[] | PaymentTypeScalarFieldEnum
    having?: PaymentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentTypeCountAggregateInputType | true
    _avg?: PaymentTypeAvgAggregateInputType
    _sum?: PaymentTypeSumAggregateInputType
    _min?: PaymentTypeMinAggregateInputType
    _max?: PaymentTypeMaxAggregateInputType
  }

  export type PaymentTypeGroupByOutputType = {
    id: number
    name: string
    isDefault: boolean
    isDisabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaymentTypeCountAggregateOutputType | null
    _avg: PaymentTypeAvgAggregateOutputType | null
    _sum: PaymentTypeSumAggregateOutputType | null
    _min: PaymentTypeMinAggregateOutputType | null
    _max: PaymentTypeMaxAggregateOutputType | null
  }

  type GetPaymentTypeGroupByPayload<T extends PaymentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentTypeGroupByOutputType[P]>
        }
      >
    >


  export type PaymentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isDefault?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseItems?: boolean | PaymentType$purchaseItemsArgs<ExtArgs>
    _count?: boolean | PaymentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentType"]>

  export type PaymentTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isDefault?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentType"]>

  export type PaymentTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isDefault?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentType"]>

  export type PaymentTypeSelectScalar = {
    id?: boolean
    name?: boolean
    isDefault?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isDefault" | "isDisabled" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentType"]>
  export type PaymentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseItems?: boolean | PaymentType$purchaseItemsArgs<ExtArgs>
    _count?: boolean | PaymentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PaymentTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentType"
    objects: {
      purchaseItems: Prisma.$PurchaseItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      isDefault: boolean
      isDisabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentType"]>
    composites: {}
  }

  type PaymentTypeGetPayload<S extends boolean | null | undefined | PaymentTypeDefaultArgs> = $Result.GetResult<Prisma.$PaymentTypePayload, S>

  type PaymentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentTypeCountAggregateInputType | true
    }

  export interface PaymentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentType'], meta: { name: 'PaymentType' } }
    /**
     * Find zero or one PaymentType that matches the filter.
     * @param {PaymentTypeFindUniqueArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentTypeFindUniqueArgs>(args: SelectSubset<T, PaymentTypeFindUniqueArgs<ExtArgs>>): Prisma__PaymentTypeClient<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentTypeFindUniqueOrThrowArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentTypeClient<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeFindFirstArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentTypeFindFirstArgs>(args?: SelectSubset<T, PaymentTypeFindFirstArgs<ExtArgs>>): Prisma__PaymentTypeClient<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeFindFirstOrThrowArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentTypeClient<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentTypes
     * const paymentTypes = await prisma.paymentType.findMany()
     * 
     * // Get first 10 PaymentTypes
     * const paymentTypes = await prisma.paymentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentTypeWithIdOnly = await prisma.paymentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentTypeFindManyArgs>(args?: SelectSubset<T, PaymentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentType.
     * @param {PaymentTypeCreateArgs} args - Arguments to create a PaymentType.
     * @example
     * // Create one PaymentType
     * const PaymentType = await prisma.paymentType.create({
     *   data: {
     *     // ... data to create a PaymentType
     *   }
     * })
     * 
     */
    create<T extends PaymentTypeCreateArgs>(args: SelectSubset<T, PaymentTypeCreateArgs<ExtArgs>>): Prisma__PaymentTypeClient<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentTypes.
     * @param {PaymentTypeCreateManyArgs} args - Arguments to create many PaymentTypes.
     * @example
     * // Create many PaymentTypes
     * const paymentType = await prisma.paymentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentTypeCreateManyArgs>(args?: SelectSubset<T, PaymentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentTypes and returns the data saved in the database.
     * @param {PaymentTypeCreateManyAndReturnArgs} args - Arguments to create many PaymentTypes.
     * @example
     * // Create many PaymentTypes
     * const paymentType = await prisma.paymentType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentTypes and only return the `id`
     * const paymentTypeWithIdOnly = await prisma.paymentType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentType.
     * @param {PaymentTypeDeleteArgs} args - Arguments to delete one PaymentType.
     * @example
     * // Delete one PaymentType
     * const PaymentType = await prisma.paymentType.delete({
     *   where: {
     *     // ... filter to delete one PaymentType
     *   }
     * })
     * 
     */
    delete<T extends PaymentTypeDeleteArgs>(args: SelectSubset<T, PaymentTypeDeleteArgs<ExtArgs>>): Prisma__PaymentTypeClient<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentType.
     * @param {PaymentTypeUpdateArgs} args - Arguments to update one PaymentType.
     * @example
     * // Update one PaymentType
     * const paymentType = await prisma.paymentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentTypeUpdateArgs>(args: SelectSubset<T, PaymentTypeUpdateArgs<ExtArgs>>): Prisma__PaymentTypeClient<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentTypes.
     * @param {PaymentTypeDeleteManyArgs} args - Arguments to filter PaymentTypes to delete.
     * @example
     * // Delete a few PaymentTypes
     * const { count } = await prisma.paymentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentTypeDeleteManyArgs>(args?: SelectSubset<T, PaymentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentTypes
     * const paymentType = await prisma.paymentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentTypeUpdateManyArgs>(args: SelectSubset<T, PaymentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTypes and returns the data updated in the database.
     * @param {PaymentTypeUpdateManyAndReturnArgs} args - Arguments to update many PaymentTypes.
     * @example
     * // Update many PaymentTypes
     * const paymentType = await prisma.paymentType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentTypes and only return the `id`
     * const paymentTypeWithIdOnly = await prisma.paymentType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentType.
     * @param {PaymentTypeUpsertArgs} args - Arguments to update or create a PaymentType.
     * @example
     * // Update or create a PaymentType
     * const paymentType = await prisma.paymentType.upsert({
     *   create: {
     *     // ... data to create a PaymentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentType we want to update
     *   }
     * })
     */
    upsert<T extends PaymentTypeUpsertArgs>(args: SelectSubset<T, PaymentTypeUpsertArgs<ExtArgs>>): Prisma__PaymentTypeClient<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeCountArgs} args - Arguments to filter PaymentTypes to count.
     * @example
     * // Count the number of PaymentTypes
     * const count = await prisma.paymentType.count({
     *   where: {
     *     // ... the filter for the PaymentTypes we want to count
     *   }
     * })
    **/
    count<T extends PaymentTypeCountArgs>(
      args?: Subset<T, PaymentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentTypeAggregateArgs>(args: Subset<T, PaymentTypeAggregateArgs>): Prisma.PrismaPromise<GetPaymentTypeAggregateType<T>>

    /**
     * Group by PaymentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentTypeGroupByArgs['orderBy'] }
        : { orderBy?: PaymentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentType model
   */
  readonly fields: PaymentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseItems<T extends PaymentType$purchaseItemsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentType$purchaseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentType model
   */
  interface PaymentTypeFieldRefs {
    readonly id: FieldRef<"PaymentType", 'Int'>
    readonly name: FieldRef<"PaymentType", 'String'>
    readonly isDefault: FieldRef<"PaymentType", 'Boolean'>
    readonly isDisabled: FieldRef<"PaymentType", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentType", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentType findUnique
   */
  export type PaymentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which PaymentType to fetch.
     */
    where: PaymentTypeWhereUniqueInput
  }

  /**
   * PaymentType findUniqueOrThrow
   */
  export type PaymentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which PaymentType to fetch.
     */
    where: PaymentTypeWhereUniqueInput
  }

  /**
   * PaymentType findFirst
   */
  export type PaymentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which PaymentType to fetch.
     */
    where?: PaymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTypes to fetch.
     */
    orderBy?: PaymentTypeOrderByWithRelationInput | PaymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTypes.
     */
    cursor?: PaymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTypes.
     */
    distinct?: PaymentTypeScalarFieldEnum | PaymentTypeScalarFieldEnum[]
  }

  /**
   * PaymentType findFirstOrThrow
   */
  export type PaymentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which PaymentType to fetch.
     */
    where?: PaymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTypes to fetch.
     */
    orderBy?: PaymentTypeOrderByWithRelationInput | PaymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTypes.
     */
    cursor?: PaymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTypes.
     */
    distinct?: PaymentTypeScalarFieldEnum | PaymentTypeScalarFieldEnum[]
  }

  /**
   * PaymentType findMany
   */
  export type PaymentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTypes to fetch.
     */
    where?: PaymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTypes to fetch.
     */
    orderBy?: PaymentTypeOrderByWithRelationInput | PaymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentTypes.
     */
    cursor?: PaymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTypes.
     */
    skip?: number
    distinct?: PaymentTypeScalarFieldEnum | PaymentTypeScalarFieldEnum[]
  }

  /**
   * PaymentType create
   */
  export type PaymentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentType.
     */
    data: XOR<PaymentTypeCreateInput, PaymentTypeUncheckedCreateInput>
  }

  /**
   * PaymentType createMany
   */
  export type PaymentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentTypes.
     */
    data: PaymentTypeCreateManyInput | PaymentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentType createManyAndReturn
   */
  export type PaymentTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentTypes.
     */
    data: PaymentTypeCreateManyInput | PaymentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentType update
   */
  export type PaymentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentType.
     */
    data: XOR<PaymentTypeUpdateInput, PaymentTypeUncheckedUpdateInput>
    /**
     * Choose, which PaymentType to update.
     */
    where: PaymentTypeWhereUniqueInput
  }

  /**
   * PaymentType updateMany
   */
  export type PaymentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentTypes.
     */
    data: XOR<PaymentTypeUpdateManyMutationInput, PaymentTypeUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTypes to update
     */
    where?: PaymentTypeWhereInput
    /**
     * Limit how many PaymentTypes to update.
     */
    limit?: number
  }

  /**
   * PaymentType updateManyAndReturn
   */
  export type PaymentTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * The data used to update PaymentTypes.
     */
    data: XOR<PaymentTypeUpdateManyMutationInput, PaymentTypeUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTypes to update
     */
    where?: PaymentTypeWhereInput
    /**
     * Limit how many PaymentTypes to update.
     */
    limit?: number
  }

  /**
   * PaymentType upsert
   */
  export type PaymentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentType to update in case it exists.
     */
    where: PaymentTypeWhereUniqueInput
    /**
     * In case the PaymentType found by the `where` argument doesn't exist, create a new PaymentType with this data.
     */
    create: XOR<PaymentTypeCreateInput, PaymentTypeUncheckedCreateInput>
    /**
     * In case the PaymentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentTypeUpdateInput, PaymentTypeUncheckedUpdateInput>
  }

  /**
   * PaymentType delete
   */
  export type PaymentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTypeInclude<ExtArgs> | null
    /**
     * Filter which PaymentType to delete.
     */
    where: PaymentTypeWhereUniqueInput
  }

  /**
   * PaymentType deleteMany
   */
  export type PaymentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTypes to delete
     */
    where?: PaymentTypeWhereInput
    /**
     * Limit how many PaymentTypes to delete.
     */
    limit?: number
  }

  /**
   * PaymentType.purchaseItems
   */
  export type PaymentType$purchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PaymentType without action
   */
  export type PaymentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTypeInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    id: number | null
    totalAmount: Decimal | null
    createdByUserId: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    id: number | null
    totalAmount: Decimal | null
    createdByUserId: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: number | null
    purchaseDate: Date | null
    totalAmount: Decimal | null
    createdByUserId: number | null
    isDisabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: number | null
    purchaseDate: Date | null
    totalAmount: Decimal | null
    createdByUserId: number | null
    isDisabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    purchaseDate: number
    totalAmount: number
    createdByUserId: number
    isDisabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    id?: true
    totalAmount?: true
    createdByUserId?: true
  }

  export type PurchaseSumAggregateInputType = {
    id?: true
    totalAmount?: true
    createdByUserId?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    purchaseDate?: true
    totalAmount?: true
    createdByUserId?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    purchaseDate?: true
    totalAmount?: true
    createdByUserId?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    purchaseDate?: true
    totalAmount?: true
    createdByUserId?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: number
    purchaseDate: Date
    totalAmount: Decimal | null
    createdByUserId: number
    isDisabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseDate?: boolean
    totalAmount?: boolean
    createdByUserId?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    suppliers?: boolean | Purchase$suppliersArgs<ExtArgs>
    items?: boolean | Purchase$itemsArgs<ExtArgs>
    productionInputs?: boolean | Purchase$productionInputsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseDate?: boolean
    totalAmount?: boolean
    createdByUserId?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseDate?: boolean
    totalAmount?: boolean
    createdByUserId?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    purchaseDate?: boolean
    totalAmount?: boolean
    createdByUserId?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseDate" | "totalAmount" | "createdByUserId" | "isDisabled" | "createdAt" | "updatedAt", ExtArgs["result"]["purchase"]>
  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    suppliers?: boolean | Purchase$suppliersArgs<ExtArgs>
    items?: boolean | Purchase$itemsArgs<ExtArgs>
    productionInputs?: boolean | Purchase$productionInputsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      createdByUser: Prisma.$UserPayload<ExtArgs>
      suppliers: Prisma.$PurchaseSupplierPayload<ExtArgs>[]
      items: Prisma.$PurchaseItemPayload<ExtArgs>[]
      productionInputs: Prisma.$ProductionInputPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      purchaseDate: Date
      totalAmount: Prisma.Decimal | null
      createdByUserId: number
      isDisabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases and returns the data updated in the database.
     * @param {PurchaseUpdateManyAndReturnArgs} args - Arguments to update many Purchases.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    suppliers<T extends Purchase$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends Purchase$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionInputs<T extends Purchase$productionInputsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$productionInputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'Int'>
    readonly purchaseDate: FieldRef<"Purchase", 'DateTime'>
    readonly totalAmount: FieldRef<"Purchase", 'Decimal'>
    readonly createdByUserId: FieldRef<"Purchase", 'Int'>
    readonly isDisabled: FieldRef<"Purchase", 'Boolean'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
  }

  /**
   * Purchase updateManyAndReturn
   */
  export type PurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to delete.
     */
    limit?: number
  }

  /**
   * Purchase.suppliers
   */
  export type Purchase$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
    where?: PurchaseSupplierWhereInput
    orderBy?: PurchaseSupplierOrderByWithRelationInput | PurchaseSupplierOrderByWithRelationInput[]
    cursor?: PurchaseSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseSupplierScalarFieldEnum | PurchaseSupplierScalarFieldEnum[]
  }

  /**
   * Purchase.items
   */
  export type Purchase$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Purchase.productionInputs
   */
  export type Purchase$productionInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    where?: ProductionInputWhereInput
    orderBy?: ProductionInputOrderByWithRelationInput | ProductionInputOrderByWithRelationInput[]
    cursor?: ProductionInputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionInputScalarFieldEnum | ProductionInputScalarFieldEnum[]
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseSupplier
   */

  export type AggregatePurchaseSupplier = {
    _count: PurchaseSupplierCountAggregateOutputType | null
    _avg: PurchaseSupplierAvgAggregateOutputType | null
    _sum: PurchaseSupplierSumAggregateOutputType | null
    _min: PurchaseSupplierMinAggregateOutputType | null
    _max: PurchaseSupplierMaxAggregateOutputType | null
  }

  export type PurchaseSupplierAvgAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    supplierId: number | null
  }

  export type PurchaseSupplierSumAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    supplierId: number | null
  }

  export type PurchaseSupplierMinAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    supplierId: number | null
    createdAt: Date | null
  }

  export type PurchaseSupplierMaxAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    supplierId: number | null
    createdAt: Date | null
  }

  export type PurchaseSupplierCountAggregateOutputType = {
    id: number
    purchaseId: number
    supplierId: number
    createdAt: number
    _all: number
  }


  export type PurchaseSupplierAvgAggregateInputType = {
    id?: true
    purchaseId?: true
    supplierId?: true
  }

  export type PurchaseSupplierSumAggregateInputType = {
    id?: true
    purchaseId?: true
    supplierId?: true
  }

  export type PurchaseSupplierMinAggregateInputType = {
    id?: true
    purchaseId?: true
    supplierId?: true
    createdAt?: true
  }

  export type PurchaseSupplierMaxAggregateInputType = {
    id?: true
    purchaseId?: true
    supplierId?: true
    createdAt?: true
  }

  export type PurchaseSupplierCountAggregateInputType = {
    id?: true
    purchaseId?: true
    supplierId?: true
    createdAt?: true
    _all?: true
  }

  export type PurchaseSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseSupplier to aggregate.
     */
    where?: PurchaseSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseSuppliers to fetch.
     */
    orderBy?: PurchaseSupplierOrderByWithRelationInput | PurchaseSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseSuppliers
    **/
    _count?: true | PurchaseSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseSupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseSupplierMaxAggregateInputType
  }

  export type GetPurchaseSupplierAggregateType<T extends PurchaseSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseSupplier[P]>
      : GetScalarType<T[P], AggregatePurchaseSupplier[P]>
  }




  export type PurchaseSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseSupplierWhereInput
    orderBy?: PurchaseSupplierOrderByWithAggregationInput | PurchaseSupplierOrderByWithAggregationInput[]
    by: PurchaseSupplierScalarFieldEnum[] | PurchaseSupplierScalarFieldEnum
    having?: PurchaseSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseSupplierCountAggregateInputType | true
    _avg?: PurchaseSupplierAvgAggregateInputType
    _sum?: PurchaseSupplierSumAggregateInputType
    _min?: PurchaseSupplierMinAggregateInputType
    _max?: PurchaseSupplierMaxAggregateInputType
  }

  export type PurchaseSupplierGroupByOutputType = {
    id: number
    purchaseId: number
    supplierId: number
    createdAt: Date
    _count: PurchaseSupplierCountAggregateOutputType | null
    _avg: PurchaseSupplierAvgAggregateOutputType | null
    _sum: PurchaseSupplierSumAggregateOutputType | null
    _min: PurchaseSupplierMinAggregateOutputType | null
    _max: PurchaseSupplierMaxAggregateOutputType | null
  }

  type GetPurchaseSupplierGroupByPayload<T extends PurchaseSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseSupplierGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    supplierId?: boolean
    createdAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseSupplier"]>

  export type PurchaseSupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    supplierId?: boolean
    createdAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseSupplier"]>

  export type PurchaseSupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    supplierId?: boolean
    createdAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseSupplier"]>

  export type PurchaseSupplierSelectScalar = {
    id?: boolean
    purchaseId?: boolean
    supplierId?: boolean
    createdAt?: boolean
  }

  export type PurchaseSupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseId" | "supplierId" | "createdAt", ExtArgs["result"]["purchaseSupplier"]>
  export type PurchaseSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type PurchaseSupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type PurchaseSupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $PurchaseSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseSupplier"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      purchaseId: number
      supplierId: number
      createdAt: Date
    }, ExtArgs["result"]["purchaseSupplier"]>
    composites: {}
  }

  type PurchaseSupplierGetPayload<S extends boolean | null | undefined | PurchaseSupplierDefaultArgs> = $Result.GetResult<Prisma.$PurchaseSupplierPayload, S>

  type PurchaseSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseSupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseSupplierCountAggregateInputType | true
    }

  export interface PurchaseSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseSupplier'], meta: { name: 'PurchaseSupplier' } }
    /**
     * Find zero or one PurchaseSupplier that matches the filter.
     * @param {PurchaseSupplierFindUniqueArgs} args - Arguments to find a PurchaseSupplier
     * @example
     * // Get one PurchaseSupplier
     * const purchaseSupplier = await prisma.purchaseSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseSupplierFindUniqueArgs>(args: SelectSubset<T, PurchaseSupplierFindUniqueArgs<ExtArgs>>): Prisma__PurchaseSupplierClient<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseSupplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseSupplierFindUniqueOrThrowArgs} args - Arguments to find a PurchaseSupplier
     * @example
     * // Get one PurchaseSupplier
     * const purchaseSupplier = await prisma.purchaseSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseSupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseSupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseSupplierClient<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseSupplierFindFirstArgs} args - Arguments to find a PurchaseSupplier
     * @example
     * // Get one PurchaseSupplier
     * const purchaseSupplier = await prisma.purchaseSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseSupplierFindFirstArgs>(args?: SelectSubset<T, PurchaseSupplierFindFirstArgs<ExtArgs>>): Prisma__PurchaseSupplierClient<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseSupplierFindFirstOrThrowArgs} args - Arguments to find a PurchaseSupplier
     * @example
     * // Get one PurchaseSupplier
     * const purchaseSupplier = await prisma.purchaseSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseSupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseSupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseSupplierClient<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseSupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseSuppliers
     * const purchaseSuppliers = await prisma.purchaseSupplier.findMany()
     * 
     * // Get first 10 PurchaseSuppliers
     * const purchaseSuppliers = await prisma.purchaseSupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseSupplierWithIdOnly = await prisma.purchaseSupplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseSupplierFindManyArgs>(args?: SelectSubset<T, PurchaseSupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseSupplier.
     * @param {PurchaseSupplierCreateArgs} args - Arguments to create a PurchaseSupplier.
     * @example
     * // Create one PurchaseSupplier
     * const PurchaseSupplier = await prisma.purchaseSupplier.create({
     *   data: {
     *     // ... data to create a PurchaseSupplier
     *   }
     * })
     * 
     */
    create<T extends PurchaseSupplierCreateArgs>(args: SelectSubset<T, PurchaseSupplierCreateArgs<ExtArgs>>): Prisma__PurchaseSupplierClient<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseSuppliers.
     * @param {PurchaseSupplierCreateManyArgs} args - Arguments to create many PurchaseSuppliers.
     * @example
     * // Create many PurchaseSuppliers
     * const purchaseSupplier = await prisma.purchaseSupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseSupplierCreateManyArgs>(args?: SelectSubset<T, PurchaseSupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseSuppliers and returns the data saved in the database.
     * @param {PurchaseSupplierCreateManyAndReturnArgs} args - Arguments to create many PurchaseSuppliers.
     * @example
     * // Create many PurchaseSuppliers
     * const purchaseSupplier = await prisma.purchaseSupplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseSuppliers and only return the `id`
     * const purchaseSupplierWithIdOnly = await prisma.purchaseSupplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseSupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseSupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseSupplier.
     * @param {PurchaseSupplierDeleteArgs} args - Arguments to delete one PurchaseSupplier.
     * @example
     * // Delete one PurchaseSupplier
     * const PurchaseSupplier = await prisma.purchaseSupplier.delete({
     *   where: {
     *     // ... filter to delete one PurchaseSupplier
     *   }
     * })
     * 
     */
    delete<T extends PurchaseSupplierDeleteArgs>(args: SelectSubset<T, PurchaseSupplierDeleteArgs<ExtArgs>>): Prisma__PurchaseSupplierClient<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseSupplier.
     * @param {PurchaseSupplierUpdateArgs} args - Arguments to update one PurchaseSupplier.
     * @example
     * // Update one PurchaseSupplier
     * const purchaseSupplier = await prisma.purchaseSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseSupplierUpdateArgs>(args: SelectSubset<T, PurchaseSupplierUpdateArgs<ExtArgs>>): Prisma__PurchaseSupplierClient<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseSuppliers.
     * @param {PurchaseSupplierDeleteManyArgs} args - Arguments to filter PurchaseSuppliers to delete.
     * @example
     * // Delete a few PurchaseSuppliers
     * const { count } = await prisma.purchaseSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseSupplierDeleteManyArgs>(args?: SelectSubset<T, PurchaseSupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseSuppliers
     * const purchaseSupplier = await prisma.purchaseSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseSupplierUpdateManyArgs>(args: SelectSubset<T, PurchaseSupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseSuppliers and returns the data updated in the database.
     * @param {PurchaseSupplierUpdateManyAndReturnArgs} args - Arguments to update many PurchaseSuppliers.
     * @example
     * // Update many PurchaseSuppliers
     * const purchaseSupplier = await prisma.purchaseSupplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseSuppliers and only return the `id`
     * const purchaseSupplierWithIdOnly = await prisma.purchaseSupplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseSupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseSupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseSupplier.
     * @param {PurchaseSupplierUpsertArgs} args - Arguments to update or create a PurchaseSupplier.
     * @example
     * // Update or create a PurchaseSupplier
     * const purchaseSupplier = await prisma.purchaseSupplier.upsert({
     *   create: {
     *     // ... data to create a PurchaseSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseSupplier we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseSupplierUpsertArgs>(args: SelectSubset<T, PurchaseSupplierUpsertArgs<ExtArgs>>): Prisma__PurchaseSupplierClient<$Result.GetResult<Prisma.$PurchaseSupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseSupplierCountArgs} args - Arguments to filter PurchaseSuppliers to count.
     * @example
     * // Count the number of PurchaseSuppliers
     * const count = await prisma.purchaseSupplier.count({
     *   where: {
     *     // ... the filter for the PurchaseSuppliers we want to count
     *   }
     * })
    **/
    count<T extends PurchaseSupplierCountArgs>(
      args?: Subset<T, PurchaseSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseSupplierAggregateArgs>(args: Subset<T, PurchaseSupplierAggregateArgs>): Prisma.PrismaPromise<GetPurchaseSupplierAggregateType<T>>

    /**
     * Group by PurchaseSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseSupplierGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseSupplier model
   */
  readonly fields: PurchaseSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends PurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDefaultArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseSupplier model
   */
  interface PurchaseSupplierFieldRefs {
    readonly id: FieldRef<"PurchaseSupplier", 'Int'>
    readonly purchaseId: FieldRef<"PurchaseSupplier", 'Int'>
    readonly supplierId: FieldRef<"PurchaseSupplier", 'Int'>
    readonly createdAt: FieldRef<"PurchaseSupplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseSupplier findUnique
   */
  export type PurchaseSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseSupplier to fetch.
     */
    where: PurchaseSupplierWhereUniqueInput
  }

  /**
   * PurchaseSupplier findUniqueOrThrow
   */
  export type PurchaseSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseSupplier to fetch.
     */
    where: PurchaseSupplierWhereUniqueInput
  }

  /**
   * PurchaseSupplier findFirst
   */
  export type PurchaseSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseSupplier to fetch.
     */
    where?: PurchaseSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseSuppliers to fetch.
     */
    orderBy?: PurchaseSupplierOrderByWithRelationInput | PurchaseSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseSuppliers.
     */
    cursor?: PurchaseSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseSuppliers.
     */
    distinct?: PurchaseSupplierScalarFieldEnum | PurchaseSupplierScalarFieldEnum[]
  }

  /**
   * PurchaseSupplier findFirstOrThrow
   */
  export type PurchaseSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseSupplier to fetch.
     */
    where?: PurchaseSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseSuppliers to fetch.
     */
    orderBy?: PurchaseSupplierOrderByWithRelationInput | PurchaseSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseSuppliers.
     */
    cursor?: PurchaseSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseSuppliers.
     */
    distinct?: PurchaseSupplierScalarFieldEnum | PurchaseSupplierScalarFieldEnum[]
  }

  /**
   * PurchaseSupplier findMany
   */
  export type PurchaseSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseSuppliers to fetch.
     */
    where?: PurchaseSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseSuppliers to fetch.
     */
    orderBy?: PurchaseSupplierOrderByWithRelationInput | PurchaseSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseSuppliers.
     */
    cursor?: PurchaseSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseSuppliers.
     */
    skip?: number
    distinct?: PurchaseSupplierScalarFieldEnum | PurchaseSupplierScalarFieldEnum[]
  }

  /**
   * PurchaseSupplier create
   */
  export type PurchaseSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseSupplier.
     */
    data: XOR<PurchaseSupplierCreateInput, PurchaseSupplierUncheckedCreateInput>
  }

  /**
   * PurchaseSupplier createMany
   */
  export type PurchaseSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseSuppliers.
     */
    data: PurchaseSupplierCreateManyInput | PurchaseSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseSupplier createManyAndReturn
   */
  export type PurchaseSupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseSuppliers.
     */
    data: PurchaseSupplierCreateManyInput | PurchaseSupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseSupplier update
   */
  export type PurchaseSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseSupplier.
     */
    data: XOR<PurchaseSupplierUpdateInput, PurchaseSupplierUncheckedUpdateInput>
    /**
     * Choose, which PurchaseSupplier to update.
     */
    where: PurchaseSupplierWhereUniqueInput
  }

  /**
   * PurchaseSupplier updateMany
   */
  export type PurchaseSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseSuppliers.
     */
    data: XOR<PurchaseSupplierUpdateManyMutationInput, PurchaseSupplierUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseSuppliers to update
     */
    where?: PurchaseSupplierWhereInput
    /**
     * Limit how many PurchaseSuppliers to update.
     */
    limit?: number
  }

  /**
   * PurchaseSupplier updateManyAndReturn
   */
  export type PurchaseSupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseSuppliers.
     */
    data: XOR<PurchaseSupplierUpdateManyMutationInput, PurchaseSupplierUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseSuppliers to update
     */
    where?: PurchaseSupplierWhereInput
    /**
     * Limit how many PurchaseSuppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseSupplier upsert
   */
  export type PurchaseSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseSupplier to update in case it exists.
     */
    where: PurchaseSupplierWhereUniqueInput
    /**
     * In case the PurchaseSupplier found by the `where` argument doesn't exist, create a new PurchaseSupplier with this data.
     */
    create: XOR<PurchaseSupplierCreateInput, PurchaseSupplierUncheckedCreateInput>
    /**
     * In case the PurchaseSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseSupplierUpdateInput, PurchaseSupplierUncheckedUpdateInput>
  }

  /**
   * PurchaseSupplier delete
   */
  export type PurchaseSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
    /**
     * Filter which PurchaseSupplier to delete.
     */
    where: PurchaseSupplierWhereUniqueInput
  }

  /**
   * PurchaseSupplier deleteMany
   */
  export type PurchaseSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseSuppliers to delete
     */
    where?: PurchaseSupplierWhereInput
    /**
     * Limit how many PurchaseSuppliers to delete.
     */
    limit?: number
  }

  /**
   * PurchaseSupplier without action
   */
  export type PurchaseSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseSupplier
     */
    select?: PurchaseSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseSupplier
     */
    omit?: PurchaseSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseSupplierInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseItem
   */

  export type AggregatePurchaseItem = {
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  export type PurchaseItemAvgAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    supplierId: number | null
    productId: number | null
    price: Decimal | null
    qty: Decimal | null
    amount: Decimal | null
    paymentTypeId: number | null
  }

  export type PurchaseItemSumAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    supplierId: number | null
    productId: number | null
    price: Decimal | null
    qty: Decimal | null
    amount: Decimal | null
    paymentTypeId: number | null
  }

  export type PurchaseItemMinAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    supplierId: number | null
    productId: number | null
    price: Decimal | null
    qty: Decimal | null
    amount: Decimal | null
    paymentTypeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseItemMaxAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    supplierId: number | null
    productId: number | null
    price: Decimal | null
    qty: Decimal | null
    amount: Decimal | null
    paymentTypeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseItemCountAggregateOutputType = {
    id: number
    purchaseId: number
    supplierId: number
    productId: number
    price: number
    qty: number
    amount: number
    paymentTypeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseItemAvgAggregateInputType = {
    id?: true
    purchaseId?: true
    supplierId?: true
    productId?: true
    price?: true
    qty?: true
    amount?: true
    paymentTypeId?: true
  }

  export type PurchaseItemSumAggregateInputType = {
    id?: true
    purchaseId?: true
    supplierId?: true
    productId?: true
    price?: true
    qty?: true
    amount?: true
    paymentTypeId?: true
  }

  export type PurchaseItemMinAggregateInputType = {
    id?: true
    purchaseId?: true
    supplierId?: true
    productId?: true
    price?: true
    qty?: true
    amount?: true
    paymentTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseItemMaxAggregateInputType = {
    id?: true
    purchaseId?: true
    supplierId?: true
    productId?: true
    price?: true
    qty?: true
    amount?: true
    paymentTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseItemCountAggregateInputType = {
    id?: true
    purchaseId?: true
    supplierId?: true
    productId?: true
    price?: true
    qty?: true
    amount?: true
    paymentTypeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItem to aggregate.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseItems
    **/
    _count?: true | PurchaseItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type GetPurchaseItemAggregateType<T extends PurchaseItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseItem[P]>
      : GetScalarType<T[P], AggregatePurchaseItem[P]>
  }




  export type PurchaseItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithAggregationInput | PurchaseItemOrderByWithAggregationInput[]
    by: PurchaseItemScalarFieldEnum[] | PurchaseItemScalarFieldEnum
    having?: PurchaseItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseItemCountAggregateInputType | true
    _avg?: PurchaseItemAvgAggregateInputType
    _sum?: PurchaseItemSumAggregateInputType
    _min?: PurchaseItemMinAggregateInputType
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type PurchaseItemGroupByOutputType = {
    id: number
    purchaseId: number
    supplierId: number
    productId: number
    price: Decimal
    qty: Decimal
    amount: Decimal
    paymentTypeId: number | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  type GetPurchaseItemGroupByPayload<T extends PurchaseItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    supplierId?: boolean
    productId?: boolean
    price?: boolean
    qty?: boolean
    amount?: boolean
    paymentTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    paymentType?: boolean | PurchaseItem$paymentTypeArgs<ExtArgs>
    productionInputs?: boolean | PurchaseItem$productionInputsArgs<ExtArgs>
    _count?: boolean | PurchaseItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>

  export type PurchaseItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    supplierId?: boolean
    productId?: boolean
    price?: boolean
    qty?: boolean
    amount?: boolean
    paymentTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    paymentType?: boolean | PurchaseItem$paymentTypeArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>

  export type PurchaseItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    supplierId?: boolean
    productId?: boolean
    price?: boolean
    qty?: boolean
    amount?: boolean
    paymentTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    paymentType?: boolean | PurchaseItem$paymentTypeArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>

  export type PurchaseItemSelectScalar = {
    id?: boolean
    purchaseId?: boolean
    supplierId?: boolean
    productId?: boolean
    price?: boolean
    qty?: boolean
    amount?: boolean
    paymentTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseId" | "supplierId" | "productId" | "price" | "qty" | "amount" | "paymentTypeId" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseItem"]>
  export type PurchaseItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    paymentType?: boolean | PurchaseItem$paymentTypeArgs<ExtArgs>
    productionInputs?: boolean | PurchaseItem$productionInputsArgs<ExtArgs>
    _count?: boolean | PurchaseItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    paymentType?: boolean | PurchaseItem$paymentTypeArgs<ExtArgs>
  }
  export type PurchaseItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    paymentType?: boolean | PurchaseItem$paymentTypeArgs<ExtArgs>
  }

  export type $PurchaseItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseItem"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      paymentType: Prisma.$PaymentTypePayload<ExtArgs> | null
      productionInputs: Prisma.$ProductionInputPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      purchaseId: number
      supplierId: number
      productId: number
      price: Prisma.Decimal
      qty: Prisma.Decimal
      amount: Prisma.Decimal
      paymentTypeId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseItem"]>
    composites: {}
  }

  type PurchaseItemGetPayload<S extends boolean | null | undefined | PurchaseItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseItemPayload, S>

  type PurchaseItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseItemCountAggregateInputType | true
    }

  export interface PurchaseItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseItem'], meta: { name: 'PurchaseItem' } }
    /**
     * Find zero or one PurchaseItem that matches the filter.
     * @param {PurchaseItemFindUniqueArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseItemFindUniqueArgs>(args: SelectSubset<T, PurchaseItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseItemFindFirstArgs>(args?: SelectSubset<T, PurchaseItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany()
     * 
     * // Get first 10 PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseItemFindManyArgs>(args?: SelectSubset<T, PurchaseItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseItem.
     * @param {PurchaseItemCreateArgs} args - Arguments to create a PurchaseItem.
     * @example
     * // Create one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.create({
     *   data: {
     *     // ... data to create a PurchaseItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseItemCreateArgs>(args: SelectSubset<T, PurchaseItemCreateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseItems.
     * @param {PurchaseItemCreateManyArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseItemCreateManyArgs>(args?: SelectSubset<T, PurchaseItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseItems and returns the data saved in the database.
     * @param {PurchaseItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseItems and only return the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseItem.
     * @param {PurchaseItemDeleteArgs} args - Arguments to delete one PurchaseItem.
     * @example
     * // Delete one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseItemDeleteArgs>(args: SelectSubset<T, PurchaseItemDeleteArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseItem.
     * @param {PurchaseItemUpdateArgs} args - Arguments to update one PurchaseItem.
     * @example
     * // Update one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseItemUpdateArgs>(args: SelectSubset<T, PurchaseItemUpdateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseItems.
     * @param {PurchaseItemDeleteManyArgs} args - Arguments to filter PurchaseItems to delete.
     * @example
     * // Delete a few PurchaseItems
     * const { count } = await prisma.purchaseItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseItemUpdateManyArgs>(args: SelectSubset<T, PurchaseItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems and returns the data updated in the database.
     * @param {PurchaseItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseItems.
     * @example
     * // Update many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseItems and only return the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseItem.
     * @param {PurchaseItemUpsertArgs} args - Arguments to update or create a PurchaseItem.
     * @example
     * // Update or create a PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseItemUpsertArgs>(args: SelectSubset<T, PurchaseItemUpsertArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemCountArgs} args - Arguments to filter PurchaseItems to count.
     * @example
     * // Count the number of PurchaseItems
     * const count = await prisma.purchaseItem.count({
     *   where: {
     *     // ... the filter for the PurchaseItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseItemCountArgs>(
      args?: Subset<T, PurchaseItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseItemAggregateArgs>(args: Subset<T, PurchaseItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseItemAggregateType<T>>

    /**
     * Group by PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseItem model
   */
  readonly fields: PurchaseItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends PurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDefaultArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentType<T extends PurchaseItem$paymentTypeArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseItem$paymentTypeArgs<ExtArgs>>): Prisma__PaymentTypeClient<$Result.GetResult<Prisma.$PaymentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productionInputs<T extends PurchaseItem$productionInputsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseItem$productionInputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseItem model
   */
  interface PurchaseItemFieldRefs {
    readonly id: FieldRef<"PurchaseItem", 'Int'>
    readonly purchaseId: FieldRef<"PurchaseItem", 'Int'>
    readonly supplierId: FieldRef<"PurchaseItem", 'Int'>
    readonly productId: FieldRef<"PurchaseItem", 'Int'>
    readonly price: FieldRef<"PurchaseItem", 'Decimal'>
    readonly qty: FieldRef<"PurchaseItem", 'Decimal'>
    readonly amount: FieldRef<"PurchaseItem", 'Decimal'>
    readonly paymentTypeId: FieldRef<"PurchaseItem", 'Int'>
    readonly createdAt: FieldRef<"PurchaseItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseItem findUnique
   */
  export type PurchaseItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findUniqueOrThrow
   */
  export type PurchaseItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findFirst
   */
  export type PurchaseItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findFirstOrThrow
   */
  export type PurchaseItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findMany
   */
  export type PurchaseItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem create
   */
  export type PurchaseItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseItem.
     */
    data: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
  }

  /**
   * PurchaseItem createMany
   */
  export type PurchaseItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemCreateManyInput | PurchaseItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseItem createManyAndReturn
   */
  export type PurchaseItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemCreateManyInput | PurchaseItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseItem update
   */
  export type PurchaseItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseItem.
     */
    data: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseItem to update.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem updateMany
   */
  export type PurchaseItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemWhereInput
    /**
     * Limit how many PurchaseItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseItem updateManyAndReturn
   */
  export type PurchaseItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemWhereInput
    /**
     * Limit how many PurchaseItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseItem upsert
   */
  export type PurchaseItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseItem to update in case it exists.
     */
    where: PurchaseItemWhereUniqueInput
    /**
     * In case the PurchaseItem found by the `where` argument doesn't exist, create a new PurchaseItem with this data.
     */
    create: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
    /**
     * In case the PurchaseItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
  }

  /**
   * PurchaseItem delete
   */
  export type PurchaseItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseItem to delete.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem deleteMany
   */
  export type PurchaseItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItems to delete
     */
    where?: PurchaseItemWhereInput
    /**
     * Limit how many PurchaseItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseItem.paymentType
   */
  export type PurchaseItem$paymentTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentType
     */
    omit?: PaymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTypeInclude<ExtArgs> | null
    where?: PaymentTypeWhereInput
  }

  /**
   * PurchaseItem.productionInputs
   */
  export type PurchaseItem$productionInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    where?: ProductionInputWhereInput
    orderBy?: ProductionInputOrderByWithRelationInput | ProductionInputOrderByWithRelationInput[]
    cursor?: ProductionInputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionInputScalarFieldEnum | ProductionInputScalarFieldEnum[]
  }

  /**
   * PurchaseItem without action
   */
  export type PurchaseItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
  }


  /**
   * Model TelegramGroup
   */

  export type AggregateTelegramGroup = {
    _count: TelegramGroupCountAggregateOutputType | null
    _avg: TelegramGroupAvgAggregateOutputType | null
    _sum: TelegramGroupSumAggregateOutputType | null
    _min: TelegramGroupMinAggregateOutputType | null
    _max: TelegramGroupMaxAggregateOutputType | null
  }

  export type TelegramGroupAvgAggregateOutputType = {
    id: number | null
    lastMessageId: number | null
  }

  export type TelegramGroupSumAggregateOutputType = {
    id: number | null
    lastMessageId: number | null
  }

  export type TelegramGroupMinAggregateOutputType = {
    id: number | null
    chatId: string | null
    title: string | null
    username: string | null
    isActive: boolean | null
    lastMessageId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramGroupMaxAggregateOutputType = {
    id: number | null
    chatId: string | null
    title: string | null
    username: string | null
    isActive: boolean | null
    lastMessageId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramGroupCountAggregateOutputType = {
    id: number
    chatId: number
    title: number
    username: number
    isActive: number
    lastMessageId: number
    parsePatterns: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TelegramGroupAvgAggregateInputType = {
    id?: true
    lastMessageId?: true
  }

  export type TelegramGroupSumAggregateInputType = {
    id?: true
    lastMessageId?: true
  }

  export type TelegramGroupMinAggregateInputType = {
    id?: true
    chatId?: true
    title?: true
    username?: true
    isActive?: true
    lastMessageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramGroupMaxAggregateInputType = {
    id?: true
    chatId?: true
    title?: true
    username?: true
    isActive?: true
    lastMessageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramGroupCountAggregateInputType = {
    id?: true
    chatId?: true
    title?: true
    username?: true
    isActive?: true
    lastMessageId?: true
    parsePatterns?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TelegramGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramGroup to aggregate.
     */
    where?: TelegramGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramGroups to fetch.
     */
    orderBy?: TelegramGroupOrderByWithRelationInput | TelegramGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelegramGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelegramGroups
    **/
    _count?: true | TelegramGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TelegramGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TelegramGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelegramGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelegramGroupMaxAggregateInputType
  }

  export type GetTelegramGroupAggregateType<T extends TelegramGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateTelegramGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelegramGroup[P]>
      : GetScalarType<T[P], AggregateTelegramGroup[P]>
  }




  export type TelegramGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramGroupWhereInput
    orderBy?: TelegramGroupOrderByWithAggregationInput | TelegramGroupOrderByWithAggregationInput[]
    by: TelegramGroupScalarFieldEnum[] | TelegramGroupScalarFieldEnum
    having?: TelegramGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelegramGroupCountAggregateInputType | true
    _avg?: TelegramGroupAvgAggregateInputType
    _sum?: TelegramGroupSumAggregateInputType
    _min?: TelegramGroupMinAggregateInputType
    _max?: TelegramGroupMaxAggregateInputType
  }

  export type TelegramGroupGroupByOutputType = {
    id: number
    chatId: string
    title: string
    username: string | null
    isActive: boolean
    lastMessageId: number | null
    parsePatterns: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TelegramGroupCountAggregateOutputType | null
    _avg: TelegramGroupAvgAggregateOutputType | null
    _sum: TelegramGroupSumAggregateOutputType | null
    _min: TelegramGroupMinAggregateOutputType | null
    _max: TelegramGroupMaxAggregateOutputType | null
  }

  type GetTelegramGroupGroupByPayload<T extends TelegramGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelegramGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelegramGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelegramGroupGroupByOutputType[P]>
            : GetScalarType<T[P], TelegramGroupGroupByOutputType[P]>
        }
      >
    >


  export type TelegramGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    title?: boolean
    username?: boolean
    isActive?: boolean
    lastMessageId?: boolean
    parsePatterns?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderDrafts?: boolean | TelegramGroup$orderDraftsArgs<ExtArgs>
    _count?: boolean | TelegramGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramGroup"]>

  export type TelegramGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    title?: boolean
    username?: boolean
    isActive?: boolean
    lastMessageId?: boolean
    parsePatterns?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["telegramGroup"]>

  export type TelegramGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    title?: boolean
    username?: boolean
    isActive?: boolean
    lastMessageId?: boolean
    parsePatterns?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["telegramGroup"]>

  export type TelegramGroupSelectScalar = {
    id?: boolean
    chatId?: boolean
    title?: boolean
    username?: boolean
    isActive?: boolean
    lastMessageId?: boolean
    parsePatterns?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TelegramGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "title" | "username" | "isActive" | "lastMessageId" | "parsePatterns" | "createdAt" | "updatedAt", ExtArgs["result"]["telegramGroup"]>
  export type TelegramGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderDrafts?: boolean | TelegramGroup$orderDraftsArgs<ExtArgs>
    _count?: boolean | TelegramGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TelegramGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TelegramGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TelegramGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelegramGroup"
    objects: {
      orderDrafts: Prisma.$TelegramOrderDraftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chatId: string
      title: string
      username: string | null
      isActive: boolean
      lastMessageId: number | null
      parsePatterns: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["telegramGroup"]>
    composites: {}
  }

  type TelegramGroupGetPayload<S extends boolean | null | undefined | TelegramGroupDefaultArgs> = $Result.GetResult<Prisma.$TelegramGroupPayload, S>

  type TelegramGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TelegramGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TelegramGroupCountAggregateInputType | true
    }

  export interface TelegramGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelegramGroup'], meta: { name: 'TelegramGroup' } }
    /**
     * Find zero or one TelegramGroup that matches the filter.
     * @param {TelegramGroupFindUniqueArgs} args - Arguments to find a TelegramGroup
     * @example
     * // Get one TelegramGroup
     * const telegramGroup = await prisma.telegramGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TelegramGroupFindUniqueArgs>(args: SelectSubset<T, TelegramGroupFindUniqueArgs<ExtArgs>>): Prisma__TelegramGroupClient<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TelegramGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TelegramGroupFindUniqueOrThrowArgs} args - Arguments to find a TelegramGroup
     * @example
     * // Get one TelegramGroup
     * const telegramGroup = await prisma.telegramGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TelegramGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, TelegramGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TelegramGroupClient<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramGroupFindFirstArgs} args - Arguments to find a TelegramGroup
     * @example
     * // Get one TelegramGroup
     * const telegramGroup = await prisma.telegramGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TelegramGroupFindFirstArgs>(args?: SelectSubset<T, TelegramGroupFindFirstArgs<ExtArgs>>): Prisma__TelegramGroupClient<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramGroupFindFirstOrThrowArgs} args - Arguments to find a TelegramGroup
     * @example
     * // Get one TelegramGroup
     * const telegramGroup = await prisma.telegramGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TelegramGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, TelegramGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__TelegramGroupClient<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TelegramGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelegramGroups
     * const telegramGroups = await prisma.telegramGroup.findMany()
     * 
     * // Get first 10 TelegramGroups
     * const telegramGroups = await prisma.telegramGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telegramGroupWithIdOnly = await prisma.telegramGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TelegramGroupFindManyArgs>(args?: SelectSubset<T, TelegramGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TelegramGroup.
     * @param {TelegramGroupCreateArgs} args - Arguments to create a TelegramGroup.
     * @example
     * // Create one TelegramGroup
     * const TelegramGroup = await prisma.telegramGroup.create({
     *   data: {
     *     // ... data to create a TelegramGroup
     *   }
     * })
     * 
     */
    create<T extends TelegramGroupCreateArgs>(args: SelectSubset<T, TelegramGroupCreateArgs<ExtArgs>>): Prisma__TelegramGroupClient<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TelegramGroups.
     * @param {TelegramGroupCreateManyArgs} args - Arguments to create many TelegramGroups.
     * @example
     * // Create many TelegramGroups
     * const telegramGroup = await prisma.telegramGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TelegramGroupCreateManyArgs>(args?: SelectSubset<T, TelegramGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TelegramGroups and returns the data saved in the database.
     * @param {TelegramGroupCreateManyAndReturnArgs} args - Arguments to create many TelegramGroups.
     * @example
     * // Create many TelegramGroups
     * const telegramGroup = await prisma.telegramGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TelegramGroups and only return the `id`
     * const telegramGroupWithIdOnly = await prisma.telegramGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TelegramGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, TelegramGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TelegramGroup.
     * @param {TelegramGroupDeleteArgs} args - Arguments to delete one TelegramGroup.
     * @example
     * // Delete one TelegramGroup
     * const TelegramGroup = await prisma.telegramGroup.delete({
     *   where: {
     *     // ... filter to delete one TelegramGroup
     *   }
     * })
     * 
     */
    delete<T extends TelegramGroupDeleteArgs>(args: SelectSubset<T, TelegramGroupDeleteArgs<ExtArgs>>): Prisma__TelegramGroupClient<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TelegramGroup.
     * @param {TelegramGroupUpdateArgs} args - Arguments to update one TelegramGroup.
     * @example
     * // Update one TelegramGroup
     * const telegramGroup = await prisma.telegramGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TelegramGroupUpdateArgs>(args: SelectSubset<T, TelegramGroupUpdateArgs<ExtArgs>>): Prisma__TelegramGroupClient<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TelegramGroups.
     * @param {TelegramGroupDeleteManyArgs} args - Arguments to filter TelegramGroups to delete.
     * @example
     * // Delete a few TelegramGroups
     * const { count } = await prisma.telegramGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TelegramGroupDeleteManyArgs>(args?: SelectSubset<T, TelegramGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelegramGroups
     * const telegramGroup = await prisma.telegramGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TelegramGroupUpdateManyArgs>(args: SelectSubset<T, TelegramGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramGroups and returns the data updated in the database.
     * @param {TelegramGroupUpdateManyAndReturnArgs} args - Arguments to update many TelegramGroups.
     * @example
     * // Update many TelegramGroups
     * const telegramGroup = await prisma.telegramGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TelegramGroups and only return the `id`
     * const telegramGroupWithIdOnly = await prisma.telegramGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TelegramGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, TelegramGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TelegramGroup.
     * @param {TelegramGroupUpsertArgs} args - Arguments to update or create a TelegramGroup.
     * @example
     * // Update or create a TelegramGroup
     * const telegramGroup = await prisma.telegramGroup.upsert({
     *   create: {
     *     // ... data to create a TelegramGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelegramGroup we want to update
     *   }
     * })
     */
    upsert<T extends TelegramGroupUpsertArgs>(args: SelectSubset<T, TelegramGroupUpsertArgs<ExtArgs>>): Prisma__TelegramGroupClient<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TelegramGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramGroupCountArgs} args - Arguments to filter TelegramGroups to count.
     * @example
     * // Count the number of TelegramGroups
     * const count = await prisma.telegramGroup.count({
     *   where: {
     *     // ... the filter for the TelegramGroups we want to count
     *   }
     * })
    **/
    count<T extends TelegramGroupCountArgs>(
      args?: Subset<T, TelegramGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelegramGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelegramGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelegramGroupAggregateArgs>(args: Subset<T, TelegramGroupAggregateArgs>): Prisma.PrismaPromise<GetTelegramGroupAggregateType<T>>

    /**
     * Group by TelegramGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelegramGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelegramGroupGroupByArgs['orderBy'] }
        : { orderBy?: TelegramGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelegramGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelegramGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelegramGroup model
   */
  readonly fields: TelegramGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelegramGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelegramGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderDrafts<T extends TelegramGroup$orderDraftsArgs<ExtArgs> = {}>(args?: Subset<T, TelegramGroup$orderDraftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TelegramGroup model
   */
  interface TelegramGroupFieldRefs {
    readonly id: FieldRef<"TelegramGroup", 'Int'>
    readonly chatId: FieldRef<"TelegramGroup", 'String'>
    readonly title: FieldRef<"TelegramGroup", 'String'>
    readonly username: FieldRef<"TelegramGroup", 'String'>
    readonly isActive: FieldRef<"TelegramGroup", 'Boolean'>
    readonly lastMessageId: FieldRef<"TelegramGroup", 'Int'>
    readonly parsePatterns: FieldRef<"TelegramGroup", 'Json'>
    readonly createdAt: FieldRef<"TelegramGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"TelegramGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TelegramGroup findUnique
   */
  export type TelegramGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramGroupInclude<ExtArgs> | null
    /**
     * Filter, which TelegramGroup to fetch.
     */
    where: TelegramGroupWhereUniqueInput
  }

  /**
   * TelegramGroup findUniqueOrThrow
   */
  export type TelegramGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramGroupInclude<ExtArgs> | null
    /**
     * Filter, which TelegramGroup to fetch.
     */
    where: TelegramGroupWhereUniqueInput
  }

  /**
   * TelegramGroup findFirst
   */
  export type TelegramGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramGroupInclude<ExtArgs> | null
    /**
     * Filter, which TelegramGroup to fetch.
     */
    where?: TelegramGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramGroups to fetch.
     */
    orderBy?: TelegramGroupOrderByWithRelationInput | TelegramGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramGroups.
     */
    cursor?: TelegramGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramGroups.
     */
    distinct?: TelegramGroupScalarFieldEnum | TelegramGroupScalarFieldEnum[]
  }

  /**
   * TelegramGroup findFirstOrThrow
   */
  export type TelegramGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramGroupInclude<ExtArgs> | null
    /**
     * Filter, which TelegramGroup to fetch.
     */
    where?: TelegramGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramGroups to fetch.
     */
    orderBy?: TelegramGroupOrderByWithRelationInput | TelegramGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramGroups.
     */
    cursor?: TelegramGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramGroups.
     */
    distinct?: TelegramGroupScalarFieldEnum | TelegramGroupScalarFieldEnum[]
  }

  /**
   * TelegramGroup findMany
   */
  export type TelegramGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramGroupInclude<ExtArgs> | null
    /**
     * Filter, which TelegramGroups to fetch.
     */
    where?: TelegramGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramGroups to fetch.
     */
    orderBy?: TelegramGroupOrderByWithRelationInput | TelegramGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelegramGroups.
     */
    cursor?: TelegramGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramGroups.
     */
    skip?: number
    distinct?: TelegramGroupScalarFieldEnum | TelegramGroupScalarFieldEnum[]
  }

  /**
   * TelegramGroup create
   */
  export type TelegramGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a TelegramGroup.
     */
    data: XOR<TelegramGroupCreateInput, TelegramGroupUncheckedCreateInput>
  }

  /**
   * TelegramGroup createMany
   */
  export type TelegramGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelegramGroups.
     */
    data: TelegramGroupCreateManyInput | TelegramGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TelegramGroup createManyAndReturn
   */
  export type TelegramGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * The data used to create many TelegramGroups.
     */
    data: TelegramGroupCreateManyInput | TelegramGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TelegramGroup update
   */
  export type TelegramGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a TelegramGroup.
     */
    data: XOR<TelegramGroupUpdateInput, TelegramGroupUncheckedUpdateInput>
    /**
     * Choose, which TelegramGroup to update.
     */
    where: TelegramGroupWhereUniqueInput
  }

  /**
   * TelegramGroup updateMany
   */
  export type TelegramGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelegramGroups.
     */
    data: XOR<TelegramGroupUpdateManyMutationInput, TelegramGroupUncheckedUpdateManyInput>
    /**
     * Filter which TelegramGroups to update
     */
    where?: TelegramGroupWhereInput
    /**
     * Limit how many TelegramGroups to update.
     */
    limit?: number
  }

  /**
   * TelegramGroup updateManyAndReturn
   */
  export type TelegramGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * The data used to update TelegramGroups.
     */
    data: XOR<TelegramGroupUpdateManyMutationInput, TelegramGroupUncheckedUpdateManyInput>
    /**
     * Filter which TelegramGroups to update
     */
    where?: TelegramGroupWhereInput
    /**
     * Limit how many TelegramGroups to update.
     */
    limit?: number
  }

  /**
   * TelegramGroup upsert
   */
  export type TelegramGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the TelegramGroup to update in case it exists.
     */
    where: TelegramGroupWhereUniqueInput
    /**
     * In case the TelegramGroup found by the `where` argument doesn't exist, create a new TelegramGroup with this data.
     */
    create: XOR<TelegramGroupCreateInput, TelegramGroupUncheckedCreateInput>
    /**
     * In case the TelegramGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelegramGroupUpdateInput, TelegramGroupUncheckedUpdateInput>
  }

  /**
   * TelegramGroup delete
   */
  export type TelegramGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramGroupInclude<ExtArgs> | null
    /**
     * Filter which TelegramGroup to delete.
     */
    where: TelegramGroupWhereUniqueInput
  }

  /**
   * TelegramGroup deleteMany
   */
  export type TelegramGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramGroups to delete
     */
    where?: TelegramGroupWhereInput
    /**
     * Limit how many TelegramGroups to delete.
     */
    limit?: number
  }

  /**
   * TelegramGroup.orderDrafts
   */
  export type TelegramGroup$orderDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftInclude<ExtArgs> | null
    where?: TelegramOrderDraftWhereInput
    orderBy?: TelegramOrderDraftOrderByWithRelationInput | TelegramOrderDraftOrderByWithRelationInput[]
    cursor?: TelegramOrderDraftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelegramOrderDraftScalarFieldEnum | TelegramOrderDraftScalarFieldEnum[]
  }

  /**
   * TelegramGroup without action
   */
  export type TelegramGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramGroup
     */
    select?: TelegramGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramGroup
     */
    omit?: TelegramGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramGroupInclude<ExtArgs> | null
  }


  /**
   * Model TelegramOrderDraft
   */

  export type AggregateTelegramOrderDraft = {
    _count: TelegramOrderDraftCountAggregateOutputType | null
    _avg: TelegramOrderDraftAvgAggregateOutputType | null
    _sum: TelegramOrderDraftSumAggregateOutputType | null
    _min: TelegramOrderDraftMinAggregateOutputType | null
    _max: TelegramOrderDraftMaxAggregateOutputType | null
  }

  export type TelegramOrderDraftAvgAggregateOutputType = {
    id: number | null
    groupId: number | null
    transferredOrderId: number | null
  }

  export type TelegramOrderDraftSumAggregateOutputType = {
    id: number | null
    groupId: number | null
    transferredOrderId: number | null
  }

  export type TelegramOrderDraftMinAggregateOutputType = {
    id: number | null
    groupId: number | null
    messageId: string | null
    messageText: string | null
    messageDate: Date | null
    senderName: string | null
    senderId: string | null
    parsedOrderNumber: string | null
    parsedCustomer: string | null
    parsedAddress: string | null
    status: string | null
    transferredOrderId: number | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramOrderDraftMaxAggregateOutputType = {
    id: number | null
    groupId: number | null
    messageId: string | null
    messageText: string | null
    messageDate: Date | null
    senderName: string | null
    senderId: string | null
    parsedOrderNumber: string | null
    parsedCustomer: string | null
    parsedAddress: string | null
    status: string | null
    transferredOrderId: number | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramOrderDraftCountAggregateOutputType = {
    id: number
    groupId: number
    messageId: number
    messageText: number
    messageDate: number
    senderName: number
    senderId: number
    parsedOrderNumber: number
    parsedCustomer: number
    parsedAddress: number
    status: number
    transferredOrderId: number
    approvedBy: number
    approvedAt: number
    rejectedReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TelegramOrderDraftAvgAggregateInputType = {
    id?: true
    groupId?: true
    transferredOrderId?: true
  }

  export type TelegramOrderDraftSumAggregateInputType = {
    id?: true
    groupId?: true
    transferredOrderId?: true
  }

  export type TelegramOrderDraftMinAggregateInputType = {
    id?: true
    groupId?: true
    messageId?: true
    messageText?: true
    messageDate?: true
    senderName?: true
    senderId?: true
    parsedOrderNumber?: true
    parsedCustomer?: true
    parsedAddress?: true
    status?: true
    transferredOrderId?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramOrderDraftMaxAggregateInputType = {
    id?: true
    groupId?: true
    messageId?: true
    messageText?: true
    messageDate?: true
    senderName?: true
    senderId?: true
    parsedOrderNumber?: true
    parsedCustomer?: true
    parsedAddress?: true
    status?: true
    transferredOrderId?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramOrderDraftCountAggregateInputType = {
    id?: true
    groupId?: true
    messageId?: true
    messageText?: true
    messageDate?: true
    senderName?: true
    senderId?: true
    parsedOrderNumber?: true
    parsedCustomer?: true
    parsedAddress?: true
    status?: true
    transferredOrderId?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TelegramOrderDraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramOrderDraft to aggregate.
     */
    where?: TelegramOrderDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramOrderDrafts to fetch.
     */
    orderBy?: TelegramOrderDraftOrderByWithRelationInput | TelegramOrderDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelegramOrderDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramOrderDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramOrderDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelegramOrderDrafts
    **/
    _count?: true | TelegramOrderDraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TelegramOrderDraftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TelegramOrderDraftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelegramOrderDraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelegramOrderDraftMaxAggregateInputType
  }

  export type GetTelegramOrderDraftAggregateType<T extends TelegramOrderDraftAggregateArgs> = {
        [P in keyof T & keyof AggregateTelegramOrderDraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelegramOrderDraft[P]>
      : GetScalarType<T[P], AggregateTelegramOrderDraft[P]>
  }




  export type TelegramOrderDraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramOrderDraftWhereInput
    orderBy?: TelegramOrderDraftOrderByWithAggregationInput | TelegramOrderDraftOrderByWithAggregationInput[]
    by: TelegramOrderDraftScalarFieldEnum[] | TelegramOrderDraftScalarFieldEnum
    having?: TelegramOrderDraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelegramOrderDraftCountAggregateInputType | true
    _avg?: TelegramOrderDraftAvgAggregateInputType
    _sum?: TelegramOrderDraftSumAggregateInputType
    _min?: TelegramOrderDraftMinAggregateInputType
    _max?: TelegramOrderDraftMaxAggregateInputType
  }

  export type TelegramOrderDraftGroupByOutputType = {
    id: number
    groupId: number
    messageId: string
    messageText: string
    messageDate: Date
    senderName: string | null
    senderId: string | null
    parsedOrderNumber: string | null
    parsedCustomer: string | null
    parsedAddress: string | null
    status: string
    transferredOrderId: number | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: TelegramOrderDraftCountAggregateOutputType | null
    _avg: TelegramOrderDraftAvgAggregateOutputType | null
    _sum: TelegramOrderDraftSumAggregateOutputType | null
    _min: TelegramOrderDraftMinAggregateOutputType | null
    _max: TelegramOrderDraftMaxAggregateOutputType | null
  }

  type GetTelegramOrderDraftGroupByPayload<T extends TelegramOrderDraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelegramOrderDraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelegramOrderDraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelegramOrderDraftGroupByOutputType[P]>
            : GetScalarType<T[P], TelegramOrderDraftGroupByOutputType[P]>
        }
      >
    >


  export type TelegramOrderDraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    messageId?: boolean
    messageText?: boolean
    messageDate?: boolean
    senderName?: boolean
    senderId?: boolean
    parsedOrderNumber?: boolean
    parsedCustomer?: boolean
    parsedAddress?: boolean
    status?: boolean
    transferredOrderId?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | TelegramGroupDefaultArgs<ExtArgs>
    items?: boolean | TelegramOrderDraft$itemsArgs<ExtArgs>
    _count?: boolean | TelegramOrderDraftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramOrderDraft"]>

  export type TelegramOrderDraftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    messageId?: boolean
    messageText?: boolean
    messageDate?: boolean
    senderName?: boolean
    senderId?: boolean
    parsedOrderNumber?: boolean
    parsedCustomer?: boolean
    parsedAddress?: boolean
    status?: boolean
    transferredOrderId?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | TelegramGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramOrderDraft"]>

  export type TelegramOrderDraftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    messageId?: boolean
    messageText?: boolean
    messageDate?: boolean
    senderName?: boolean
    senderId?: boolean
    parsedOrderNumber?: boolean
    parsedCustomer?: boolean
    parsedAddress?: boolean
    status?: boolean
    transferredOrderId?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | TelegramGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramOrderDraft"]>

  export type TelegramOrderDraftSelectScalar = {
    id?: boolean
    groupId?: boolean
    messageId?: boolean
    messageText?: boolean
    messageDate?: boolean
    senderName?: boolean
    senderId?: boolean
    parsedOrderNumber?: boolean
    parsedCustomer?: boolean
    parsedAddress?: boolean
    status?: boolean
    transferredOrderId?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TelegramOrderDraftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "messageId" | "messageText" | "messageDate" | "senderName" | "senderId" | "parsedOrderNumber" | "parsedCustomer" | "parsedAddress" | "status" | "transferredOrderId" | "approvedBy" | "approvedAt" | "rejectedReason" | "createdAt" | "updatedAt", ExtArgs["result"]["telegramOrderDraft"]>
  export type TelegramOrderDraftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | TelegramGroupDefaultArgs<ExtArgs>
    items?: boolean | TelegramOrderDraft$itemsArgs<ExtArgs>
    _count?: boolean | TelegramOrderDraftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TelegramOrderDraftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | TelegramGroupDefaultArgs<ExtArgs>
  }
  export type TelegramOrderDraftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | TelegramGroupDefaultArgs<ExtArgs>
  }

  export type $TelegramOrderDraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelegramOrderDraft"
    objects: {
      group: Prisma.$TelegramGroupPayload<ExtArgs>
      items: Prisma.$TelegramOrderDraftItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      groupId: number
      messageId: string
      messageText: string
      messageDate: Date
      senderName: string | null
      senderId: string | null
      parsedOrderNumber: string | null
      parsedCustomer: string | null
      parsedAddress: string | null
      status: string
      transferredOrderId: number | null
      approvedBy: string | null
      approvedAt: Date | null
      rejectedReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["telegramOrderDraft"]>
    composites: {}
  }

  type TelegramOrderDraftGetPayload<S extends boolean | null | undefined | TelegramOrderDraftDefaultArgs> = $Result.GetResult<Prisma.$TelegramOrderDraftPayload, S>

  type TelegramOrderDraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TelegramOrderDraftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TelegramOrderDraftCountAggregateInputType | true
    }

  export interface TelegramOrderDraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelegramOrderDraft'], meta: { name: 'TelegramOrderDraft' } }
    /**
     * Find zero or one TelegramOrderDraft that matches the filter.
     * @param {TelegramOrderDraftFindUniqueArgs} args - Arguments to find a TelegramOrderDraft
     * @example
     * // Get one TelegramOrderDraft
     * const telegramOrderDraft = await prisma.telegramOrderDraft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TelegramOrderDraftFindUniqueArgs>(args: SelectSubset<T, TelegramOrderDraftFindUniqueArgs<ExtArgs>>): Prisma__TelegramOrderDraftClient<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TelegramOrderDraft that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TelegramOrderDraftFindUniqueOrThrowArgs} args - Arguments to find a TelegramOrderDraft
     * @example
     * // Get one TelegramOrderDraft
     * const telegramOrderDraft = await prisma.telegramOrderDraft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TelegramOrderDraftFindUniqueOrThrowArgs>(args: SelectSubset<T, TelegramOrderDraftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TelegramOrderDraftClient<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramOrderDraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftFindFirstArgs} args - Arguments to find a TelegramOrderDraft
     * @example
     * // Get one TelegramOrderDraft
     * const telegramOrderDraft = await prisma.telegramOrderDraft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TelegramOrderDraftFindFirstArgs>(args?: SelectSubset<T, TelegramOrderDraftFindFirstArgs<ExtArgs>>): Prisma__TelegramOrderDraftClient<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramOrderDraft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftFindFirstOrThrowArgs} args - Arguments to find a TelegramOrderDraft
     * @example
     * // Get one TelegramOrderDraft
     * const telegramOrderDraft = await prisma.telegramOrderDraft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TelegramOrderDraftFindFirstOrThrowArgs>(args?: SelectSubset<T, TelegramOrderDraftFindFirstOrThrowArgs<ExtArgs>>): Prisma__TelegramOrderDraftClient<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TelegramOrderDrafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelegramOrderDrafts
     * const telegramOrderDrafts = await prisma.telegramOrderDraft.findMany()
     * 
     * // Get first 10 TelegramOrderDrafts
     * const telegramOrderDrafts = await prisma.telegramOrderDraft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telegramOrderDraftWithIdOnly = await prisma.telegramOrderDraft.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TelegramOrderDraftFindManyArgs>(args?: SelectSubset<T, TelegramOrderDraftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TelegramOrderDraft.
     * @param {TelegramOrderDraftCreateArgs} args - Arguments to create a TelegramOrderDraft.
     * @example
     * // Create one TelegramOrderDraft
     * const TelegramOrderDraft = await prisma.telegramOrderDraft.create({
     *   data: {
     *     // ... data to create a TelegramOrderDraft
     *   }
     * })
     * 
     */
    create<T extends TelegramOrderDraftCreateArgs>(args: SelectSubset<T, TelegramOrderDraftCreateArgs<ExtArgs>>): Prisma__TelegramOrderDraftClient<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TelegramOrderDrafts.
     * @param {TelegramOrderDraftCreateManyArgs} args - Arguments to create many TelegramOrderDrafts.
     * @example
     * // Create many TelegramOrderDrafts
     * const telegramOrderDraft = await prisma.telegramOrderDraft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TelegramOrderDraftCreateManyArgs>(args?: SelectSubset<T, TelegramOrderDraftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TelegramOrderDrafts and returns the data saved in the database.
     * @param {TelegramOrderDraftCreateManyAndReturnArgs} args - Arguments to create many TelegramOrderDrafts.
     * @example
     * // Create many TelegramOrderDrafts
     * const telegramOrderDraft = await prisma.telegramOrderDraft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TelegramOrderDrafts and only return the `id`
     * const telegramOrderDraftWithIdOnly = await prisma.telegramOrderDraft.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TelegramOrderDraftCreateManyAndReturnArgs>(args?: SelectSubset<T, TelegramOrderDraftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TelegramOrderDraft.
     * @param {TelegramOrderDraftDeleteArgs} args - Arguments to delete one TelegramOrderDraft.
     * @example
     * // Delete one TelegramOrderDraft
     * const TelegramOrderDraft = await prisma.telegramOrderDraft.delete({
     *   where: {
     *     // ... filter to delete one TelegramOrderDraft
     *   }
     * })
     * 
     */
    delete<T extends TelegramOrderDraftDeleteArgs>(args: SelectSubset<T, TelegramOrderDraftDeleteArgs<ExtArgs>>): Prisma__TelegramOrderDraftClient<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TelegramOrderDraft.
     * @param {TelegramOrderDraftUpdateArgs} args - Arguments to update one TelegramOrderDraft.
     * @example
     * // Update one TelegramOrderDraft
     * const telegramOrderDraft = await prisma.telegramOrderDraft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TelegramOrderDraftUpdateArgs>(args: SelectSubset<T, TelegramOrderDraftUpdateArgs<ExtArgs>>): Prisma__TelegramOrderDraftClient<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TelegramOrderDrafts.
     * @param {TelegramOrderDraftDeleteManyArgs} args - Arguments to filter TelegramOrderDrafts to delete.
     * @example
     * // Delete a few TelegramOrderDrafts
     * const { count } = await prisma.telegramOrderDraft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TelegramOrderDraftDeleteManyArgs>(args?: SelectSubset<T, TelegramOrderDraftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramOrderDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelegramOrderDrafts
     * const telegramOrderDraft = await prisma.telegramOrderDraft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TelegramOrderDraftUpdateManyArgs>(args: SelectSubset<T, TelegramOrderDraftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramOrderDrafts and returns the data updated in the database.
     * @param {TelegramOrderDraftUpdateManyAndReturnArgs} args - Arguments to update many TelegramOrderDrafts.
     * @example
     * // Update many TelegramOrderDrafts
     * const telegramOrderDraft = await prisma.telegramOrderDraft.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TelegramOrderDrafts and only return the `id`
     * const telegramOrderDraftWithIdOnly = await prisma.telegramOrderDraft.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TelegramOrderDraftUpdateManyAndReturnArgs>(args: SelectSubset<T, TelegramOrderDraftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TelegramOrderDraft.
     * @param {TelegramOrderDraftUpsertArgs} args - Arguments to update or create a TelegramOrderDraft.
     * @example
     * // Update or create a TelegramOrderDraft
     * const telegramOrderDraft = await prisma.telegramOrderDraft.upsert({
     *   create: {
     *     // ... data to create a TelegramOrderDraft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelegramOrderDraft we want to update
     *   }
     * })
     */
    upsert<T extends TelegramOrderDraftUpsertArgs>(args: SelectSubset<T, TelegramOrderDraftUpsertArgs<ExtArgs>>): Prisma__TelegramOrderDraftClient<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TelegramOrderDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftCountArgs} args - Arguments to filter TelegramOrderDrafts to count.
     * @example
     * // Count the number of TelegramOrderDrafts
     * const count = await prisma.telegramOrderDraft.count({
     *   where: {
     *     // ... the filter for the TelegramOrderDrafts we want to count
     *   }
     * })
    **/
    count<T extends TelegramOrderDraftCountArgs>(
      args?: Subset<T, TelegramOrderDraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelegramOrderDraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelegramOrderDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelegramOrderDraftAggregateArgs>(args: Subset<T, TelegramOrderDraftAggregateArgs>): Prisma.PrismaPromise<GetTelegramOrderDraftAggregateType<T>>

    /**
     * Group by TelegramOrderDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelegramOrderDraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelegramOrderDraftGroupByArgs['orderBy'] }
        : { orderBy?: TelegramOrderDraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelegramOrderDraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelegramOrderDraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelegramOrderDraft model
   */
  readonly fields: TelegramOrderDraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelegramOrderDraft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelegramOrderDraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends TelegramGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TelegramGroupDefaultArgs<ExtArgs>>): Prisma__TelegramGroupClient<$Result.GetResult<Prisma.$TelegramGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends TelegramOrderDraft$itemsArgs<ExtArgs> = {}>(args?: Subset<T, TelegramOrderDraft$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TelegramOrderDraft model
   */
  interface TelegramOrderDraftFieldRefs {
    readonly id: FieldRef<"TelegramOrderDraft", 'Int'>
    readonly groupId: FieldRef<"TelegramOrderDraft", 'Int'>
    readonly messageId: FieldRef<"TelegramOrderDraft", 'String'>
    readonly messageText: FieldRef<"TelegramOrderDraft", 'String'>
    readonly messageDate: FieldRef<"TelegramOrderDraft", 'DateTime'>
    readonly senderName: FieldRef<"TelegramOrderDraft", 'String'>
    readonly senderId: FieldRef<"TelegramOrderDraft", 'String'>
    readonly parsedOrderNumber: FieldRef<"TelegramOrderDraft", 'String'>
    readonly parsedCustomer: FieldRef<"TelegramOrderDraft", 'String'>
    readonly parsedAddress: FieldRef<"TelegramOrderDraft", 'String'>
    readonly status: FieldRef<"TelegramOrderDraft", 'String'>
    readonly transferredOrderId: FieldRef<"TelegramOrderDraft", 'Int'>
    readonly approvedBy: FieldRef<"TelegramOrderDraft", 'String'>
    readonly approvedAt: FieldRef<"TelegramOrderDraft", 'DateTime'>
    readonly rejectedReason: FieldRef<"TelegramOrderDraft", 'String'>
    readonly createdAt: FieldRef<"TelegramOrderDraft", 'DateTime'>
    readonly updatedAt: FieldRef<"TelegramOrderDraft", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TelegramOrderDraft findUnique
   */
  export type TelegramOrderDraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftInclude<ExtArgs> | null
    /**
     * Filter, which TelegramOrderDraft to fetch.
     */
    where: TelegramOrderDraftWhereUniqueInput
  }

  /**
   * TelegramOrderDraft findUniqueOrThrow
   */
  export type TelegramOrderDraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftInclude<ExtArgs> | null
    /**
     * Filter, which TelegramOrderDraft to fetch.
     */
    where: TelegramOrderDraftWhereUniqueInput
  }

  /**
   * TelegramOrderDraft findFirst
   */
  export type TelegramOrderDraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftInclude<ExtArgs> | null
    /**
     * Filter, which TelegramOrderDraft to fetch.
     */
    where?: TelegramOrderDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramOrderDrafts to fetch.
     */
    orderBy?: TelegramOrderDraftOrderByWithRelationInput | TelegramOrderDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramOrderDrafts.
     */
    cursor?: TelegramOrderDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramOrderDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramOrderDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramOrderDrafts.
     */
    distinct?: TelegramOrderDraftScalarFieldEnum | TelegramOrderDraftScalarFieldEnum[]
  }

  /**
   * TelegramOrderDraft findFirstOrThrow
   */
  export type TelegramOrderDraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftInclude<ExtArgs> | null
    /**
     * Filter, which TelegramOrderDraft to fetch.
     */
    where?: TelegramOrderDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramOrderDrafts to fetch.
     */
    orderBy?: TelegramOrderDraftOrderByWithRelationInput | TelegramOrderDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramOrderDrafts.
     */
    cursor?: TelegramOrderDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramOrderDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramOrderDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramOrderDrafts.
     */
    distinct?: TelegramOrderDraftScalarFieldEnum | TelegramOrderDraftScalarFieldEnum[]
  }

  /**
   * TelegramOrderDraft findMany
   */
  export type TelegramOrderDraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftInclude<ExtArgs> | null
    /**
     * Filter, which TelegramOrderDrafts to fetch.
     */
    where?: TelegramOrderDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramOrderDrafts to fetch.
     */
    orderBy?: TelegramOrderDraftOrderByWithRelationInput | TelegramOrderDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelegramOrderDrafts.
     */
    cursor?: TelegramOrderDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramOrderDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramOrderDrafts.
     */
    skip?: number
    distinct?: TelegramOrderDraftScalarFieldEnum | TelegramOrderDraftScalarFieldEnum[]
  }

  /**
   * TelegramOrderDraft create
   */
  export type TelegramOrderDraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftInclude<ExtArgs> | null
    /**
     * The data needed to create a TelegramOrderDraft.
     */
    data: XOR<TelegramOrderDraftCreateInput, TelegramOrderDraftUncheckedCreateInput>
  }

  /**
   * TelegramOrderDraft createMany
   */
  export type TelegramOrderDraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelegramOrderDrafts.
     */
    data: TelegramOrderDraftCreateManyInput | TelegramOrderDraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TelegramOrderDraft createManyAndReturn
   */
  export type TelegramOrderDraftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * The data used to create many TelegramOrderDrafts.
     */
    data: TelegramOrderDraftCreateManyInput | TelegramOrderDraftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramOrderDraft update
   */
  export type TelegramOrderDraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftInclude<ExtArgs> | null
    /**
     * The data needed to update a TelegramOrderDraft.
     */
    data: XOR<TelegramOrderDraftUpdateInput, TelegramOrderDraftUncheckedUpdateInput>
    /**
     * Choose, which TelegramOrderDraft to update.
     */
    where: TelegramOrderDraftWhereUniqueInput
  }

  /**
   * TelegramOrderDraft updateMany
   */
  export type TelegramOrderDraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelegramOrderDrafts.
     */
    data: XOR<TelegramOrderDraftUpdateManyMutationInput, TelegramOrderDraftUncheckedUpdateManyInput>
    /**
     * Filter which TelegramOrderDrafts to update
     */
    where?: TelegramOrderDraftWhereInput
    /**
     * Limit how many TelegramOrderDrafts to update.
     */
    limit?: number
  }

  /**
   * TelegramOrderDraft updateManyAndReturn
   */
  export type TelegramOrderDraftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * The data used to update TelegramOrderDrafts.
     */
    data: XOR<TelegramOrderDraftUpdateManyMutationInput, TelegramOrderDraftUncheckedUpdateManyInput>
    /**
     * Filter which TelegramOrderDrafts to update
     */
    where?: TelegramOrderDraftWhereInput
    /**
     * Limit how many TelegramOrderDrafts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramOrderDraft upsert
   */
  export type TelegramOrderDraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftInclude<ExtArgs> | null
    /**
     * The filter to search for the TelegramOrderDraft to update in case it exists.
     */
    where: TelegramOrderDraftWhereUniqueInput
    /**
     * In case the TelegramOrderDraft found by the `where` argument doesn't exist, create a new TelegramOrderDraft with this data.
     */
    create: XOR<TelegramOrderDraftCreateInput, TelegramOrderDraftUncheckedCreateInput>
    /**
     * In case the TelegramOrderDraft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelegramOrderDraftUpdateInput, TelegramOrderDraftUncheckedUpdateInput>
  }

  /**
   * TelegramOrderDraft delete
   */
  export type TelegramOrderDraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftInclude<ExtArgs> | null
    /**
     * Filter which TelegramOrderDraft to delete.
     */
    where: TelegramOrderDraftWhereUniqueInput
  }

  /**
   * TelegramOrderDraft deleteMany
   */
  export type TelegramOrderDraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramOrderDrafts to delete
     */
    where?: TelegramOrderDraftWhereInput
    /**
     * Limit how many TelegramOrderDrafts to delete.
     */
    limit?: number
  }

  /**
   * TelegramOrderDraft.items
   */
  export type TelegramOrderDraft$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemInclude<ExtArgs> | null
    where?: TelegramOrderDraftItemWhereInput
    orderBy?: TelegramOrderDraftItemOrderByWithRelationInput | TelegramOrderDraftItemOrderByWithRelationInput[]
    cursor?: TelegramOrderDraftItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelegramOrderDraftItemScalarFieldEnum | TelegramOrderDraftItemScalarFieldEnum[]
  }

  /**
   * TelegramOrderDraft without action
   */
  export type TelegramOrderDraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraft
     */
    select?: TelegramOrderDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraft
     */
    omit?: TelegramOrderDraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftInclude<ExtArgs> | null
  }


  /**
   * Model TelegramOrderDraftItem
   */

  export type AggregateTelegramOrderDraftItem = {
    _count: TelegramOrderDraftItemCountAggregateOutputType | null
    _avg: TelegramOrderDraftItemAvgAggregateOutputType | null
    _sum: TelegramOrderDraftItemSumAggregateOutputType | null
    _min: TelegramOrderDraftItemMinAggregateOutputType | null
    _max: TelegramOrderDraftItemMaxAggregateOutputType | null
  }

  export type TelegramOrderDraftItemAvgAggregateOutputType = {
    id: number | null
    draftId: number | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
  }

  export type TelegramOrderDraftItemSumAggregateOutputType = {
    id: number | null
    draftId: number | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
  }

  export type TelegramOrderDraftItemMinAggregateOutputType = {
    id: number | null
    draftId: number | null
    rawProductName: string | null
    rawQuantity: string | null
    rawPrice: string | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramOrderDraftItemMaxAggregateOutputType = {
    id: number | null
    draftId: number | null
    rawProductName: string | null
    rawQuantity: string | null
    rawPrice: string | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramOrderDraftItemCountAggregateOutputType = {
    id: number
    draftId: number
    rawProductName: number
    rawQuantity: number
    rawPrice: number
    productId: number
    quantity: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TelegramOrderDraftItemAvgAggregateInputType = {
    id?: true
    draftId?: true
    productId?: true
    quantity?: true
    price?: true
  }

  export type TelegramOrderDraftItemSumAggregateInputType = {
    id?: true
    draftId?: true
    productId?: true
    quantity?: true
    price?: true
  }

  export type TelegramOrderDraftItemMinAggregateInputType = {
    id?: true
    draftId?: true
    rawProductName?: true
    rawQuantity?: true
    rawPrice?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramOrderDraftItemMaxAggregateInputType = {
    id?: true
    draftId?: true
    rawProductName?: true
    rawQuantity?: true
    rawPrice?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramOrderDraftItemCountAggregateInputType = {
    id?: true
    draftId?: true
    rawProductName?: true
    rawQuantity?: true
    rawPrice?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TelegramOrderDraftItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramOrderDraftItem to aggregate.
     */
    where?: TelegramOrderDraftItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramOrderDraftItems to fetch.
     */
    orderBy?: TelegramOrderDraftItemOrderByWithRelationInput | TelegramOrderDraftItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelegramOrderDraftItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramOrderDraftItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramOrderDraftItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelegramOrderDraftItems
    **/
    _count?: true | TelegramOrderDraftItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TelegramOrderDraftItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TelegramOrderDraftItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelegramOrderDraftItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelegramOrderDraftItemMaxAggregateInputType
  }

  export type GetTelegramOrderDraftItemAggregateType<T extends TelegramOrderDraftItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTelegramOrderDraftItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelegramOrderDraftItem[P]>
      : GetScalarType<T[P], AggregateTelegramOrderDraftItem[P]>
  }




  export type TelegramOrderDraftItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramOrderDraftItemWhereInput
    orderBy?: TelegramOrderDraftItemOrderByWithAggregationInput | TelegramOrderDraftItemOrderByWithAggregationInput[]
    by: TelegramOrderDraftItemScalarFieldEnum[] | TelegramOrderDraftItemScalarFieldEnum
    having?: TelegramOrderDraftItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelegramOrderDraftItemCountAggregateInputType | true
    _avg?: TelegramOrderDraftItemAvgAggregateInputType
    _sum?: TelegramOrderDraftItemSumAggregateInputType
    _min?: TelegramOrderDraftItemMinAggregateInputType
    _max?: TelegramOrderDraftItemMaxAggregateInputType
  }

  export type TelegramOrderDraftItemGroupByOutputType = {
    id: number
    draftId: number
    rawProductName: string
    rawQuantity: string
    rawPrice: string | null
    productId: number | null
    quantity: number | null
    price: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: TelegramOrderDraftItemCountAggregateOutputType | null
    _avg: TelegramOrderDraftItemAvgAggregateOutputType | null
    _sum: TelegramOrderDraftItemSumAggregateOutputType | null
    _min: TelegramOrderDraftItemMinAggregateOutputType | null
    _max: TelegramOrderDraftItemMaxAggregateOutputType | null
  }

  type GetTelegramOrderDraftItemGroupByPayload<T extends TelegramOrderDraftItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelegramOrderDraftItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelegramOrderDraftItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelegramOrderDraftItemGroupByOutputType[P]>
            : GetScalarType<T[P], TelegramOrderDraftItemGroupByOutputType[P]>
        }
      >
    >


  export type TelegramOrderDraftItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    rawProductName?: boolean
    rawQuantity?: boolean
    rawPrice?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    draft?: boolean | TelegramOrderDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramOrderDraftItem"]>

  export type TelegramOrderDraftItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    rawProductName?: boolean
    rawQuantity?: boolean
    rawPrice?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    draft?: boolean | TelegramOrderDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramOrderDraftItem"]>

  export type TelegramOrderDraftItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    rawProductName?: boolean
    rawQuantity?: boolean
    rawPrice?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    draft?: boolean | TelegramOrderDraftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramOrderDraftItem"]>

  export type TelegramOrderDraftItemSelectScalar = {
    id?: boolean
    draftId?: boolean
    rawProductName?: boolean
    rawQuantity?: boolean
    rawPrice?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TelegramOrderDraftItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "draftId" | "rawProductName" | "rawQuantity" | "rawPrice" | "productId" | "quantity" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["telegramOrderDraftItem"]>
  export type TelegramOrderDraftItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | TelegramOrderDraftDefaultArgs<ExtArgs>
  }
  export type TelegramOrderDraftItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | TelegramOrderDraftDefaultArgs<ExtArgs>
  }
  export type TelegramOrderDraftItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | TelegramOrderDraftDefaultArgs<ExtArgs>
  }

  export type $TelegramOrderDraftItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelegramOrderDraftItem"
    objects: {
      draft: Prisma.$TelegramOrderDraftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      draftId: number
      rawProductName: string
      rawQuantity: string
      rawPrice: string | null
      productId: number | null
      quantity: number | null
      price: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["telegramOrderDraftItem"]>
    composites: {}
  }

  type TelegramOrderDraftItemGetPayload<S extends boolean | null | undefined | TelegramOrderDraftItemDefaultArgs> = $Result.GetResult<Prisma.$TelegramOrderDraftItemPayload, S>

  type TelegramOrderDraftItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TelegramOrderDraftItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TelegramOrderDraftItemCountAggregateInputType | true
    }

  export interface TelegramOrderDraftItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelegramOrderDraftItem'], meta: { name: 'TelegramOrderDraftItem' } }
    /**
     * Find zero or one TelegramOrderDraftItem that matches the filter.
     * @param {TelegramOrderDraftItemFindUniqueArgs} args - Arguments to find a TelegramOrderDraftItem
     * @example
     * // Get one TelegramOrderDraftItem
     * const telegramOrderDraftItem = await prisma.telegramOrderDraftItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TelegramOrderDraftItemFindUniqueArgs>(args: SelectSubset<T, TelegramOrderDraftItemFindUniqueArgs<ExtArgs>>): Prisma__TelegramOrderDraftItemClient<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TelegramOrderDraftItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TelegramOrderDraftItemFindUniqueOrThrowArgs} args - Arguments to find a TelegramOrderDraftItem
     * @example
     * // Get one TelegramOrderDraftItem
     * const telegramOrderDraftItem = await prisma.telegramOrderDraftItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TelegramOrderDraftItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TelegramOrderDraftItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TelegramOrderDraftItemClient<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramOrderDraftItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftItemFindFirstArgs} args - Arguments to find a TelegramOrderDraftItem
     * @example
     * // Get one TelegramOrderDraftItem
     * const telegramOrderDraftItem = await prisma.telegramOrderDraftItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TelegramOrderDraftItemFindFirstArgs>(args?: SelectSubset<T, TelegramOrderDraftItemFindFirstArgs<ExtArgs>>): Prisma__TelegramOrderDraftItemClient<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramOrderDraftItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftItemFindFirstOrThrowArgs} args - Arguments to find a TelegramOrderDraftItem
     * @example
     * // Get one TelegramOrderDraftItem
     * const telegramOrderDraftItem = await prisma.telegramOrderDraftItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TelegramOrderDraftItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TelegramOrderDraftItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TelegramOrderDraftItemClient<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TelegramOrderDraftItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelegramOrderDraftItems
     * const telegramOrderDraftItems = await prisma.telegramOrderDraftItem.findMany()
     * 
     * // Get first 10 TelegramOrderDraftItems
     * const telegramOrderDraftItems = await prisma.telegramOrderDraftItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telegramOrderDraftItemWithIdOnly = await prisma.telegramOrderDraftItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TelegramOrderDraftItemFindManyArgs>(args?: SelectSubset<T, TelegramOrderDraftItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TelegramOrderDraftItem.
     * @param {TelegramOrderDraftItemCreateArgs} args - Arguments to create a TelegramOrderDraftItem.
     * @example
     * // Create one TelegramOrderDraftItem
     * const TelegramOrderDraftItem = await prisma.telegramOrderDraftItem.create({
     *   data: {
     *     // ... data to create a TelegramOrderDraftItem
     *   }
     * })
     * 
     */
    create<T extends TelegramOrderDraftItemCreateArgs>(args: SelectSubset<T, TelegramOrderDraftItemCreateArgs<ExtArgs>>): Prisma__TelegramOrderDraftItemClient<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TelegramOrderDraftItems.
     * @param {TelegramOrderDraftItemCreateManyArgs} args - Arguments to create many TelegramOrderDraftItems.
     * @example
     * // Create many TelegramOrderDraftItems
     * const telegramOrderDraftItem = await prisma.telegramOrderDraftItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TelegramOrderDraftItemCreateManyArgs>(args?: SelectSubset<T, TelegramOrderDraftItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TelegramOrderDraftItems and returns the data saved in the database.
     * @param {TelegramOrderDraftItemCreateManyAndReturnArgs} args - Arguments to create many TelegramOrderDraftItems.
     * @example
     * // Create many TelegramOrderDraftItems
     * const telegramOrderDraftItem = await prisma.telegramOrderDraftItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TelegramOrderDraftItems and only return the `id`
     * const telegramOrderDraftItemWithIdOnly = await prisma.telegramOrderDraftItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TelegramOrderDraftItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TelegramOrderDraftItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TelegramOrderDraftItem.
     * @param {TelegramOrderDraftItemDeleteArgs} args - Arguments to delete one TelegramOrderDraftItem.
     * @example
     * // Delete one TelegramOrderDraftItem
     * const TelegramOrderDraftItem = await prisma.telegramOrderDraftItem.delete({
     *   where: {
     *     // ... filter to delete one TelegramOrderDraftItem
     *   }
     * })
     * 
     */
    delete<T extends TelegramOrderDraftItemDeleteArgs>(args: SelectSubset<T, TelegramOrderDraftItemDeleteArgs<ExtArgs>>): Prisma__TelegramOrderDraftItemClient<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TelegramOrderDraftItem.
     * @param {TelegramOrderDraftItemUpdateArgs} args - Arguments to update one TelegramOrderDraftItem.
     * @example
     * // Update one TelegramOrderDraftItem
     * const telegramOrderDraftItem = await prisma.telegramOrderDraftItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TelegramOrderDraftItemUpdateArgs>(args: SelectSubset<T, TelegramOrderDraftItemUpdateArgs<ExtArgs>>): Prisma__TelegramOrderDraftItemClient<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TelegramOrderDraftItems.
     * @param {TelegramOrderDraftItemDeleteManyArgs} args - Arguments to filter TelegramOrderDraftItems to delete.
     * @example
     * // Delete a few TelegramOrderDraftItems
     * const { count } = await prisma.telegramOrderDraftItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TelegramOrderDraftItemDeleteManyArgs>(args?: SelectSubset<T, TelegramOrderDraftItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramOrderDraftItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelegramOrderDraftItems
     * const telegramOrderDraftItem = await prisma.telegramOrderDraftItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TelegramOrderDraftItemUpdateManyArgs>(args: SelectSubset<T, TelegramOrderDraftItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramOrderDraftItems and returns the data updated in the database.
     * @param {TelegramOrderDraftItemUpdateManyAndReturnArgs} args - Arguments to update many TelegramOrderDraftItems.
     * @example
     * // Update many TelegramOrderDraftItems
     * const telegramOrderDraftItem = await prisma.telegramOrderDraftItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TelegramOrderDraftItems and only return the `id`
     * const telegramOrderDraftItemWithIdOnly = await prisma.telegramOrderDraftItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TelegramOrderDraftItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TelegramOrderDraftItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TelegramOrderDraftItem.
     * @param {TelegramOrderDraftItemUpsertArgs} args - Arguments to update or create a TelegramOrderDraftItem.
     * @example
     * // Update or create a TelegramOrderDraftItem
     * const telegramOrderDraftItem = await prisma.telegramOrderDraftItem.upsert({
     *   create: {
     *     // ... data to create a TelegramOrderDraftItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelegramOrderDraftItem we want to update
     *   }
     * })
     */
    upsert<T extends TelegramOrderDraftItemUpsertArgs>(args: SelectSubset<T, TelegramOrderDraftItemUpsertArgs<ExtArgs>>): Prisma__TelegramOrderDraftItemClient<$Result.GetResult<Prisma.$TelegramOrderDraftItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TelegramOrderDraftItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftItemCountArgs} args - Arguments to filter TelegramOrderDraftItems to count.
     * @example
     * // Count the number of TelegramOrderDraftItems
     * const count = await prisma.telegramOrderDraftItem.count({
     *   where: {
     *     // ... the filter for the TelegramOrderDraftItems we want to count
     *   }
     * })
    **/
    count<T extends TelegramOrderDraftItemCountArgs>(
      args?: Subset<T, TelegramOrderDraftItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelegramOrderDraftItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelegramOrderDraftItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelegramOrderDraftItemAggregateArgs>(args: Subset<T, TelegramOrderDraftItemAggregateArgs>): Prisma.PrismaPromise<GetTelegramOrderDraftItemAggregateType<T>>

    /**
     * Group by TelegramOrderDraftItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramOrderDraftItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelegramOrderDraftItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelegramOrderDraftItemGroupByArgs['orderBy'] }
        : { orderBy?: TelegramOrderDraftItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelegramOrderDraftItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelegramOrderDraftItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelegramOrderDraftItem model
   */
  readonly fields: TelegramOrderDraftItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelegramOrderDraftItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelegramOrderDraftItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    draft<T extends TelegramOrderDraftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TelegramOrderDraftDefaultArgs<ExtArgs>>): Prisma__TelegramOrderDraftClient<$Result.GetResult<Prisma.$TelegramOrderDraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TelegramOrderDraftItem model
   */
  interface TelegramOrderDraftItemFieldRefs {
    readonly id: FieldRef<"TelegramOrderDraftItem", 'Int'>
    readonly draftId: FieldRef<"TelegramOrderDraftItem", 'Int'>
    readonly rawProductName: FieldRef<"TelegramOrderDraftItem", 'String'>
    readonly rawQuantity: FieldRef<"TelegramOrderDraftItem", 'String'>
    readonly rawPrice: FieldRef<"TelegramOrderDraftItem", 'String'>
    readonly productId: FieldRef<"TelegramOrderDraftItem", 'Int'>
    readonly quantity: FieldRef<"TelegramOrderDraftItem", 'Float'>
    readonly price: FieldRef<"TelegramOrderDraftItem", 'Decimal'>
    readonly createdAt: FieldRef<"TelegramOrderDraftItem", 'DateTime'>
    readonly updatedAt: FieldRef<"TelegramOrderDraftItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TelegramOrderDraftItem findUnique
   */
  export type TelegramOrderDraftItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemInclude<ExtArgs> | null
    /**
     * Filter, which TelegramOrderDraftItem to fetch.
     */
    where: TelegramOrderDraftItemWhereUniqueInput
  }

  /**
   * TelegramOrderDraftItem findUniqueOrThrow
   */
  export type TelegramOrderDraftItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemInclude<ExtArgs> | null
    /**
     * Filter, which TelegramOrderDraftItem to fetch.
     */
    where: TelegramOrderDraftItemWhereUniqueInput
  }

  /**
   * TelegramOrderDraftItem findFirst
   */
  export type TelegramOrderDraftItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemInclude<ExtArgs> | null
    /**
     * Filter, which TelegramOrderDraftItem to fetch.
     */
    where?: TelegramOrderDraftItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramOrderDraftItems to fetch.
     */
    orderBy?: TelegramOrderDraftItemOrderByWithRelationInput | TelegramOrderDraftItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramOrderDraftItems.
     */
    cursor?: TelegramOrderDraftItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramOrderDraftItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramOrderDraftItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramOrderDraftItems.
     */
    distinct?: TelegramOrderDraftItemScalarFieldEnum | TelegramOrderDraftItemScalarFieldEnum[]
  }

  /**
   * TelegramOrderDraftItem findFirstOrThrow
   */
  export type TelegramOrderDraftItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemInclude<ExtArgs> | null
    /**
     * Filter, which TelegramOrderDraftItem to fetch.
     */
    where?: TelegramOrderDraftItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramOrderDraftItems to fetch.
     */
    orderBy?: TelegramOrderDraftItemOrderByWithRelationInput | TelegramOrderDraftItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramOrderDraftItems.
     */
    cursor?: TelegramOrderDraftItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramOrderDraftItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramOrderDraftItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramOrderDraftItems.
     */
    distinct?: TelegramOrderDraftItemScalarFieldEnum | TelegramOrderDraftItemScalarFieldEnum[]
  }

  /**
   * TelegramOrderDraftItem findMany
   */
  export type TelegramOrderDraftItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemInclude<ExtArgs> | null
    /**
     * Filter, which TelegramOrderDraftItems to fetch.
     */
    where?: TelegramOrderDraftItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramOrderDraftItems to fetch.
     */
    orderBy?: TelegramOrderDraftItemOrderByWithRelationInput | TelegramOrderDraftItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelegramOrderDraftItems.
     */
    cursor?: TelegramOrderDraftItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramOrderDraftItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramOrderDraftItems.
     */
    skip?: number
    distinct?: TelegramOrderDraftItemScalarFieldEnum | TelegramOrderDraftItemScalarFieldEnum[]
  }

  /**
   * TelegramOrderDraftItem create
   */
  export type TelegramOrderDraftItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TelegramOrderDraftItem.
     */
    data: XOR<TelegramOrderDraftItemCreateInput, TelegramOrderDraftItemUncheckedCreateInput>
  }

  /**
   * TelegramOrderDraftItem createMany
   */
  export type TelegramOrderDraftItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelegramOrderDraftItems.
     */
    data: TelegramOrderDraftItemCreateManyInput | TelegramOrderDraftItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TelegramOrderDraftItem createManyAndReturn
   */
  export type TelegramOrderDraftItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * The data used to create many TelegramOrderDraftItems.
     */
    data: TelegramOrderDraftItemCreateManyInput | TelegramOrderDraftItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramOrderDraftItem update
   */
  export type TelegramOrderDraftItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TelegramOrderDraftItem.
     */
    data: XOR<TelegramOrderDraftItemUpdateInput, TelegramOrderDraftItemUncheckedUpdateInput>
    /**
     * Choose, which TelegramOrderDraftItem to update.
     */
    where: TelegramOrderDraftItemWhereUniqueInput
  }

  /**
   * TelegramOrderDraftItem updateMany
   */
  export type TelegramOrderDraftItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelegramOrderDraftItems.
     */
    data: XOR<TelegramOrderDraftItemUpdateManyMutationInput, TelegramOrderDraftItemUncheckedUpdateManyInput>
    /**
     * Filter which TelegramOrderDraftItems to update
     */
    where?: TelegramOrderDraftItemWhereInput
    /**
     * Limit how many TelegramOrderDraftItems to update.
     */
    limit?: number
  }

  /**
   * TelegramOrderDraftItem updateManyAndReturn
   */
  export type TelegramOrderDraftItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * The data used to update TelegramOrderDraftItems.
     */
    data: XOR<TelegramOrderDraftItemUpdateManyMutationInput, TelegramOrderDraftItemUncheckedUpdateManyInput>
    /**
     * Filter which TelegramOrderDraftItems to update
     */
    where?: TelegramOrderDraftItemWhereInput
    /**
     * Limit how many TelegramOrderDraftItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramOrderDraftItem upsert
   */
  export type TelegramOrderDraftItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TelegramOrderDraftItem to update in case it exists.
     */
    where: TelegramOrderDraftItemWhereUniqueInput
    /**
     * In case the TelegramOrderDraftItem found by the `where` argument doesn't exist, create a new TelegramOrderDraftItem with this data.
     */
    create: XOR<TelegramOrderDraftItemCreateInput, TelegramOrderDraftItemUncheckedCreateInput>
    /**
     * In case the TelegramOrderDraftItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelegramOrderDraftItemUpdateInput, TelegramOrderDraftItemUncheckedUpdateInput>
  }

  /**
   * TelegramOrderDraftItem delete
   */
  export type TelegramOrderDraftItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemInclude<ExtArgs> | null
    /**
     * Filter which TelegramOrderDraftItem to delete.
     */
    where: TelegramOrderDraftItemWhereUniqueInput
  }

  /**
   * TelegramOrderDraftItem deleteMany
   */
  export type TelegramOrderDraftItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramOrderDraftItems to delete
     */
    where?: TelegramOrderDraftItemWhereInput
    /**
     * Limit how many TelegramOrderDraftItems to delete.
     */
    limit?: number
  }

  /**
   * TelegramOrderDraftItem without action
   */
  export type TelegramOrderDraftItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramOrderDraftItem
     */
    select?: TelegramOrderDraftItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramOrderDraftItem
     */
    omit?: TelegramOrderDraftItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramOrderDraftItemInclude<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseAvgAggregateOutputType = {
    id: number | null
    responsibleUserId: number | null
  }

  export type WarehouseSumAggregateOutputType = {
    id: number | null
    responsibleUserId: number | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    responsibleUserId: number | null
    comment: string | null
    isDisabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    responsibleUserId: number | null
    comment: string | null
    isDisabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    code: number
    name: number
    address: number
    phone: number
    responsibleUserId: number
    comment: number
    isDisabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseAvgAggregateInputType = {
    id?: true
    responsibleUserId?: true
  }

  export type WarehouseSumAggregateInputType = {
    id?: true
    responsibleUserId?: true
  }

  export type WarehouseMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    responsibleUserId?: true
    comment?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    responsibleUserId?: true
    comment?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    responsibleUserId?: true
    comment?: true
    isDisabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _avg?: WarehouseAvgAggregateInputType
    _sum?: WarehouseSumAggregateInputType
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: number
    code: string
    name: string
    address: string
    phone: string | null
    responsibleUserId: number | null
    comment: string | null
    isDisabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    responsibleUserId?: boolean
    comment?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responsibleUser?: boolean | Warehouse$responsibleUserArgs<ExtArgs>
    productionDocs?: boolean | Warehouse$productionDocsArgs<ExtArgs>
    productionInputs?: boolean | Warehouse$productionInputsArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    responsibleUserId?: boolean
    comment?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responsibleUser?: boolean | Warehouse$responsibleUserArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    responsibleUserId?: boolean
    comment?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responsibleUser?: boolean | Warehouse$responsibleUserArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    responsibleUserId?: boolean
    comment?: boolean
    isDisabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "address" | "phone" | "responsibleUserId" | "comment" | "isDisabled" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouse"]>
  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsibleUser?: boolean | Warehouse$responsibleUserArgs<ExtArgs>
    productionDocs?: boolean | Warehouse$productionDocsArgs<ExtArgs>
    productionInputs?: boolean | Warehouse$productionInputsArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsibleUser?: boolean | Warehouse$responsibleUserArgs<ExtArgs>
  }
  export type WarehouseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsibleUser?: boolean | Warehouse$responsibleUserArgs<ExtArgs>
  }

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      responsibleUser: Prisma.$UserPayload<ExtArgs> | null
      productionDocs: Prisma.$ProductionDocPayload<ExtArgs>[]
      productionInputs: Prisma.$ProductionInputPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      address: string
      phone: string | null
      responsibleUserId: number | null
      comment: string | null
      isDisabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {WarehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses and returns the data updated in the database.
     * @param {WarehouseUpdateManyAndReturnArgs} args - Arguments to update many Warehouses.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responsibleUser<T extends Warehouse$responsibleUserArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$responsibleUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productionDocs<T extends Warehouse$productionDocsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$productionDocsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productionInputs<T extends Warehouse$productionInputsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$productionInputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */
  interface WarehouseFieldRefs {
    readonly id: FieldRef<"Warehouse", 'Int'>
    readonly code: FieldRef<"Warehouse", 'String'>
    readonly name: FieldRef<"Warehouse", 'String'>
    readonly address: FieldRef<"Warehouse", 'String'>
    readonly phone: FieldRef<"Warehouse", 'String'>
    readonly responsibleUserId: FieldRef<"Warehouse", 'Int'>
    readonly comment: FieldRef<"Warehouse", 'String'>
    readonly isDisabled: FieldRef<"Warehouse", 'Boolean'>
    readonly createdAt: FieldRef<"Warehouse", 'DateTime'>
    readonly updatedAt: FieldRef<"Warehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse createManyAndReturn
   */
  export type WarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse updateManyAndReturn
   */
  export type WarehouseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to delete.
     */
    limit?: number
  }

  /**
   * Warehouse.responsibleUser
   */
  export type Warehouse$responsibleUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Warehouse.productionDocs
   */
  export type Warehouse$productionDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
    where?: ProductionDocWhereInput
    orderBy?: ProductionDocOrderByWithRelationInput | ProductionDocOrderByWithRelationInput[]
    cursor?: ProductionDocWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionDocScalarFieldEnum | ProductionDocScalarFieldEnum[]
  }

  /**
   * Warehouse.productionInputs
   */
  export type Warehouse$productionInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    where?: ProductionInputWhereInput
    orderBy?: ProductionInputOrderByWithRelationInput | ProductionInputOrderByWithRelationInput[]
    cursor?: ProductionInputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionInputScalarFieldEnum | ProductionInputScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model SvodHeader
   */

  export type AggregateSvodHeader = {
    _count: SvodHeaderCountAggregateOutputType | null
    _avg: SvodHeaderAvgAggregateOutputType | null
    _sum: SvodHeaderSumAggregateOutputType | null
    _min: SvodHeaderMinAggregateOutputType | null
    _max: SvodHeaderMaxAggregateOutputType | null
  }

  export type SvodHeaderAvgAggregateOutputType = {
    id: number | null
  }

  export type SvodHeaderSumAggregateOutputType = {
    id: number | null
  }

  export type SvodHeaderMinAggregateOutputType = {
    id: number | null
    svodDate: Date | null
    status: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SvodHeaderMaxAggregateOutputType = {
    id: number | null
    svodDate: Date | null
    status: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SvodHeaderCountAggregateOutputType = {
    id: number
    svodDate: number
    status: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SvodHeaderAvgAggregateInputType = {
    id?: true
  }

  export type SvodHeaderSumAggregateInputType = {
    id?: true
  }

  export type SvodHeaderMinAggregateInputType = {
    id?: true
    svodDate?: true
    status?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SvodHeaderMaxAggregateInputType = {
    id?: true
    svodDate?: true
    status?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SvodHeaderCountAggregateInputType = {
    id?: true
    svodDate?: true
    status?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SvodHeaderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SvodHeader to aggregate.
     */
    where?: SvodHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodHeaders to fetch.
     */
    orderBy?: SvodHeaderOrderByWithRelationInput | SvodHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SvodHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SvodHeaders
    **/
    _count?: true | SvodHeaderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SvodHeaderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SvodHeaderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SvodHeaderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SvodHeaderMaxAggregateInputType
  }

  export type GetSvodHeaderAggregateType<T extends SvodHeaderAggregateArgs> = {
        [P in keyof T & keyof AggregateSvodHeader]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSvodHeader[P]>
      : GetScalarType<T[P], AggregateSvodHeader[P]>
  }




  export type SvodHeaderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SvodHeaderWhereInput
    orderBy?: SvodHeaderOrderByWithAggregationInput | SvodHeaderOrderByWithAggregationInput[]
    by: SvodHeaderScalarFieldEnum[] | SvodHeaderScalarFieldEnum
    having?: SvodHeaderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SvodHeaderCountAggregateInputType | true
    _avg?: SvodHeaderAvgAggregateInputType
    _sum?: SvodHeaderSumAggregateInputType
    _min?: SvodHeaderMinAggregateInputType
    _max?: SvodHeaderMaxAggregateInputType
  }

  export type SvodHeaderGroupByOutputType = {
    id: number
    svodDate: Date
    status: string
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string | null
    _count: SvodHeaderCountAggregateOutputType | null
    _avg: SvodHeaderAvgAggregateOutputType | null
    _sum: SvodHeaderSumAggregateOutputType | null
    _min: SvodHeaderMinAggregateOutputType | null
    _max: SvodHeaderMaxAggregateOutputType | null
  }

  type GetSvodHeaderGroupByPayload<T extends SvodHeaderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SvodHeaderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SvodHeaderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SvodHeaderGroupByOutputType[P]>
            : GetScalarType<T[P], SvodHeaderGroupByOutputType[P]>
        }
      >
    >


  export type SvodHeaderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodDate?: boolean
    status?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    lines?: boolean | SvodHeader$linesArgs<ExtArgs>
    supplierCols?: boolean | SvodHeader$supplierColsArgs<ExtArgs>
    supplierValues?: boolean | SvodHeader$supplierValuesArgs<ExtArgs>
    _count?: boolean | SvodHeaderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["svodHeader"]>

  export type SvodHeaderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodDate?: boolean
    status?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["svodHeader"]>

  export type SvodHeaderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodDate?: boolean
    status?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["svodHeader"]>

  export type SvodHeaderSelectScalar = {
    id?: boolean
    svodDate?: boolean
    status?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type SvodHeaderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "svodDate" | "status" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["svodHeader"]>
  export type SvodHeaderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | SvodHeader$linesArgs<ExtArgs>
    supplierCols?: boolean | SvodHeader$supplierColsArgs<ExtArgs>
    supplierValues?: boolean | SvodHeader$supplierValuesArgs<ExtArgs>
    _count?: boolean | SvodHeaderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SvodHeaderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SvodHeaderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SvodHeaderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SvodHeader"
    objects: {
      lines: Prisma.$SvodLinePayload<ExtArgs>[]
      supplierCols: Prisma.$SvodSupplierColPayload<ExtArgs>[]
      supplierValues: Prisma.$SvodSupplierValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      svodDate: Date
      status: string
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["svodHeader"]>
    composites: {}
  }

  type SvodHeaderGetPayload<S extends boolean | null | undefined | SvodHeaderDefaultArgs> = $Result.GetResult<Prisma.$SvodHeaderPayload, S>

  type SvodHeaderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SvodHeaderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SvodHeaderCountAggregateInputType | true
    }

  export interface SvodHeaderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SvodHeader'], meta: { name: 'SvodHeader' } }
    /**
     * Find zero or one SvodHeader that matches the filter.
     * @param {SvodHeaderFindUniqueArgs} args - Arguments to find a SvodHeader
     * @example
     * // Get one SvodHeader
     * const svodHeader = await prisma.svodHeader.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SvodHeaderFindUniqueArgs>(args: SelectSubset<T, SvodHeaderFindUniqueArgs<ExtArgs>>): Prisma__SvodHeaderClient<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SvodHeader that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SvodHeaderFindUniqueOrThrowArgs} args - Arguments to find a SvodHeader
     * @example
     * // Get one SvodHeader
     * const svodHeader = await prisma.svodHeader.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SvodHeaderFindUniqueOrThrowArgs>(args: SelectSubset<T, SvodHeaderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SvodHeaderClient<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SvodHeader that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodHeaderFindFirstArgs} args - Arguments to find a SvodHeader
     * @example
     * // Get one SvodHeader
     * const svodHeader = await prisma.svodHeader.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SvodHeaderFindFirstArgs>(args?: SelectSubset<T, SvodHeaderFindFirstArgs<ExtArgs>>): Prisma__SvodHeaderClient<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SvodHeader that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodHeaderFindFirstOrThrowArgs} args - Arguments to find a SvodHeader
     * @example
     * // Get one SvodHeader
     * const svodHeader = await prisma.svodHeader.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SvodHeaderFindFirstOrThrowArgs>(args?: SelectSubset<T, SvodHeaderFindFirstOrThrowArgs<ExtArgs>>): Prisma__SvodHeaderClient<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SvodHeaders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodHeaderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SvodHeaders
     * const svodHeaders = await prisma.svodHeader.findMany()
     * 
     * // Get first 10 SvodHeaders
     * const svodHeaders = await prisma.svodHeader.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const svodHeaderWithIdOnly = await prisma.svodHeader.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SvodHeaderFindManyArgs>(args?: SelectSubset<T, SvodHeaderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SvodHeader.
     * @param {SvodHeaderCreateArgs} args - Arguments to create a SvodHeader.
     * @example
     * // Create one SvodHeader
     * const SvodHeader = await prisma.svodHeader.create({
     *   data: {
     *     // ... data to create a SvodHeader
     *   }
     * })
     * 
     */
    create<T extends SvodHeaderCreateArgs>(args: SelectSubset<T, SvodHeaderCreateArgs<ExtArgs>>): Prisma__SvodHeaderClient<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SvodHeaders.
     * @param {SvodHeaderCreateManyArgs} args - Arguments to create many SvodHeaders.
     * @example
     * // Create many SvodHeaders
     * const svodHeader = await prisma.svodHeader.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SvodHeaderCreateManyArgs>(args?: SelectSubset<T, SvodHeaderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SvodHeaders and returns the data saved in the database.
     * @param {SvodHeaderCreateManyAndReturnArgs} args - Arguments to create many SvodHeaders.
     * @example
     * // Create many SvodHeaders
     * const svodHeader = await prisma.svodHeader.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SvodHeaders and only return the `id`
     * const svodHeaderWithIdOnly = await prisma.svodHeader.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SvodHeaderCreateManyAndReturnArgs>(args?: SelectSubset<T, SvodHeaderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SvodHeader.
     * @param {SvodHeaderDeleteArgs} args - Arguments to delete one SvodHeader.
     * @example
     * // Delete one SvodHeader
     * const SvodHeader = await prisma.svodHeader.delete({
     *   where: {
     *     // ... filter to delete one SvodHeader
     *   }
     * })
     * 
     */
    delete<T extends SvodHeaderDeleteArgs>(args: SelectSubset<T, SvodHeaderDeleteArgs<ExtArgs>>): Prisma__SvodHeaderClient<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SvodHeader.
     * @param {SvodHeaderUpdateArgs} args - Arguments to update one SvodHeader.
     * @example
     * // Update one SvodHeader
     * const svodHeader = await prisma.svodHeader.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SvodHeaderUpdateArgs>(args: SelectSubset<T, SvodHeaderUpdateArgs<ExtArgs>>): Prisma__SvodHeaderClient<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SvodHeaders.
     * @param {SvodHeaderDeleteManyArgs} args - Arguments to filter SvodHeaders to delete.
     * @example
     * // Delete a few SvodHeaders
     * const { count } = await prisma.svodHeader.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SvodHeaderDeleteManyArgs>(args?: SelectSubset<T, SvodHeaderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SvodHeaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodHeaderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SvodHeaders
     * const svodHeader = await prisma.svodHeader.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SvodHeaderUpdateManyArgs>(args: SelectSubset<T, SvodHeaderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SvodHeaders and returns the data updated in the database.
     * @param {SvodHeaderUpdateManyAndReturnArgs} args - Arguments to update many SvodHeaders.
     * @example
     * // Update many SvodHeaders
     * const svodHeader = await prisma.svodHeader.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SvodHeaders and only return the `id`
     * const svodHeaderWithIdOnly = await prisma.svodHeader.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SvodHeaderUpdateManyAndReturnArgs>(args: SelectSubset<T, SvodHeaderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SvodHeader.
     * @param {SvodHeaderUpsertArgs} args - Arguments to update or create a SvodHeader.
     * @example
     * // Update or create a SvodHeader
     * const svodHeader = await prisma.svodHeader.upsert({
     *   create: {
     *     // ... data to create a SvodHeader
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SvodHeader we want to update
     *   }
     * })
     */
    upsert<T extends SvodHeaderUpsertArgs>(args: SelectSubset<T, SvodHeaderUpsertArgs<ExtArgs>>): Prisma__SvodHeaderClient<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SvodHeaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodHeaderCountArgs} args - Arguments to filter SvodHeaders to count.
     * @example
     * // Count the number of SvodHeaders
     * const count = await prisma.svodHeader.count({
     *   where: {
     *     // ... the filter for the SvodHeaders we want to count
     *   }
     * })
    **/
    count<T extends SvodHeaderCountArgs>(
      args?: Subset<T, SvodHeaderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SvodHeaderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SvodHeader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodHeaderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SvodHeaderAggregateArgs>(args: Subset<T, SvodHeaderAggregateArgs>): Prisma.PrismaPromise<GetSvodHeaderAggregateType<T>>

    /**
     * Group by SvodHeader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodHeaderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SvodHeaderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SvodHeaderGroupByArgs['orderBy'] }
        : { orderBy?: SvodHeaderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SvodHeaderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSvodHeaderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SvodHeader model
   */
  readonly fields: SvodHeaderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SvodHeader.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SvodHeaderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lines<T extends SvodHeader$linesArgs<ExtArgs> = {}>(args?: Subset<T, SvodHeader$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supplierCols<T extends SvodHeader$supplierColsArgs<ExtArgs> = {}>(args?: Subset<T, SvodHeader$supplierColsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supplierValues<T extends SvodHeader$supplierValuesArgs<ExtArgs> = {}>(args?: Subset<T, SvodHeader$supplierValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SvodHeader model
   */
  interface SvodHeaderFieldRefs {
    readonly id: FieldRef<"SvodHeader", 'Int'>
    readonly svodDate: FieldRef<"SvodHeader", 'DateTime'>
    readonly status: FieldRef<"SvodHeader", 'String'>
    readonly createdAt: FieldRef<"SvodHeader", 'DateTime'>
    readonly createdBy: FieldRef<"SvodHeader", 'String'>
    readonly updatedAt: FieldRef<"SvodHeader", 'DateTime'>
    readonly updatedBy: FieldRef<"SvodHeader", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SvodHeader findUnique
   */
  export type SvodHeaderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodHeaderInclude<ExtArgs> | null
    /**
     * Filter, which SvodHeader to fetch.
     */
    where: SvodHeaderWhereUniqueInput
  }

  /**
   * SvodHeader findUniqueOrThrow
   */
  export type SvodHeaderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodHeaderInclude<ExtArgs> | null
    /**
     * Filter, which SvodHeader to fetch.
     */
    where: SvodHeaderWhereUniqueInput
  }

  /**
   * SvodHeader findFirst
   */
  export type SvodHeaderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodHeaderInclude<ExtArgs> | null
    /**
     * Filter, which SvodHeader to fetch.
     */
    where?: SvodHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodHeaders to fetch.
     */
    orderBy?: SvodHeaderOrderByWithRelationInput | SvodHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SvodHeaders.
     */
    cursor?: SvodHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SvodHeaders.
     */
    distinct?: SvodHeaderScalarFieldEnum | SvodHeaderScalarFieldEnum[]
  }

  /**
   * SvodHeader findFirstOrThrow
   */
  export type SvodHeaderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodHeaderInclude<ExtArgs> | null
    /**
     * Filter, which SvodHeader to fetch.
     */
    where?: SvodHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodHeaders to fetch.
     */
    orderBy?: SvodHeaderOrderByWithRelationInput | SvodHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SvodHeaders.
     */
    cursor?: SvodHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SvodHeaders.
     */
    distinct?: SvodHeaderScalarFieldEnum | SvodHeaderScalarFieldEnum[]
  }

  /**
   * SvodHeader findMany
   */
  export type SvodHeaderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodHeaderInclude<ExtArgs> | null
    /**
     * Filter, which SvodHeaders to fetch.
     */
    where?: SvodHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodHeaders to fetch.
     */
    orderBy?: SvodHeaderOrderByWithRelationInput | SvodHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SvodHeaders.
     */
    cursor?: SvodHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodHeaders.
     */
    skip?: number
    distinct?: SvodHeaderScalarFieldEnum | SvodHeaderScalarFieldEnum[]
  }

  /**
   * SvodHeader create
   */
  export type SvodHeaderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodHeaderInclude<ExtArgs> | null
    /**
     * The data needed to create a SvodHeader.
     */
    data: XOR<SvodHeaderCreateInput, SvodHeaderUncheckedCreateInput>
  }

  /**
   * SvodHeader createMany
   */
  export type SvodHeaderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SvodHeaders.
     */
    data: SvodHeaderCreateManyInput | SvodHeaderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SvodHeader createManyAndReturn
   */
  export type SvodHeaderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * The data used to create many SvodHeaders.
     */
    data: SvodHeaderCreateManyInput | SvodHeaderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SvodHeader update
   */
  export type SvodHeaderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodHeaderInclude<ExtArgs> | null
    /**
     * The data needed to update a SvodHeader.
     */
    data: XOR<SvodHeaderUpdateInput, SvodHeaderUncheckedUpdateInput>
    /**
     * Choose, which SvodHeader to update.
     */
    where: SvodHeaderWhereUniqueInput
  }

  /**
   * SvodHeader updateMany
   */
  export type SvodHeaderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SvodHeaders.
     */
    data: XOR<SvodHeaderUpdateManyMutationInput, SvodHeaderUncheckedUpdateManyInput>
    /**
     * Filter which SvodHeaders to update
     */
    where?: SvodHeaderWhereInput
    /**
     * Limit how many SvodHeaders to update.
     */
    limit?: number
  }

  /**
   * SvodHeader updateManyAndReturn
   */
  export type SvodHeaderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * The data used to update SvodHeaders.
     */
    data: XOR<SvodHeaderUpdateManyMutationInput, SvodHeaderUncheckedUpdateManyInput>
    /**
     * Filter which SvodHeaders to update
     */
    where?: SvodHeaderWhereInput
    /**
     * Limit how many SvodHeaders to update.
     */
    limit?: number
  }

  /**
   * SvodHeader upsert
   */
  export type SvodHeaderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodHeaderInclude<ExtArgs> | null
    /**
     * The filter to search for the SvodHeader to update in case it exists.
     */
    where: SvodHeaderWhereUniqueInput
    /**
     * In case the SvodHeader found by the `where` argument doesn't exist, create a new SvodHeader with this data.
     */
    create: XOR<SvodHeaderCreateInput, SvodHeaderUncheckedCreateInput>
    /**
     * In case the SvodHeader was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SvodHeaderUpdateInput, SvodHeaderUncheckedUpdateInput>
  }

  /**
   * SvodHeader delete
   */
  export type SvodHeaderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodHeaderInclude<ExtArgs> | null
    /**
     * Filter which SvodHeader to delete.
     */
    where: SvodHeaderWhereUniqueInput
  }

  /**
   * SvodHeader deleteMany
   */
  export type SvodHeaderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SvodHeaders to delete
     */
    where?: SvodHeaderWhereInput
    /**
     * Limit how many SvodHeaders to delete.
     */
    limit?: number
  }

  /**
   * SvodHeader.lines
   */
  export type SvodHeader$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
    where?: SvodLineWhereInput
    orderBy?: SvodLineOrderByWithRelationInput | SvodLineOrderByWithRelationInput[]
    cursor?: SvodLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SvodLineScalarFieldEnum | SvodLineScalarFieldEnum[]
  }

  /**
   * SvodHeader.supplierCols
   */
  export type SvodHeader$supplierColsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
    where?: SvodSupplierColWhereInput
    orderBy?: SvodSupplierColOrderByWithRelationInput | SvodSupplierColOrderByWithRelationInput[]
    cursor?: SvodSupplierColWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SvodSupplierColScalarFieldEnum | SvodSupplierColScalarFieldEnum[]
  }

  /**
   * SvodHeader.supplierValues
   */
  export type SvodHeader$supplierValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    where?: SvodSupplierValueWhereInput
    orderBy?: SvodSupplierValueOrderByWithRelationInput | SvodSupplierValueOrderByWithRelationInput[]
    cursor?: SvodSupplierValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SvodSupplierValueScalarFieldEnum | SvodSupplierValueScalarFieldEnum[]
  }

  /**
   * SvodHeader without action
   */
  export type SvodHeaderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodHeader
     */
    select?: SvodHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodHeader
     */
    omit?: SvodHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodHeaderInclude<ExtArgs> | null
  }


  /**
   * Model SvodLine
   */

  export type AggregateSvodLine = {
    _count: SvodLineCountAggregateOutputType | null
    _avg: SvodLineAvgAggregateOutputType | null
    _sum: SvodLineSumAggregateOutputType | null
    _min: SvodLineMinAggregateOutputType | null
    _max: SvodLineMaxAggregateOutputType | null
  }

  export type SvodLineAvgAggregateOutputType = {
    id: number | null
    svodId: number | null
    productId: number | null
    coefficient: Decimal | null
    orderQty: Decimal | null
    productionInQty: Decimal | null
    openingStock: Decimal | null
    afterPurchaseStock: Decimal | null
    afterShipmentStock: Decimal | null
    qtyToShip: Decimal | null
    factMinusWaste: Decimal | null
    weightToShip: Decimal | null
    planFactDiff: Decimal | null
    underOver: Decimal | null
    sortOrder: number | null
  }

  export type SvodLineSumAggregateOutputType = {
    id: number | null
    svodId: number | null
    productId: number | null
    coefficient: Decimal | null
    orderQty: Decimal | null
    productionInQty: Decimal | null
    openingStock: Decimal | null
    afterPurchaseStock: Decimal | null
    afterShipmentStock: Decimal | null
    qtyToShip: Decimal | null
    factMinusWaste: Decimal | null
    weightToShip: Decimal | null
    planFactDiff: Decimal | null
    underOver: Decimal | null
    sortOrder: number | null
  }

  export type SvodLineMinAggregateOutputType = {
    id: number | null
    svodId: number | null
    productId: number | null
    shortName: string | null
    category: string | null
    coefficient: Decimal | null
    orderQty: Decimal | null
    productionInQty: Decimal | null
    openingStock: Decimal | null
    openingStockIsManual: boolean | null
    afterPurchaseStock: Decimal | null
    afterShipmentStock: Decimal | null
    qtyToShip: Decimal | null
    factMinusWaste: Decimal | null
    weightToShip: Decimal | null
    planFactDiff: Decimal | null
    underOver: Decimal | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SvodLineMaxAggregateOutputType = {
    id: number | null
    svodId: number | null
    productId: number | null
    shortName: string | null
    category: string | null
    coefficient: Decimal | null
    orderQty: Decimal | null
    productionInQty: Decimal | null
    openingStock: Decimal | null
    openingStockIsManual: boolean | null
    afterPurchaseStock: Decimal | null
    afterShipmentStock: Decimal | null
    qtyToShip: Decimal | null
    factMinusWaste: Decimal | null
    weightToShip: Decimal | null
    planFactDiff: Decimal | null
    underOver: Decimal | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SvodLineCountAggregateOutputType = {
    id: number
    svodId: number
    productId: number
    shortName: number
    category: number
    coefficient: number
    orderQty: number
    productionInQty: number
    openingStock: number
    openingStockIsManual: number
    afterPurchaseStock: number
    afterShipmentStock: number
    qtyToShip: number
    factMinusWaste: number
    weightToShip: number
    planFactDiff: number
    underOver: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SvodLineAvgAggregateInputType = {
    id?: true
    svodId?: true
    productId?: true
    coefficient?: true
    orderQty?: true
    productionInQty?: true
    openingStock?: true
    afterPurchaseStock?: true
    afterShipmentStock?: true
    qtyToShip?: true
    factMinusWaste?: true
    weightToShip?: true
    planFactDiff?: true
    underOver?: true
    sortOrder?: true
  }

  export type SvodLineSumAggregateInputType = {
    id?: true
    svodId?: true
    productId?: true
    coefficient?: true
    orderQty?: true
    productionInQty?: true
    openingStock?: true
    afterPurchaseStock?: true
    afterShipmentStock?: true
    qtyToShip?: true
    factMinusWaste?: true
    weightToShip?: true
    planFactDiff?: true
    underOver?: true
    sortOrder?: true
  }

  export type SvodLineMinAggregateInputType = {
    id?: true
    svodId?: true
    productId?: true
    shortName?: true
    category?: true
    coefficient?: true
    orderQty?: true
    productionInQty?: true
    openingStock?: true
    openingStockIsManual?: true
    afterPurchaseStock?: true
    afterShipmentStock?: true
    qtyToShip?: true
    factMinusWaste?: true
    weightToShip?: true
    planFactDiff?: true
    underOver?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SvodLineMaxAggregateInputType = {
    id?: true
    svodId?: true
    productId?: true
    shortName?: true
    category?: true
    coefficient?: true
    orderQty?: true
    productionInQty?: true
    openingStock?: true
    openingStockIsManual?: true
    afterPurchaseStock?: true
    afterShipmentStock?: true
    qtyToShip?: true
    factMinusWaste?: true
    weightToShip?: true
    planFactDiff?: true
    underOver?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SvodLineCountAggregateInputType = {
    id?: true
    svodId?: true
    productId?: true
    shortName?: true
    category?: true
    coefficient?: true
    orderQty?: true
    productionInQty?: true
    openingStock?: true
    openingStockIsManual?: true
    afterPurchaseStock?: true
    afterShipmentStock?: true
    qtyToShip?: true
    factMinusWaste?: true
    weightToShip?: true
    planFactDiff?: true
    underOver?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SvodLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SvodLine to aggregate.
     */
    where?: SvodLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodLines to fetch.
     */
    orderBy?: SvodLineOrderByWithRelationInput | SvodLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SvodLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SvodLines
    **/
    _count?: true | SvodLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SvodLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SvodLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SvodLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SvodLineMaxAggregateInputType
  }

  export type GetSvodLineAggregateType<T extends SvodLineAggregateArgs> = {
        [P in keyof T & keyof AggregateSvodLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSvodLine[P]>
      : GetScalarType<T[P], AggregateSvodLine[P]>
  }




  export type SvodLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SvodLineWhereInput
    orderBy?: SvodLineOrderByWithAggregationInput | SvodLineOrderByWithAggregationInput[]
    by: SvodLineScalarFieldEnum[] | SvodLineScalarFieldEnum
    having?: SvodLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SvodLineCountAggregateInputType | true
    _avg?: SvodLineAvgAggregateInputType
    _sum?: SvodLineSumAggregateInputType
    _min?: SvodLineMinAggregateInputType
    _max?: SvodLineMaxAggregateInputType
  }

  export type SvodLineGroupByOutputType = {
    id: number
    svodId: number
    productId: number
    shortName: string | null
    category: string | null
    coefficient: Decimal | null
    orderQty: Decimal
    productionInQty: Decimal
    openingStock: Decimal
    openingStockIsManual: boolean
    afterPurchaseStock: Decimal | null
    afterShipmentStock: Decimal | null
    qtyToShip: Decimal | null
    factMinusWaste: Decimal | null
    weightToShip: Decimal | null
    planFactDiff: Decimal | null
    underOver: Decimal | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: SvodLineCountAggregateOutputType | null
    _avg: SvodLineAvgAggregateOutputType | null
    _sum: SvodLineSumAggregateOutputType | null
    _min: SvodLineMinAggregateOutputType | null
    _max: SvodLineMaxAggregateOutputType | null
  }

  type GetSvodLineGroupByPayload<T extends SvodLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SvodLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SvodLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SvodLineGroupByOutputType[P]>
            : GetScalarType<T[P], SvodLineGroupByOutputType[P]>
        }
      >
    >


  export type SvodLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodId?: boolean
    productId?: boolean
    shortName?: boolean
    category?: boolean
    coefficient?: boolean
    orderQty?: boolean
    productionInQty?: boolean
    openingStock?: boolean
    openingStockIsManual?: boolean
    afterPurchaseStock?: boolean
    afterShipmentStock?: boolean
    qtyToShip?: boolean
    factMinusWaste?: boolean
    weightToShip?: boolean
    planFactDiff?: boolean
    underOver?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["svodLine"]>

  export type SvodLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodId?: boolean
    productId?: boolean
    shortName?: boolean
    category?: boolean
    coefficient?: boolean
    orderQty?: boolean
    productionInQty?: boolean
    openingStock?: boolean
    openingStockIsManual?: boolean
    afterPurchaseStock?: boolean
    afterShipmentStock?: boolean
    qtyToShip?: boolean
    factMinusWaste?: boolean
    weightToShip?: boolean
    planFactDiff?: boolean
    underOver?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["svodLine"]>

  export type SvodLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodId?: boolean
    productId?: boolean
    shortName?: boolean
    category?: boolean
    coefficient?: boolean
    orderQty?: boolean
    productionInQty?: boolean
    openingStock?: boolean
    openingStockIsManual?: boolean
    afterPurchaseStock?: boolean
    afterShipmentStock?: boolean
    qtyToShip?: boolean
    factMinusWaste?: boolean
    weightToShip?: boolean
    planFactDiff?: boolean
    underOver?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["svodLine"]>

  export type SvodLineSelectScalar = {
    id?: boolean
    svodId?: boolean
    productId?: boolean
    shortName?: boolean
    category?: boolean
    coefficient?: boolean
    orderQty?: boolean
    productionInQty?: boolean
    openingStock?: boolean
    openingStockIsManual?: boolean
    afterPurchaseStock?: boolean
    afterShipmentStock?: boolean
    qtyToShip?: boolean
    factMinusWaste?: boolean
    weightToShip?: boolean
    planFactDiff?: boolean
    underOver?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SvodLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "svodId" | "productId" | "shortName" | "category" | "coefficient" | "orderQty" | "productionInQty" | "openingStock" | "openingStockIsManual" | "afterPurchaseStock" | "afterShipmentStock" | "qtyToShip" | "factMinusWaste" | "weightToShip" | "planFactDiff" | "underOver" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["svodLine"]>
  export type SvodLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SvodLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SvodLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $SvodLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SvodLine"
    objects: {
      svod: Prisma.$SvodHeaderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      svodId: number
      productId: number
      shortName: string | null
      category: string | null
      coefficient: Prisma.Decimal | null
      orderQty: Prisma.Decimal
      productionInQty: Prisma.Decimal
      openingStock: Prisma.Decimal
      openingStockIsManual: boolean
      afterPurchaseStock: Prisma.Decimal | null
      afterShipmentStock: Prisma.Decimal | null
      qtyToShip: Prisma.Decimal | null
      factMinusWaste: Prisma.Decimal | null
      weightToShip: Prisma.Decimal | null
      planFactDiff: Prisma.Decimal | null
      underOver: Prisma.Decimal | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["svodLine"]>
    composites: {}
  }

  type SvodLineGetPayload<S extends boolean | null | undefined | SvodLineDefaultArgs> = $Result.GetResult<Prisma.$SvodLinePayload, S>

  type SvodLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SvodLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SvodLineCountAggregateInputType | true
    }

  export interface SvodLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SvodLine'], meta: { name: 'SvodLine' } }
    /**
     * Find zero or one SvodLine that matches the filter.
     * @param {SvodLineFindUniqueArgs} args - Arguments to find a SvodLine
     * @example
     * // Get one SvodLine
     * const svodLine = await prisma.svodLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SvodLineFindUniqueArgs>(args: SelectSubset<T, SvodLineFindUniqueArgs<ExtArgs>>): Prisma__SvodLineClient<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SvodLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SvodLineFindUniqueOrThrowArgs} args - Arguments to find a SvodLine
     * @example
     * // Get one SvodLine
     * const svodLine = await prisma.svodLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SvodLineFindUniqueOrThrowArgs>(args: SelectSubset<T, SvodLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SvodLineClient<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SvodLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodLineFindFirstArgs} args - Arguments to find a SvodLine
     * @example
     * // Get one SvodLine
     * const svodLine = await prisma.svodLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SvodLineFindFirstArgs>(args?: SelectSubset<T, SvodLineFindFirstArgs<ExtArgs>>): Prisma__SvodLineClient<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SvodLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodLineFindFirstOrThrowArgs} args - Arguments to find a SvodLine
     * @example
     * // Get one SvodLine
     * const svodLine = await prisma.svodLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SvodLineFindFirstOrThrowArgs>(args?: SelectSubset<T, SvodLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__SvodLineClient<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SvodLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SvodLines
     * const svodLines = await prisma.svodLine.findMany()
     * 
     * // Get first 10 SvodLines
     * const svodLines = await prisma.svodLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const svodLineWithIdOnly = await prisma.svodLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SvodLineFindManyArgs>(args?: SelectSubset<T, SvodLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SvodLine.
     * @param {SvodLineCreateArgs} args - Arguments to create a SvodLine.
     * @example
     * // Create one SvodLine
     * const SvodLine = await prisma.svodLine.create({
     *   data: {
     *     // ... data to create a SvodLine
     *   }
     * })
     * 
     */
    create<T extends SvodLineCreateArgs>(args: SelectSubset<T, SvodLineCreateArgs<ExtArgs>>): Prisma__SvodLineClient<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SvodLines.
     * @param {SvodLineCreateManyArgs} args - Arguments to create many SvodLines.
     * @example
     * // Create many SvodLines
     * const svodLine = await prisma.svodLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SvodLineCreateManyArgs>(args?: SelectSubset<T, SvodLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SvodLines and returns the data saved in the database.
     * @param {SvodLineCreateManyAndReturnArgs} args - Arguments to create many SvodLines.
     * @example
     * // Create many SvodLines
     * const svodLine = await prisma.svodLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SvodLines and only return the `id`
     * const svodLineWithIdOnly = await prisma.svodLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SvodLineCreateManyAndReturnArgs>(args?: SelectSubset<T, SvodLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SvodLine.
     * @param {SvodLineDeleteArgs} args - Arguments to delete one SvodLine.
     * @example
     * // Delete one SvodLine
     * const SvodLine = await prisma.svodLine.delete({
     *   where: {
     *     // ... filter to delete one SvodLine
     *   }
     * })
     * 
     */
    delete<T extends SvodLineDeleteArgs>(args: SelectSubset<T, SvodLineDeleteArgs<ExtArgs>>): Prisma__SvodLineClient<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SvodLine.
     * @param {SvodLineUpdateArgs} args - Arguments to update one SvodLine.
     * @example
     * // Update one SvodLine
     * const svodLine = await prisma.svodLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SvodLineUpdateArgs>(args: SelectSubset<T, SvodLineUpdateArgs<ExtArgs>>): Prisma__SvodLineClient<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SvodLines.
     * @param {SvodLineDeleteManyArgs} args - Arguments to filter SvodLines to delete.
     * @example
     * // Delete a few SvodLines
     * const { count } = await prisma.svodLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SvodLineDeleteManyArgs>(args?: SelectSubset<T, SvodLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SvodLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SvodLines
     * const svodLine = await prisma.svodLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SvodLineUpdateManyArgs>(args: SelectSubset<T, SvodLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SvodLines and returns the data updated in the database.
     * @param {SvodLineUpdateManyAndReturnArgs} args - Arguments to update many SvodLines.
     * @example
     * // Update many SvodLines
     * const svodLine = await prisma.svodLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SvodLines and only return the `id`
     * const svodLineWithIdOnly = await prisma.svodLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SvodLineUpdateManyAndReturnArgs>(args: SelectSubset<T, SvodLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SvodLine.
     * @param {SvodLineUpsertArgs} args - Arguments to update or create a SvodLine.
     * @example
     * // Update or create a SvodLine
     * const svodLine = await prisma.svodLine.upsert({
     *   create: {
     *     // ... data to create a SvodLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SvodLine we want to update
     *   }
     * })
     */
    upsert<T extends SvodLineUpsertArgs>(args: SelectSubset<T, SvodLineUpsertArgs<ExtArgs>>): Prisma__SvodLineClient<$Result.GetResult<Prisma.$SvodLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SvodLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodLineCountArgs} args - Arguments to filter SvodLines to count.
     * @example
     * // Count the number of SvodLines
     * const count = await prisma.svodLine.count({
     *   where: {
     *     // ... the filter for the SvodLines we want to count
     *   }
     * })
    **/
    count<T extends SvodLineCountArgs>(
      args?: Subset<T, SvodLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SvodLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SvodLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SvodLineAggregateArgs>(args: Subset<T, SvodLineAggregateArgs>): Prisma.PrismaPromise<GetSvodLineAggregateType<T>>

    /**
     * Group by SvodLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SvodLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SvodLineGroupByArgs['orderBy'] }
        : { orderBy?: SvodLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SvodLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSvodLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SvodLine model
   */
  readonly fields: SvodLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SvodLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SvodLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    svod<T extends SvodHeaderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SvodHeaderDefaultArgs<ExtArgs>>): Prisma__SvodHeaderClient<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SvodLine model
   */
  interface SvodLineFieldRefs {
    readonly id: FieldRef<"SvodLine", 'Int'>
    readonly svodId: FieldRef<"SvodLine", 'Int'>
    readonly productId: FieldRef<"SvodLine", 'Int'>
    readonly shortName: FieldRef<"SvodLine", 'String'>
    readonly category: FieldRef<"SvodLine", 'String'>
    readonly coefficient: FieldRef<"SvodLine", 'Decimal'>
    readonly orderQty: FieldRef<"SvodLine", 'Decimal'>
    readonly productionInQty: FieldRef<"SvodLine", 'Decimal'>
    readonly openingStock: FieldRef<"SvodLine", 'Decimal'>
    readonly openingStockIsManual: FieldRef<"SvodLine", 'Boolean'>
    readonly afterPurchaseStock: FieldRef<"SvodLine", 'Decimal'>
    readonly afterShipmentStock: FieldRef<"SvodLine", 'Decimal'>
    readonly qtyToShip: FieldRef<"SvodLine", 'Decimal'>
    readonly factMinusWaste: FieldRef<"SvodLine", 'Decimal'>
    readonly weightToShip: FieldRef<"SvodLine", 'Decimal'>
    readonly planFactDiff: FieldRef<"SvodLine", 'Decimal'>
    readonly underOver: FieldRef<"SvodLine", 'Decimal'>
    readonly sortOrder: FieldRef<"SvodLine", 'Int'>
    readonly createdAt: FieldRef<"SvodLine", 'DateTime'>
    readonly updatedAt: FieldRef<"SvodLine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SvodLine findUnique
   */
  export type SvodLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
    /**
     * Filter, which SvodLine to fetch.
     */
    where: SvodLineWhereUniqueInput
  }

  /**
   * SvodLine findUniqueOrThrow
   */
  export type SvodLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
    /**
     * Filter, which SvodLine to fetch.
     */
    where: SvodLineWhereUniqueInput
  }

  /**
   * SvodLine findFirst
   */
  export type SvodLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
    /**
     * Filter, which SvodLine to fetch.
     */
    where?: SvodLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodLines to fetch.
     */
    orderBy?: SvodLineOrderByWithRelationInput | SvodLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SvodLines.
     */
    cursor?: SvodLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SvodLines.
     */
    distinct?: SvodLineScalarFieldEnum | SvodLineScalarFieldEnum[]
  }

  /**
   * SvodLine findFirstOrThrow
   */
  export type SvodLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
    /**
     * Filter, which SvodLine to fetch.
     */
    where?: SvodLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodLines to fetch.
     */
    orderBy?: SvodLineOrderByWithRelationInput | SvodLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SvodLines.
     */
    cursor?: SvodLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SvodLines.
     */
    distinct?: SvodLineScalarFieldEnum | SvodLineScalarFieldEnum[]
  }

  /**
   * SvodLine findMany
   */
  export type SvodLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
    /**
     * Filter, which SvodLines to fetch.
     */
    where?: SvodLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodLines to fetch.
     */
    orderBy?: SvodLineOrderByWithRelationInput | SvodLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SvodLines.
     */
    cursor?: SvodLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodLines.
     */
    skip?: number
    distinct?: SvodLineScalarFieldEnum | SvodLineScalarFieldEnum[]
  }

  /**
   * SvodLine create
   */
  export type SvodLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
    /**
     * The data needed to create a SvodLine.
     */
    data: XOR<SvodLineCreateInput, SvodLineUncheckedCreateInput>
  }

  /**
   * SvodLine createMany
   */
  export type SvodLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SvodLines.
     */
    data: SvodLineCreateManyInput | SvodLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SvodLine createManyAndReturn
   */
  export type SvodLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * The data used to create many SvodLines.
     */
    data: SvodLineCreateManyInput | SvodLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SvodLine update
   */
  export type SvodLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
    /**
     * The data needed to update a SvodLine.
     */
    data: XOR<SvodLineUpdateInput, SvodLineUncheckedUpdateInput>
    /**
     * Choose, which SvodLine to update.
     */
    where: SvodLineWhereUniqueInput
  }

  /**
   * SvodLine updateMany
   */
  export type SvodLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SvodLines.
     */
    data: XOR<SvodLineUpdateManyMutationInput, SvodLineUncheckedUpdateManyInput>
    /**
     * Filter which SvodLines to update
     */
    where?: SvodLineWhereInput
    /**
     * Limit how many SvodLines to update.
     */
    limit?: number
  }

  /**
   * SvodLine updateManyAndReturn
   */
  export type SvodLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * The data used to update SvodLines.
     */
    data: XOR<SvodLineUpdateManyMutationInput, SvodLineUncheckedUpdateManyInput>
    /**
     * Filter which SvodLines to update
     */
    where?: SvodLineWhereInput
    /**
     * Limit how many SvodLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SvodLine upsert
   */
  export type SvodLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
    /**
     * The filter to search for the SvodLine to update in case it exists.
     */
    where: SvodLineWhereUniqueInput
    /**
     * In case the SvodLine found by the `where` argument doesn't exist, create a new SvodLine with this data.
     */
    create: XOR<SvodLineCreateInput, SvodLineUncheckedCreateInput>
    /**
     * In case the SvodLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SvodLineUpdateInput, SvodLineUncheckedUpdateInput>
  }

  /**
   * SvodLine delete
   */
  export type SvodLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
    /**
     * Filter which SvodLine to delete.
     */
    where: SvodLineWhereUniqueInput
  }

  /**
   * SvodLine deleteMany
   */
  export type SvodLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SvodLines to delete
     */
    where?: SvodLineWhereInput
    /**
     * Limit how many SvodLines to delete.
     */
    limit?: number
  }

  /**
   * SvodLine without action
   */
  export type SvodLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodLine
     */
    select?: SvodLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodLine
     */
    omit?: SvodLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodLineInclude<ExtArgs> | null
  }


  /**
   * Model SvodSupplierCol
   */

  export type AggregateSvodSupplierCol = {
    _count: SvodSupplierColCountAggregateOutputType | null
    _avg: SvodSupplierColAvgAggregateOutputType | null
    _sum: SvodSupplierColSumAggregateOutputType | null
    _min: SvodSupplierColMinAggregateOutputType | null
    _max: SvodSupplierColMaxAggregateOutputType | null
  }

  export type SvodSupplierColAvgAggregateOutputType = {
    id: number | null
    svodId: number | null
    colIndex: number | null
    supplierId: number | null
    totalPurchase: Decimal | null
  }

  export type SvodSupplierColSumAggregateOutputType = {
    id: number | null
    svodId: number | null
    colIndex: number | null
    supplierId: number | null
    totalPurchase: Decimal | null
  }

  export type SvodSupplierColMinAggregateOutputType = {
    id: number | null
    svodId: number | null
    colIndex: number | null
    supplierId: number | null
    supplierName: string | null
    totalPurchase: Decimal | null
    createdAt: Date | null
  }

  export type SvodSupplierColMaxAggregateOutputType = {
    id: number | null
    svodId: number | null
    colIndex: number | null
    supplierId: number | null
    supplierName: string | null
    totalPurchase: Decimal | null
    createdAt: Date | null
  }

  export type SvodSupplierColCountAggregateOutputType = {
    id: number
    svodId: number
    colIndex: number
    supplierId: number
    supplierName: number
    totalPurchase: number
    createdAt: number
    _all: number
  }


  export type SvodSupplierColAvgAggregateInputType = {
    id?: true
    svodId?: true
    colIndex?: true
    supplierId?: true
    totalPurchase?: true
  }

  export type SvodSupplierColSumAggregateInputType = {
    id?: true
    svodId?: true
    colIndex?: true
    supplierId?: true
    totalPurchase?: true
  }

  export type SvodSupplierColMinAggregateInputType = {
    id?: true
    svodId?: true
    colIndex?: true
    supplierId?: true
    supplierName?: true
    totalPurchase?: true
    createdAt?: true
  }

  export type SvodSupplierColMaxAggregateInputType = {
    id?: true
    svodId?: true
    colIndex?: true
    supplierId?: true
    supplierName?: true
    totalPurchase?: true
    createdAt?: true
  }

  export type SvodSupplierColCountAggregateInputType = {
    id?: true
    svodId?: true
    colIndex?: true
    supplierId?: true
    supplierName?: true
    totalPurchase?: true
    createdAt?: true
    _all?: true
  }

  export type SvodSupplierColAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SvodSupplierCol to aggregate.
     */
    where?: SvodSupplierColWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodSupplierCols to fetch.
     */
    orderBy?: SvodSupplierColOrderByWithRelationInput | SvodSupplierColOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SvodSupplierColWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodSupplierCols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodSupplierCols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SvodSupplierCols
    **/
    _count?: true | SvodSupplierColCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SvodSupplierColAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SvodSupplierColSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SvodSupplierColMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SvodSupplierColMaxAggregateInputType
  }

  export type GetSvodSupplierColAggregateType<T extends SvodSupplierColAggregateArgs> = {
        [P in keyof T & keyof AggregateSvodSupplierCol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSvodSupplierCol[P]>
      : GetScalarType<T[P], AggregateSvodSupplierCol[P]>
  }




  export type SvodSupplierColGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SvodSupplierColWhereInput
    orderBy?: SvodSupplierColOrderByWithAggregationInput | SvodSupplierColOrderByWithAggregationInput[]
    by: SvodSupplierColScalarFieldEnum[] | SvodSupplierColScalarFieldEnum
    having?: SvodSupplierColScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SvodSupplierColCountAggregateInputType | true
    _avg?: SvodSupplierColAvgAggregateInputType
    _sum?: SvodSupplierColSumAggregateInputType
    _min?: SvodSupplierColMinAggregateInputType
    _max?: SvodSupplierColMaxAggregateInputType
  }

  export type SvodSupplierColGroupByOutputType = {
    id: number
    svodId: number
    colIndex: number
    supplierId: number
    supplierName: string
    totalPurchase: Decimal
    createdAt: Date
    _count: SvodSupplierColCountAggregateOutputType | null
    _avg: SvodSupplierColAvgAggregateOutputType | null
    _sum: SvodSupplierColSumAggregateOutputType | null
    _min: SvodSupplierColMinAggregateOutputType | null
    _max: SvodSupplierColMaxAggregateOutputType | null
  }

  type GetSvodSupplierColGroupByPayload<T extends SvodSupplierColGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SvodSupplierColGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SvodSupplierColGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SvodSupplierColGroupByOutputType[P]>
            : GetScalarType<T[P], SvodSupplierColGroupByOutputType[P]>
        }
      >
    >


  export type SvodSupplierColSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodId?: boolean
    colIndex?: boolean
    supplierId?: boolean
    supplierName?: boolean
    totalPurchase?: boolean
    createdAt?: boolean
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["svodSupplierCol"]>

  export type SvodSupplierColSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodId?: boolean
    colIndex?: boolean
    supplierId?: boolean
    supplierName?: boolean
    totalPurchase?: boolean
    createdAt?: boolean
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["svodSupplierCol"]>

  export type SvodSupplierColSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodId?: boolean
    colIndex?: boolean
    supplierId?: boolean
    supplierName?: boolean
    totalPurchase?: boolean
    createdAt?: boolean
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["svodSupplierCol"]>

  export type SvodSupplierColSelectScalar = {
    id?: boolean
    svodId?: boolean
    colIndex?: boolean
    supplierId?: boolean
    supplierName?: boolean
    totalPurchase?: boolean
    createdAt?: boolean
  }

  export type SvodSupplierColOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "svodId" | "colIndex" | "supplierId" | "supplierName" | "totalPurchase" | "createdAt", ExtArgs["result"]["svodSupplierCol"]>
  export type SvodSupplierColInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SvodSupplierColIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SvodSupplierColIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $SvodSupplierColPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SvodSupplierCol"
    objects: {
      svod: Prisma.$SvodHeaderPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      svodId: number
      colIndex: number
      supplierId: number
      supplierName: string
      totalPurchase: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["svodSupplierCol"]>
    composites: {}
  }

  type SvodSupplierColGetPayload<S extends boolean | null | undefined | SvodSupplierColDefaultArgs> = $Result.GetResult<Prisma.$SvodSupplierColPayload, S>

  type SvodSupplierColCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SvodSupplierColFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SvodSupplierColCountAggregateInputType | true
    }

  export interface SvodSupplierColDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SvodSupplierCol'], meta: { name: 'SvodSupplierCol' } }
    /**
     * Find zero or one SvodSupplierCol that matches the filter.
     * @param {SvodSupplierColFindUniqueArgs} args - Arguments to find a SvodSupplierCol
     * @example
     * // Get one SvodSupplierCol
     * const svodSupplierCol = await prisma.svodSupplierCol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SvodSupplierColFindUniqueArgs>(args: SelectSubset<T, SvodSupplierColFindUniqueArgs<ExtArgs>>): Prisma__SvodSupplierColClient<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SvodSupplierCol that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SvodSupplierColFindUniqueOrThrowArgs} args - Arguments to find a SvodSupplierCol
     * @example
     * // Get one SvodSupplierCol
     * const svodSupplierCol = await prisma.svodSupplierCol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SvodSupplierColFindUniqueOrThrowArgs>(args: SelectSubset<T, SvodSupplierColFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SvodSupplierColClient<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SvodSupplierCol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierColFindFirstArgs} args - Arguments to find a SvodSupplierCol
     * @example
     * // Get one SvodSupplierCol
     * const svodSupplierCol = await prisma.svodSupplierCol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SvodSupplierColFindFirstArgs>(args?: SelectSubset<T, SvodSupplierColFindFirstArgs<ExtArgs>>): Prisma__SvodSupplierColClient<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SvodSupplierCol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierColFindFirstOrThrowArgs} args - Arguments to find a SvodSupplierCol
     * @example
     * // Get one SvodSupplierCol
     * const svodSupplierCol = await prisma.svodSupplierCol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SvodSupplierColFindFirstOrThrowArgs>(args?: SelectSubset<T, SvodSupplierColFindFirstOrThrowArgs<ExtArgs>>): Prisma__SvodSupplierColClient<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SvodSupplierCols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierColFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SvodSupplierCols
     * const svodSupplierCols = await prisma.svodSupplierCol.findMany()
     * 
     * // Get first 10 SvodSupplierCols
     * const svodSupplierCols = await prisma.svodSupplierCol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const svodSupplierColWithIdOnly = await prisma.svodSupplierCol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SvodSupplierColFindManyArgs>(args?: SelectSubset<T, SvodSupplierColFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SvodSupplierCol.
     * @param {SvodSupplierColCreateArgs} args - Arguments to create a SvodSupplierCol.
     * @example
     * // Create one SvodSupplierCol
     * const SvodSupplierCol = await prisma.svodSupplierCol.create({
     *   data: {
     *     // ... data to create a SvodSupplierCol
     *   }
     * })
     * 
     */
    create<T extends SvodSupplierColCreateArgs>(args: SelectSubset<T, SvodSupplierColCreateArgs<ExtArgs>>): Prisma__SvodSupplierColClient<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SvodSupplierCols.
     * @param {SvodSupplierColCreateManyArgs} args - Arguments to create many SvodSupplierCols.
     * @example
     * // Create many SvodSupplierCols
     * const svodSupplierCol = await prisma.svodSupplierCol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SvodSupplierColCreateManyArgs>(args?: SelectSubset<T, SvodSupplierColCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SvodSupplierCols and returns the data saved in the database.
     * @param {SvodSupplierColCreateManyAndReturnArgs} args - Arguments to create many SvodSupplierCols.
     * @example
     * // Create many SvodSupplierCols
     * const svodSupplierCol = await prisma.svodSupplierCol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SvodSupplierCols and only return the `id`
     * const svodSupplierColWithIdOnly = await prisma.svodSupplierCol.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SvodSupplierColCreateManyAndReturnArgs>(args?: SelectSubset<T, SvodSupplierColCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SvodSupplierCol.
     * @param {SvodSupplierColDeleteArgs} args - Arguments to delete one SvodSupplierCol.
     * @example
     * // Delete one SvodSupplierCol
     * const SvodSupplierCol = await prisma.svodSupplierCol.delete({
     *   where: {
     *     // ... filter to delete one SvodSupplierCol
     *   }
     * })
     * 
     */
    delete<T extends SvodSupplierColDeleteArgs>(args: SelectSubset<T, SvodSupplierColDeleteArgs<ExtArgs>>): Prisma__SvodSupplierColClient<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SvodSupplierCol.
     * @param {SvodSupplierColUpdateArgs} args - Arguments to update one SvodSupplierCol.
     * @example
     * // Update one SvodSupplierCol
     * const svodSupplierCol = await prisma.svodSupplierCol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SvodSupplierColUpdateArgs>(args: SelectSubset<T, SvodSupplierColUpdateArgs<ExtArgs>>): Prisma__SvodSupplierColClient<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SvodSupplierCols.
     * @param {SvodSupplierColDeleteManyArgs} args - Arguments to filter SvodSupplierCols to delete.
     * @example
     * // Delete a few SvodSupplierCols
     * const { count } = await prisma.svodSupplierCol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SvodSupplierColDeleteManyArgs>(args?: SelectSubset<T, SvodSupplierColDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SvodSupplierCols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierColUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SvodSupplierCols
     * const svodSupplierCol = await prisma.svodSupplierCol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SvodSupplierColUpdateManyArgs>(args: SelectSubset<T, SvodSupplierColUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SvodSupplierCols and returns the data updated in the database.
     * @param {SvodSupplierColUpdateManyAndReturnArgs} args - Arguments to update many SvodSupplierCols.
     * @example
     * // Update many SvodSupplierCols
     * const svodSupplierCol = await prisma.svodSupplierCol.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SvodSupplierCols and only return the `id`
     * const svodSupplierColWithIdOnly = await prisma.svodSupplierCol.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SvodSupplierColUpdateManyAndReturnArgs>(args: SelectSubset<T, SvodSupplierColUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SvodSupplierCol.
     * @param {SvodSupplierColUpsertArgs} args - Arguments to update or create a SvodSupplierCol.
     * @example
     * // Update or create a SvodSupplierCol
     * const svodSupplierCol = await prisma.svodSupplierCol.upsert({
     *   create: {
     *     // ... data to create a SvodSupplierCol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SvodSupplierCol we want to update
     *   }
     * })
     */
    upsert<T extends SvodSupplierColUpsertArgs>(args: SelectSubset<T, SvodSupplierColUpsertArgs<ExtArgs>>): Prisma__SvodSupplierColClient<$Result.GetResult<Prisma.$SvodSupplierColPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SvodSupplierCols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierColCountArgs} args - Arguments to filter SvodSupplierCols to count.
     * @example
     * // Count the number of SvodSupplierCols
     * const count = await prisma.svodSupplierCol.count({
     *   where: {
     *     // ... the filter for the SvodSupplierCols we want to count
     *   }
     * })
    **/
    count<T extends SvodSupplierColCountArgs>(
      args?: Subset<T, SvodSupplierColCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SvodSupplierColCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SvodSupplierCol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierColAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SvodSupplierColAggregateArgs>(args: Subset<T, SvodSupplierColAggregateArgs>): Prisma.PrismaPromise<GetSvodSupplierColAggregateType<T>>

    /**
     * Group by SvodSupplierCol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierColGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SvodSupplierColGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SvodSupplierColGroupByArgs['orderBy'] }
        : { orderBy?: SvodSupplierColGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SvodSupplierColGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSvodSupplierColGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SvodSupplierCol model
   */
  readonly fields: SvodSupplierColFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SvodSupplierCol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SvodSupplierColClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    svod<T extends SvodHeaderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SvodHeaderDefaultArgs<ExtArgs>>): Prisma__SvodHeaderClient<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SvodSupplierCol model
   */
  interface SvodSupplierColFieldRefs {
    readonly id: FieldRef<"SvodSupplierCol", 'Int'>
    readonly svodId: FieldRef<"SvodSupplierCol", 'Int'>
    readonly colIndex: FieldRef<"SvodSupplierCol", 'Int'>
    readonly supplierId: FieldRef<"SvodSupplierCol", 'Int'>
    readonly supplierName: FieldRef<"SvodSupplierCol", 'String'>
    readonly totalPurchase: FieldRef<"SvodSupplierCol", 'Decimal'>
    readonly createdAt: FieldRef<"SvodSupplierCol", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SvodSupplierCol findUnique
   */
  export type SvodSupplierColFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
    /**
     * Filter, which SvodSupplierCol to fetch.
     */
    where: SvodSupplierColWhereUniqueInput
  }

  /**
   * SvodSupplierCol findUniqueOrThrow
   */
  export type SvodSupplierColFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
    /**
     * Filter, which SvodSupplierCol to fetch.
     */
    where: SvodSupplierColWhereUniqueInput
  }

  /**
   * SvodSupplierCol findFirst
   */
  export type SvodSupplierColFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
    /**
     * Filter, which SvodSupplierCol to fetch.
     */
    where?: SvodSupplierColWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodSupplierCols to fetch.
     */
    orderBy?: SvodSupplierColOrderByWithRelationInput | SvodSupplierColOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SvodSupplierCols.
     */
    cursor?: SvodSupplierColWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodSupplierCols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodSupplierCols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SvodSupplierCols.
     */
    distinct?: SvodSupplierColScalarFieldEnum | SvodSupplierColScalarFieldEnum[]
  }

  /**
   * SvodSupplierCol findFirstOrThrow
   */
  export type SvodSupplierColFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
    /**
     * Filter, which SvodSupplierCol to fetch.
     */
    where?: SvodSupplierColWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodSupplierCols to fetch.
     */
    orderBy?: SvodSupplierColOrderByWithRelationInput | SvodSupplierColOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SvodSupplierCols.
     */
    cursor?: SvodSupplierColWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodSupplierCols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodSupplierCols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SvodSupplierCols.
     */
    distinct?: SvodSupplierColScalarFieldEnum | SvodSupplierColScalarFieldEnum[]
  }

  /**
   * SvodSupplierCol findMany
   */
  export type SvodSupplierColFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
    /**
     * Filter, which SvodSupplierCols to fetch.
     */
    where?: SvodSupplierColWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodSupplierCols to fetch.
     */
    orderBy?: SvodSupplierColOrderByWithRelationInput | SvodSupplierColOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SvodSupplierCols.
     */
    cursor?: SvodSupplierColWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodSupplierCols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodSupplierCols.
     */
    skip?: number
    distinct?: SvodSupplierColScalarFieldEnum | SvodSupplierColScalarFieldEnum[]
  }

  /**
   * SvodSupplierCol create
   */
  export type SvodSupplierColCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
    /**
     * The data needed to create a SvodSupplierCol.
     */
    data: XOR<SvodSupplierColCreateInput, SvodSupplierColUncheckedCreateInput>
  }

  /**
   * SvodSupplierCol createMany
   */
  export type SvodSupplierColCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SvodSupplierCols.
     */
    data: SvodSupplierColCreateManyInput | SvodSupplierColCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SvodSupplierCol createManyAndReturn
   */
  export type SvodSupplierColCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * The data used to create many SvodSupplierCols.
     */
    data: SvodSupplierColCreateManyInput | SvodSupplierColCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SvodSupplierCol update
   */
  export type SvodSupplierColUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
    /**
     * The data needed to update a SvodSupplierCol.
     */
    data: XOR<SvodSupplierColUpdateInput, SvodSupplierColUncheckedUpdateInput>
    /**
     * Choose, which SvodSupplierCol to update.
     */
    where: SvodSupplierColWhereUniqueInput
  }

  /**
   * SvodSupplierCol updateMany
   */
  export type SvodSupplierColUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SvodSupplierCols.
     */
    data: XOR<SvodSupplierColUpdateManyMutationInput, SvodSupplierColUncheckedUpdateManyInput>
    /**
     * Filter which SvodSupplierCols to update
     */
    where?: SvodSupplierColWhereInput
    /**
     * Limit how many SvodSupplierCols to update.
     */
    limit?: number
  }

  /**
   * SvodSupplierCol updateManyAndReturn
   */
  export type SvodSupplierColUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * The data used to update SvodSupplierCols.
     */
    data: XOR<SvodSupplierColUpdateManyMutationInput, SvodSupplierColUncheckedUpdateManyInput>
    /**
     * Filter which SvodSupplierCols to update
     */
    where?: SvodSupplierColWhereInput
    /**
     * Limit how many SvodSupplierCols to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SvodSupplierCol upsert
   */
  export type SvodSupplierColUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
    /**
     * The filter to search for the SvodSupplierCol to update in case it exists.
     */
    where: SvodSupplierColWhereUniqueInput
    /**
     * In case the SvodSupplierCol found by the `where` argument doesn't exist, create a new SvodSupplierCol with this data.
     */
    create: XOR<SvodSupplierColCreateInput, SvodSupplierColUncheckedCreateInput>
    /**
     * In case the SvodSupplierCol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SvodSupplierColUpdateInput, SvodSupplierColUncheckedUpdateInput>
  }

  /**
   * SvodSupplierCol delete
   */
  export type SvodSupplierColDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
    /**
     * Filter which SvodSupplierCol to delete.
     */
    where: SvodSupplierColWhereUniqueInput
  }

  /**
   * SvodSupplierCol deleteMany
   */
  export type SvodSupplierColDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SvodSupplierCols to delete
     */
    where?: SvodSupplierColWhereInput
    /**
     * Limit how many SvodSupplierCols to delete.
     */
    limit?: number
  }

  /**
   * SvodSupplierCol without action
   */
  export type SvodSupplierColDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierCol
     */
    select?: SvodSupplierColSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierCol
     */
    omit?: SvodSupplierColOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierColInclude<ExtArgs> | null
  }


  /**
   * Model SvodSupplierValue
   */

  export type AggregateSvodSupplierValue = {
    _count: SvodSupplierValueCountAggregateOutputType | null
    _avg: SvodSupplierValueAvgAggregateOutputType | null
    _sum: SvodSupplierValueSumAggregateOutputType | null
    _min: SvodSupplierValueMinAggregateOutputType | null
    _max: SvodSupplierValueMaxAggregateOutputType | null
  }

  export type SvodSupplierValueAvgAggregateOutputType = {
    id: number | null
    svodId: number | null
    productId: number | null
    supplierId: number | null
    purchaseQty: Decimal | null
  }

  export type SvodSupplierValueSumAggregateOutputType = {
    id: number | null
    svodId: number | null
    productId: number | null
    supplierId: number | null
    purchaseQty: Decimal | null
  }

  export type SvodSupplierValueMinAggregateOutputType = {
    id: number | null
    svodId: number | null
    productId: number | null
    supplierId: number | null
    purchaseQty: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SvodSupplierValueMaxAggregateOutputType = {
    id: number | null
    svodId: number | null
    productId: number | null
    supplierId: number | null
    purchaseQty: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SvodSupplierValueCountAggregateOutputType = {
    id: number
    svodId: number
    productId: number
    supplierId: number
    purchaseQty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SvodSupplierValueAvgAggregateInputType = {
    id?: true
    svodId?: true
    productId?: true
    supplierId?: true
    purchaseQty?: true
  }

  export type SvodSupplierValueSumAggregateInputType = {
    id?: true
    svodId?: true
    productId?: true
    supplierId?: true
    purchaseQty?: true
  }

  export type SvodSupplierValueMinAggregateInputType = {
    id?: true
    svodId?: true
    productId?: true
    supplierId?: true
    purchaseQty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SvodSupplierValueMaxAggregateInputType = {
    id?: true
    svodId?: true
    productId?: true
    supplierId?: true
    purchaseQty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SvodSupplierValueCountAggregateInputType = {
    id?: true
    svodId?: true
    productId?: true
    supplierId?: true
    purchaseQty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SvodSupplierValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SvodSupplierValue to aggregate.
     */
    where?: SvodSupplierValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodSupplierValues to fetch.
     */
    orderBy?: SvodSupplierValueOrderByWithRelationInput | SvodSupplierValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SvodSupplierValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodSupplierValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodSupplierValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SvodSupplierValues
    **/
    _count?: true | SvodSupplierValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SvodSupplierValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SvodSupplierValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SvodSupplierValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SvodSupplierValueMaxAggregateInputType
  }

  export type GetSvodSupplierValueAggregateType<T extends SvodSupplierValueAggregateArgs> = {
        [P in keyof T & keyof AggregateSvodSupplierValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSvodSupplierValue[P]>
      : GetScalarType<T[P], AggregateSvodSupplierValue[P]>
  }




  export type SvodSupplierValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SvodSupplierValueWhereInput
    orderBy?: SvodSupplierValueOrderByWithAggregationInput | SvodSupplierValueOrderByWithAggregationInput[]
    by: SvodSupplierValueScalarFieldEnum[] | SvodSupplierValueScalarFieldEnum
    having?: SvodSupplierValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SvodSupplierValueCountAggregateInputType | true
    _avg?: SvodSupplierValueAvgAggregateInputType
    _sum?: SvodSupplierValueSumAggregateInputType
    _min?: SvodSupplierValueMinAggregateInputType
    _max?: SvodSupplierValueMaxAggregateInputType
  }

  export type SvodSupplierValueGroupByOutputType = {
    id: number
    svodId: number
    productId: number
    supplierId: number
    purchaseQty: Decimal
    createdAt: Date
    updatedAt: Date
    _count: SvodSupplierValueCountAggregateOutputType | null
    _avg: SvodSupplierValueAvgAggregateOutputType | null
    _sum: SvodSupplierValueSumAggregateOutputType | null
    _min: SvodSupplierValueMinAggregateOutputType | null
    _max: SvodSupplierValueMaxAggregateOutputType | null
  }

  type GetSvodSupplierValueGroupByPayload<T extends SvodSupplierValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SvodSupplierValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SvodSupplierValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SvodSupplierValueGroupByOutputType[P]>
            : GetScalarType<T[P], SvodSupplierValueGroupByOutputType[P]>
        }
      >
    >


  export type SvodSupplierValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodId?: boolean
    productId?: boolean
    supplierId?: boolean
    purchaseQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["svodSupplierValue"]>

  export type SvodSupplierValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodId?: boolean
    productId?: boolean
    supplierId?: boolean
    purchaseQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["svodSupplierValue"]>

  export type SvodSupplierValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    svodId?: boolean
    productId?: boolean
    supplierId?: boolean
    purchaseQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["svodSupplierValue"]>

  export type SvodSupplierValueSelectScalar = {
    id?: boolean
    svodId?: boolean
    productId?: boolean
    supplierId?: boolean
    purchaseQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SvodSupplierValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "svodId" | "productId" | "supplierId" | "purchaseQty" | "createdAt" | "updatedAt", ExtArgs["result"]["svodSupplierValue"]>
  export type SvodSupplierValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SvodSupplierValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SvodSupplierValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    svod?: boolean | SvodHeaderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $SvodSupplierValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SvodSupplierValue"
    objects: {
      svod: Prisma.$SvodHeaderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      svodId: number
      productId: number
      supplierId: number
      purchaseQty: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["svodSupplierValue"]>
    composites: {}
  }

  type SvodSupplierValueGetPayload<S extends boolean | null | undefined | SvodSupplierValueDefaultArgs> = $Result.GetResult<Prisma.$SvodSupplierValuePayload, S>

  type SvodSupplierValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SvodSupplierValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SvodSupplierValueCountAggregateInputType | true
    }

  export interface SvodSupplierValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SvodSupplierValue'], meta: { name: 'SvodSupplierValue' } }
    /**
     * Find zero or one SvodSupplierValue that matches the filter.
     * @param {SvodSupplierValueFindUniqueArgs} args - Arguments to find a SvodSupplierValue
     * @example
     * // Get one SvodSupplierValue
     * const svodSupplierValue = await prisma.svodSupplierValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SvodSupplierValueFindUniqueArgs>(args: SelectSubset<T, SvodSupplierValueFindUniqueArgs<ExtArgs>>): Prisma__SvodSupplierValueClient<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SvodSupplierValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SvodSupplierValueFindUniqueOrThrowArgs} args - Arguments to find a SvodSupplierValue
     * @example
     * // Get one SvodSupplierValue
     * const svodSupplierValue = await prisma.svodSupplierValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SvodSupplierValueFindUniqueOrThrowArgs>(args: SelectSubset<T, SvodSupplierValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SvodSupplierValueClient<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SvodSupplierValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierValueFindFirstArgs} args - Arguments to find a SvodSupplierValue
     * @example
     * // Get one SvodSupplierValue
     * const svodSupplierValue = await prisma.svodSupplierValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SvodSupplierValueFindFirstArgs>(args?: SelectSubset<T, SvodSupplierValueFindFirstArgs<ExtArgs>>): Prisma__SvodSupplierValueClient<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SvodSupplierValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierValueFindFirstOrThrowArgs} args - Arguments to find a SvodSupplierValue
     * @example
     * // Get one SvodSupplierValue
     * const svodSupplierValue = await prisma.svodSupplierValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SvodSupplierValueFindFirstOrThrowArgs>(args?: SelectSubset<T, SvodSupplierValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__SvodSupplierValueClient<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SvodSupplierValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SvodSupplierValues
     * const svodSupplierValues = await prisma.svodSupplierValue.findMany()
     * 
     * // Get first 10 SvodSupplierValues
     * const svodSupplierValues = await prisma.svodSupplierValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const svodSupplierValueWithIdOnly = await prisma.svodSupplierValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SvodSupplierValueFindManyArgs>(args?: SelectSubset<T, SvodSupplierValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SvodSupplierValue.
     * @param {SvodSupplierValueCreateArgs} args - Arguments to create a SvodSupplierValue.
     * @example
     * // Create one SvodSupplierValue
     * const SvodSupplierValue = await prisma.svodSupplierValue.create({
     *   data: {
     *     // ... data to create a SvodSupplierValue
     *   }
     * })
     * 
     */
    create<T extends SvodSupplierValueCreateArgs>(args: SelectSubset<T, SvodSupplierValueCreateArgs<ExtArgs>>): Prisma__SvodSupplierValueClient<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SvodSupplierValues.
     * @param {SvodSupplierValueCreateManyArgs} args - Arguments to create many SvodSupplierValues.
     * @example
     * // Create many SvodSupplierValues
     * const svodSupplierValue = await prisma.svodSupplierValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SvodSupplierValueCreateManyArgs>(args?: SelectSubset<T, SvodSupplierValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SvodSupplierValues and returns the data saved in the database.
     * @param {SvodSupplierValueCreateManyAndReturnArgs} args - Arguments to create many SvodSupplierValues.
     * @example
     * // Create many SvodSupplierValues
     * const svodSupplierValue = await prisma.svodSupplierValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SvodSupplierValues and only return the `id`
     * const svodSupplierValueWithIdOnly = await prisma.svodSupplierValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SvodSupplierValueCreateManyAndReturnArgs>(args?: SelectSubset<T, SvodSupplierValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SvodSupplierValue.
     * @param {SvodSupplierValueDeleteArgs} args - Arguments to delete one SvodSupplierValue.
     * @example
     * // Delete one SvodSupplierValue
     * const SvodSupplierValue = await prisma.svodSupplierValue.delete({
     *   where: {
     *     // ... filter to delete one SvodSupplierValue
     *   }
     * })
     * 
     */
    delete<T extends SvodSupplierValueDeleteArgs>(args: SelectSubset<T, SvodSupplierValueDeleteArgs<ExtArgs>>): Prisma__SvodSupplierValueClient<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SvodSupplierValue.
     * @param {SvodSupplierValueUpdateArgs} args - Arguments to update one SvodSupplierValue.
     * @example
     * // Update one SvodSupplierValue
     * const svodSupplierValue = await prisma.svodSupplierValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SvodSupplierValueUpdateArgs>(args: SelectSubset<T, SvodSupplierValueUpdateArgs<ExtArgs>>): Prisma__SvodSupplierValueClient<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SvodSupplierValues.
     * @param {SvodSupplierValueDeleteManyArgs} args - Arguments to filter SvodSupplierValues to delete.
     * @example
     * // Delete a few SvodSupplierValues
     * const { count } = await prisma.svodSupplierValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SvodSupplierValueDeleteManyArgs>(args?: SelectSubset<T, SvodSupplierValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SvodSupplierValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SvodSupplierValues
     * const svodSupplierValue = await prisma.svodSupplierValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SvodSupplierValueUpdateManyArgs>(args: SelectSubset<T, SvodSupplierValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SvodSupplierValues and returns the data updated in the database.
     * @param {SvodSupplierValueUpdateManyAndReturnArgs} args - Arguments to update many SvodSupplierValues.
     * @example
     * // Update many SvodSupplierValues
     * const svodSupplierValue = await prisma.svodSupplierValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SvodSupplierValues and only return the `id`
     * const svodSupplierValueWithIdOnly = await prisma.svodSupplierValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SvodSupplierValueUpdateManyAndReturnArgs>(args: SelectSubset<T, SvodSupplierValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SvodSupplierValue.
     * @param {SvodSupplierValueUpsertArgs} args - Arguments to update or create a SvodSupplierValue.
     * @example
     * // Update or create a SvodSupplierValue
     * const svodSupplierValue = await prisma.svodSupplierValue.upsert({
     *   create: {
     *     // ... data to create a SvodSupplierValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SvodSupplierValue we want to update
     *   }
     * })
     */
    upsert<T extends SvodSupplierValueUpsertArgs>(args: SelectSubset<T, SvodSupplierValueUpsertArgs<ExtArgs>>): Prisma__SvodSupplierValueClient<$Result.GetResult<Prisma.$SvodSupplierValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SvodSupplierValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierValueCountArgs} args - Arguments to filter SvodSupplierValues to count.
     * @example
     * // Count the number of SvodSupplierValues
     * const count = await prisma.svodSupplierValue.count({
     *   where: {
     *     // ... the filter for the SvodSupplierValues we want to count
     *   }
     * })
    **/
    count<T extends SvodSupplierValueCountArgs>(
      args?: Subset<T, SvodSupplierValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SvodSupplierValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SvodSupplierValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SvodSupplierValueAggregateArgs>(args: Subset<T, SvodSupplierValueAggregateArgs>): Prisma.PrismaPromise<GetSvodSupplierValueAggregateType<T>>

    /**
     * Group by SvodSupplierValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SvodSupplierValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SvodSupplierValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SvodSupplierValueGroupByArgs['orderBy'] }
        : { orderBy?: SvodSupplierValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SvodSupplierValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSvodSupplierValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SvodSupplierValue model
   */
  readonly fields: SvodSupplierValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SvodSupplierValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SvodSupplierValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    svod<T extends SvodHeaderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SvodHeaderDefaultArgs<ExtArgs>>): Prisma__SvodHeaderClient<$Result.GetResult<Prisma.$SvodHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SvodSupplierValue model
   */
  interface SvodSupplierValueFieldRefs {
    readonly id: FieldRef<"SvodSupplierValue", 'Int'>
    readonly svodId: FieldRef<"SvodSupplierValue", 'Int'>
    readonly productId: FieldRef<"SvodSupplierValue", 'Int'>
    readonly supplierId: FieldRef<"SvodSupplierValue", 'Int'>
    readonly purchaseQty: FieldRef<"SvodSupplierValue", 'Decimal'>
    readonly createdAt: FieldRef<"SvodSupplierValue", 'DateTime'>
    readonly updatedAt: FieldRef<"SvodSupplierValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SvodSupplierValue findUnique
   */
  export type SvodSupplierValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    /**
     * Filter, which SvodSupplierValue to fetch.
     */
    where: SvodSupplierValueWhereUniqueInput
  }

  /**
   * SvodSupplierValue findUniqueOrThrow
   */
  export type SvodSupplierValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    /**
     * Filter, which SvodSupplierValue to fetch.
     */
    where: SvodSupplierValueWhereUniqueInput
  }

  /**
   * SvodSupplierValue findFirst
   */
  export type SvodSupplierValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    /**
     * Filter, which SvodSupplierValue to fetch.
     */
    where?: SvodSupplierValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodSupplierValues to fetch.
     */
    orderBy?: SvodSupplierValueOrderByWithRelationInput | SvodSupplierValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SvodSupplierValues.
     */
    cursor?: SvodSupplierValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodSupplierValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodSupplierValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SvodSupplierValues.
     */
    distinct?: SvodSupplierValueScalarFieldEnum | SvodSupplierValueScalarFieldEnum[]
  }

  /**
   * SvodSupplierValue findFirstOrThrow
   */
  export type SvodSupplierValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    /**
     * Filter, which SvodSupplierValue to fetch.
     */
    where?: SvodSupplierValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodSupplierValues to fetch.
     */
    orderBy?: SvodSupplierValueOrderByWithRelationInput | SvodSupplierValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SvodSupplierValues.
     */
    cursor?: SvodSupplierValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodSupplierValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodSupplierValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SvodSupplierValues.
     */
    distinct?: SvodSupplierValueScalarFieldEnum | SvodSupplierValueScalarFieldEnum[]
  }

  /**
   * SvodSupplierValue findMany
   */
  export type SvodSupplierValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    /**
     * Filter, which SvodSupplierValues to fetch.
     */
    where?: SvodSupplierValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SvodSupplierValues to fetch.
     */
    orderBy?: SvodSupplierValueOrderByWithRelationInput | SvodSupplierValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SvodSupplierValues.
     */
    cursor?: SvodSupplierValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SvodSupplierValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SvodSupplierValues.
     */
    skip?: number
    distinct?: SvodSupplierValueScalarFieldEnum | SvodSupplierValueScalarFieldEnum[]
  }

  /**
   * SvodSupplierValue create
   */
  export type SvodSupplierValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    /**
     * The data needed to create a SvodSupplierValue.
     */
    data: XOR<SvodSupplierValueCreateInput, SvodSupplierValueUncheckedCreateInput>
  }

  /**
   * SvodSupplierValue createMany
   */
  export type SvodSupplierValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SvodSupplierValues.
     */
    data: SvodSupplierValueCreateManyInput | SvodSupplierValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SvodSupplierValue createManyAndReturn
   */
  export type SvodSupplierValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * The data used to create many SvodSupplierValues.
     */
    data: SvodSupplierValueCreateManyInput | SvodSupplierValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SvodSupplierValue update
   */
  export type SvodSupplierValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    /**
     * The data needed to update a SvodSupplierValue.
     */
    data: XOR<SvodSupplierValueUpdateInput, SvodSupplierValueUncheckedUpdateInput>
    /**
     * Choose, which SvodSupplierValue to update.
     */
    where: SvodSupplierValueWhereUniqueInput
  }

  /**
   * SvodSupplierValue updateMany
   */
  export type SvodSupplierValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SvodSupplierValues.
     */
    data: XOR<SvodSupplierValueUpdateManyMutationInput, SvodSupplierValueUncheckedUpdateManyInput>
    /**
     * Filter which SvodSupplierValues to update
     */
    where?: SvodSupplierValueWhereInput
    /**
     * Limit how many SvodSupplierValues to update.
     */
    limit?: number
  }

  /**
   * SvodSupplierValue updateManyAndReturn
   */
  export type SvodSupplierValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * The data used to update SvodSupplierValues.
     */
    data: XOR<SvodSupplierValueUpdateManyMutationInput, SvodSupplierValueUncheckedUpdateManyInput>
    /**
     * Filter which SvodSupplierValues to update
     */
    where?: SvodSupplierValueWhereInput
    /**
     * Limit how many SvodSupplierValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SvodSupplierValue upsert
   */
  export type SvodSupplierValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    /**
     * The filter to search for the SvodSupplierValue to update in case it exists.
     */
    where: SvodSupplierValueWhereUniqueInput
    /**
     * In case the SvodSupplierValue found by the `where` argument doesn't exist, create a new SvodSupplierValue with this data.
     */
    create: XOR<SvodSupplierValueCreateInput, SvodSupplierValueUncheckedCreateInput>
    /**
     * In case the SvodSupplierValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SvodSupplierValueUpdateInput, SvodSupplierValueUncheckedUpdateInput>
  }

  /**
   * SvodSupplierValue delete
   */
  export type SvodSupplierValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
    /**
     * Filter which SvodSupplierValue to delete.
     */
    where: SvodSupplierValueWhereUniqueInput
  }

  /**
   * SvodSupplierValue deleteMany
   */
  export type SvodSupplierValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SvodSupplierValues to delete
     */
    where?: SvodSupplierValueWhereInput
    /**
     * Limit how many SvodSupplierValues to delete.
     */
    limit?: number
  }

  /**
   * SvodSupplierValue without action
   */
  export type SvodSupplierValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SvodSupplierValue
     */
    select?: SvodSupplierValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SvodSupplierValue
     */
    omit?: SvodSupplierValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SvodSupplierValueInclude<ExtArgs> | null
  }


  /**
   * Model ProductionDoc
   */

  export type AggregateProductionDoc = {
    _count: ProductionDocCountAggregateOutputType | null
    _avg: ProductionDocAvgAggregateOutputType | null
    _sum: ProductionDocSumAggregateOutputType | null
    _min: ProductionDocMinAggregateOutputType | null
    _max: ProductionDocMaxAggregateOutputType | null
  }

  export type ProductionDocAvgAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    createdByUserId: number | null
  }

  export type ProductionDocSumAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    createdByUserId: number | null
  }

  export type ProductionDocMinAggregateOutputType = {
    id: number | null
    date: Date | null
    warehouseId: number | null
    status: string | null
    createdByUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionDocMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    warehouseId: number | null
    status: string | null
    createdByUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionDocCountAggregateOutputType = {
    id: number
    date: number
    warehouseId: number
    status: number
    createdByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionDocAvgAggregateInputType = {
    id?: true
    warehouseId?: true
    createdByUserId?: true
  }

  export type ProductionDocSumAggregateInputType = {
    id?: true
    warehouseId?: true
    createdByUserId?: true
  }

  export type ProductionDocMinAggregateInputType = {
    id?: true
    date?: true
    warehouseId?: true
    status?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionDocMaxAggregateInputType = {
    id?: true
    date?: true
    warehouseId?: true
    status?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionDocCountAggregateInputType = {
    id?: true
    date?: true
    warehouseId?: true
    status?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionDocAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionDoc to aggregate.
     */
    where?: ProductionDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionDocs to fetch.
     */
    orderBy?: ProductionDocOrderByWithRelationInput | ProductionDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionDocs
    **/
    _count?: true | ProductionDocCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionDocAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionDocSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionDocMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionDocMaxAggregateInputType
  }

  export type GetProductionDocAggregateType<T extends ProductionDocAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionDoc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionDoc[P]>
      : GetScalarType<T[P], AggregateProductionDoc[P]>
  }




  export type ProductionDocGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionDocWhereInput
    orderBy?: ProductionDocOrderByWithAggregationInput | ProductionDocOrderByWithAggregationInput[]
    by: ProductionDocScalarFieldEnum[] | ProductionDocScalarFieldEnum
    having?: ProductionDocScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionDocCountAggregateInputType | true
    _avg?: ProductionDocAvgAggregateInputType
    _sum?: ProductionDocSumAggregateInputType
    _min?: ProductionDocMinAggregateInputType
    _max?: ProductionDocMaxAggregateInputType
  }

  export type ProductionDocGroupByOutputType = {
    id: number
    date: Date
    warehouseId: number
    status: string
    createdByUserId: number
    createdAt: Date
    updatedAt: Date
    _count: ProductionDocCountAggregateOutputType | null
    _avg: ProductionDocAvgAggregateOutputType | null
    _sum: ProductionDocSumAggregateOutputType | null
    _min: ProductionDocMinAggregateOutputType | null
    _max: ProductionDocMaxAggregateOutputType | null
  }

  type GetProductionDocGroupByPayload<T extends ProductionDocGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionDocGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionDocGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionDocGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionDocGroupByOutputType[P]>
        }
      >
    >


  export type ProductionDocSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    warehouseId?: boolean
    status?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    inputs?: boolean | ProductionDoc$inputsArgs<ExtArgs>
    outputs?: boolean | ProductionDoc$outputsArgs<ExtArgs>
    cuttingLines?: boolean | ProductionDoc$cuttingLinesArgs<ExtArgs>
    _count?: boolean | ProductionDocCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionDoc"]>

  export type ProductionDocSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    warehouseId?: boolean
    status?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionDoc"]>

  export type ProductionDocSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    warehouseId?: boolean
    status?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionDoc"]>

  export type ProductionDocSelectScalar = {
    id?: boolean
    date?: boolean
    warehouseId?: boolean
    status?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionDocOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "warehouseId" | "status" | "createdByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["productionDoc"]>
  export type ProductionDocInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    inputs?: boolean | ProductionDoc$inputsArgs<ExtArgs>
    outputs?: boolean | ProductionDoc$outputsArgs<ExtArgs>
    cuttingLines?: boolean | ProductionDoc$cuttingLinesArgs<ExtArgs>
    _count?: boolean | ProductionDocCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionDocIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductionDocIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductionDocPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionDoc"
    objects: {
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      inputs: Prisma.$ProductionInputPayload<ExtArgs>[]
      outputs: Prisma.$ProductionOutputPayload<ExtArgs>[]
      cuttingLines: Prisma.$ProductionCuttingLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      warehouseId: number
      status: string
      createdByUserId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionDoc"]>
    composites: {}
  }

  type ProductionDocGetPayload<S extends boolean | null | undefined | ProductionDocDefaultArgs> = $Result.GetResult<Prisma.$ProductionDocPayload, S>

  type ProductionDocCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionDocFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionDocCountAggregateInputType | true
    }

  export interface ProductionDocDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionDoc'], meta: { name: 'ProductionDoc' } }
    /**
     * Find zero or one ProductionDoc that matches the filter.
     * @param {ProductionDocFindUniqueArgs} args - Arguments to find a ProductionDoc
     * @example
     * // Get one ProductionDoc
     * const productionDoc = await prisma.productionDoc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionDocFindUniqueArgs>(args: SelectSubset<T, ProductionDocFindUniqueArgs<ExtArgs>>): Prisma__ProductionDocClient<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionDoc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionDocFindUniqueOrThrowArgs} args - Arguments to find a ProductionDoc
     * @example
     * // Get one ProductionDoc
     * const productionDoc = await prisma.productionDoc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionDocFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionDocFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionDocClient<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionDoc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDocFindFirstArgs} args - Arguments to find a ProductionDoc
     * @example
     * // Get one ProductionDoc
     * const productionDoc = await prisma.productionDoc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionDocFindFirstArgs>(args?: SelectSubset<T, ProductionDocFindFirstArgs<ExtArgs>>): Prisma__ProductionDocClient<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionDoc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDocFindFirstOrThrowArgs} args - Arguments to find a ProductionDoc
     * @example
     * // Get one ProductionDoc
     * const productionDoc = await prisma.productionDoc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionDocFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionDocFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionDocClient<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionDocs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDocFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionDocs
     * const productionDocs = await prisma.productionDoc.findMany()
     * 
     * // Get first 10 ProductionDocs
     * const productionDocs = await prisma.productionDoc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionDocWithIdOnly = await prisma.productionDoc.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionDocFindManyArgs>(args?: SelectSubset<T, ProductionDocFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionDoc.
     * @param {ProductionDocCreateArgs} args - Arguments to create a ProductionDoc.
     * @example
     * // Create one ProductionDoc
     * const ProductionDoc = await prisma.productionDoc.create({
     *   data: {
     *     // ... data to create a ProductionDoc
     *   }
     * })
     * 
     */
    create<T extends ProductionDocCreateArgs>(args: SelectSubset<T, ProductionDocCreateArgs<ExtArgs>>): Prisma__ProductionDocClient<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionDocs.
     * @param {ProductionDocCreateManyArgs} args - Arguments to create many ProductionDocs.
     * @example
     * // Create many ProductionDocs
     * const productionDoc = await prisma.productionDoc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionDocCreateManyArgs>(args?: SelectSubset<T, ProductionDocCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionDocs and returns the data saved in the database.
     * @param {ProductionDocCreateManyAndReturnArgs} args - Arguments to create many ProductionDocs.
     * @example
     * // Create many ProductionDocs
     * const productionDoc = await prisma.productionDoc.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionDocs and only return the `id`
     * const productionDocWithIdOnly = await prisma.productionDoc.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionDocCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionDocCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionDoc.
     * @param {ProductionDocDeleteArgs} args - Arguments to delete one ProductionDoc.
     * @example
     * // Delete one ProductionDoc
     * const ProductionDoc = await prisma.productionDoc.delete({
     *   where: {
     *     // ... filter to delete one ProductionDoc
     *   }
     * })
     * 
     */
    delete<T extends ProductionDocDeleteArgs>(args: SelectSubset<T, ProductionDocDeleteArgs<ExtArgs>>): Prisma__ProductionDocClient<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionDoc.
     * @param {ProductionDocUpdateArgs} args - Arguments to update one ProductionDoc.
     * @example
     * // Update one ProductionDoc
     * const productionDoc = await prisma.productionDoc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionDocUpdateArgs>(args: SelectSubset<T, ProductionDocUpdateArgs<ExtArgs>>): Prisma__ProductionDocClient<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionDocs.
     * @param {ProductionDocDeleteManyArgs} args - Arguments to filter ProductionDocs to delete.
     * @example
     * // Delete a few ProductionDocs
     * const { count } = await prisma.productionDoc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionDocDeleteManyArgs>(args?: SelectSubset<T, ProductionDocDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDocUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionDocs
     * const productionDoc = await prisma.productionDoc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionDocUpdateManyArgs>(args: SelectSubset<T, ProductionDocUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionDocs and returns the data updated in the database.
     * @param {ProductionDocUpdateManyAndReturnArgs} args - Arguments to update many ProductionDocs.
     * @example
     * // Update many ProductionDocs
     * const productionDoc = await prisma.productionDoc.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionDocs and only return the `id`
     * const productionDocWithIdOnly = await prisma.productionDoc.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionDocUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionDocUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionDoc.
     * @param {ProductionDocUpsertArgs} args - Arguments to update or create a ProductionDoc.
     * @example
     * // Update or create a ProductionDoc
     * const productionDoc = await prisma.productionDoc.upsert({
     *   create: {
     *     // ... data to create a ProductionDoc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionDoc we want to update
     *   }
     * })
     */
    upsert<T extends ProductionDocUpsertArgs>(args: SelectSubset<T, ProductionDocUpsertArgs<ExtArgs>>): Prisma__ProductionDocClient<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDocCountArgs} args - Arguments to filter ProductionDocs to count.
     * @example
     * // Count the number of ProductionDocs
     * const count = await prisma.productionDoc.count({
     *   where: {
     *     // ... the filter for the ProductionDocs we want to count
     *   }
     * })
    **/
    count<T extends ProductionDocCountArgs>(
      args?: Subset<T, ProductionDocCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionDocCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionDoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDocAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionDocAggregateArgs>(args: Subset<T, ProductionDocAggregateArgs>): Prisma.PrismaPromise<GetProductionDocAggregateType<T>>

    /**
     * Group by ProductionDoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDocGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionDocGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionDocGroupByArgs['orderBy'] }
        : { orderBy?: ProductionDocGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionDocGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionDocGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionDoc model
   */
  readonly fields: ProductionDocFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionDoc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionDocClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inputs<T extends ProductionDoc$inputsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionDoc$inputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    outputs<T extends ProductionDoc$outputsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionDoc$outputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cuttingLines<T extends ProductionDoc$cuttingLinesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionDoc$cuttingLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionDoc model
   */
  interface ProductionDocFieldRefs {
    readonly id: FieldRef<"ProductionDoc", 'Int'>
    readonly date: FieldRef<"ProductionDoc", 'DateTime'>
    readonly warehouseId: FieldRef<"ProductionDoc", 'Int'>
    readonly status: FieldRef<"ProductionDoc", 'String'>
    readonly createdByUserId: FieldRef<"ProductionDoc", 'Int'>
    readonly createdAt: FieldRef<"ProductionDoc", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionDoc", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionDoc findUnique
   */
  export type ProductionDocFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
    /**
     * Filter, which ProductionDoc to fetch.
     */
    where: ProductionDocWhereUniqueInput
  }

  /**
   * ProductionDoc findUniqueOrThrow
   */
  export type ProductionDocFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
    /**
     * Filter, which ProductionDoc to fetch.
     */
    where: ProductionDocWhereUniqueInput
  }

  /**
   * ProductionDoc findFirst
   */
  export type ProductionDocFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
    /**
     * Filter, which ProductionDoc to fetch.
     */
    where?: ProductionDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionDocs to fetch.
     */
    orderBy?: ProductionDocOrderByWithRelationInput | ProductionDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionDocs.
     */
    cursor?: ProductionDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionDocs.
     */
    distinct?: ProductionDocScalarFieldEnum | ProductionDocScalarFieldEnum[]
  }

  /**
   * ProductionDoc findFirstOrThrow
   */
  export type ProductionDocFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
    /**
     * Filter, which ProductionDoc to fetch.
     */
    where?: ProductionDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionDocs to fetch.
     */
    orderBy?: ProductionDocOrderByWithRelationInput | ProductionDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionDocs.
     */
    cursor?: ProductionDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionDocs.
     */
    distinct?: ProductionDocScalarFieldEnum | ProductionDocScalarFieldEnum[]
  }

  /**
   * ProductionDoc findMany
   */
  export type ProductionDocFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
    /**
     * Filter, which ProductionDocs to fetch.
     */
    where?: ProductionDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionDocs to fetch.
     */
    orderBy?: ProductionDocOrderByWithRelationInput | ProductionDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionDocs.
     */
    cursor?: ProductionDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionDocs.
     */
    skip?: number
    distinct?: ProductionDocScalarFieldEnum | ProductionDocScalarFieldEnum[]
  }

  /**
   * ProductionDoc create
   */
  export type ProductionDocCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionDoc.
     */
    data: XOR<ProductionDocCreateInput, ProductionDocUncheckedCreateInput>
  }

  /**
   * ProductionDoc createMany
   */
  export type ProductionDocCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionDocs.
     */
    data: ProductionDocCreateManyInput | ProductionDocCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionDoc createManyAndReturn
   */
  export type ProductionDocCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionDocs.
     */
    data: ProductionDocCreateManyInput | ProductionDocCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionDoc update
   */
  export type ProductionDocUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionDoc.
     */
    data: XOR<ProductionDocUpdateInput, ProductionDocUncheckedUpdateInput>
    /**
     * Choose, which ProductionDoc to update.
     */
    where: ProductionDocWhereUniqueInput
  }

  /**
   * ProductionDoc updateMany
   */
  export type ProductionDocUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionDocs.
     */
    data: XOR<ProductionDocUpdateManyMutationInput, ProductionDocUncheckedUpdateManyInput>
    /**
     * Filter which ProductionDocs to update
     */
    where?: ProductionDocWhereInput
    /**
     * Limit how many ProductionDocs to update.
     */
    limit?: number
  }

  /**
   * ProductionDoc updateManyAndReturn
   */
  export type ProductionDocUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * The data used to update ProductionDocs.
     */
    data: XOR<ProductionDocUpdateManyMutationInput, ProductionDocUncheckedUpdateManyInput>
    /**
     * Filter which ProductionDocs to update
     */
    where?: ProductionDocWhereInput
    /**
     * Limit how many ProductionDocs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionDoc upsert
   */
  export type ProductionDocUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionDoc to update in case it exists.
     */
    where: ProductionDocWhereUniqueInput
    /**
     * In case the ProductionDoc found by the `where` argument doesn't exist, create a new ProductionDoc with this data.
     */
    create: XOR<ProductionDocCreateInput, ProductionDocUncheckedCreateInput>
    /**
     * In case the ProductionDoc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionDocUpdateInput, ProductionDocUncheckedUpdateInput>
  }

  /**
   * ProductionDoc delete
   */
  export type ProductionDocDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
    /**
     * Filter which ProductionDoc to delete.
     */
    where: ProductionDocWhereUniqueInput
  }

  /**
   * ProductionDoc deleteMany
   */
  export type ProductionDocDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionDocs to delete
     */
    where?: ProductionDocWhereInput
    /**
     * Limit how many ProductionDocs to delete.
     */
    limit?: number
  }

  /**
   * ProductionDoc.inputs
   */
  export type ProductionDoc$inputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    where?: ProductionInputWhereInput
    orderBy?: ProductionInputOrderByWithRelationInput | ProductionInputOrderByWithRelationInput[]
    cursor?: ProductionInputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionInputScalarFieldEnum | ProductionInputScalarFieldEnum[]
  }

  /**
   * ProductionDoc.outputs
   */
  export type ProductionDoc$outputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
    where?: ProductionOutputWhereInput
    orderBy?: ProductionOutputOrderByWithRelationInput | ProductionOutputOrderByWithRelationInput[]
    cursor?: ProductionOutputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionOutputScalarFieldEnum | ProductionOutputScalarFieldEnum[]
  }

  /**
   * ProductionDoc.cuttingLines
   */
  export type ProductionDoc$cuttingLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    where?: ProductionCuttingLineWhereInput
    orderBy?: ProductionCuttingLineOrderByWithRelationInput | ProductionCuttingLineOrderByWithRelationInput[]
    cursor?: ProductionCuttingLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionCuttingLineScalarFieldEnum | ProductionCuttingLineScalarFieldEnum[]
  }

  /**
   * ProductionDoc without action
   */
  export type ProductionDocDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDoc
     */
    select?: ProductionDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionDoc
     */
    omit?: ProductionDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDocInclude<ExtArgs> | null
  }


  /**
   * Model ProductionInput
   */

  export type AggregateProductionInput = {
    _count: ProductionInputCountAggregateOutputType | null
    _avg: ProductionInputAvgAggregateOutputType | null
    _sum: ProductionInputSumAggregateOutputType | null
    _min: ProductionInputMinAggregateOutputType | null
    _max: ProductionInputMaxAggregateOutputType | null
  }

  export type ProductionInputAvgAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    purchaseId: number | null
    purchaseItemId: number | null
    productId: number | null
    warehouseId: number | null
    qtyIn: Decimal | null
    qtyUsed: Decimal | null
    priceIn: Decimal | null
    loadedByUserId: number | null
  }

  export type ProductionInputSumAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    purchaseId: number | null
    purchaseItemId: number | null
    productId: number | null
    warehouseId: number | null
    qtyIn: Decimal | null
    qtyUsed: Decimal | null
    priceIn: Decimal | null
    loadedByUserId: number | null
  }

  export type ProductionInputMinAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    purchaseId: number | null
    purchaseItemId: number | null
    productId: number | null
    warehouseId: number | null
    qtyIn: Decimal | null
    qtyUsed: Decimal | null
    priceIn: Decimal | null
    loadedAt: Date | null
    loadedByUserId: number | null
  }

  export type ProductionInputMaxAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    purchaseId: number | null
    purchaseItemId: number | null
    productId: number | null
    warehouseId: number | null
    qtyIn: Decimal | null
    qtyUsed: Decimal | null
    priceIn: Decimal | null
    loadedAt: Date | null
    loadedByUserId: number | null
  }

  export type ProductionInputCountAggregateOutputType = {
    id: number
    productionDocId: number
    purchaseId: number
    purchaseItemId: number
    productId: number
    warehouseId: number
    qtyIn: number
    qtyUsed: number
    priceIn: number
    loadedAt: number
    loadedByUserId: number
    _all: number
  }


  export type ProductionInputAvgAggregateInputType = {
    id?: true
    productionDocId?: true
    purchaseId?: true
    purchaseItemId?: true
    productId?: true
    warehouseId?: true
    qtyIn?: true
    qtyUsed?: true
    priceIn?: true
    loadedByUserId?: true
  }

  export type ProductionInputSumAggregateInputType = {
    id?: true
    productionDocId?: true
    purchaseId?: true
    purchaseItemId?: true
    productId?: true
    warehouseId?: true
    qtyIn?: true
    qtyUsed?: true
    priceIn?: true
    loadedByUserId?: true
  }

  export type ProductionInputMinAggregateInputType = {
    id?: true
    productionDocId?: true
    purchaseId?: true
    purchaseItemId?: true
    productId?: true
    warehouseId?: true
    qtyIn?: true
    qtyUsed?: true
    priceIn?: true
    loadedAt?: true
    loadedByUserId?: true
  }

  export type ProductionInputMaxAggregateInputType = {
    id?: true
    productionDocId?: true
    purchaseId?: true
    purchaseItemId?: true
    productId?: true
    warehouseId?: true
    qtyIn?: true
    qtyUsed?: true
    priceIn?: true
    loadedAt?: true
    loadedByUserId?: true
  }

  export type ProductionInputCountAggregateInputType = {
    id?: true
    productionDocId?: true
    purchaseId?: true
    purchaseItemId?: true
    productId?: true
    warehouseId?: true
    qtyIn?: true
    qtyUsed?: true
    priceIn?: true
    loadedAt?: true
    loadedByUserId?: true
    _all?: true
  }

  export type ProductionInputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionInput to aggregate.
     */
    where?: ProductionInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionInputs to fetch.
     */
    orderBy?: ProductionInputOrderByWithRelationInput | ProductionInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionInputs
    **/
    _count?: true | ProductionInputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionInputAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionInputSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionInputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionInputMaxAggregateInputType
  }

  export type GetProductionInputAggregateType<T extends ProductionInputAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionInput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionInput[P]>
      : GetScalarType<T[P], AggregateProductionInput[P]>
  }




  export type ProductionInputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionInputWhereInput
    orderBy?: ProductionInputOrderByWithAggregationInput | ProductionInputOrderByWithAggregationInput[]
    by: ProductionInputScalarFieldEnum[] | ProductionInputScalarFieldEnum
    having?: ProductionInputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionInputCountAggregateInputType | true
    _avg?: ProductionInputAvgAggregateInputType
    _sum?: ProductionInputSumAggregateInputType
    _min?: ProductionInputMinAggregateInputType
    _max?: ProductionInputMaxAggregateInputType
  }

  export type ProductionInputGroupByOutputType = {
    id: number
    productionDocId: number
    purchaseId: number
    purchaseItemId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal
    qtyUsed: Decimal
    priceIn: Decimal | null
    loadedAt: Date
    loadedByUserId: number
    _count: ProductionInputCountAggregateOutputType | null
    _avg: ProductionInputAvgAggregateOutputType | null
    _sum: ProductionInputSumAggregateOutputType | null
    _min: ProductionInputMinAggregateOutputType | null
    _max: ProductionInputMaxAggregateOutputType | null
  }

  type GetProductionInputGroupByPayload<T extends ProductionInputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionInputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionInputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionInputGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionInputGroupByOutputType[P]>
        }
      >
    >


  export type ProductionInputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDocId?: boolean
    purchaseId?: boolean
    purchaseItemId?: boolean
    productId?: boolean
    warehouseId?: boolean
    qtyIn?: boolean
    qtyUsed?: boolean
    priceIn?: boolean
    loadedAt?: boolean
    loadedByUserId?: boolean
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    purchaseItem?: boolean | PurchaseItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    loadedBy?: boolean | UserDefaultArgs<ExtArgs>
    cuttingLines?: boolean | ProductionInput$cuttingLinesArgs<ExtArgs>
    _count?: boolean | ProductionInputCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionInput"]>

  export type ProductionInputSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDocId?: boolean
    purchaseId?: boolean
    purchaseItemId?: boolean
    productId?: boolean
    warehouseId?: boolean
    qtyIn?: boolean
    qtyUsed?: boolean
    priceIn?: boolean
    loadedAt?: boolean
    loadedByUserId?: boolean
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    purchaseItem?: boolean | PurchaseItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    loadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionInput"]>

  export type ProductionInputSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDocId?: boolean
    purchaseId?: boolean
    purchaseItemId?: boolean
    productId?: boolean
    warehouseId?: boolean
    qtyIn?: boolean
    qtyUsed?: boolean
    priceIn?: boolean
    loadedAt?: boolean
    loadedByUserId?: boolean
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    purchaseItem?: boolean | PurchaseItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    loadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionInput"]>

  export type ProductionInputSelectScalar = {
    id?: boolean
    productionDocId?: boolean
    purchaseId?: boolean
    purchaseItemId?: boolean
    productId?: boolean
    warehouseId?: boolean
    qtyIn?: boolean
    qtyUsed?: boolean
    priceIn?: boolean
    loadedAt?: boolean
    loadedByUserId?: boolean
  }

  export type ProductionInputOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionDocId" | "purchaseId" | "purchaseItemId" | "productId" | "warehouseId" | "qtyIn" | "qtyUsed" | "priceIn" | "loadedAt" | "loadedByUserId", ExtArgs["result"]["productionInput"]>
  export type ProductionInputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    purchaseItem?: boolean | PurchaseItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    loadedBy?: boolean | UserDefaultArgs<ExtArgs>
    cuttingLines?: boolean | ProductionInput$cuttingLinesArgs<ExtArgs>
    _count?: boolean | ProductionInputCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionInputIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    purchaseItem?: boolean | PurchaseItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    loadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductionInputIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    purchaseItem?: boolean | PurchaseItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    loadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductionInputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionInput"
    objects: {
      productionDoc: Prisma.$ProductionDocPayload<ExtArgs>
      purchase: Prisma.$PurchasePayload<ExtArgs>
      purchaseItem: Prisma.$PurchaseItemPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      loadedBy: Prisma.$UserPayload<ExtArgs>
      cuttingLines: Prisma.$ProductionCuttingLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionDocId: number
      purchaseId: number
      purchaseItemId: number
      productId: number
      warehouseId: number
      qtyIn: Prisma.Decimal
      qtyUsed: Prisma.Decimal
      priceIn: Prisma.Decimal | null
      loadedAt: Date
      loadedByUserId: number
    }, ExtArgs["result"]["productionInput"]>
    composites: {}
  }

  type ProductionInputGetPayload<S extends boolean | null | undefined | ProductionInputDefaultArgs> = $Result.GetResult<Prisma.$ProductionInputPayload, S>

  type ProductionInputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionInputFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionInputCountAggregateInputType | true
    }

  export interface ProductionInputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionInput'], meta: { name: 'ProductionInput' } }
    /**
     * Find zero or one ProductionInput that matches the filter.
     * @param {ProductionInputFindUniqueArgs} args - Arguments to find a ProductionInput
     * @example
     * // Get one ProductionInput
     * const productionInput = await prisma.productionInput.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionInputFindUniqueArgs>(args: SelectSubset<T, ProductionInputFindUniqueArgs<ExtArgs>>): Prisma__ProductionInputClient<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionInput that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionInputFindUniqueOrThrowArgs} args - Arguments to find a ProductionInput
     * @example
     * // Get one ProductionInput
     * const productionInput = await prisma.productionInput.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionInputFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionInputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionInputClient<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionInput that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionInputFindFirstArgs} args - Arguments to find a ProductionInput
     * @example
     * // Get one ProductionInput
     * const productionInput = await prisma.productionInput.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionInputFindFirstArgs>(args?: SelectSubset<T, ProductionInputFindFirstArgs<ExtArgs>>): Prisma__ProductionInputClient<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionInput that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionInputFindFirstOrThrowArgs} args - Arguments to find a ProductionInput
     * @example
     * // Get one ProductionInput
     * const productionInput = await prisma.productionInput.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionInputFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionInputFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionInputClient<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionInputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionInputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionInputs
     * const productionInputs = await prisma.productionInput.findMany()
     * 
     * // Get first 10 ProductionInputs
     * const productionInputs = await prisma.productionInput.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionInputWithIdOnly = await prisma.productionInput.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionInputFindManyArgs>(args?: SelectSubset<T, ProductionInputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionInput.
     * @param {ProductionInputCreateArgs} args - Arguments to create a ProductionInput.
     * @example
     * // Create one ProductionInput
     * const ProductionInput = await prisma.productionInput.create({
     *   data: {
     *     // ... data to create a ProductionInput
     *   }
     * })
     * 
     */
    create<T extends ProductionInputCreateArgs>(args: SelectSubset<T, ProductionInputCreateArgs<ExtArgs>>): Prisma__ProductionInputClient<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionInputs.
     * @param {ProductionInputCreateManyArgs} args - Arguments to create many ProductionInputs.
     * @example
     * // Create many ProductionInputs
     * const productionInput = await prisma.productionInput.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionInputCreateManyArgs>(args?: SelectSubset<T, ProductionInputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionInputs and returns the data saved in the database.
     * @param {ProductionInputCreateManyAndReturnArgs} args - Arguments to create many ProductionInputs.
     * @example
     * // Create many ProductionInputs
     * const productionInput = await prisma.productionInput.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionInputs and only return the `id`
     * const productionInputWithIdOnly = await prisma.productionInput.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionInputCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionInputCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionInput.
     * @param {ProductionInputDeleteArgs} args - Arguments to delete one ProductionInput.
     * @example
     * // Delete one ProductionInput
     * const ProductionInput = await prisma.productionInput.delete({
     *   where: {
     *     // ... filter to delete one ProductionInput
     *   }
     * })
     * 
     */
    delete<T extends ProductionInputDeleteArgs>(args: SelectSubset<T, ProductionInputDeleteArgs<ExtArgs>>): Prisma__ProductionInputClient<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionInput.
     * @param {ProductionInputUpdateArgs} args - Arguments to update one ProductionInput.
     * @example
     * // Update one ProductionInput
     * const productionInput = await prisma.productionInput.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionInputUpdateArgs>(args: SelectSubset<T, ProductionInputUpdateArgs<ExtArgs>>): Prisma__ProductionInputClient<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionInputs.
     * @param {ProductionInputDeleteManyArgs} args - Arguments to filter ProductionInputs to delete.
     * @example
     * // Delete a few ProductionInputs
     * const { count } = await prisma.productionInput.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionInputDeleteManyArgs>(args?: SelectSubset<T, ProductionInputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionInputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionInputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionInputs
     * const productionInput = await prisma.productionInput.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionInputUpdateManyArgs>(args: SelectSubset<T, ProductionInputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionInputs and returns the data updated in the database.
     * @param {ProductionInputUpdateManyAndReturnArgs} args - Arguments to update many ProductionInputs.
     * @example
     * // Update many ProductionInputs
     * const productionInput = await prisma.productionInput.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionInputs and only return the `id`
     * const productionInputWithIdOnly = await prisma.productionInput.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionInputUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionInputUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionInput.
     * @param {ProductionInputUpsertArgs} args - Arguments to update or create a ProductionInput.
     * @example
     * // Update or create a ProductionInput
     * const productionInput = await prisma.productionInput.upsert({
     *   create: {
     *     // ... data to create a ProductionInput
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionInput we want to update
     *   }
     * })
     */
    upsert<T extends ProductionInputUpsertArgs>(args: SelectSubset<T, ProductionInputUpsertArgs<ExtArgs>>): Prisma__ProductionInputClient<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionInputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionInputCountArgs} args - Arguments to filter ProductionInputs to count.
     * @example
     * // Count the number of ProductionInputs
     * const count = await prisma.productionInput.count({
     *   where: {
     *     // ... the filter for the ProductionInputs we want to count
     *   }
     * })
    **/
    count<T extends ProductionInputCountArgs>(
      args?: Subset<T, ProductionInputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionInputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionInput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionInputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionInputAggregateArgs>(args: Subset<T, ProductionInputAggregateArgs>): Prisma.PrismaPromise<GetProductionInputAggregateType<T>>

    /**
     * Group by ProductionInput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionInputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionInputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionInputGroupByArgs['orderBy'] }
        : { orderBy?: ProductionInputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionInputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionInputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionInput model
   */
  readonly fields: ProductionInputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionInput.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionInputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionDoc<T extends ProductionDocDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionDocDefaultArgs<ExtArgs>>): Prisma__ProductionDocClient<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchase<T extends PurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDefaultArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseItem<T extends PurchaseItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseItemDefaultArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    loadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cuttingLines<T extends ProductionInput$cuttingLinesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionInput$cuttingLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionInput model
   */
  interface ProductionInputFieldRefs {
    readonly id: FieldRef<"ProductionInput", 'Int'>
    readonly productionDocId: FieldRef<"ProductionInput", 'Int'>
    readonly purchaseId: FieldRef<"ProductionInput", 'Int'>
    readonly purchaseItemId: FieldRef<"ProductionInput", 'Int'>
    readonly productId: FieldRef<"ProductionInput", 'Int'>
    readonly warehouseId: FieldRef<"ProductionInput", 'Int'>
    readonly qtyIn: FieldRef<"ProductionInput", 'Decimal'>
    readonly qtyUsed: FieldRef<"ProductionInput", 'Decimal'>
    readonly priceIn: FieldRef<"ProductionInput", 'Decimal'>
    readonly loadedAt: FieldRef<"ProductionInput", 'DateTime'>
    readonly loadedByUserId: FieldRef<"ProductionInput", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductionInput findUnique
   */
  export type ProductionInputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    /**
     * Filter, which ProductionInput to fetch.
     */
    where: ProductionInputWhereUniqueInput
  }

  /**
   * ProductionInput findUniqueOrThrow
   */
  export type ProductionInputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    /**
     * Filter, which ProductionInput to fetch.
     */
    where: ProductionInputWhereUniqueInput
  }

  /**
   * ProductionInput findFirst
   */
  export type ProductionInputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    /**
     * Filter, which ProductionInput to fetch.
     */
    where?: ProductionInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionInputs to fetch.
     */
    orderBy?: ProductionInputOrderByWithRelationInput | ProductionInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionInputs.
     */
    cursor?: ProductionInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionInputs.
     */
    distinct?: ProductionInputScalarFieldEnum | ProductionInputScalarFieldEnum[]
  }

  /**
   * ProductionInput findFirstOrThrow
   */
  export type ProductionInputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    /**
     * Filter, which ProductionInput to fetch.
     */
    where?: ProductionInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionInputs to fetch.
     */
    orderBy?: ProductionInputOrderByWithRelationInput | ProductionInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionInputs.
     */
    cursor?: ProductionInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionInputs.
     */
    distinct?: ProductionInputScalarFieldEnum | ProductionInputScalarFieldEnum[]
  }

  /**
   * ProductionInput findMany
   */
  export type ProductionInputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    /**
     * Filter, which ProductionInputs to fetch.
     */
    where?: ProductionInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionInputs to fetch.
     */
    orderBy?: ProductionInputOrderByWithRelationInput | ProductionInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionInputs.
     */
    cursor?: ProductionInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionInputs.
     */
    skip?: number
    distinct?: ProductionInputScalarFieldEnum | ProductionInputScalarFieldEnum[]
  }

  /**
   * ProductionInput create
   */
  export type ProductionInputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionInput.
     */
    data: XOR<ProductionInputCreateInput, ProductionInputUncheckedCreateInput>
  }

  /**
   * ProductionInput createMany
   */
  export type ProductionInputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionInputs.
     */
    data: ProductionInputCreateManyInput | ProductionInputCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionInput createManyAndReturn
   */
  export type ProductionInputCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionInputs.
     */
    data: ProductionInputCreateManyInput | ProductionInputCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionInput update
   */
  export type ProductionInputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionInput.
     */
    data: XOR<ProductionInputUpdateInput, ProductionInputUncheckedUpdateInput>
    /**
     * Choose, which ProductionInput to update.
     */
    where: ProductionInputWhereUniqueInput
  }

  /**
   * ProductionInput updateMany
   */
  export type ProductionInputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionInputs.
     */
    data: XOR<ProductionInputUpdateManyMutationInput, ProductionInputUncheckedUpdateManyInput>
    /**
     * Filter which ProductionInputs to update
     */
    where?: ProductionInputWhereInput
    /**
     * Limit how many ProductionInputs to update.
     */
    limit?: number
  }

  /**
   * ProductionInput updateManyAndReturn
   */
  export type ProductionInputUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * The data used to update ProductionInputs.
     */
    data: XOR<ProductionInputUpdateManyMutationInput, ProductionInputUncheckedUpdateManyInput>
    /**
     * Filter which ProductionInputs to update
     */
    where?: ProductionInputWhereInput
    /**
     * Limit how many ProductionInputs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionInput upsert
   */
  export type ProductionInputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionInput to update in case it exists.
     */
    where: ProductionInputWhereUniqueInput
    /**
     * In case the ProductionInput found by the `where` argument doesn't exist, create a new ProductionInput with this data.
     */
    create: XOR<ProductionInputCreateInput, ProductionInputUncheckedCreateInput>
    /**
     * In case the ProductionInput was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionInputUpdateInput, ProductionInputUncheckedUpdateInput>
  }

  /**
   * ProductionInput delete
   */
  export type ProductionInputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
    /**
     * Filter which ProductionInput to delete.
     */
    where: ProductionInputWhereUniqueInput
  }

  /**
   * ProductionInput deleteMany
   */
  export type ProductionInputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionInputs to delete
     */
    where?: ProductionInputWhereInput
    /**
     * Limit how many ProductionInputs to delete.
     */
    limit?: number
  }

  /**
   * ProductionInput.cuttingLines
   */
  export type ProductionInput$cuttingLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    where?: ProductionCuttingLineWhereInput
    orderBy?: ProductionCuttingLineOrderByWithRelationInput | ProductionCuttingLineOrderByWithRelationInput[]
    cursor?: ProductionCuttingLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionCuttingLineScalarFieldEnum | ProductionCuttingLineScalarFieldEnum[]
  }

  /**
   * ProductionInput without action
   */
  export type ProductionInputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionInput
     */
    select?: ProductionInputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionInput
     */
    omit?: ProductionInputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInputInclude<ExtArgs> | null
  }


  /**
   * Model ProductionOutput
   */

  export type AggregateProductionOutput = {
    _count: ProductionOutputCountAggregateOutputType | null
    _avg: ProductionOutputAvgAggregateOutputType | null
    _sum: ProductionOutputSumAggregateOutputType | null
    _min: ProductionOutputMinAggregateOutputType | null
    _max: ProductionOutputMaxAggregateOutputType | null
  }

  export type ProductionOutputAvgAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    productId: number | null
    qtyOut: Decimal | null
    costTotal: Decimal | null
    costPerUnit: Decimal | null
  }

  export type ProductionOutputSumAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    productId: number | null
    qtyOut: Decimal | null
    costTotal: Decimal | null
    costPerUnit: Decimal | null
  }

  export type ProductionOutputMinAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    productId: number | null
    qtyOut: Decimal | null
    uom: string | null
    costTotal: Decimal | null
    costPerUnit: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionOutputMaxAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    productId: number | null
    qtyOut: Decimal | null
    uom: string | null
    costTotal: Decimal | null
    costPerUnit: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionOutputCountAggregateOutputType = {
    id: number
    productionDocId: number
    productId: number
    qtyOut: number
    uom: number
    costTotal: number
    costPerUnit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionOutputAvgAggregateInputType = {
    id?: true
    productionDocId?: true
    productId?: true
    qtyOut?: true
    costTotal?: true
    costPerUnit?: true
  }

  export type ProductionOutputSumAggregateInputType = {
    id?: true
    productionDocId?: true
    productId?: true
    qtyOut?: true
    costTotal?: true
    costPerUnit?: true
  }

  export type ProductionOutputMinAggregateInputType = {
    id?: true
    productionDocId?: true
    productId?: true
    qtyOut?: true
    uom?: true
    costTotal?: true
    costPerUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionOutputMaxAggregateInputType = {
    id?: true
    productionDocId?: true
    productId?: true
    qtyOut?: true
    uom?: true
    costTotal?: true
    costPerUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionOutputCountAggregateInputType = {
    id?: true
    productionDocId?: true
    productId?: true
    qtyOut?: true
    uom?: true
    costTotal?: true
    costPerUnit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionOutputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionOutput to aggregate.
     */
    where?: ProductionOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOutputs to fetch.
     */
    orderBy?: ProductionOutputOrderByWithRelationInput | ProductionOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionOutputs
    **/
    _count?: true | ProductionOutputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionOutputAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionOutputSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionOutputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionOutputMaxAggregateInputType
  }

  export type GetProductionOutputAggregateType<T extends ProductionOutputAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionOutput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionOutput[P]>
      : GetScalarType<T[P], AggregateProductionOutput[P]>
  }




  export type ProductionOutputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionOutputWhereInput
    orderBy?: ProductionOutputOrderByWithAggregationInput | ProductionOutputOrderByWithAggregationInput[]
    by: ProductionOutputScalarFieldEnum[] | ProductionOutputScalarFieldEnum
    having?: ProductionOutputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionOutputCountAggregateInputType | true
    _avg?: ProductionOutputAvgAggregateInputType
    _sum?: ProductionOutputSumAggregateInputType
    _min?: ProductionOutputMinAggregateInputType
    _max?: ProductionOutputMaxAggregateInputType
  }

  export type ProductionOutputGroupByOutputType = {
    id: number
    productionDocId: number
    productId: number
    qtyOut: Decimal
    uom: string
    costTotal: Decimal | null
    costPerUnit: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: ProductionOutputCountAggregateOutputType | null
    _avg: ProductionOutputAvgAggregateOutputType | null
    _sum: ProductionOutputSumAggregateOutputType | null
    _min: ProductionOutputMinAggregateOutputType | null
    _max: ProductionOutputMaxAggregateOutputType | null
  }

  type GetProductionOutputGroupByPayload<T extends ProductionOutputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionOutputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionOutputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionOutputGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionOutputGroupByOutputType[P]>
        }
      >
    >


  export type ProductionOutputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDocId?: boolean
    productId?: boolean
    qtyOut?: boolean
    uom?: boolean
    costTotal?: boolean
    costPerUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionOutput"]>

  export type ProductionOutputSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDocId?: boolean
    productId?: boolean
    qtyOut?: boolean
    uom?: boolean
    costTotal?: boolean
    costPerUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionOutput"]>

  export type ProductionOutputSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDocId?: boolean
    productId?: boolean
    qtyOut?: boolean
    uom?: boolean
    costTotal?: boolean
    costPerUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionOutput"]>

  export type ProductionOutputSelectScalar = {
    id?: boolean
    productionDocId?: boolean
    productId?: boolean
    qtyOut?: boolean
    uom?: boolean
    costTotal?: boolean
    costPerUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionOutputOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionDocId" | "productId" | "qtyOut" | "uom" | "costTotal" | "costPerUnit" | "createdAt" | "updatedAt", ExtArgs["result"]["productionOutput"]>
  export type ProductionOutputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductionOutputIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductionOutputIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductionOutputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionOutput"
    objects: {
      productionDoc: Prisma.$ProductionDocPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionDocId: number
      productId: number
      qtyOut: Prisma.Decimal
      uom: string
      costTotal: Prisma.Decimal | null
      costPerUnit: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionOutput"]>
    composites: {}
  }

  type ProductionOutputGetPayload<S extends boolean | null | undefined | ProductionOutputDefaultArgs> = $Result.GetResult<Prisma.$ProductionOutputPayload, S>

  type ProductionOutputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionOutputFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionOutputCountAggregateInputType | true
    }

  export interface ProductionOutputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionOutput'], meta: { name: 'ProductionOutput' } }
    /**
     * Find zero or one ProductionOutput that matches the filter.
     * @param {ProductionOutputFindUniqueArgs} args - Arguments to find a ProductionOutput
     * @example
     * // Get one ProductionOutput
     * const productionOutput = await prisma.productionOutput.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionOutputFindUniqueArgs>(args: SelectSubset<T, ProductionOutputFindUniqueArgs<ExtArgs>>): Prisma__ProductionOutputClient<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionOutput that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionOutputFindUniqueOrThrowArgs} args - Arguments to find a ProductionOutput
     * @example
     * // Get one ProductionOutput
     * const productionOutput = await prisma.productionOutput.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionOutputFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionOutputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionOutputClient<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionOutput that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOutputFindFirstArgs} args - Arguments to find a ProductionOutput
     * @example
     * // Get one ProductionOutput
     * const productionOutput = await prisma.productionOutput.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionOutputFindFirstArgs>(args?: SelectSubset<T, ProductionOutputFindFirstArgs<ExtArgs>>): Prisma__ProductionOutputClient<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionOutput that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOutputFindFirstOrThrowArgs} args - Arguments to find a ProductionOutput
     * @example
     * // Get one ProductionOutput
     * const productionOutput = await prisma.productionOutput.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionOutputFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionOutputFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionOutputClient<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionOutputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOutputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionOutputs
     * const productionOutputs = await prisma.productionOutput.findMany()
     * 
     * // Get first 10 ProductionOutputs
     * const productionOutputs = await prisma.productionOutput.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionOutputWithIdOnly = await prisma.productionOutput.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionOutputFindManyArgs>(args?: SelectSubset<T, ProductionOutputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionOutput.
     * @param {ProductionOutputCreateArgs} args - Arguments to create a ProductionOutput.
     * @example
     * // Create one ProductionOutput
     * const ProductionOutput = await prisma.productionOutput.create({
     *   data: {
     *     // ... data to create a ProductionOutput
     *   }
     * })
     * 
     */
    create<T extends ProductionOutputCreateArgs>(args: SelectSubset<T, ProductionOutputCreateArgs<ExtArgs>>): Prisma__ProductionOutputClient<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionOutputs.
     * @param {ProductionOutputCreateManyArgs} args - Arguments to create many ProductionOutputs.
     * @example
     * // Create many ProductionOutputs
     * const productionOutput = await prisma.productionOutput.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionOutputCreateManyArgs>(args?: SelectSubset<T, ProductionOutputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionOutputs and returns the data saved in the database.
     * @param {ProductionOutputCreateManyAndReturnArgs} args - Arguments to create many ProductionOutputs.
     * @example
     * // Create many ProductionOutputs
     * const productionOutput = await prisma.productionOutput.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionOutputs and only return the `id`
     * const productionOutputWithIdOnly = await prisma.productionOutput.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionOutputCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionOutputCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionOutput.
     * @param {ProductionOutputDeleteArgs} args - Arguments to delete one ProductionOutput.
     * @example
     * // Delete one ProductionOutput
     * const ProductionOutput = await prisma.productionOutput.delete({
     *   where: {
     *     // ... filter to delete one ProductionOutput
     *   }
     * })
     * 
     */
    delete<T extends ProductionOutputDeleteArgs>(args: SelectSubset<T, ProductionOutputDeleteArgs<ExtArgs>>): Prisma__ProductionOutputClient<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionOutput.
     * @param {ProductionOutputUpdateArgs} args - Arguments to update one ProductionOutput.
     * @example
     * // Update one ProductionOutput
     * const productionOutput = await prisma.productionOutput.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionOutputUpdateArgs>(args: SelectSubset<T, ProductionOutputUpdateArgs<ExtArgs>>): Prisma__ProductionOutputClient<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionOutputs.
     * @param {ProductionOutputDeleteManyArgs} args - Arguments to filter ProductionOutputs to delete.
     * @example
     * // Delete a few ProductionOutputs
     * const { count } = await prisma.productionOutput.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionOutputDeleteManyArgs>(args?: SelectSubset<T, ProductionOutputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOutputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionOutputs
     * const productionOutput = await prisma.productionOutput.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionOutputUpdateManyArgs>(args: SelectSubset<T, ProductionOutputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionOutputs and returns the data updated in the database.
     * @param {ProductionOutputUpdateManyAndReturnArgs} args - Arguments to update many ProductionOutputs.
     * @example
     * // Update many ProductionOutputs
     * const productionOutput = await prisma.productionOutput.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionOutputs and only return the `id`
     * const productionOutputWithIdOnly = await prisma.productionOutput.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionOutputUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionOutputUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionOutput.
     * @param {ProductionOutputUpsertArgs} args - Arguments to update or create a ProductionOutput.
     * @example
     * // Update or create a ProductionOutput
     * const productionOutput = await prisma.productionOutput.upsert({
     *   create: {
     *     // ... data to create a ProductionOutput
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionOutput we want to update
     *   }
     * })
     */
    upsert<T extends ProductionOutputUpsertArgs>(args: SelectSubset<T, ProductionOutputUpsertArgs<ExtArgs>>): Prisma__ProductionOutputClient<$Result.GetResult<Prisma.$ProductionOutputPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOutputCountArgs} args - Arguments to filter ProductionOutputs to count.
     * @example
     * // Count the number of ProductionOutputs
     * const count = await prisma.productionOutput.count({
     *   where: {
     *     // ... the filter for the ProductionOutputs we want to count
     *   }
     * })
    **/
    count<T extends ProductionOutputCountArgs>(
      args?: Subset<T, ProductionOutputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionOutputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOutputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionOutputAggregateArgs>(args: Subset<T, ProductionOutputAggregateArgs>): Prisma.PrismaPromise<GetProductionOutputAggregateType<T>>

    /**
     * Group by ProductionOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOutputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionOutputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionOutputGroupByArgs['orderBy'] }
        : { orderBy?: ProductionOutputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionOutputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionOutputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionOutput model
   */
  readonly fields: ProductionOutputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionOutput.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionOutputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionDoc<T extends ProductionDocDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionDocDefaultArgs<ExtArgs>>): Prisma__ProductionDocClient<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionOutput model
   */
  interface ProductionOutputFieldRefs {
    readonly id: FieldRef<"ProductionOutput", 'Int'>
    readonly productionDocId: FieldRef<"ProductionOutput", 'Int'>
    readonly productId: FieldRef<"ProductionOutput", 'Int'>
    readonly qtyOut: FieldRef<"ProductionOutput", 'Decimal'>
    readonly uom: FieldRef<"ProductionOutput", 'String'>
    readonly costTotal: FieldRef<"ProductionOutput", 'Decimal'>
    readonly costPerUnit: FieldRef<"ProductionOutput", 'Decimal'>
    readonly createdAt: FieldRef<"ProductionOutput", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionOutput", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionOutput findUnique
   */
  export type ProductionOutputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOutput to fetch.
     */
    where: ProductionOutputWhereUniqueInput
  }

  /**
   * ProductionOutput findUniqueOrThrow
   */
  export type ProductionOutputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOutput to fetch.
     */
    where: ProductionOutputWhereUniqueInput
  }

  /**
   * ProductionOutput findFirst
   */
  export type ProductionOutputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOutput to fetch.
     */
    where?: ProductionOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOutputs to fetch.
     */
    orderBy?: ProductionOutputOrderByWithRelationInput | ProductionOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionOutputs.
     */
    cursor?: ProductionOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionOutputs.
     */
    distinct?: ProductionOutputScalarFieldEnum | ProductionOutputScalarFieldEnum[]
  }

  /**
   * ProductionOutput findFirstOrThrow
   */
  export type ProductionOutputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOutput to fetch.
     */
    where?: ProductionOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOutputs to fetch.
     */
    orderBy?: ProductionOutputOrderByWithRelationInput | ProductionOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionOutputs.
     */
    cursor?: ProductionOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionOutputs.
     */
    distinct?: ProductionOutputScalarFieldEnum | ProductionOutputScalarFieldEnum[]
  }

  /**
   * ProductionOutput findMany
   */
  export type ProductionOutputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOutputs to fetch.
     */
    where?: ProductionOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOutputs to fetch.
     */
    orderBy?: ProductionOutputOrderByWithRelationInput | ProductionOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionOutputs.
     */
    cursor?: ProductionOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOutputs.
     */
    skip?: number
    distinct?: ProductionOutputScalarFieldEnum | ProductionOutputScalarFieldEnum[]
  }

  /**
   * ProductionOutput create
   */
  export type ProductionOutputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionOutput.
     */
    data: XOR<ProductionOutputCreateInput, ProductionOutputUncheckedCreateInput>
  }

  /**
   * ProductionOutput createMany
   */
  export type ProductionOutputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionOutputs.
     */
    data: ProductionOutputCreateManyInput | ProductionOutputCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionOutput createManyAndReturn
   */
  export type ProductionOutputCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionOutputs.
     */
    data: ProductionOutputCreateManyInput | ProductionOutputCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionOutput update
   */
  export type ProductionOutputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionOutput.
     */
    data: XOR<ProductionOutputUpdateInput, ProductionOutputUncheckedUpdateInput>
    /**
     * Choose, which ProductionOutput to update.
     */
    where: ProductionOutputWhereUniqueInput
  }

  /**
   * ProductionOutput updateMany
   */
  export type ProductionOutputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionOutputs.
     */
    data: XOR<ProductionOutputUpdateManyMutationInput, ProductionOutputUncheckedUpdateManyInput>
    /**
     * Filter which ProductionOutputs to update
     */
    where?: ProductionOutputWhereInput
    /**
     * Limit how many ProductionOutputs to update.
     */
    limit?: number
  }

  /**
   * ProductionOutput updateManyAndReturn
   */
  export type ProductionOutputUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * The data used to update ProductionOutputs.
     */
    data: XOR<ProductionOutputUpdateManyMutationInput, ProductionOutputUncheckedUpdateManyInput>
    /**
     * Filter which ProductionOutputs to update
     */
    where?: ProductionOutputWhereInput
    /**
     * Limit how many ProductionOutputs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionOutput upsert
   */
  export type ProductionOutputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionOutput to update in case it exists.
     */
    where: ProductionOutputWhereUniqueInput
    /**
     * In case the ProductionOutput found by the `where` argument doesn't exist, create a new ProductionOutput with this data.
     */
    create: XOR<ProductionOutputCreateInput, ProductionOutputUncheckedCreateInput>
    /**
     * In case the ProductionOutput was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionOutputUpdateInput, ProductionOutputUncheckedUpdateInput>
  }

  /**
   * ProductionOutput delete
   */
  export type ProductionOutputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
    /**
     * Filter which ProductionOutput to delete.
     */
    where: ProductionOutputWhereUniqueInput
  }

  /**
   * ProductionOutput deleteMany
   */
  export type ProductionOutputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionOutputs to delete
     */
    where?: ProductionOutputWhereInput
    /**
     * Limit how many ProductionOutputs to delete.
     */
    limit?: number
  }

  /**
   * ProductionOutput without action
   */
  export type ProductionOutputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOutput
     */
    select?: ProductionOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOutput
     */
    omit?: ProductionOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOutputInclude<ExtArgs> | null
  }


  /**
   * Model ProductionCuttingLine
   */

  export type AggregateProductionCuttingLine = {
    _count: ProductionCuttingLineCountAggregateOutputType | null
    _avg: ProductionCuttingLineAvgAggregateOutputType | null
    _sum: ProductionCuttingLineSumAggregateOutputType | null
    _min: ProductionCuttingLineMinAggregateOutputType | null
    _max: ProductionCuttingLineMaxAggregateOutputType | null
  }

  export type ProductionCuttingLineAvgAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    productionInputId: number | null
    mmlId: number | null
    outProductId: number | null
    qtyOut: Decimal | null
    qtyInConsumed: Decimal | null
    createdByUserId: number | null
  }

  export type ProductionCuttingLineSumAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    productionInputId: number | null
    mmlId: number | null
    outProductId: number | null
    qtyOut: Decimal | null
    qtyInConsumed: Decimal | null
    createdByUserId: number | null
  }

  export type ProductionCuttingLineMinAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    productionInputId: number | null
    mmlId: number | null
    outProductId: number | null
    qtyOut: Decimal | null
    qtyInConsumed: Decimal | null
    createdAt: Date | null
    createdByUserId: number | null
  }

  export type ProductionCuttingLineMaxAggregateOutputType = {
    id: number | null
    productionDocId: number | null
    productionInputId: number | null
    mmlId: number | null
    outProductId: number | null
    qtyOut: Decimal | null
    qtyInConsumed: Decimal | null
    createdAt: Date | null
    createdByUserId: number | null
  }

  export type ProductionCuttingLineCountAggregateOutputType = {
    id: number
    productionDocId: number
    productionInputId: number
    mmlId: number
    outProductId: number
    qtyOut: number
    qtyInConsumed: number
    createdAt: number
    createdByUserId: number
    _all: number
  }


  export type ProductionCuttingLineAvgAggregateInputType = {
    id?: true
    productionDocId?: true
    productionInputId?: true
    mmlId?: true
    outProductId?: true
    qtyOut?: true
    qtyInConsumed?: true
    createdByUserId?: true
  }

  export type ProductionCuttingLineSumAggregateInputType = {
    id?: true
    productionDocId?: true
    productionInputId?: true
    mmlId?: true
    outProductId?: true
    qtyOut?: true
    qtyInConsumed?: true
    createdByUserId?: true
  }

  export type ProductionCuttingLineMinAggregateInputType = {
    id?: true
    productionDocId?: true
    productionInputId?: true
    mmlId?: true
    outProductId?: true
    qtyOut?: true
    qtyInConsumed?: true
    createdAt?: true
    createdByUserId?: true
  }

  export type ProductionCuttingLineMaxAggregateInputType = {
    id?: true
    productionDocId?: true
    productionInputId?: true
    mmlId?: true
    outProductId?: true
    qtyOut?: true
    qtyInConsumed?: true
    createdAt?: true
    createdByUserId?: true
  }

  export type ProductionCuttingLineCountAggregateInputType = {
    id?: true
    productionDocId?: true
    productionInputId?: true
    mmlId?: true
    outProductId?: true
    qtyOut?: true
    qtyInConsumed?: true
    createdAt?: true
    createdByUserId?: true
    _all?: true
  }

  export type ProductionCuttingLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionCuttingLine to aggregate.
     */
    where?: ProductionCuttingLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionCuttingLines to fetch.
     */
    orderBy?: ProductionCuttingLineOrderByWithRelationInput | ProductionCuttingLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionCuttingLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionCuttingLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionCuttingLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionCuttingLines
    **/
    _count?: true | ProductionCuttingLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionCuttingLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionCuttingLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionCuttingLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionCuttingLineMaxAggregateInputType
  }

  export type GetProductionCuttingLineAggregateType<T extends ProductionCuttingLineAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionCuttingLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionCuttingLine[P]>
      : GetScalarType<T[P], AggregateProductionCuttingLine[P]>
  }




  export type ProductionCuttingLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionCuttingLineWhereInput
    orderBy?: ProductionCuttingLineOrderByWithAggregationInput | ProductionCuttingLineOrderByWithAggregationInput[]
    by: ProductionCuttingLineScalarFieldEnum[] | ProductionCuttingLineScalarFieldEnum
    having?: ProductionCuttingLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionCuttingLineCountAggregateInputType | true
    _avg?: ProductionCuttingLineAvgAggregateInputType
    _sum?: ProductionCuttingLineSumAggregateInputType
    _min?: ProductionCuttingLineMinAggregateInputType
    _max?: ProductionCuttingLineMaxAggregateInputType
  }

  export type ProductionCuttingLineGroupByOutputType = {
    id: number
    productionDocId: number
    productionInputId: number
    mmlId: number
    outProductId: number
    qtyOut: Decimal
    qtyInConsumed: Decimal
    createdAt: Date
    createdByUserId: number
    _count: ProductionCuttingLineCountAggregateOutputType | null
    _avg: ProductionCuttingLineAvgAggregateOutputType | null
    _sum: ProductionCuttingLineSumAggregateOutputType | null
    _min: ProductionCuttingLineMinAggregateOutputType | null
    _max: ProductionCuttingLineMaxAggregateOutputType | null
  }

  type GetProductionCuttingLineGroupByPayload<T extends ProductionCuttingLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionCuttingLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionCuttingLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionCuttingLineGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionCuttingLineGroupByOutputType[P]>
        }
      >
    >


  export type ProductionCuttingLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDocId?: boolean
    productionInputId?: boolean
    mmlId?: boolean
    outProductId?: boolean
    qtyOut?: boolean
    qtyInConsumed?: boolean
    createdAt?: boolean
    createdByUserId?: boolean
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    productionInput?: boolean | ProductionInputDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    outProduct?: boolean | ProductDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionCuttingLine"]>

  export type ProductionCuttingLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDocId?: boolean
    productionInputId?: boolean
    mmlId?: boolean
    outProductId?: boolean
    qtyOut?: boolean
    qtyInConsumed?: boolean
    createdAt?: boolean
    createdByUserId?: boolean
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    productionInput?: boolean | ProductionInputDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    outProduct?: boolean | ProductDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionCuttingLine"]>

  export type ProductionCuttingLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionDocId?: boolean
    productionInputId?: boolean
    mmlId?: boolean
    outProductId?: boolean
    qtyOut?: boolean
    qtyInConsumed?: boolean
    createdAt?: boolean
    createdByUserId?: boolean
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    productionInput?: boolean | ProductionInputDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    outProduct?: boolean | ProductDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionCuttingLine"]>

  export type ProductionCuttingLineSelectScalar = {
    id?: boolean
    productionDocId?: boolean
    productionInputId?: boolean
    mmlId?: boolean
    outProductId?: boolean
    qtyOut?: boolean
    qtyInConsumed?: boolean
    createdAt?: boolean
    createdByUserId?: boolean
  }

  export type ProductionCuttingLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionDocId" | "productionInputId" | "mmlId" | "outProductId" | "qtyOut" | "qtyInConsumed" | "createdAt" | "createdByUserId", ExtArgs["result"]["productionCuttingLine"]>
  export type ProductionCuttingLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    productionInput?: boolean | ProductionInputDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    outProduct?: boolean | ProductDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductionCuttingLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    productionInput?: boolean | ProductionInputDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    outProduct?: boolean | ProductDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductionCuttingLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionDoc?: boolean | ProductionDocDefaultArgs<ExtArgs>
    productionInput?: boolean | ProductionInputDefaultArgs<ExtArgs>
    mml?: boolean | ProductionMmlDefaultArgs<ExtArgs>
    outProduct?: boolean | ProductDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductionCuttingLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionCuttingLine"
    objects: {
      productionDoc: Prisma.$ProductionDocPayload<ExtArgs>
      productionInput: Prisma.$ProductionInputPayload<ExtArgs>
      mml: Prisma.$ProductionMmlPayload<ExtArgs>
      outProduct: Prisma.$ProductPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionDocId: number
      productionInputId: number
      mmlId: number
      outProductId: number
      qtyOut: Prisma.Decimal
      qtyInConsumed: Prisma.Decimal
      createdAt: Date
      createdByUserId: number
    }, ExtArgs["result"]["productionCuttingLine"]>
    composites: {}
  }

  type ProductionCuttingLineGetPayload<S extends boolean | null | undefined | ProductionCuttingLineDefaultArgs> = $Result.GetResult<Prisma.$ProductionCuttingLinePayload, S>

  type ProductionCuttingLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionCuttingLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionCuttingLineCountAggregateInputType | true
    }

  export interface ProductionCuttingLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionCuttingLine'], meta: { name: 'ProductionCuttingLine' } }
    /**
     * Find zero or one ProductionCuttingLine that matches the filter.
     * @param {ProductionCuttingLineFindUniqueArgs} args - Arguments to find a ProductionCuttingLine
     * @example
     * // Get one ProductionCuttingLine
     * const productionCuttingLine = await prisma.productionCuttingLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionCuttingLineFindUniqueArgs>(args: SelectSubset<T, ProductionCuttingLineFindUniqueArgs<ExtArgs>>): Prisma__ProductionCuttingLineClient<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionCuttingLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionCuttingLineFindUniqueOrThrowArgs} args - Arguments to find a ProductionCuttingLine
     * @example
     * // Get one ProductionCuttingLine
     * const productionCuttingLine = await prisma.productionCuttingLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionCuttingLineFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionCuttingLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionCuttingLineClient<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionCuttingLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionCuttingLineFindFirstArgs} args - Arguments to find a ProductionCuttingLine
     * @example
     * // Get one ProductionCuttingLine
     * const productionCuttingLine = await prisma.productionCuttingLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionCuttingLineFindFirstArgs>(args?: SelectSubset<T, ProductionCuttingLineFindFirstArgs<ExtArgs>>): Prisma__ProductionCuttingLineClient<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionCuttingLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionCuttingLineFindFirstOrThrowArgs} args - Arguments to find a ProductionCuttingLine
     * @example
     * // Get one ProductionCuttingLine
     * const productionCuttingLine = await prisma.productionCuttingLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionCuttingLineFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionCuttingLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionCuttingLineClient<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionCuttingLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionCuttingLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionCuttingLines
     * const productionCuttingLines = await prisma.productionCuttingLine.findMany()
     * 
     * // Get first 10 ProductionCuttingLines
     * const productionCuttingLines = await prisma.productionCuttingLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionCuttingLineWithIdOnly = await prisma.productionCuttingLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionCuttingLineFindManyArgs>(args?: SelectSubset<T, ProductionCuttingLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionCuttingLine.
     * @param {ProductionCuttingLineCreateArgs} args - Arguments to create a ProductionCuttingLine.
     * @example
     * // Create one ProductionCuttingLine
     * const ProductionCuttingLine = await prisma.productionCuttingLine.create({
     *   data: {
     *     // ... data to create a ProductionCuttingLine
     *   }
     * })
     * 
     */
    create<T extends ProductionCuttingLineCreateArgs>(args: SelectSubset<T, ProductionCuttingLineCreateArgs<ExtArgs>>): Prisma__ProductionCuttingLineClient<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionCuttingLines.
     * @param {ProductionCuttingLineCreateManyArgs} args - Arguments to create many ProductionCuttingLines.
     * @example
     * // Create many ProductionCuttingLines
     * const productionCuttingLine = await prisma.productionCuttingLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionCuttingLineCreateManyArgs>(args?: SelectSubset<T, ProductionCuttingLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionCuttingLines and returns the data saved in the database.
     * @param {ProductionCuttingLineCreateManyAndReturnArgs} args - Arguments to create many ProductionCuttingLines.
     * @example
     * // Create many ProductionCuttingLines
     * const productionCuttingLine = await prisma.productionCuttingLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionCuttingLines and only return the `id`
     * const productionCuttingLineWithIdOnly = await prisma.productionCuttingLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionCuttingLineCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionCuttingLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionCuttingLine.
     * @param {ProductionCuttingLineDeleteArgs} args - Arguments to delete one ProductionCuttingLine.
     * @example
     * // Delete one ProductionCuttingLine
     * const ProductionCuttingLine = await prisma.productionCuttingLine.delete({
     *   where: {
     *     // ... filter to delete one ProductionCuttingLine
     *   }
     * })
     * 
     */
    delete<T extends ProductionCuttingLineDeleteArgs>(args: SelectSubset<T, ProductionCuttingLineDeleteArgs<ExtArgs>>): Prisma__ProductionCuttingLineClient<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionCuttingLine.
     * @param {ProductionCuttingLineUpdateArgs} args - Arguments to update one ProductionCuttingLine.
     * @example
     * // Update one ProductionCuttingLine
     * const productionCuttingLine = await prisma.productionCuttingLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionCuttingLineUpdateArgs>(args: SelectSubset<T, ProductionCuttingLineUpdateArgs<ExtArgs>>): Prisma__ProductionCuttingLineClient<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionCuttingLines.
     * @param {ProductionCuttingLineDeleteManyArgs} args - Arguments to filter ProductionCuttingLines to delete.
     * @example
     * // Delete a few ProductionCuttingLines
     * const { count } = await prisma.productionCuttingLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionCuttingLineDeleteManyArgs>(args?: SelectSubset<T, ProductionCuttingLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionCuttingLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionCuttingLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionCuttingLines
     * const productionCuttingLine = await prisma.productionCuttingLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionCuttingLineUpdateManyArgs>(args: SelectSubset<T, ProductionCuttingLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionCuttingLines and returns the data updated in the database.
     * @param {ProductionCuttingLineUpdateManyAndReturnArgs} args - Arguments to update many ProductionCuttingLines.
     * @example
     * // Update many ProductionCuttingLines
     * const productionCuttingLine = await prisma.productionCuttingLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionCuttingLines and only return the `id`
     * const productionCuttingLineWithIdOnly = await prisma.productionCuttingLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionCuttingLineUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionCuttingLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionCuttingLine.
     * @param {ProductionCuttingLineUpsertArgs} args - Arguments to update or create a ProductionCuttingLine.
     * @example
     * // Update or create a ProductionCuttingLine
     * const productionCuttingLine = await prisma.productionCuttingLine.upsert({
     *   create: {
     *     // ... data to create a ProductionCuttingLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionCuttingLine we want to update
     *   }
     * })
     */
    upsert<T extends ProductionCuttingLineUpsertArgs>(args: SelectSubset<T, ProductionCuttingLineUpsertArgs<ExtArgs>>): Prisma__ProductionCuttingLineClient<$Result.GetResult<Prisma.$ProductionCuttingLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionCuttingLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionCuttingLineCountArgs} args - Arguments to filter ProductionCuttingLines to count.
     * @example
     * // Count the number of ProductionCuttingLines
     * const count = await prisma.productionCuttingLine.count({
     *   where: {
     *     // ... the filter for the ProductionCuttingLines we want to count
     *   }
     * })
    **/
    count<T extends ProductionCuttingLineCountArgs>(
      args?: Subset<T, ProductionCuttingLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionCuttingLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionCuttingLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionCuttingLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionCuttingLineAggregateArgs>(args: Subset<T, ProductionCuttingLineAggregateArgs>): Prisma.PrismaPromise<GetProductionCuttingLineAggregateType<T>>

    /**
     * Group by ProductionCuttingLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionCuttingLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionCuttingLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionCuttingLineGroupByArgs['orderBy'] }
        : { orderBy?: ProductionCuttingLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionCuttingLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionCuttingLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionCuttingLine model
   */
  readonly fields: ProductionCuttingLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionCuttingLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionCuttingLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionDoc<T extends ProductionDocDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionDocDefaultArgs<ExtArgs>>): Prisma__ProductionDocClient<$Result.GetResult<Prisma.$ProductionDocPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productionInput<T extends ProductionInputDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionInputDefaultArgs<ExtArgs>>): Prisma__ProductionInputClient<$Result.GetResult<Prisma.$ProductionInputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mml<T extends ProductionMmlDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionMmlDefaultArgs<ExtArgs>>): Prisma__ProductionMmlClient<$Result.GetResult<Prisma.$ProductionMmlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outProduct<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionCuttingLine model
   */
  interface ProductionCuttingLineFieldRefs {
    readonly id: FieldRef<"ProductionCuttingLine", 'Int'>
    readonly productionDocId: FieldRef<"ProductionCuttingLine", 'Int'>
    readonly productionInputId: FieldRef<"ProductionCuttingLine", 'Int'>
    readonly mmlId: FieldRef<"ProductionCuttingLine", 'Int'>
    readonly outProductId: FieldRef<"ProductionCuttingLine", 'Int'>
    readonly qtyOut: FieldRef<"ProductionCuttingLine", 'Decimal'>
    readonly qtyInConsumed: FieldRef<"ProductionCuttingLine", 'Decimal'>
    readonly createdAt: FieldRef<"ProductionCuttingLine", 'DateTime'>
    readonly createdByUserId: FieldRef<"ProductionCuttingLine", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductionCuttingLine findUnique
   */
  export type ProductionCuttingLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductionCuttingLine to fetch.
     */
    where: ProductionCuttingLineWhereUniqueInput
  }

  /**
   * ProductionCuttingLine findUniqueOrThrow
   */
  export type ProductionCuttingLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductionCuttingLine to fetch.
     */
    where: ProductionCuttingLineWhereUniqueInput
  }

  /**
   * ProductionCuttingLine findFirst
   */
  export type ProductionCuttingLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductionCuttingLine to fetch.
     */
    where?: ProductionCuttingLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionCuttingLines to fetch.
     */
    orderBy?: ProductionCuttingLineOrderByWithRelationInput | ProductionCuttingLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionCuttingLines.
     */
    cursor?: ProductionCuttingLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionCuttingLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionCuttingLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionCuttingLines.
     */
    distinct?: ProductionCuttingLineScalarFieldEnum | ProductionCuttingLineScalarFieldEnum[]
  }

  /**
   * ProductionCuttingLine findFirstOrThrow
   */
  export type ProductionCuttingLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductionCuttingLine to fetch.
     */
    where?: ProductionCuttingLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionCuttingLines to fetch.
     */
    orderBy?: ProductionCuttingLineOrderByWithRelationInput | ProductionCuttingLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionCuttingLines.
     */
    cursor?: ProductionCuttingLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionCuttingLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionCuttingLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionCuttingLines.
     */
    distinct?: ProductionCuttingLineScalarFieldEnum | ProductionCuttingLineScalarFieldEnum[]
  }

  /**
   * ProductionCuttingLine findMany
   */
  export type ProductionCuttingLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductionCuttingLines to fetch.
     */
    where?: ProductionCuttingLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionCuttingLines to fetch.
     */
    orderBy?: ProductionCuttingLineOrderByWithRelationInput | ProductionCuttingLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionCuttingLines.
     */
    cursor?: ProductionCuttingLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionCuttingLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionCuttingLines.
     */
    skip?: number
    distinct?: ProductionCuttingLineScalarFieldEnum | ProductionCuttingLineScalarFieldEnum[]
  }

  /**
   * ProductionCuttingLine create
   */
  export type ProductionCuttingLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionCuttingLine.
     */
    data: XOR<ProductionCuttingLineCreateInput, ProductionCuttingLineUncheckedCreateInput>
  }

  /**
   * ProductionCuttingLine createMany
   */
  export type ProductionCuttingLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionCuttingLines.
     */
    data: ProductionCuttingLineCreateManyInput | ProductionCuttingLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionCuttingLine createManyAndReturn
   */
  export type ProductionCuttingLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionCuttingLines.
     */
    data: ProductionCuttingLineCreateManyInput | ProductionCuttingLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionCuttingLine update
   */
  export type ProductionCuttingLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionCuttingLine.
     */
    data: XOR<ProductionCuttingLineUpdateInput, ProductionCuttingLineUncheckedUpdateInput>
    /**
     * Choose, which ProductionCuttingLine to update.
     */
    where: ProductionCuttingLineWhereUniqueInput
  }

  /**
   * ProductionCuttingLine updateMany
   */
  export type ProductionCuttingLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionCuttingLines.
     */
    data: XOR<ProductionCuttingLineUpdateManyMutationInput, ProductionCuttingLineUncheckedUpdateManyInput>
    /**
     * Filter which ProductionCuttingLines to update
     */
    where?: ProductionCuttingLineWhereInput
    /**
     * Limit how many ProductionCuttingLines to update.
     */
    limit?: number
  }

  /**
   * ProductionCuttingLine updateManyAndReturn
   */
  export type ProductionCuttingLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * The data used to update ProductionCuttingLines.
     */
    data: XOR<ProductionCuttingLineUpdateManyMutationInput, ProductionCuttingLineUncheckedUpdateManyInput>
    /**
     * Filter which ProductionCuttingLines to update
     */
    where?: ProductionCuttingLineWhereInput
    /**
     * Limit how many ProductionCuttingLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionCuttingLine upsert
   */
  export type ProductionCuttingLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionCuttingLine to update in case it exists.
     */
    where: ProductionCuttingLineWhereUniqueInput
    /**
     * In case the ProductionCuttingLine found by the `where` argument doesn't exist, create a new ProductionCuttingLine with this data.
     */
    create: XOR<ProductionCuttingLineCreateInput, ProductionCuttingLineUncheckedCreateInput>
    /**
     * In case the ProductionCuttingLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionCuttingLineUpdateInput, ProductionCuttingLineUncheckedUpdateInput>
  }

  /**
   * ProductionCuttingLine delete
   */
  export type ProductionCuttingLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
    /**
     * Filter which ProductionCuttingLine to delete.
     */
    where: ProductionCuttingLineWhereUniqueInput
  }

  /**
   * ProductionCuttingLine deleteMany
   */
  export type ProductionCuttingLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionCuttingLines to delete
     */
    where?: ProductionCuttingLineWhereInput
    /**
     * Limit how many ProductionCuttingLines to delete.
     */
    limit?: number
  }

  /**
   * ProductionCuttingLine without action
   */
  export type ProductionCuttingLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCuttingLine
     */
    select?: ProductionCuttingLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionCuttingLine
     */
    omit?: ProductionCuttingLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionCuttingLineInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    name: 'name',
    role: 'role',
    telegramId: 'telegramId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DistrictScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name'
  };

  export type DistrictScalarFieldEnum = (typeof DistrictScalarFieldEnum)[keyof typeof DistrictScalarFieldEnum]


  export const ManagerScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    phone: 'phone'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    altName: 'altName',
    priceListName: 'priceListName',
    category: 'category',
    status: 'status',
    coefficient: 'coefficient',
    lossNorm: 'lossNorm',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    legalName: 'legalName',
    districtId: 'districtId',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerProductScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    productId: 'productId',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerProductScalarFieldEnum = (typeof CustomerProductScalarFieldEnum)[keyof typeof CustomerProductScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    legalName: 'legalName',
    altName: 'altName',
    phone: 'phone',
    telegram: 'telegram',
    isActive: 'isActive',
    primaryMmlId: 'primaryMmlId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const SupplierProductScalarFieldEnum: {
    supplierId: 'supplierId',
    productId: 'productId'
  };

  export type SupplierProductScalarFieldEnum = (typeof SupplierProductScalarFieldEnum)[keyof typeof SupplierProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    idn: 'idn',
    date: 'date',
    status: 'status',
    paymentType: 'paymentType',
    customerId: 'customerId',
    expeditorId: 'expeditorId',
    totalAmount: 'totalAmount',
    totalWeight: 'totalWeight',
    isDisabled: 'isDisabled',
    deliveryAddress: 'deliveryAddress',
    assignedAt: 'assignedAt',
    deliveryStatus: 'deliveryStatus',
    completedAt: 'completedAt',
    signatureUrl: 'signatureUrl',
    signedInvoiceUrl: 'signedInvoiceUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderAttachmentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    type: 'type',
    filename: 'filename',
    url: 'url',
    mimeType: 'mimeType',
    createdAt: 'createdAt'
  };

  export type OrderAttachmentScalarFieldEnum = (typeof OrderAttachmentScalarFieldEnum)[keyof typeof OrderAttachmentScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    price: 'price',
    amount: 'amount',
    shippedQty: 'shippedQty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    distributionCoef: 'distributionCoef',
    sumWithRevaluation: 'sumWithRevaluation',
    weightToDistribute: 'weightToDistribute'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const ExpeditorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpeditorScalarFieldEnum = (typeof ExpeditorScalarFieldEnum)[keyof typeof ExpeditorScalarFieldEnum]


  export const StockScalarFieldEnum: {
    productId: 'productId',
    quantity: 'quantity',
    updatedAt: 'updatedAt'
  };

  export type StockScalarFieldEnum = (typeof StockScalarFieldEnum)[keyof typeof StockScalarFieldEnum]


  export const StockTransactionScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    type: 'type',
    quantity: 'quantity',
    orderId: 'orderId',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type StockTransactionScalarFieldEnum = (typeof StockTransactionScalarFieldEnum)[keyof typeof StockTransactionScalarFieldEnum]


  export const SummaryOrderJournalScalarFieldEnum: {
    id: 'id',
    idn: 'idn',
    shipDate: 'shipDate',
    paymentType: 'paymentType',
    customerId: 'customerId',
    customerName: 'customerName',
    productId: 'productId',
    productCode: 'productCode',
    productFullName: 'productFullName',
    category: 'category',
    shortNameMorning: 'shortNameMorning',
    priceType: 'priceType',
    price: 'price',
    shippedQty: 'shippedQty',
    orderQty: 'orderQty',
    sumWithRevaluation: 'sumWithRevaluation',
    distributionCoef: 'distributionCoef',
    weightToDistribute: 'weightToDistribute',
    managerId: 'managerId',
    managerName: 'managerName',
    district: 'district',
    pointAddress: 'pointAddress',
    status: 'status',
    preAssemblyStatus: 'preAssemblyStatus',
    assemblyStartedAt: 'assemblyStartedAt',
    assemblyStartedBy: 'assemblyStartedBy',
    assemblyReturnedAt: 'assemblyReturnedAt',
    assemblyReturnedBy: 'assemblyReturnedBy',
    assemblyReturnReason: 'assemblyReturnReason',
    assemblyReturnComment: 'assemblyReturnComment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SummaryOrderJournalScalarFieldEnum = (typeof SummaryOrderJournalScalarFieldEnum)[keyof typeof SummaryOrderJournalScalarFieldEnum]


  export const SummaryOrderEventScalarFieldEnum: {
    id: 'id',
    summaryOrderId: 'summaryOrderId',
    eventType: 'eventType',
    fromStatus: 'fromStatus',
    toStatus: 'toStatus',
    reason: 'reason',
    comment: 'comment',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    payload: 'payload'
  };

  export type SummaryOrderEventScalarFieldEnum = (typeof SummaryOrderEventScalarFieldEnum)[keyof typeof SummaryOrderEventScalarFieldEnum]


  export const SummaryOrdersJournalScalarFieldEnum: {
    id: 'id',
    summaryDate: 'summaryDate',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    isHidden: 'isHidden',
    data: 'data'
  };

  export type SummaryOrdersJournalScalarFieldEnum = (typeof SummaryOrdersJournalScalarFieldEnum)[keyof typeof SummaryOrdersJournalScalarFieldEnum]


  export const AssemblyOrdersJournalScalarFieldEnum: {
    id: 'id',
    assemblyDate: 'assemblyDate',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    isHidden: 'isHidden',
    sourceSummaryId: 'sourceSummaryId',
    data: 'data'
  };

  export type AssemblyOrdersJournalScalarFieldEnum = (typeof AssemblyOrdersJournalScalarFieldEnum)[keyof typeof AssemblyOrdersJournalScalarFieldEnum]


  export const ProductionStaffScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    phone: 'phone',
    userId: 'userId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionStaffScalarFieldEnum = (typeof ProductionStaffScalarFieldEnum)[keyof typeof ProductionStaffScalarFieldEnum]


  export const ProductionJournalScalarFieldEnum: {
    id: 'id',
    productionDate: 'productionDate',
    staffId: 'staffId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ProductionJournalScalarFieldEnum = (typeof ProductionJournalScalarFieldEnum)[keyof typeof ProductionJournalScalarFieldEnum]


  export const ProductionItemScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    productId: 'productId',
    productName: 'productName',
    state: 'state',
    sortOrder: 'sortOrder',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ProductionItemScalarFieldEnum = (typeof ProductionItemScalarFieldEnum)[keyof typeof ProductionItemScalarFieldEnum]


  export const ProductionItemValueScalarFieldEnum: {
    id: 'id',
    productionItemId: 'productionItemId',
    fieldKey: 'fieldKey',
    fieldValue: 'fieldValue',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ProductionItemValueScalarFieldEnum = (typeof ProductionItemValueScalarFieldEnum)[keyof typeof ProductionItemValueScalarFieldEnum]


  export const PurchasePriceListScalarFieldEnum: {
    id: 'id',
    date: 'date',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type PurchasePriceListScalarFieldEnum = (typeof PurchasePriceListScalarFieldEnum)[keyof typeof PurchasePriceListScalarFieldEnum]


  export const PurchasePriceListSupplierScalarFieldEnum: {
    id: 'id',
    priceListId: 'priceListId',
    supplierId: 'supplierId',
    primaryMmlId: 'primaryMmlId',
    createdAt: 'createdAt'
  };

  export type PurchasePriceListSupplierScalarFieldEnum = (typeof PurchasePriceListSupplierScalarFieldEnum)[keyof typeof PurchasePriceListSupplierScalarFieldEnum]


  export const PurchasePriceItemScalarFieldEnum: {
    id: 'id',
    priceListId: 'priceListId',
    supplierId: 'supplierId',
    productId: 'productId',
    purchasePrice: 'purchasePrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchasePriceItemScalarFieldEnum = (typeof PurchasePriceItemScalarFieldEnum)[keyof typeof PurchasePriceItemScalarFieldEnum]


  export const SalesPriceListScalarFieldEnum: {
    id: 'id',
    listType: 'listType',
    customerId: 'customerId',
    title: 'title',
    effectiveDate: 'effectiveDate',
    status: 'status',
    isCurrent: 'isCurrent',
    isHidden: 'isHidden',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type SalesPriceListScalarFieldEnum = (typeof SalesPriceListScalarFieldEnum)[keyof typeof SalesPriceListScalarFieldEnum]


  export const SalesPriceItemScalarFieldEnum: {
    id: 'id',
    priceListId: 'priceListId',
    productId: 'productId',
    salePrice: 'salePrice',
    rowDate: 'rowDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SalesPriceItemScalarFieldEnum = (typeof SalesPriceItemScalarFieldEnum)[keyof typeof SalesPriceItemScalarFieldEnum]


  export const ProductionMmlScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    createdBy: 'createdBy',
    isLocked: 'isLocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionMmlScalarFieldEnum = (typeof ProductionMmlScalarFieldEnum)[keyof typeof ProductionMmlScalarFieldEnum]


  export const ProductionMmlNodeScalarFieldEnum: {
    id: 'id',
    mmlId: 'mmlId',
    parentNodeId: 'parentNodeId',
    productId: 'productId',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionMmlNodeScalarFieldEnum = (typeof ProductionMmlNodeScalarFieldEnum)[keyof typeof ProductionMmlNodeScalarFieldEnum]


  export const ProductionRunScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    mmlId: 'mmlId',
    userId: 'userId',
    productionDate: 'productionDate',
    plannedWeight: 'plannedWeight',
    actualWeight: 'actualWeight',
    isLocked: 'isLocked',
    isHidden: 'isHidden',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionRunScalarFieldEnum = (typeof ProductionRunScalarFieldEnum)[keyof typeof ProductionRunScalarFieldEnum]


  export const ProductionRunValueScalarFieldEnum: {
    id: 'id',
    productionRunId: 'productionRunId',
    mmlNodeId: 'mmlNodeId',
    snapshotProductId: 'snapshotProductId',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionRunValueScalarFieldEnum = (typeof ProductionRunValueScalarFieldEnum)[keyof typeof ProductionRunValueScalarFieldEnum]


  export const PaymentTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isDefault: 'isDefault',
    isDisabled: 'isDisabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentTypeScalarFieldEnum = (typeof PaymentTypeScalarFieldEnum)[keyof typeof PaymentTypeScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    purchaseDate: 'purchaseDate',
    totalAmount: 'totalAmount',
    createdByUserId: 'createdByUserId',
    isDisabled: 'isDisabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const PurchaseSupplierScalarFieldEnum: {
    id: 'id',
    purchaseId: 'purchaseId',
    supplierId: 'supplierId',
    createdAt: 'createdAt'
  };

  export type PurchaseSupplierScalarFieldEnum = (typeof PurchaseSupplierScalarFieldEnum)[keyof typeof PurchaseSupplierScalarFieldEnum]


  export const PurchaseItemScalarFieldEnum: {
    id: 'id',
    purchaseId: 'purchaseId',
    supplierId: 'supplierId',
    productId: 'productId',
    price: 'price',
    qty: 'qty',
    amount: 'amount',
    paymentTypeId: 'paymentTypeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseItemScalarFieldEnum = (typeof PurchaseItemScalarFieldEnum)[keyof typeof PurchaseItemScalarFieldEnum]


  export const TelegramGroupScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    title: 'title',
    username: 'username',
    isActive: 'isActive',
    lastMessageId: 'lastMessageId',
    parsePatterns: 'parsePatterns',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TelegramGroupScalarFieldEnum = (typeof TelegramGroupScalarFieldEnum)[keyof typeof TelegramGroupScalarFieldEnum]


  export const TelegramOrderDraftScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    messageId: 'messageId',
    messageText: 'messageText',
    messageDate: 'messageDate',
    senderName: 'senderName',
    senderId: 'senderId',
    parsedOrderNumber: 'parsedOrderNumber',
    parsedCustomer: 'parsedCustomer',
    parsedAddress: 'parsedAddress',
    status: 'status',
    transferredOrderId: 'transferredOrderId',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectedReason: 'rejectedReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TelegramOrderDraftScalarFieldEnum = (typeof TelegramOrderDraftScalarFieldEnum)[keyof typeof TelegramOrderDraftScalarFieldEnum]


  export const TelegramOrderDraftItemScalarFieldEnum: {
    id: 'id',
    draftId: 'draftId',
    rawProductName: 'rawProductName',
    rawQuantity: 'rawQuantity',
    rawPrice: 'rawPrice',
    productId: 'productId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TelegramOrderDraftItemScalarFieldEnum = (typeof TelegramOrderDraftItemScalarFieldEnum)[keyof typeof TelegramOrderDraftItemScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    address: 'address',
    phone: 'phone',
    responsibleUserId: 'responsibleUserId',
    comment: 'comment',
    isDisabled: 'isDisabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const SvodHeaderScalarFieldEnum: {
    id: 'id',
    svodDate: 'svodDate',
    status: 'status',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SvodHeaderScalarFieldEnum = (typeof SvodHeaderScalarFieldEnum)[keyof typeof SvodHeaderScalarFieldEnum]


  export const SvodLineScalarFieldEnum: {
    id: 'id',
    svodId: 'svodId',
    productId: 'productId',
    shortName: 'shortName',
    category: 'category',
    coefficient: 'coefficient',
    orderQty: 'orderQty',
    productionInQty: 'productionInQty',
    openingStock: 'openingStock',
    openingStockIsManual: 'openingStockIsManual',
    afterPurchaseStock: 'afterPurchaseStock',
    afterShipmentStock: 'afterShipmentStock',
    qtyToShip: 'qtyToShip',
    factMinusWaste: 'factMinusWaste',
    weightToShip: 'weightToShip',
    planFactDiff: 'planFactDiff',
    underOver: 'underOver',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SvodLineScalarFieldEnum = (typeof SvodLineScalarFieldEnum)[keyof typeof SvodLineScalarFieldEnum]


  export const SvodSupplierColScalarFieldEnum: {
    id: 'id',
    svodId: 'svodId',
    colIndex: 'colIndex',
    supplierId: 'supplierId',
    supplierName: 'supplierName',
    totalPurchase: 'totalPurchase',
    createdAt: 'createdAt'
  };

  export type SvodSupplierColScalarFieldEnum = (typeof SvodSupplierColScalarFieldEnum)[keyof typeof SvodSupplierColScalarFieldEnum]


  export const SvodSupplierValueScalarFieldEnum: {
    id: 'id',
    svodId: 'svodId',
    productId: 'productId',
    supplierId: 'supplierId',
    purchaseQty: 'purchaseQty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SvodSupplierValueScalarFieldEnum = (typeof SvodSupplierValueScalarFieldEnum)[keyof typeof SvodSupplierValueScalarFieldEnum]


  export const ProductionDocScalarFieldEnum: {
    id: 'id',
    date: 'date',
    warehouseId: 'warehouseId',
    status: 'status',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionDocScalarFieldEnum = (typeof ProductionDocScalarFieldEnum)[keyof typeof ProductionDocScalarFieldEnum]


  export const ProductionInputScalarFieldEnum: {
    id: 'id',
    productionDocId: 'productionDocId',
    purchaseId: 'purchaseId',
    purchaseItemId: 'purchaseItemId',
    productId: 'productId',
    warehouseId: 'warehouseId',
    qtyIn: 'qtyIn',
    qtyUsed: 'qtyUsed',
    priceIn: 'priceIn',
    loadedAt: 'loadedAt',
    loadedByUserId: 'loadedByUserId'
  };

  export type ProductionInputScalarFieldEnum = (typeof ProductionInputScalarFieldEnum)[keyof typeof ProductionInputScalarFieldEnum]


  export const ProductionOutputScalarFieldEnum: {
    id: 'id',
    productionDocId: 'productionDocId',
    productId: 'productId',
    qtyOut: 'qtyOut',
    uom: 'uom',
    costTotal: 'costTotal',
    costPerUnit: 'costPerUnit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionOutputScalarFieldEnum = (typeof ProductionOutputScalarFieldEnum)[keyof typeof ProductionOutputScalarFieldEnum]


  export const ProductionCuttingLineScalarFieldEnum: {
    id: 'id',
    productionDocId: 'productionDocId',
    productionInputId: 'productionInputId',
    mmlId: 'mmlId',
    outProductId: 'outProductId',
    qtyOut: 'qtyOut',
    qtyInConsumed: 'qtyInConsumed',
    createdAt: 'createdAt',
    createdByUserId: 'createdByUserId'
  };

  export type ProductionCuttingLineScalarFieldEnum = (typeof ProductionCuttingLineScalarFieldEnum)[keyof typeof ProductionCuttingLineScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    telegramId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    productionStaff?: XOR<ProductionStaffNullableScalarRelationFilter, ProductionStaffWhereInput> | null
    createdMmls?: ProductionMmlListRelationFilter
    productionRuns?: ProductionRunListRelationFilter
    purchases?: PurchaseListRelationFilter
    warehouses?: WarehouseListRelationFilter
    productionDocs?: ProductionDocListRelationFilter
    productionInputs?: ProductionInputListRelationFilter
    cuttingLines?: ProductionCuttingLineListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    telegramId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productionStaff?: ProductionStaffOrderByWithRelationInput
    createdMmls?: ProductionMmlOrderByRelationAggregateInput
    productionRuns?: ProductionRunOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    warehouses?: WarehouseOrderByRelationAggregateInput
    productionDocs?: ProductionDocOrderByRelationAggregateInput
    productionInputs?: ProductionInputOrderByRelationAggregateInput
    cuttingLines?: ProductionCuttingLineOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    telegramId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    productionStaff?: XOR<ProductionStaffNullableScalarRelationFilter, ProductionStaffWhereInput> | null
    createdMmls?: ProductionMmlListRelationFilter
    productionRuns?: ProductionRunListRelationFilter
    purchases?: PurchaseListRelationFilter
    warehouses?: WarehouseListRelationFilter
    productionDocs?: ProductionDocListRelationFilter
    productionInputs?: ProductionInputListRelationFilter
    cuttingLines?: ProductionCuttingLineListRelationFilter
  }, "id" | "username" | "telegramId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    telegramId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    telegramId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type DistrictWhereInput = {
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    id?: IntFilter<"District"> | number
    code?: StringFilter<"District"> | string
    name?: StringFilter<"District"> | string
    customers?: CustomerListRelationFilter
  }

  export type DistrictOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    customers?: CustomerOrderByRelationAggregateInput
  }

  export type DistrictWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    name?: StringFilter<"District"> | string
    customers?: CustomerListRelationFilter
  }, "id" | "code">

  export type DistrictOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    _count?: DistrictCountOrderByAggregateInput
    _avg?: DistrictAvgOrderByAggregateInput
    _max?: DistrictMaxOrderByAggregateInput
    _min?: DistrictMinOrderByAggregateInput
    _sum?: DistrictSumOrderByAggregateInput
  }

  export type DistrictScalarWhereWithAggregatesInput = {
    AND?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    OR?: DistrictScalarWhereWithAggregatesInput[]
    NOT?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"District"> | number
    code?: StringWithAggregatesFilter<"District"> | string
    name?: StringWithAggregatesFilter<"District"> | string
  }

  export type ManagerWhereInput = {
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    id?: IntFilter<"Manager"> | number
    code?: StringFilter<"Manager"> | string
    name?: StringFilter<"Manager"> | string
    phone?: StringNullableFilter<"Manager"> | string | null
    customers?: CustomerListRelationFilter
  }

  export type ManagerOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    customers?: CustomerOrderByRelationAggregateInput
  }

  export type ManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    name?: StringFilter<"Manager"> | string
    phone?: StringNullableFilter<"Manager"> | string | null
    customers?: CustomerListRelationFilter
  }, "id" | "code">

  export type ManagerOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: ManagerCountOrderByAggregateInput
    _avg?: ManagerAvgOrderByAggregateInput
    _max?: ManagerMaxOrderByAggregateInput
    _min?: ManagerMinOrderByAggregateInput
    _sum?: ManagerSumOrderByAggregateInput
  }

  export type ManagerScalarWhereWithAggregatesInput = {
    AND?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    OR?: ManagerScalarWhereWithAggregatesInput[]
    NOT?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Manager"> | number
    code?: StringWithAggregatesFilter<"Manager"> | string
    name?: StringWithAggregatesFilter<"Manager"> | string
    phone?: StringNullableWithAggregatesFilter<"Manager"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    code?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    altName?: StringNullableFilter<"Product"> | string | null
    priceListName?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    status?: StringFilter<"Product"> | string
    coefficient?: FloatFilter<"Product"> | number
    lossNorm?: FloatFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    orderItems?: OrderItemListRelationFilter
    stock?: XOR<StockNullableScalarRelationFilter, StockWhereInput> | null
    stockTransactions?: StockTransactionListRelationFilter
    suppliers?: SupplierProductListRelationFilter
    summaryJournalEntries?: SummaryOrderJournalListRelationFilter
    productionItems?: ProductionItemListRelationFilter
    purchasePriceItems?: PurchasePriceItemListRelationFilter
    salesPriceItems?: SalesPriceItemListRelationFilter
    productionMmls?: ProductionMmlListRelationFilter
    mmlNodes?: ProductionMmlNodeListRelationFilter
    productionRuns?: ProductionRunListRelationFilter
    runValueSnapshots?: ProductionRunValueListRelationFilter
    purchaseItemsRel?: PurchaseItemListRelationFilter
    svodLines?: SvodLineListRelationFilter
    svodSupplierValues?: SvodSupplierValueListRelationFilter
    productionInputs?: ProductionInputListRelationFilter
    productionOutputs?: ProductionOutputListRelationFilter
    cuttingLineOutputs?: ProductionCuttingLineListRelationFilter
    customerProducts?: CustomerProductListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    altName?: SortOrderInput | SortOrder
    priceListName?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    stock?: StockOrderByWithRelationInput
    stockTransactions?: StockTransactionOrderByRelationAggregateInput
    suppliers?: SupplierProductOrderByRelationAggregateInput
    summaryJournalEntries?: SummaryOrderJournalOrderByRelationAggregateInput
    productionItems?: ProductionItemOrderByRelationAggregateInput
    purchasePriceItems?: PurchasePriceItemOrderByRelationAggregateInput
    salesPriceItems?: SalesPriceItemOrderByRelationAggregateInput
    productionMmls?: ProductionMmlOrderByRelationAggregateInput
    mmlNodes?: ProductionMmlNodeOrderByRelationAggregateInput
    productionRuns?: ProductionRunOrderByRelationAggregateInput
    runValueSnapshots?: ProductionRunValueOrderByRelationAggregateInput
    purchaseItemsRel?: PurchaseItemOrderByRelationAggregateInput
    svodLines?: SvodLineOrderByRelationAggregateInput
    svodSupplierValues?: SvodSupplierValueOrderByRelationAggregateInput
    productionInputs?: ProductionInputOrderByRelationAggregateInput
    productionOutputs?: ProductionOutputOrderByRelationAggregateInput
    cuttingLineOutputs?: ProductionCuttingLineOrderByRelationAggregateInput
    customerProducts?: CustomerProductOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    altName?: StringNullableFilter<"Product"> | string | null
    priceListName?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    status?: StringFilter<"Product"> | string
    coefficient?: FloatFilter<"Product"> | number
    lossNorm?: FloatFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    orderItems?: OrderItemListRelationFilter
    stock?: XOR<StockNullableScalarRelationFilter, StockWhereInput> | null
    stockTransactions?: StockTransactionListRelationFilter
    suppliers?: SupplierProductListRelationFilter
    summaryJournalEntries?: SummaryOrderJournalListRelationFilter
    productionItems?: ProductionItemListRelationFilter
    purchasePriceItems?: PurchasePriceItemListRelationFilter
    salesPriceItems?: SalesPriceItemListRelationFilter
    productionMmls?: ProductionMmlListRelationFilter
    mmlNodes?: ProductionMmlNodeListRelationFilter
    productionRuns?: ProductionRunListRelationFilter
    runValueSnapshots?: ProductionRunValueListRelationFilter
    purchaseItemsRel?: PurchaseItemListRelationFilter
    svodLines?: SvodLineListRelationFilter
    svodSupplierValues?: SvodSupplierValueListRelationFilter
    productionInputs?: ProductionInputListRelationFilter
    productionOutputs?: ProductionOutputListRelationFilter
    cuttingLineOutputs?: ProductionCuttingLineListRelationFilter
    customerProducts?: CustomerProductListRelationFilter
  }, "id" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    altName?: SortOrderInput | SortOrder
    priceListName?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    code?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    altName?: StringNullableWithAggregatesFilter<"Product"> | string | null
    priceListName?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    status?: StringWithAggregatesFilter<"Product"> | string
    coefficient?: FloatWithAggregatesFilter<"Product"> | number
    lossNorm?: FloatWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    code?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    legalName?: StringNullableFilter<"Customer"> | string | null
    districtId?: StringNullableFilter<"Customer"> | string | null
    managerId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    district?: XOR<DistrictNullableScalarRelationFilter, DistrictWhereInput> | null
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    orders?: OrderListRelationFilter
    summaryJournalEntries?: SummaryOrderJournalListRelationFilter
    salesPriceLists?: SalesPriceListListRelationFilter
    customerProducts?: CustomerProductListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    districtId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    district?: DistrictOrderByWithRelationInput
    manager?: ManagerOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    summaryJournalEntries?: SummaryOrderJournalOrderByRelationAggregateInput
    salesPriceLists?: SalesPriceListOrderByRelationAggregateInput
    customerProducts?: CustomerProductOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    legalName?: StringNullableFilter<"Customer"> | string | null
    districtId?: StringNullableFilter<"Customer"> | string | null
    managerId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    district?: XOR<DistrictNullableScalarRelationFilter, DistrictWhereInput> | null
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    orders?: OrderListRelationFilter
    summaryJournalEntries?: SummaryOrderJournalListRelationFilter
    salesPriceLists?: SalesPriceListListRelationFilter
    customerProducts?: CustomerProductListRelationFilter
  }, "id" | "code">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    districtId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    code?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    legalName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    districtId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type CustomerProductWhereInput = {
    AND?: CustomerProductWhereInput | CustomerProductWhereInput[]
    OR?: CustomerProductWhereInput[]
    NOT?: CustomerProductWhereInput | CustomerProductWhereInput[]
    id?: IntFilter<"CustomerProduct"> | number
    customerId?: IntFilter<"CustomerProduct"> | number
    productId?: IntFilter<"CustomerProduct"> | number
    sortOrder?: IntFilter<"CustomerProduct"> | number
    createdAt?: DateTimeFilter<"CustomerProduct"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerProduct"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type CustomerProductOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CustomerProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    customerId_productId?: CustomerProductCustomerIdProductIdCompoundUniqueInput
    AND?: CustomerProductWhereInput | CustomerProductWhereInput[]
    OR?: CustomerProductWhereInput[]
    NOT?: CustomerProductWhereInput | CustomerProductWhereInput[]
    customerId?: IntFilter<"CustomerProduct"> | number
    productId?: IntFilter<"CustomerProduct"> | number
    sortOrder?: IntFilter<"CustomerProduct"> | number
    createdAt?: DateTimeFilter<"CustomerProduct"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerProduct"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "customerId_productId">

  export type CustomerProductOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerProductCountOrderByAggregateInput
    _avg?: CustomerProductAvgOrderByAggregateInput
    _max?: CustomerProductMaxOrderByAggregateInput
    _min?: CustomerProductMinOrderByAggregateInput
    _sum?: CustomerProductSumOrderByAggregateInput
  }

  export type CustomerProductScalarWhereWithAggregatesInput = {
    AND?: CustomerProductScalarWhereWithAggregatesInput | CustomerProductScalarWhereWithAggregatesInput[]
    OR?: CustomerProductScalarWhereWithAggregatesInput[]
    NOT?: CustomerProductScalarWhereWithAggregatesInput | CustomerProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerProduct"> | number
    customerId?: IntWithAggregatesFilter<"CustomerProduct"> | number
    productId?: IntWithAggregatesFilter<"CustomerProduct"> | number
    sortOrder?: IntWithAggregatesFilter<"CustomerProduct"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CustomerProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerProduct"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: IntFilter<"Supplier"> | number
    code?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    legalName?: StringNullableFilter<"Supplier"> | string | null
    altName?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    telegram?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    primaryMmlId?: IntNullableFilter<"Supplier"> | number | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    primaryMml?: XOR<ProductionMmlNullableScalarRelationFilter, ProductionMmlWhereInput> | null
    products?: SupplierProductListRelationFilter
    purchasePriceListSuppliers?: PurchasePriceListSupplierListRelationFilter
    purchasePriceItems?: PurchasePriceItemListRelationFilter
    purchases?: PurchaseSupplierListRelationFilter
    purchaseItems?: PurchaseItemListRelationFilter
    svodSupplierCols?: SvodSupplierColListRelationFilter
    svodSupplierValues?: SvodSupplierValueListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    altName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    isActive?: SortOrder
    primaryMmlId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryMml?: ProductionMmlOrderByWithRelationInput
    products?: SupplierProductOrderByRelationAggregateInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierOrderByRelationAggregateInput
    purchasePriceItems?: PurchasePriceItemOrderByRelationAggregateInput
    purchases?: PurchaseSupplierOrderByRelationAggregateInput
    purchaseItems?: PurchaseItemOrderByRelationAggregateInput
    svodSupplierCols?: SvodSupplierColOrderByRelationAggregateInput
    svodSupplierValues?: SvodSupplierValueOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    legalName?: StringNullableFilter<"Supplier"> | string | null
    altName?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    telegram?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    primaryMmlId?: IntNullableFilter<"Supplier"> | number | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    primaryMml?: XOR<ProductionMmlNullableScalarRelationFilter, ProductionMmlWhereInput> | null
    products?: SupplierProductListRelationFilter
    purchasePriceListSuppliers?: PurchasePriceListSupplierListRelationFilter
    purchasePriceItems?: PurchasePriceItemListRelationFilter
    purchases?: PurchaseSupplierListRelationFilter
    purchaseItems?: PurchaseItemListRelationFilter
    svodSupplierCols?: SvodSupplierColListRelationFilter
    svodSupplierValues?: SvodSupplierValueListRelationFilter
  }, "id" | "code">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    altName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    isActive?: SortOrder
    primaryMmlId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Supplier"> | number
    code?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    legalName?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    altName?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    telegram?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    primaryMmlId?: IntNullableWithAggregatesFilter<"Supplier"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type SupplierProductWhereInput = {
    AND?: SupplierProductWhereInput | SupplierProductWhereInput[]
    OR?: SupplierProductWhereInput[]
    NOT?: SupplierProductWhereInput | SupplierProductWhereInput[]
    supplierId?: IntFilter<"SupplierProduct"> | number
    productId?: IntFilter<"SupplierProduct"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type SupplierProductOrderByWithRelationInput = {
    supplierId?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type SupplierProductWhereUniqueInput = Prisma.AtLeast<{
    supplierId_productId?: SupplierProductSupplierIdProductIdCompoundUniqueInput
    AND?: SupplierProductWhereInput | SupplierProductWhereInput[]
    OR?: SupplierProductWhereInput[]
    NOT?: SupplierProductWhereInput | SupplierProductWhereInput[]
    supplierId?: IntFilter<"SupplierProduct"> | number
    productId?: IntFilter<"SupplierProduct"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "supplierId_productId">

  export type SupplierProductOrderByWithAggregationInput = {
    supplierId?: SortOrder
    productId?: SortOrder
    _count?: SupplierProductCountOrderByAggregateInput
    _avg?: SupplierProductAvgOrderByAggregateInput
    _max?: SupplierProductMaxOrderByAggregateInput
    _min?: SupplierProductMinOrderByAggregateInput
    _sum?: SupplierProductSumOrderByAggregateInput
  }

  export type SupplierProductScalarWhereWithAggregatesInput = {
    AND?: SupplierProductScalarWhereWithAggregatesInput | SupplierProductScalarWhereWithAggregatesInput[]
    OR?: SupplierProductScalarWhereWithAggregatesInput[]
    NOT?: SupplierProductScalarWhereWithAggregatesInput | SupplierProductScalarWhereWithAggregatesInput[]
    supplierId?: IntWithAggregatesFilter<"SupplierProduct"> | number
    productId?: IntWithAggregatesFilter<"SupplierProduct"> | number
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    idn?: StringNullableFilter<"Order"> | string | null
    date?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    paymentType?: StringNullableFilter<"Order"> | string | null
    customerId?: IntFilter<"Order"> | number
    expeditorId?: IntNullableFilter<"Order"> | number | null
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFilter<"Order"> | number
    isDisabled?: BoolFilter<"Order"> | boolean
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    assignedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryStatus?: StringFilter<"Order"> | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    signatureUrl?: StringNullableFilter<"Order"> | string | null
    signedInvoiceUrl?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    expeditor?: XOR<ExpeditorNullableScalarRelationFilter, ExpeditorWhereInput> | null
    items?: OrderItemListRelationFilter
    stockTransactions?: StockTransactionListRelationFilter
    attachments?: OrderAttachmentListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    idn?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
    isDisabled?: SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    deliveryStatus?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    signedInvoiceUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    expeditor?: ExpeditorOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    stockTransactions?: StockTransactionOrderByRelationAggregateInput
    attachments?: OrderAttachmentOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    idn?: StringNullableFilter<"Order"> | string | null
    date?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    paymentType?: StringNullableFilter<"Order"> | string | null
    customerId?: IntFilter<"Order"> | number
    expeditorId?: IntNullableFilter<"Order"> | number | null
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFilter<"Order"> | number
    isDisabled?: BoolFilter<"Order"> | boolean
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    assignedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryStatus?: StringFilter<"Order"> | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    signatureUrl?: StringNullableFilter<"Order"> | string | null
    signedInvoiceUrl?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    expeditor?: XOR<ExpeditorNullableScalarRelationFilter, ExpeditorWhereInput> | null
    items?: OrderItemListRelationFilter
    stockTransactions?: StockTransactionListRelationFilter
    attachments?: OrderAttachmentListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    idn?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
    isDisabled?: SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    deliveryStatus?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    signedInvoiceUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    idn?: StringNullableWithAggregatesFilter<"Order"> | string | null
    date?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    status?: StringWithAggregatesFilter<"Order"> | string
    paymentType?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerId?: IntWithAggregatesFilter<"Order"> | number
    expeditorId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    totalAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatWithAggregatesFilter<"Order"> | number
    isDisabled?: BoolWithAggregatesFilter<"Order"> | boolean
    deliveryAddress?: StringNullableWithAggregatesFilter<"Order"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    deliveryStatus?: StringWithAggregatesFilter<"Order"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    signatureUrl?: StringNullableWithAggregatesFilter<"Order"> | string | null
    signedInvoiceUrl?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderAttachmentWhereInput = {
    AND?: OrderAttachmentWhereInput | OrderAttachmentWhereInput[]
    OR?: OrderAttachmentWhereInput[]
    NOT?: OrderAttachmentWhereInput | OrderAttachmentWhereInput[]
    id?: IntFilter<"OrderAttachment"> | number
    orderId?: IntFilter<"OrderAttachment"> | number
    type?: StringFilter<"OrderAttachment"> | string
    filename?: StringFilter<"OrderAttachment"> | string
    url?: StringFilter<"OrderAttachment"> | string
    mimeType?: StringNullableFilter<"OrderAttachment"> | string | null
    createdAt?: DateTimeFilter<"OrderAttachment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type OrderAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type OrderAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderAttachmentWhereInput | OrderAttachmentWhereInput[]
    OR?: OrderAttachmentWhereInput[]
    NOT?: OrderAttachmentWhereInput | OrderAttachmentWhereInput[]
    orderId?: IntFilter<"OrderAttachment"> | number
    type?: StringFilter<"OrderAttachment"> | string
    filename?: StringFilter<"OrderAttachment"> | string
    url?: StringFilter<"OrderAttachment"> | string
    mimeType?: StringNullableFilter<"OrderAttachment"> | string | null
    createdAt?: DateTimeFilter<"OrderAttachment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type OrderAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OrderAttachmentCountOrderByAggregateInput
    _avg?: OrderAttachmentAvgOrderByAggregateInput
    _max?: OrderAttachmentMaxOrderByAggregateInput
    _min?: OrderAttachmentMinOrderByAggregateInput
    _sum?: OrderAttachmentSumOrderByAggregateInput
  }

  export type OrderAttachmentScalarWhereWithAggregatesInput = {
    AND?: OrderAttachmentScalarWhereWithAggregatesInput | OrderAttachmentScalarWhereWithAggregatesInput[]
    OR?: OrderAttachmentScalarWhereWithAggregatesInput[]
    NOT?: OrderAttachmentScalarWhereWithAggregatesInput | OrderAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderAttachment"> | number
    orderId?: IntWithAggregatesFilter<"OrderAttachment"> | number
    type?: StringWithAggregatesFilter<"OrderAttachment"> | string
    filename?: StringWithAggregatesFilter<"OrderAttachment"> | string
    url?: StringWithAggregatesFilter<"OrderAttachment"> | string
    mimeType?: StringNullableWithAggregatesFilter<"OrderAttachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderAttachment"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: FloatFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    distributionCoef?: FloatNullableFilter<"OrderItem"> | number | null
    sumWithRevaluation?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: FloatNullableFilter<"OrderItem"> | number | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributionCoef?: SortOrderInput | SortOrder
    sumWithRevaluation?: SortOrderInput | SortOrder
    weightToDistribute?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: FloatFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    distributionCoef?: FloatNullableFilter<"OrderItem"> | number | null
    sumWithRevaluation?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: FloatNullableFilter<"OrderItem"> | number | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributionCoef?: SortOrderInput | SortOrder
    sumWithRevaluation?: SortOrderInput | SortOrder
    weightToDistribute?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    productId?: IntWithAggregatesFilter<"OrderItem"> | number
    quantity?: FloatWithAggregatesFilter<"OrderItem"> | number
    price?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatWithAggregatesFilter<"OrderItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    distributionCoef?: FloatNullableWithAggregatesFilter<"OrderItem"> | number | null
    sumWithRevaluation?: DecimalNullableWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: FloatNullableWithAggregatesFilter<"OrderItem"> | number | null
  }

  export type ExpeditorWhereInput = {
    AND?: ExpeditorWhereInput | ExpeditorWhereInput[]
    OR?: ExpeditorWhereInput[]
    NOT?: ExpeditorWhereInput | ExpeditorWhereInput[]
    id?: IntFilter<"Expeditor"> | number
    name?: StringFilter<"Expeditor"> | string
    phone?: StringNullableFilter<"Expeditor"> | string | null
    isActive?: BoolFilter<"Expeditor"> | boolean
    createdAt?: DateTimeFilter<"Expeditor"> | Date | string
    updatedAt?: DateTimeFilter<"Expeditor"> | Date | string
    orders?: OrderListRelationFilter
  }

  export type ExpeditorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type ExpeditorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExpeditorWhereInput | ExpeditorWhereInput[]
    OR?: ExpeditorWhereInput[]
    NOT?: ExpeditorWhereInput | ExpeditorWhereInput[]
    name?: StringFilter<"Expeditor"> | string
    phone?: StringNullableFilter<"Expeditor"> | string | null
    isActive?: BoolFilter<"Expeditor"> | boolean
    createdAt?: DateTimeFilter<"Expeditor"> | Date | string
    updatedAt?: DateTimeFilter<"Expeditor"> | Date | string
    orders?: OrderListRelationFilter
  }, "id">

  export type ExpeditorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpeditorCountOrderByAggregateInput
    _avg?: ExpeditorAvgOrderByAggregateInput
    _max?: ExpeditorMaxOrderByAggregateInput
    _min?: ExpeditorMinOrderByAggregateInput
    _sum?: ExpeditorSumOrderByAggregateInput
  }

  export type ExpeditorScalarWhereWithAggregatesInput = {
    AND?: ExpeditorScalarWhereWithAggregatesInput | ExpeditorScalarWhereWithAggregatesInput[]
    OR?: ExpeditorScalarWhereWithAggregatesInput[]
    NOT?: ExpeditorScalarWhereWithAggregatesInput | ExpeditorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Expeditor"> | number
    name?: StringWithAggregatesFilter<"Expeditor"> | string
    phone?: StringNullableWithAggregatesFilter<"Expeditor"> | string | null
    isActive?: BoolWithAggregatesFilter<"Expeditor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Expeditor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expeditor"> | Date | string
  }

  export type StockWhereInput = {
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    productId?: IntFilter<"Stock"> | number
    quantity?: FloatFilter<"Stock"> | number
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type StockOrderByWithRelationInput = {
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type StockWhereUniqueInput = Prisma.AtLeast<{
    productId?: number
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    quantity?: FloatFilter<"Stock"> | number
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "productId">

  export type StockOrderByWithAggregationInput = {
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
    _count?: StockCountOrderByAggregateInput
    _avg?: StockAvgOrderByAggregateInput
    _max?: StockMaxOrderByAggregateInput
    _min?: StockMinOrderByAggregateInput
    _sum?: StockSumOrderByAggregateInput
  }

  export type StockScalarWhereWithAggregatesInput = {
    AND?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    OR?: StockScalarWhereWithAggregatesInput[]
    NOT?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    productId?: IntWithAggregatesFilter<"Stock"> | number
    quantity?: FloatWithAggregatesFilter<"Stock"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Stock"> | Date | string
  }

  export type StockTransactionWhereInput = {
    AND?: StockTransactionWhereInput | StockTransactionWhereInput[]
    OR?: StockTransactionWhereInput[]
    NOT?: StockTransactionWhereInput | StockTransactionWhereInput[]
    id?: IntFilter<"StockTransaction"> | number
    productId?: IntFilter<"StockTransaction"> | number
    type?: StringFilter<"StockTransaction"> | string
    quantity?: FloatFilter<"StockTransaction"> | number
    orderId?: IntNullableFilter<"StockTransaction"> | number | null
    note?: StringNullableFilter<"StockTransaction"> | string | null
    createdAt?: DateTimeFilter<"StockTransaction"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type StockTransactionOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type StockTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StockTransactionWhereInput | StockTransactionWhereInput[]
    OR?: StockTransactionWhereInput[]
    NOT?: StockTransactionWhereInput | StockTransactionWhereInput[]
    productId?: IntFilter<"StockTransaction"> | number
    type?: StringFilter<"StockTransaction"> | string
    quantity?: FloatFilter<"StockTransaction"> | number
    orderId?: IntNullableFilter<"StockTransaction"> | number | null
    note?: StringNullableFilter<"StockTransaction"> | string | null
    createdAt?: DateTimeFilter<"StockTransaction"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type StockTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StockTransactionCountOrderByAggregateInput
    _avg?: StockTransactionAvgOrderByAggregateInput
    _max?: StockTransactionMaxOrderByAggregateInput
    _min?: StockTransactionMinOrderByAggregateInput
    _sum?: StockTransactionSumOrderByAggregateInput
  }

  export type StockTransactionScalarWhereWithAggregatesInput = {
    AND?: StockTransactionScalarWhereWithAggregatesInput | StockTransactionScalarWhereWithAggregatesInput[]
    OR?: StockTransactionScalarWhereWithAggregatesInput[]
    NOT?: StockTransactionScalarWhereWithAggregatesInput | StockTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StockTransaction"> | number
    productId?: IntWithAggregatesFilter<"StockTransaction"> | number
    type?: StringWithAggregatesFilter<"StockTransaction"> | string
    quantity?: FloatWithAggregatesFilter<"StockTransaction"> | number
    orderId?: IntNullableWithAggregatesFilter<"StockTransaction"> | number | null
    note?: StringNullableWithAggregatesFilter<"StockTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockTransaction"> | Date | string
  }

  export type SummaryOrderJournalWhereInput = {
    AND?: SummaryOrderJournalWhereInput | SummaryOrderJournalWhereInput[]
    OR?: SummaryOrderJournalWhereInput[]
    NOT?: SummaryOrderJournalWhereInput | SummaryOrderJournalWhereInput[]
    id?: IntFilter<"SummaryOrderJournal"> | number
    idn?: StringFilter<"SummaryOrderJournal"> | string
    shipDate?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    paymentType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    customerId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    customerName?: StringFilter<"SummaryOrderJournal"> | string
    productId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    productCode?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    productFullName?: StringFilter<"SummaryOrderJournal"> | string
    category?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    shortNameMorning?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    priceType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    price?: DecimalFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"SummaryOrderJournal"> | number
    orderQty?: FloatFilter<"SummaryOrderJournal"> | number
    sumWithRevaluation?: DecimalNullableFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    weightToDistribute?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    managerId?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    managerName?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    district?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    pointAddress?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    status?: StringFilter<"SummaryOrderJournal"> | string
    preAssemblyStatus?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyStartedAt?: DateTimeNullableFilter<"SummaryOrderJournal"> | Date | string | null
    assemblyStartedBy?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnedAt?: DateTimeNullableFilter<"SummaryOrderJournal"> | Date | string | null
    assemblyReturnedBy?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnReason?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnComment?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    createdAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    updatedAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    events?: SummaryOrderEventListRelationFilter
  }

  export type SummaryOrderJournalOrderByWithRelationInput = {
    id?: SortOrder
    idn?: SortOrder
    shipDate?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    productId?: SortOrderInput | SortOrder
    productCode?: SortOrderInput | SortOrder
    productFullName?: SortOrder
    category?: SortOrderInput | SortOrder
    shortNameMorning?: SortOrderInput | SortOrder
    priceType?: SortOrderInput | SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrderInput | SortOrder
    distributionCoef?: SortOrderInput | SortOrder
    weightToDistribute?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    managerName?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    pointAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    preAssemblyStatus?: SortOrderInput | SortOrder
    assemblyStartedAt?: SortOrderInput | SortOrder
    assemblyStartedBy?: SortOrderInput | SortOrder
    assemblyReturnedAt?: SortOrderInput | SortOrder
    assemblyReturnedBy?: SortOrderInput | SortOrder
    assemblyReturnReason?: SortOrderInput | SortOrder
    assemblyReturnComment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    events?: SummaryOrderEventOrderByRelationAggregateInput
  }

  export type SummaryOrderJournalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SummaryOrderJournalWhereInput | SummaryOrderJournalWhereInput[]
    OR?: SummaryOrderJournalWhereInput[]
    NOT?: SummaryOrderJournalWhereInput | SummaryOrderJournalWhereInput[]
    idn?: StringFilter<"SummaryOrderJournal"> | string
    shipDate?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    paymentType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    customerId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    customerName?: StringFilter<"SummaryOrderJournal"> | string
    productId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    productCode?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    productFullName?: StringFilter<"SummaryOrderJournal"> | string
    category?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    shortNameMorning?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    priceType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    price?: DecimalFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"SummaryOrderJournal"> | number
    orderQty?: FloatFilter<"SummaryOrderJournal"> | number
    sumWithRevaluation?: DecimalNullableFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    weightToDistribute?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    managerId?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    managerName?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    district?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    pointAddress?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    status?: StringFilter<"SummaryOrderJournal"> | string
    preAssemblyStatus?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyStartedAt?: DateTimeNullableFilter<"SummaryOrderJournal"> | Date | string | null
    assemblyStartedBy?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnedAt?: DateTimeNullableFilter<"SummaryOrderJournal"> | Date | string | null
    assemblyReturnedBy?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnReason?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnComment?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    createdAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    updatedAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    events?: SummaryOrderEventListRelationFilter
  }, "id">

  export type SummaryOrderJournalOrderByWithAggregationInput = {
    id?: SortOrder
    idn?: SortOrder
    shipDate?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    productId?: SortOrderInput | SortOrder
    productCode?: SortOrderInput | SortOrder
    productFullName?: SortOrder
    category?: SortOrderInput | SortOrder
    shortNameMorning?: SortOrderInput | SortOrder
    priceType?: SortOrderInput | SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrderInput | SortOrder
    distributionCoef?: SortOrderInput | SortOrder
    weightToDistribute?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    managerName?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    pointAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    preAssemblyStatus?: SortOrderInput | SortOrder
    assemblyStartedAt?: SortOrderInput | SortOrder
    assemblyStartedBy?: SortOrderInput | SortOrder
    assemblyReturnedAt?: SortOrderInput | SortOrder
    assemblyReturnedBy?: SortOrderInput | SortOrder
    assemblyReturnReason?: SortOrderInput | SortOrder
    assemblyReturnComment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SummaryOrderJournalCountOrderByAggregateInput
    _avg?: SummaryOrderJournalAvgOrderByAggregateInput
    _max?: SummaryOrderJournalMaxOrderByAggregateInput
    _min?: SummaryOrderJournalMinOrderByAggregateInput
    _sum?: SummaryOrderJournalSumOrderByAggregateInput
  }

  export type SummaryOrderJournalScalarWhereWithAggregatesInput = {
    AND?: SummaryOrderJournalScalarWhereWithAggregatesInput | SummaryOrderJournalScalarWhereWithAggregatesInput[]
    OR?: SummaryOrderJournalScalarWhereWithAggregatesInput[]
    NOT?: SummaryOrderJournalScalarWhereWithAggregatesInput | SummaryOrderJournalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SummaryOrderJournal"> | number
    idn?: StringWithAggregatesFilter<"SummaryOrderJournal"> | string
    shipDate?: DateTimeWithAggregatesFilter<"SummaryOrderJournal"> | Date | string
    paymentType?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    customerId?: IntNullableWithAggregatesFilter<"SummaryOrderJournal"> | number | null
    customerName?: StringWithAggregatesFilter<"SummaryOrderJournal"> | string
    productId?: IntNullableWithAggregatesFilter<"SummaryOrderJournal"> | number | null
    productCode?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    productFullName?: StringWithAggregatesFilter<"SummaryOrderJournal"> | string
    category?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    shortNameMorning?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    priceType?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    price?: DecimalWithAggregatesFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatWithAggregatesFilter<"SummaryOrderJournal"> | number
    orderQty?: FloatWithAggregatesFilter<"SummaryOrderJournal"> | number
    sumWithRevaluation?: DecimalNullableWithAggregatesFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: FloatNullableWithAggregatesFilter<"SummaryOrderJournal"> | number | null
    weightToDistribute?: FloatNullableWithAggregatesFilter<"SummaryOrderJournal"> | number | null
    managerId?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    managerName?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    district?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    pointAddress?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    status?: StringWithAggregatesFilter<"SummaryOrderJournal"> | string
    preAssemblyStatus?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    assemblyStartedAt?: DateTimeNullableWithAggregatesFilter<"SummaryOrderJournal"> | Date | string | null
    assemblyStartedBy?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnedAt?: DateTimeNullableWithAggregatesFilter<"SummaryOrderJournal"> | Date | string | null
    assemblyReturnedBy?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnReason?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnComment?: StringNullableWithAggregatesFilter<"SummaryOrderJournal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SummaryOrderJournal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SummaryOrderJournal"> | Date | string
  }

  export type SummaryOrderEventWhereInput = {
    AND?: SummaryOrderEventWhereInput | SummaryOrderEventWhereInput[]
    OR?: SummaryOrderEventWhereInput[]
    NOT?: SummaryOrderEventWhereInput | SummaryOrderEventWhereInput[]
    id?: IntFilter<"SummaryOrderEvent"> | number
    summaryOrderId?: IntFilter<"SummaryOrderEvent"> | number
    eventType?: StringFilter<"SummaryOrderEvent"> | string
    fromStatus?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    toStatus?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    reason?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    comment?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    createdAt?: DateTimeFilter<"SummaryOrderEvent"> | Date | string
    createdBy?: StringFilter<"SummaryOrderEvent"> | string
    payload?: JsonNullableFilter<"SummaryOrderEvent">
    summaryOrder?: XOR<SummaryOrderJournalScalarRelationFilter, SummaryOrderJournalWhereInput>
  }

  export type SummaryOrderEventOrderByWithRelationInput = {
    id?: SortOrder
    summaryOrderId?: SortOrder
    eventType?: SortOrder
    fromStatus?: SortOrderInput | SortOrder
    toStatus?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    payload?: SortOrderInput | SortOrder
    summaryOrder?: SummaryOrderJournalOrderByWithRelationInput
  }

  export type SummaryOrderEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SummaryOrderEventWhereInput | SummaryOrderEventWhereInput[]
    OR?: SummaryOrderEventWhereInput[]
    NOT?: SummaryOrderEventWhereInput | SummaryOrderEventWhereInput[]
    summaryOrderId?: IntFilter<"SummaryOrderEvent"> | number
    eventType?: StringFilter<"SummaryOrderEvent"> | string
    fromStatus?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    toStatus?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    reason?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    comment?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    createdAt?: DateTimeFilter<"SummaryOrderEvent"> | Date | string
    createdBy?: StringFilter<"SummaryOrderEvent"> | string
    payload?: JsonNullableFilter<"SummaryOrderEvent">
    summaryOrder?: XOR<SummaryOrderJournalScalarRelationFilter, SummaryOrderJournalWhereInput>
  }, "id">

  export type SummaryOrderEventOrderByWithAggregationInput = {
    id?: SortOrder
    summaryOrderId?: SortOrder
    eventType?: SortOrder
    fromStatus?: SortOrderInput | SortOrder
    toStatus?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    payload?: SortOrderInput | SortOrder
    _count?: SummaryOrderEventCountOrderByAggregateInput
    _avg?: SummaryOrderEventAvgOrderByAggregateInput
    _max?: SummaryOrderEventMaxOrderByAggregateInput
    _min?: SummaryOrderEventMinOrderByAggregateInput
    _sum?: SummaryOrderEventSumOrderByAggregateInput
  }

  export type SummaryOrderEventScalarWhereWithAggregatesInput = {
    AND?: SummaryOrderEventScalarWhereWithAggregatesInput | SummaryOrderEventScalarWhereWithAggregatesInput[]
    OR?: SummaryOrderEventScalarWhereWithAggregatesInput[]
    NOT?: SummaryOrderEventScalarWhereWithAggregatesInput | SummaryOrderEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SummaryOrderEvent"> | number
    summaryOrderId?: IntWithAggregatesFilter<"SummaryOrderEvent"> | number
    eventType?: StringWithAggregatesFilter<"SummaryOrderEvent"> | string
    fromStatus?: StringNullableWithAggregatesFilter<"SummaryOrderEvent"> | string | null
    toStatus?: StringNullableWithAggregatesFilter<"SummaryOrderEvent"> | string | null
    reason?: StringNullableWithAggregatesFilter<"SummaryOrderEvent"> | string | null
    comment?: StringNullableWithAggregatesFilter<"SummaryOrderEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SummaryOrderEvent"> | Date | string
    createdBy?: StringWithAggregatesFilter<"SummaryOrderEvent"> | string
    payload?: JsonNullableWithAggregatesFilter<"SummaryOrderEvent">
  }

  export type SummaryOrdersJournalWhereInput = {
    AND?: SummaryOrdersJournalWhereInput | SummaryOrdersJournalWhereInput[]
    OR?: SummaryOrdersJournalWhereInput[]
    NOT?: SummaryOrdersJournalWhereInput | SummaryOrdersJournalWhereInput[]
    id?: IntFilter<"SummaryOrdersJournal"> | number
    summaryDate?: DateTimeFilter<"SummaryOrdersJournal"> | Date | string
    createdAt?: DateTimeFilter<"SummaryOrdersJournal"> | Date | string
    createdBy?: StringFilter<"SummaryOrdersJournal"> | string
    isHidden?: BoolFilter<"SummaryOrdersJournal"> | boolean
    data?: JsonFilter<"SummaryOrdersJournal">
  }

  export type SummaryOrdersJournalOrderByWithRelationInput = {
    id?: SortOrder
    summaryDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    data?: SortOrder
  }

  export type SummaryOrdersJournalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SummaryOrdersJournalWhereInput | SummaryOrdersJournalWhereInput[]
    OR?: SummaryOrdersJournalWhereInput[]
    NOT?: SummaryOrdersJournalWhereInput | SummaryOrdersJournalWhereInput[]
    summaryDate?: DateTimeFilter<"SummaryOrdersJournal"> | Date | string
    createdAt?: DateTimeFilter<"SummaryOrdersJournal"> | Date | string
    createdBy?: StringFilter<"SummaryOrdersJournal"> | string
    isHidden?: BoolFilter<"SummaryOrdersJournal"> | boolean
    data?: JsonFilter<"SummaryOrdersJournal">
  }, "id">

  export type SummaryOrdersJournalOrderByWithAggregationInput = {
    id?: SortOrder
    summaryDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    data?: SortOrder
    _count?: SummaryOrdersJournalCountOrderByAggregateInput
    _avg?: SummaryOrdersJournalAvgOrderByAggregateInput
    _max?: SummaryOrdersJournalMaxOrderByAggregateInput
    _min?: SummaryOrdersJournalMinOrderByAggregateInput
    _sum?: SummaryOrdersJournalSumOrderByAggregateInput
  }

  export type SummaryOrdersJournalScalarWhereWithAggregatesInput = {
    AND?: SummaryOrdersJournalScalarWhereWithAggregatesInput | SummaryOrdersJournalScalarWhereWithAggregatesInput[]
    OR?: SummaryOrdersJournalScalarWhereWithAggregatesInput[]
    NOT?: SummaryOrdersJournalScalarWhereWithAggregatesInput | SummaryOrdersJournalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SummaryOrdersJournal"> | number
    summaryDate?: DateTimeWithAggregatesFilter<"SummaryOrdersJournal"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SummaryOrdersJournal"> | Date | string
    createdBy?: StringWithAggregatesFilter<"SummaryOrdersJournal"> | string
    isHidden?: BoolWithAggregatesFilter<"SummaryOrdersJournal"> | boolean
    data?: JsonWithAggregatesFilter<"SummaryOrdersJournal">
  }

  export type AssemblyOrdersJournalWhereInput = {
    AND?: AssemblyOrdersJournalWhereInput | AssemblyOrdersJournalWhereInput[]
    OR?: AssemblyOrdersJournalWhereInput[]
    NOT?: AssemblyOrdersJournalWhereInput | AssemblyOrdersJournalWhereInput[]
    id?: IntFilter<"AssemblyOrdersJournal"> | number
    assemblyDate?: DateTimeFilter<"AssemblyOrdersJournal"> | Date | string
    createdAt?: DateTimeFilter<"AssemblyOrdersJournal"> | Date | string
    createdBy?: StringFilter<"AssemblyOrdersJournal"> | string
    isHidden?: BoolFilter<"AssemblyOrdersJournal"> | boolean
    sourceSummaryId?: IntNullableFilter<"AssemblyOrdersJournal"> | number | null
    data?: JsonFilter<"AssemblyOrdersJournal">
  }

  export type AssemblyOrdersJournalOrderByWithRelationInput = {
    id?: SortOrder
    assemblyDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    sourceSummaryId?: SortOrderInput | SortOrder
    data?: SortOrder
  }

  export type AssemblyOrdersJournalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssemblyOrdersJournalWhereInput | AssemblyOrdersJournalWhereInput[]
    OR?: AssemblyOrdersJournalWhereInput[]
    NOT?: AssemblyOrdersJournalWhereInput | AssemblyOrdersJournalWhereInput[]
    assemblyDate?: DateTimeFilter<"AssemblyOrdersJournal"> | Date | string
    createdAt?: DateTimeFilter<"AssemblyOrdersJournal"> | Date | string
    createdBy?: StringFilter<"AssemblyOrdersJournal"> | string
    isHidden?: BoolFilter<"AssemblyOrdersJournal"> | boolean
    sourceSummaryId?: IntNullableFilter<"AssemblyOrdersJournal"> | number | null
    data?: JsonFilter<"AssemblyOrdersJournal">
  }, "id">

  export type AssemblyOrdersJournalOrderByWithAggregationInput = {
    id?: SortOrder
    assemblyDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    sourceSummaryId?: SortOrderInput | SortOrder
    data?: SortOrder
    _count?: AssemblyOrdersJournalCountOrderByAggregateInput
    _avg?: AssemblyOrdersJournalAvgOrderByAggregateInput
    _max?: AssemblyOrdersJournalMaxOrderByAggregateInput
    _min?: AssemblyOrdersJournalMinOrderByAggregateInput
    _sum?: AssemblyOrdersJournalSumOrderByAggregateInput
  }

  export type AssemblyOrdersJournalScalarWhereWithAggregatesInput = {
    AND?: AssemblyOrdersJournalScalarWhereWithAggregatesInput | AssemblyOrdersJournalScalarWhereWithAggregatesInput[]
    OR?: AssemblyOrdersJournalScalarWhereWithAggregatesInput[]
    NOT?: AssemblyOrdersJournalScalarWhereWithAggregatesInput | AssemblyOrdersJournalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssemblyOrdersJournal"> | number
    assemblyDate?: DateTimeWithAggregatesFilter<"AssemblyOrdersJournal"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AssemblyOrdersJournal"> | Date | string
    createdBy?: StringWithAggregatesFilter<"AssemblyOrdersJournal"> | string
    isHidden?: BoolWithAggregatesFilter<"AssemblyOrdersJournal"> | boolean
    sourceSummaryId?: IntNullableWithAggregatesFilter<"AssemblyOrdersJournal"> | number | null
    data?: JsonWithAggregatesFilter<"AssemblyOrdersJournal">
  }

  export type ProductionStaffWhereInput = {
    AND?: ProductionStaffWhereInput | ProductionStaffWhereInput[]
    OR?: ProductionStaffWhereInput[]
    NOT?: ProductionStaffWhereInput | ProductionStaffWhereInput[]
    id?: IntFilter<"ProductionStaff"> | number
    fullName?: StringFilter<"ProductionStaff"> | string
    phone?: StringNullableFilter<"ProductionStaff"> | string | null
    userId?: IntFilter<"ProductionStaff"> | number
    isActive?: BoolFilter<"ProductionStaff"> | boolean
    createdAt?: DateTimeFilter<"ProductionStaff"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    journals?: ProductionJournalListRelationFilter
  }

  export type ProductionStaffOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    journals?: ProductionJournalOrderByRelationAggregateInput
  }

  export type ProductionStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: ProductionStaffWhereInput | ProductionStaffWhereInput[]
    OR?: ProductionStaffWhereInput[]
    NOT?: ProductionStaffWhereInput | ProductionStaffWhereInput[]
    fullName?: StringFilter<"ProductionStaff"> | string
    phone?: StringNullableFilter<"ProductionStaff"> | string | null
    isActive?: BoolFilter<"ProductionStaff"> | boolean
    createdAt?: DateTimeFilter<"ProductionStaff"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    journals?: ProductionJournalListRelationFilter
  }, "id" | "userId">

  export type ProductionStaffOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionStaffCountOrderByAggregateInput
    _avg?: ProductionStaffAvgOrderByAggregateInput
    _max?: ProductionStaffMaxOrderByAggregateInput
    _min?: ProductionStaffMinOrderByAggregateInput
    _sum?: ProductionStaffSumOrderByAggregateInput
  }

  export type ProductionStaffScalarWhereWithAggregatesInput = {
    AND?: ProductionStaffScalarWhereWithAggregatesInput | ProductionStaffScalarWhereWithAggregatesInput[]
    OR?: ProductionStaffScalarWhereWithAggregatesInput[]
    NOT?: ProductionStaffScalarWhereWithAggregatesInput | ProductionStaffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionStaff"> | number
    fullName?: StringWithAggregatesFilter<"ProductionStaff"> | string
    phone?: StringNullableWithAggregatesFilter<"ProductionStaff"> | string | null
    userId?: IntWithAggregatesFilter<"ProductionStaff"> | number
    isActive?: BoolWithAggregatesFilter<"ProductionStaff"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductionStaff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionStaff"> | Date | string
  }

  export type ProductionJournalWhereInput = {
    AND?: ProductionJournalWhereInput | ProductionJournalWhereInput[]
    OR?: ProductionJournalWhereInput[]
    NOT?: ProductionJournalWhereInput | ProductionJournalWhereInput[]
    id?: IntFilter<"ProductionJournal"> | number
    productionDate?: DateTimeFilter<"ProductionJournal"> | Date | string
    staffId?: IntFilter<"ProductionJournal"> | number
    status?: StringFilter<"ProductionJournal"> | string
    createdAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    createdBy?: StringFilter<"ProductionJournal"> | string
    updatedBy?: StringNullableFilter<"ProductionJournal"> | string | null
    staff?: XOR<ProductionStaffScalarRelationFilter, ProductionStaffWhereInput>
    items?: ProductionItemListRelationFilter
  }

  export type ProductionJournalOrderByWithRelationInput = {
    id?: SortOrder
    productionDate?: SortOrder
    staffId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    staff?: ProductionStaffOrderByWithRelationInput
    items?: ProductionItemOrderByRelationAggregateInput
  }

  export type ProductionJournalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productionDate_staffId?: ProductionJournalProductionDateStaffIdCompoundUniqueInput
    AND?: ProductionJournalWhereInput | ProductionJournalWhereInput[]
    OR?: ProductionJournalWhereInput[]
    NOT?: ProductionJournalWhereInput | ProductionJournalWhereInput[]
    productionDate?: DateTimeFilter<"ProductionJournal"> | Date | string
    staffId?: IntFilter<"ProductionJournal"> | number
    status?: StringFilter<"ProductionJournal"> | string
    createdAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    createdBy?: StringFilter<"ProductionJournal"> | string
    updatedBy?: StringNullableFilter<"ProductionJournal"> | string | null
    staff?: XOR<ProductionStaffScalarRelationFilter, ProductionStaffWhereInput>
    items?: ProductionItemListRelationFilter
  }, "id" | "productionDate_staffId">

  export type ProductionJournalOrderByWithAggregationInput = {
    id?: SortOrder
    productionDate?: SortOrder
    staffId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ProductionJournalCountOrderByAggregateInput
    _avg?: ProductionJournalAvgOrderByAggregateInput
    _max?: ProductionJournalMaxOrderByAggregateInput
    _min?: ProductionJournalMinOrderByAggregateInput
    _sum?: ProductionJournalSumOrderByAggregateInput
  }

  export type ProductionJournalScalarWhereWithAggregatesInput = {
    AND?: ProductionJournalScalarWhereWithAggregatesInput | ProductionJournalScalarWhereWithAggregatesInput[]
    OR?: ProductionJournalScalarWhereWithAggregatesInput[]
    NOT?: ProductionJournalScalarWhereWithAggregatesInput | ProductionJournalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionJournal"> | number
    productionDate?: DateTimeWithAggregatesFilter<"ProductionJournal"> | Date | string
    staffId?: IntWithAggregatesFilter<"ProductionJournal"> | number
    status?: StringWithAggregatesFilter<"ProductionJournal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductionJournal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionJournal"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ProductionJournal"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"ProductionJournal"> | string | null
  }

  export type ProductionItemWhereInput = {
    AND?: ProductionItemWhereInput | ProductionItemWhereInput[]
    OR?: ProductionItemWhereInput[]
    NOT?: ProductionItemWhereInput | ProductionItemWhereInput[]
    id?: IntFilter<"ProductionItem"> | number
    journalId?: IntFilter<"ProductionItem"> | number
    productId?: IntNullableFilter<"ProductionItem"> | number | null
    productName?: StringNullableFilter<"ProductionItem"> | string | null
    state?: StringFilter<"ProductionItem"> | string
    sortOrder?: IntFilter<"ProductionItem"> | number
    isDeleted?: BoolFilter<"ProductionItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"ProductionItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"ProductionItem"> | string | null
    createdAt?: DateTimeFilter<"ProductionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionItem"> | Date | string
    createdBy?: StringFilter<"ProductionItem"> | string
    updatedBy?: StringNullableFilter<"ProductionItem"> | string | null
    journal?: XOR<ProductionJournalScalarRelationFilter, ProductionJournalWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    values?: ProductionItemValueListRelationFilter
  }

  export type ProductionItemOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    state?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    journal?: ProductionJournalOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    values?: ProductionItemValueOrderByRelationAggregateInput
  }

  export type ProductionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductionItemWhereInput | ProductionItemWhereInput[]
    OR?: ProductionItemWhereInput[]
    NOT?: ProductionItemWhereInput | ProductionItemWhereInput[]
    journalId?: IntFilter<"ProductionItem"> | number
    productId?: IntNullableFilter<"ProductionItem"> | number | null
    productName?: StringNullableFilter<"ProductionItem"> | string | null
    state?: StringFilter<"ProductionItem"> | string
    sortOrder?: IntFilter<"ProductionItem"> | number
    isDeleted?: BoolFilter<"ProductionItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"ProductionItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"ProductionItem"> | string | null
    createdAt?: DateTimeFilter<"ProductionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionItem"> | Date | string
    createdBy?: StringFilter<"ProductionItem"> | string
    updatedBy?: StringNullableFilter<"ProductionItem"> | string | null
    journal?: XOR<ProductionJournalScalarRelationFilter, ProductionJournalWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    values?: ProductionItemValueListRelationFilter
  }, "id">

  export type ProductionItemOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    state?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ProductionItemCountOrderByAggregateInput
    _avg?: ProductionItemAvgOrderByAggregateInput
    _max?: ProductionItemMaxOrderByAggregateInput
    _min?: ProductionItemMinOrderByAggregateInput
    _sum?: ProductionItemSumOrderByAggregateInput
  }

  export type ProductionItemScalarWhereWithAggregatesInput = {
    AND?: ProductionItemScalarWhereWithAggregatesInput | ProductionItemScalarWhereWithAggregatesInput[]
    OR?: ProductionItemScalarWhereWithAggregatesInput[]
    NOT?: ProductionItemScalarWhereWithAggregatesInput | ProductionItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionItem"> | number
    journalId?: IntWithAggregatesFilter<"ProductionItem"> | number
    productId?: IntNullableWithAggregatesFilter<"ProductionItem"> | number | null
    productName?: StringNullableWithAggregatesFilter<"ProductionItem"> | string | null
    state?: StringWithAggregatesFilter<"ProductionItem"> | string
    sortOrder?: IntWithAggregatesFilter<"ProductionItem"> | number
    isDeleted?: BoolWithAggregatesFilter<"ProductionItem"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ProductionItem"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"ProductionItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductionItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionItem"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ProductionItem"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"ProductionItem"> | string | null
  }

  export type ProductionItemValueWhereInput = {
    AND?: ProductionItemValueWhereInput | ProductionItemValueWhereInput[]
    OR?: ProductionItemValueWhereInput[]
    NOT?: ProductionItemValueWhereInput | ProductionItemValueWhereInput[]
    id?: IntFilter<"ProductionItemValue"> | number
    productionItemId?: IntFilter<"ProductionItemValue"> | number
    fieldKey?: StringFilter<"ProductionItemValue"> | string
    fieldValue?: StringNullableFilter<"ProductionItemValue"> | string | null
    updatedAt?: DateTimeFilter<"ProductionItemValue"> | Date | string
    updatedBy?: StringNullableFilter<"ProductionItemValue"> | string | null
    productionItem?: XOR<ProductionItemScalarRelationFilter, ProductionItemWhereInput>
  }

  export type ProductionItemValueOrderByWithRelationInput = {
    id?: SortOrder
    productionItemId?: SortOrder
    fieldKey?: SortOrder
    fieldValue?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    productionItem?: ProductionItemOrderByWithRelationInput
  }

  export type ProductionItemValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productionItemId_fieldKey?: ProductionItemValueProductionItemIdFieldKeyCompoundUniqueInput
    AND?: ProductionItemValueWhereInput | ProductionItemValueWhereInput[]
    OR?: ProductionItemValueWhereInput[]
    NOT?: ProductionItemValueWhereInput | ProductionItemValueWhereInput[]
    productionItemId?: IntFilter<"ProductionItemValue"> | number
    fieldKey?: StringFilter<"ProductionItemValue"> | string
    fieldValue?: StringNullableFilter<"ProductionItemValue"> | string | null
    updatedAt?: DateTimeFilter<"ProductionItemValue"> | Date | string
    updatedBy?: StringNullableFilter<"ProductionItemValue"> | string | null
    productionItem?: XOR<ProductionItemScalarRelationFilter, ProductionItemWhereInput>
  }, "id" | "productionItemId_fieldKey">

  export type ProductionItemValueOrderByWithAggregationInput = {
    id?: SortOrder
    productionItemId?: SortOrder
    fieldKey?: SortOrder
    fieldValue?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ProductionItemValueCountOrderByAggregateInput
    _avg?: ProductionItemValueAvgOrderByAggregateInput
    _max?: ProductionItemValueMaxOrderByAggregateInput
    _min?: ProductionItemValueMinOrderByAggregateInput
    _sum?: ProductionItemValueSumOrderByAggregateInput
  }

  export type ProductionItemValueScalarWhereWithAggregatesInput = {
    AND?: ProductionItemValueScalarWhereWithAggregatesInput | ProductionItemValueScalarWhereWithAggregatesInput[]
    OR?: ProductionItemValueScalarWhereWithAggregatesInput[]
    NOT?: ProductionItemValueScalarWhereWithAggregatesInput | ProductionItemValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionItemValue"> | number
    productionItemId?: IntWithAggregatesFilter<"ProductionItemValue"> | number
    fieldKey?: StringWithAggregatesFilter<"ProductionItemValue"> | string
    fieldValue?: StringNullableWithAggregatesFilter<"ProductionItemValue"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionItemValue"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"ProductionItemValue"> | string | null
  }

  export type PurchasePriceListWhereInput = {
    AND?: PurchasePriceListWhereInput | PurchasePriceListWhereInput[]
    OR?: PurchasePriceListWhereInput[]
    NOT?: PurchasePriceListWhereInput | PurchasePriceListWhereInput[]
    id?: IntFilter<"PurchasePriceList"> | number
    date?: DateTimeFilter<"PurchasePriceList"> | Date | string
    name?: StringNullableFilter<"PurchasePriceList"> | string | null
    isActive?: BoolFilter<"PurchasePriceList"> | boolean
    createdAt?: DateTimeFilter<"PurchasePriceList"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasePriceList"> | Date | string
    createdBy?: StringFilter<"PurchasePriceList"> | string
    updatedBy?: StringNullableFilter<"PurchasePriceList"> | string | null
    suppliers?: PurchasePriceListSupplierListRelationFilter
    items?: PurchasePriceItemListRelationFilter
  }

  export type PurchasePriceListOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    suppliers?: PurchasePriceListSupplierOrderByRelationAggregateInput
    items?: PurchasePriceItemOrderByRelationAggregateInput
  }

  export type PurchasePriceListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchasePriceListWhereInput | PurchasePriceListWhereInput[]
    OR?: PurchasePriceListWhereInput[]
    NOT?: PurchasePriceListWhereInput | PurchasePriceListWhereInput[]
    date?: DateTimeFilter<"PurchasePriceList"> | Date | string
    name?: StringNullableFilter<"PurchasePriceList"> | string | null
    isActive?: BoolFilter<"PurchasePriceList"> | boolean
    createdAt?: DateTimeFilter<"PurchasePriceList"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasePriceList"> | Date | string
    createdBy?: StringFilter<"PurchasePriceList"> | string
    updatedBy?: StringNullableFilter<"PurchasePriceList"> | string | null
    suppliers?: PurchasePriceListSupplierListRelationFilter
    items?: PurchasePriceItemListRelationFilter
  }, "id">

  export type PurchasePriceListOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: PurchasePriceListCountOrderByAggregateInput
    _avg?: PurchasePriceListAvgOrderByAggregateInput
    _max?: PurchasePriceListMaxOrderByAggregateInput
    _min?: PurchasePriceListMinOrderByAggregateInput
    _sum?: PurchasePriceListSumOrderByAggregateInput
  }

  export type PurchasePriceListScalarWhereWithAggregatesInput = {
    AND?: PurchasePriceListScalarWhereWithAggregatesInput | PurchasePriceListScalarWhereWithAggregatesInput[]
    OR?: PurchasePriceListScalarWhereWithAggregatesInput[]
    NOT?: PurchasePriceListScalarWhereWithAggregatesInput | PurchasePriceListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchasePriceList"> | number
    date?: DateTimeWithAggregatesFilter<"PurchasePriceList"> | Date | string
    name?: StringNullableWithAggregatesFilter<"PurchasePriceList"> | string | null
    isActive?: BoolWithAggregatesFilter<"PurchasePriceList"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PurchasePriceList"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchasePriceList"> | Date | string
    createdBy?: StringWithAggregatesFilter<"PurchasePriceList"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"PurchasePriceList"> | string | null
  }

  export type PurchasePriceListSupplierWhereInput = {
    AND?: PurchasePriceListSupplierWhereInput | PurchasePriceListSupplierWhereInput[]
    OR?: PurchasePriceListSupplierWhereInput[]
    NOT?: PurchasePriceListSupplierWhereInput | PurchasePriceListSupplierWhereInput[]
    id?: IntFilter<"PurchasePriceListSupplier"> | number
    priceListId?: IntFilter<"PurchasePriceListSupplier"> | number
    supplierId?: IntFilter<"PurchasePriceListSupplier"> | number
    primaryMmlId?: IntNullableFilter<"PurchasePriceListSupplier"> | number | null
    createdAt?: DateTimeFilter<"PurchasePriceListSupplier"> | Date | string
    priceList?: XOR<PurchasePriceListScalarRelationFilter, PurchasePriceListWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    primaryMml?: XOR<ProductionMmlNullableScalarRelationFilter, ProductionMmlWhereInput> | null
  }

  export type PurchasePriceListSupplierOrderByWithRelationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    priceList?: PurchasePriceListOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    primaryMml?: ProductionMmlOrderByWithRelationInput
  }

  export type PurchasePriceListSupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    priceListId_supplierId?: PurchasePriceListSupplierPriceListIdSupplierIdCompoundUniqueInput
    AND?: PurchasePriceListSupplierWhereInput | PurchasePriceListSupplierWhereInput[]
    OR?: PurchasePriceListSupplierWhereInput[]
    NOT?: PurchasePriceListSupplierWhereInput | PurchasePriceListSupplierWhereInput[]
    priceListId?: IntFilter<"PurchasePriceListSupplier"> | number
    supplierId?: IntFilter<"PurchasePriceListSupplier"> | number
    primaryMmlId?: IntNullableFilter<"PurchasePriceListSupplier"> | number | null
    createdAt?: DateTimeFilter<"PurchasePriceListSupplier"> | Date | string
    priceList?: XOR<PurchasePriceListScalarRelationFilter, PurchasePriceListWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    primaryMml?: XOR<ProductionMmlNullableScalarRelationFilter, ProductionMmlWhereInput> | null
  }, "id" | "priceListId_supplierId">

  export type PurchasePriceListSupplierOrderByWithAggregationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PurchasePriceListSupplierCountOrderByAggregateInput
    _avg?: PurchasePriceListSupplierAvgOrderByAggregateInput
    _max?: PurchasePriceListSupplierMaxOrderByAggregateInput
    _min?: PurchasePriceListSupplierMinOrderByAggregateInput
    _sum?: PurchasePriceListSupplierSumOrderByAggregateInput
  }

  export type PurchasePriceListSupplierScalarWhereWithAggregatesInput = {
    AND?: PurchasePriceListSupplierScalarWhereWithAggregatesInput | PurchasePriceListSupplierScalarWhereWithAggregatesInput[]
    OR?: PurchasePriceListSupplierScalarWhereWithAggregatesInput[]
    NOT?: PurchasePriceListSupplierScalarWhereWithAggregatesInput | PurchasePriceListSupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchasePriceListSupplier"> | number
    priceListId?: IntWithAggregatesFilter<"PurchasePriceListSupplier"> | number
    supplierId?: IntWithAggregatesFilter<"PurchasePriceListSupplier"> | number
    primaryMmlId?: IntNullableWithAggregatesFilter<"PurchasePriceListSupplier"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchasePriceListSupplier"> | Date | string
  }

  export type PurchasePriceItemWhereInput = {
    AND?: PurchasePriceItemWhereInput | PurchasePriceItemWhereInput[]
    OR?: PurchasePriceItemWhereInput[]
    NOT?: PurchasePriceItemWhereInput | PurchasePriceItemWhereInput[]
    id?: IntFilter<"PurchasePriceItem"> | number
    priceListId?: IntFilter<"PurchasePriceItem"> | number
    supplierId?: IntFilter<"PurchasePriceItem"> | number
    productId?: IntFilter<"PurchasePriceItem"> | number
    purchasePrice?: DecimalFilter<"PurchasePriceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
    priceList?: XOR<PurchasePriceListScalarRelationFilter, PurchasePriceListWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type PurchasePriceItemOrderByWithRelationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    priceList?: PurchasePriceListOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PurchasePriceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    priceListId_supplierId_productId?: PurchasePriceItemPriceListIdSupplierIdProductIdCompoundUniqueInput
    AND?: PurchasePriceItemWhereInput | PurchasePriceItemWhereInput[]
    OR?: PurchasePriceItemWhereInput[]
    NOT?: PurchasePriceItemWhereInput | PurchasePriceItemWhereInput[]
    priceListId?: IntFilter<"PurchasePriceItem"> | number
    supplierId?: IntFilter<"PurchasePriceItem"> | number
    productId?: IntFilter<"PurchasePriceItem"> | number
    purchasePrice?: DecimalFilter<"PurchasePriceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
    priceList?: XOR<PurchasePriceListScalarRelationFilter, PurchasePriceListWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "priceListId_supplierId_productId">

  export type PurchasePriceItemOrderByWithAggregationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchasePriceItemCountOrderByAggregateInput
    _avg?: PurchasePriceItemAvgOrderByAggregateInput
    _max?: PurchasePriceItemMaxOrderByAggregateInput
    _min?: PurchasePriceItemMinOrderByAggregateInput
    _sum?: PurchasePriceItemSumOrderByAggregateInput
  }

  export type PurchasePriceItemScalarWhereWithAggregatesInput = {
    AND?: PurchasePriceItemScalarWhereWithAggregatesInput | PurchasePriceItemScalarWhereWithAggregatesInput[]
    OR?: PurchasePriceItemScalarWhereWithAggregatesInput[]
    NOT?: PurchasePriceItemScalarWhereWithAggregatesInput | PurchasePriceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchasePriceItem"> | number
    priceListId?: IntWithAggregatesFilter<"PurchasePriceItem"> | number
    supplierId?: IntWithAggregatesFilter<"PurchasePriceItem"> | number
    productId?: IntWithAggregatesFilter<"PurchasePriceItem"> | number
    purchasePrice?: DecimalWithAggregatesFilter<"PurchasePriceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"PurchasePriceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchasePriceItem"> | Date | string
  }

  export type SalesPriceListWhereInput = {
    AND?: SalesPriceListWhereInput | SalesPriceListWhereInput[]
    OR?: SalesPriceListWhereInput[]
    NOT?: SalesPriceListWhereInput | SalesPriceListWhereInput[]
    id?: IntFilter<"SalesPriceList"> | number
    listType?: StringFilter<"SalesPriceList"> | string
    customerId?: IntNullableFilter<"SalesPriceList"> | number | null
    title?: StringNullableFilter<"SalesPriceList"> | string | null
    effectiveDate?: DateTimeFilter<"SalesPriceList"> | Date | string
    status?: StringFilter<"SalesPriceList"> | string
    isCurrent?: BoolFilter<"SalesPriceList"> | boolean
    isHidden?: BoolFilter<"SalesPriceList"> | boolean
    createdAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    createdBy?: StringFilter<"SalesPriceList"> | string
    updatedBy?: StringNullableFilter<"SalesPriceList"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: SalesPriceItemListRelationFilter
  }

  export type SalesPriceListOrderByWithRelationInput = {
    id?: SortOrder
    listType?: SortOrder
    customerId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    status?: SortOrder
    isCurrent?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    items?: SalesPriceItemOrderByRelationAggregateInput
  }

  export type SalesPriceListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalesPriceListWhereInput | SalesPriceListWhereInput[]
    OR?: SalesPriceListWhereInput[]
    NOT?: SalesPriceListWhereInput | SalesPriceListWhereInput[]
    listType?: StringFilter<"SalesPriceList"> | string
    customerId?: IntNullableFilter<"SalesPriceList"> | number | null
    title?: StringNullableFilter<"SalesPriceList"> | string | null
    effectiveDate?: DateTimeFilter<"SalesPriceList"> | Date | string
    status?: StringFilter<"SalesPriceList"> | string
    isCurrent?: BoolFilter<"SalesPriceList"> | boolean
    isHidden?: BoolFilter<"SalesPriceList"> | boolean
    createdAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    createdBy?: StringFilter<"SalesPriceList"> | string
    updatedBy?: StringNullableFilter<"SalesPriceList"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: SalesPriceItemListRelationFilter
  }, "id">

  export type SalesPriceListOrderByWithAggregationInput = {
    id?: SortOrder
    listType?: SortOrder
    customerId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    status?: SortOrder
    isCurrent?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SalesPriceListCountOrderByAggregateInput
    _avg?: SalesPriceListAvgOrderByAggregateInput
    _max?: SalesPriceListMaxOrderByAggregateInput
    _min?: SalesPriceListMinOrderByAggregateInput
    _sum?: SalesPriceListSumOrderByAggregateInput
  }

  export type SalesPriceListScalarWhereWithAggregatesInput = {
    AND?: SalesPriceListScalarWhereWithAggregatesInput | SalesPriceListScalarWhereWithAggregatesInput[]
    OR?: SalesPriceListScalarWhereWithAggregatesInput[]
    NOT?: SalesPriceListScalarWhereWithAggregatesInput | SalesPriceListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesPriceList"> | number
    listType?: StringWithAggregatesFilter<"SalesPriceList"> | string
    customerId?: IntNullableWithAggregatesFilter<"SalesPriceList"> | number | null
    title?: StringNullableWithAggregatesFilter<"SalesPriceList"> | string | null
    effectiveDate?: DateTimeWithAggregatesFilter<"SalesPriceList"> | Date | string
    status?: StringWithAggregatesFilter<"SalesPriceList"> | string
    isCurrent?: BoolWithAggregatesFilter<"SalesPriceList"> | boolean
    isHidden?: BoolWithAggregatesFilter<"SalesPriceList"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SalesPriceList"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesPriceList"> | Date | string
    createdBy?: StringWithAggregatesFilter<"SalesPriceList"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"SalesPriceList"> | string | null
  }

  export type SalesPriceItemWhereInput = {
    AND?: SalesPriceItemWhereInput | SalesPriceItemWhereInput[]
    OR?: SalesPriceItemWhereInput[]
    NOT?: SalesPriceItemWhereInput | SalesPriceItemWhereInput[]
    id?: IntFilter<"SalesPriceItem"> | number
    priceListId?: IntFilter<"SalesPriceItem"> | number
    productId?: IntFilter<"SalesPriceItem"> | number
    salePrice?: DecimalFilter<"SalesPriceItem"> | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFilter<"SalesPriceItem"> | Date | string
    createdAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedBy?: StringNullableFilter<"SalesPriceItem"> | string | null
    priceList?: XOR<SalesPriceListScalarRelationFilter, SalesPriceListWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type SalesPriceItemOrderByWithRelationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
    rowDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    priceList?: SalesPriceListOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type SalesPriceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    priceListId_productId?: SalesPriceItemPriceListIdProductIdCompoundUniqueInput
    AND?: SalesPriceItemWhereInput | SalesPriceItemWhereInput[]
    OR?: SalesPriceItemWhereInput[]
    NOT?: SalesPriceItemWhereInput | SalesPriceItemWhereInput[]
    priceListId?: IntFilter<"SalesPriceItem"> | number
    productId?: IntFilter<"SalesPriceItem"> | number
    salePrice?: DecimalFilter<"SalesPriceItem"> | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFilter<"SalesPriceItem"> | Date | string
    createdAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedBy?: StringNullableFilter<"SalesPriceItem"> | string | null
    priceList?: XOR<SalesPriceListScalarRelationFilter, SalesPriceListWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "priceListId_productId">

  export type SalesPriceItemOrderByWithAggregationInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
    rowDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SalesPriceItemCountOrderByAggregateInput
    _avg?: SalesPriceItemAvgOrderByAggregateInput
    _max?: SalesPriceItemMaxOrderByAggregateInput
    _min?: SalesPriceItemMinOrderByAggregateInput
    _sum?: SalesPriceItemSumOrderByAggregateInput
  }

  export type SalesPriceItemScalarWhereWithAggregatesInput = {
    AND?: SalesPriceItemScalarWhereWithAggregatesInput | SalesPriceItemScalarWhereWithAggregatesInput[]
    OR?: SalesPriceItemScalarWhereWithAggregatesInput[]
    NOT?: SalesPriceItemScalarWhereWithAggregatesInput | SalesPriceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesPriceItem"> | number
    priceListId?: IntWithAggregatesFilter<"SalesPriceItem"> | number
    productId?: IntWithAggregatesFilter<"SalesPriceItem"> | number
    salePrice?: DecimalWithAggregatesFilter<"SalesPriceItem"> | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeWithAggregatesFilter<"SalesPriceItem"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SalesPriceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesPriceItem"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"SalesPriceItem"> | string | null
  }

  export type ProductionMmlWhereInput = {
    AND?: ProductionMmlWhereInput | ProductionMmlWhereInput[]
    OR?: ProductionMmlWhereInput[]
    NOT?: ProductionMmlWhereInput | ProductionMmlWhereInput[]
    id?: IntFilter<"ProductionMml"> | number
    productId?: IntFilter<"ProductionMml"> | number
    createdBy?: IntFilter<"ProductionMml"> | number
    isLocked?: BoolFilter<"ProductionMml"> | boolean
    createdAt?: DateTimeFilter<"ProductionMml"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMml"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    nodes?: ProductionMmlNodeListRelationFilter
    runs?: ProductionRunListRelationFilter
    suppliersWithPrimaryMml?: SupplierListRelationFilter
    priceListSuppliers?: PurchasePriceListSupplierListRelationFilter
    cuttingLines?: ProductionCuttingLineListRelationFilter
  }

  export type ProductionMmlOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    nodes?: ProductionMmlNodeOrderByRelationAggregateInput
    runs?: ProductionRunOrderByRelationAggregateInput
    suppliersWithPrimaryMml?: SupplierOrderByRelationAggregateInput
    priceListSuppliers?: PurchasePriceListSupplierOrderByRelationAggregateInput
    cuttingLines?: ProductionCuttingLineOrderByRelationAggregateInput
  }

  export type ProductionMmlWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productId?: number
    AND?: ProductionMmlWhereInput | ProductionMmlWhereInput[]
    OR?: ProductionMmlWhereInput[]
    NOT?: ProductionMmlWhereInput | ProductionMmlWhereInput[]
    createdBy?: IntFilter<"ProductionMml"> | number
    isLocked?: BoolFilter<"ProductionMml"> | boolean
    createdAt?: DateTimeFilter<"ProductionMml"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMml"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    nodes?: ProductionMmlNodeListRelationFilter
    runs?: ProductionRunListRelationFilter
    suppliersWithPrimaryMml?: SupplierListRelationFilter
    priceListSuppliers?: PurchasePriceListSupplierListRelationFilter
    cuttingLines?: ProductionCuttingLineListRelationFilter
  }, "id" | "productId">

  export type ProductionMmlOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionMmlCountOrderByAggregateInput
    _avg?: ProductionMmlAvgOrderByAggregateInput
    _max?: ProductionMmlMaxOrderByAggregateInput
    _min?: ProductionMmlMinOrderByAggregateInput
    _sum?: ProductionMmlSumOrderByAggregateInput
  }

  export type ProductionMmlScalarWhereWithAggregatesInput = {
    AND?: ProductionMmlScalarWhereWithAggregatesInput | ProductionMmlScalarWhereWithAggregatesInput[]
    OR?: ProductionMmlScalarWhereWithAggregatesInput[]
    NOT?: ProductionMmlScalarWhereWithAggregatesInput | ProductionMmlScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionMml"> | number
    productId?: IntWithAggregatesFilter<"ProductionMml"> | number
    createdBy?: IntWithAggregatesFilter<"ProductionMml"> | number
    isLocked?: BoolWithAggregatesFilter<"ProductionMml"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductionMml"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionMml"> | Date | string
  }

  export type ProductionMmlNodeWhereInput = {
    AND?: ProductionMmlNodeWhereInput | ProductionMmlNodeWhereInput[]
    OR?: ProductionMmlNodeWhereInput[]
    NOT?: ProductionMmlNodeWhereInput | ProductionMmlNodeWhereInput[]
    id?: IntFilter<"ProductionMmlNode"> | number
    mmlId?: IntFilter<"ProductionMmlNode"> | number
    parentNodeId?: IntNullableFilter<"ProductionMmlNode"> | number | null
    productId?: IntFilter<"ProductionMmlNode"> | number
    sortOrder?: IntFilter<"ProductionMmlNode"> | number
    createdAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
    mml?: XOR<ProductionMmlScalarRelationFilter, ProductionMmlWhereInput>
    parentNode?: XOR<ProductionMmlNodeNullableScalarRelationFilter, ProductionMmlNodeWhereInput> | null
    children?: ProductionMmlNodeListRelationFilter
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    runValues?: ProductionRunValueListRelationFilter
  }

  export type ProductionMmlNodeOrderByWithRelationInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrderInput | SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mml?: ProductionMmlOrderByWithRelationInput
    parentNode?: ProductionMmlNodeOrderByWithRelationInput
    children?: ProductionMmlNodeOrderByRelationAggregateInput
    product?: ProductOrderByWithRelationInput
    runValues?: ProductionRunValueOrderByRelationAggregateInput
  }

  export type ProductionMmlNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductionMmlNodeWhereInput | ProductionMmlNodeWhereInput[]
    OR?: ProductionMmlNodeWhereInput[]
    NOT?: ProductionMmlNodeWhereInput | ProductionMmlNodeWhereInput[]
    mmlId?: IntFilter<"ProductionMmlNode"> | number
    parentNodeId?: IntNullableFilter<"ProductionMmlNode"> | number | null
    productId?: IntFilter<"ProductionMmlNode"> | number
    sortOrder?: IntFilter<"ProductionMmlNode"> | number
    createdAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
    mml?: XOR<ProductionMmlScalarRelationFilter, ProductionMmlWhereInput>
    parentNode?: XOR<ProductionMmlNodeNullableScalarRelationFilter, ProductionMmlNodeWhereInput> | null
    children?: ProductionMmlNodeListRelationFilter
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    runValues?: ProductionRunValueListRelationFilter
  }, "id">

  export type ProductionMmlNodeOrderByWithAggregationInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrderInput | SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionMmlNodeCountOrderByAggregateInput
    _avg?: ProductionMmlNodeAvgOrderByAggregateInput
    _max?: ProductionMmlNodeMaxOrderByAggregateInput
    _min?: ProductionMmlNodeMinOrderByAggregateInput
    _sum?: ProductionMmlNodeSumOrderByAggregateInput
  }

  export type ProductionMmlNodeScalarWhereWithAggregatesInput = {
    AND?: ProductionMmlNodeScalarWhereWithAggregatesInput | ProductionMmlNodeScalarWhereWithAggregatesInput[]
    OR?: ProductionMmlNodeScalarWhereWithAggregatesInput[]
    NOT?: ProductionMmlNodeScalarWhereWithAggregatesInput | ProductionMmlNodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionMmlNode"> | number
    mmlId?: IntWithAggregatesFilter<"ProductionMmlNode"> | number
    parentNodeId?: IntNullableWithAggregatesFilter<"ProductionMmlNode"> | number | null
    productId?: IntWithAggregatesFilter<"ProductionMmlNode"> | number
    sortOrder?: IntWithAggregatesFilter<"ProductionMmlNode"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductionMmlNode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionMmlNode"> | Date | string
  }

  export type ProductionRunWhereInput = {
    AND?: ProductionRunWhereInput | ProductionRunWhereInput[]
    OR?: ProductionRunWhereInput[]
    NOT?: ProductionRunWhereInput | ProductionRunWhereInput[]
    id?: IntFilter<"ProductionRun"> | number
    productId?: IntFilter<"ProductionRun"> | number
    mmlId?: IntFilter<"ProductionRun"> | number
    userId?: IntFilter<"ProductionRun"> | number
    productionDate?: DateTimeFilter<"ProductionRun"> | Date | string
    plannedWeight?: DecimalNullableFilter<"ProductionRun"> | Decimal | DecimalJsLike | number | string | null
    actualWeight?: DecimalNullableFilter<"ProductionRun"> | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFilter<"ProductionRun"> | boolean
    isHidden?: BoolFilter<"ProductionRun"> | boolean
    createdAt?: DateTimeFilter<"ProductionRun"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRun"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    mml?: XOR<ProductionMmlScalarRelationFilter, ProductionMmlWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    values?: ProductionRunValueListRelationFilter
  }

  export type ProductionRunOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    productionDate?: SortOrder
    plannedWeight?: SortOrderInput | SortOrder
    actualWeight?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    mml?: ProductionMmlOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    values?: ProductionRunValueOrderByRelationAggregateInput
  }

  export type ProductionRunWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductionRunWhereInput | ProductionRunWhereInput[]
    OR?: ProductionRunWhereInput[]
    NOT?: ProductionRunWhereInput | ProductionRunWhereInput[]
    productId?: IntFilter<"ProductionRun"> | number
    mmlId?: IntFilter<"ProductionRun"> | number
    userId?: IntFilter<"ProductionRun"> | number
    productionDate?: DateTimeFilter<"ProductionRun"> | Date | string
    plannedWeight?: DecimalNullableFilter<"ProductionRun"> | Decimal | DecimalJsLike | number | string | null
    actualWeight?: DecimalNullableFilter<"ProductionRun"> | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFilter<"ProductionRun"> | boolean
    isHidden?: BoolFilter<"ProductionRun"> | boolean
    createdAt?: DateTimeFilter<"ProductionRun"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRun"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    mml?: XOR<ProductionMmlScalarRelationFilter, ProductionMmlWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    values?: ProductionRunValueListRelationFilter
  }, "id">

  export type ProductionRunOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    productionDate?: SortOrder
    plannedWeight?: SortOrderInput | SortOrder
    actualWeight?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionRunCountOrderByAggregateInput
    _avg?: ProductionRunAvgOrderByAggregateInput
    _max?: ProductionRunMaxOrderByAggregateInput
    _min?: ProductionRunMinOrderByAggregateInput
    _sum?: ProductionRunSumOrderByAggregateInput
  }

  export type ProductionRunScalarWhereWithAggregatesInput = {
    AND?: ProductionRunScalarWhereWithAggregatesInput | ProductionRunScalarWhereWithAggregatesInput[]
    OR?: ProductionRunScalarWhereWithAggregatesInput[]
    NOT?: ProductionRunScalarWhereWithAggregatesInput | ProductionRunScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionRun"> | number
    productId?: IntWithAggregatesFilter<"ProductionRun"> | number
    mmlId?: IntWithAggregatesFilter<"ProductionRun"> | number
    userId?: IntWithAggregatesFilter<"ProductionRun"> | number
    productionDate?: DateTimeWithAggregatesFilter<"ProductionRun"> | Date | string
    plannedWeight?: DecimalNullableWithAggregatesFilter<"ProductionRun"> | Decimal | DecimalJsLike | number | string | null
    actualWeight?: DecimalNullableWithAggregatesFilter<"ProductionRun"> | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolWithAggregatesFilter<"ProductionRun"> | boolean
    isHidden?: BoolWithAggregatesFilter<"ProductionRun"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductionRun"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionRun"> | Date | string
  }

  export type ProductionRunValueWhereInput = {
    AND?: ProductionRunValueWhereInput | ProductionRunValueWhereInput[]
    OR?: ProductionRunValueWhereInput[]
    NOT?: ProductionRunValueWhereInput | ProductionRunValueWhereInput[]
    id?: IntFilter<"ProductionRunValue"> | number
    productionRunId?: IntFilter<"ProductionRunValue"> | number
    mmlNodeId?: IntFilter<"ProductionRunValue"> | number
    snapshotProductId?: IntNullableFilter<"ProductionRunValue"> | number | null
    value?: DecimalNullableFilter<"ProductionRunValue"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
    run?: XOR<ProductionRunScalarRelationFilter, ProductionRunWhereInput>
    node?: XOR<ProductionMmlNodeScalarRelationFilter, ProductionMmlNodeWhereInput>
    snapshotProduct?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }

  export type ProductionRunValueOrderByWithRelationInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    snapshotProductId?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    run?: ProductionRunOrderByWithRelationInput
    node?: ProductionMmlNodeOrderByWithRelationInput
    snapshotProduct?: ProductOrderByWithRelationInput
  }

  export type ProductionRunValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productionRunId_mmlNodeId?: ProductionRunValueProductionRunIdMmlNodeIdCompoundUniqueInput
    AND?: ProductionRunValueWhereInput | ProductionRunValueWhereInput[]
    OR?: ProductionRunValueWhereInput[]
    NOT?: ProductionRunValueWhereInput | ProductionRunValueWhereInput[]
    productionRunId?: IntFilter<"ProductionRunValue"> | number
    mmlNodeId?: IntFilter<"ProductionRunValue"> | number
    snapshotProductId?: IntNullableFilter<"ProductionRunValue"> | number | null
    value?: DecimalNullableFilter<"ProductionRunValue"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
    run?: XOR<ProductionRunScalarRelationFilter, ProductionRunWhereInput>
    node?: XOR<ProductionMmlNodeScalarRelationFilter, ProductionMmlNodeWhereInput>
    snapshotProduct?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }, "id" | "productionRunId_mmlNodeId">

  export type ProductionRunValueOrderByWithAggregationInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    snapshotProductId?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionRunValueCountOrderByAggregateInput
    _avg?: ProductionRunValueAvgOrderByAggregateInput
    _max?: ProductionRunValueMaxOrderByAggregateInput
    _min?: ProductionRunValueMinOrderByAggregateInput
    _sum?: ProductionRunValueSumOrderByAggregateInput
  }

  export type ProductionRunValueScalarWhereWithAggregatesInput = {
    AND?: ProductionRunValueScalarWhereWithAggregatesInput | ProductionRunValueScalarWhereWithAggregatesInput[]
    OR?: ProductionRunValueScalarWhereWithAggregatesInput[]
    NOT?: ProductionRunValueScalarWhereWithAggregatesInput | ProductionRunValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionRunValue"> | number
    productionRunId?: IntWithAggregatesFilter<"ProductionRunValue"> | number
    mmlNodeId?: IntWithAggregatesFilter<"ProductionRunValue"> | number
    snapshotProductId?: IntNullableWithAggregatesFilter<"ProductionRunValue"> | number | null
    value?: DecimalNullableWithAggregatesFilter<"ProductionRunValue"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductionRunValue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionRunValue"> | Date | string
  }

  export type PaymentTypeWhereInput = {
    AND?: PaymentTypeWhereInput | PaymentTypeWhereInput[]
    OR?: PaymentTypeWhereInput[]
    NOT?: PaymentTypeWhereInput | PaymentTypeWhereInput[]
    id?: IntFilter<"PaymentType"> | number
    name?: StringFilter<"PaymentType"> | string
    isDefault?: BoolFilter<"PaymentType"> | boolean
    isDisabled?: BoolFilter<"PaymentType"> | boolean
    createdAt?: DateTimeFilter<"PaymentType"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentType"> | Date | string
    purchaseItems?: PurchaseItemListRelationFilter
  }

  export type PaymentTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseItems?: PurchaseItemOrderByRelationAggregateInput
  }

  export type PaymentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PaymentTypeWhereInput | PaymentTypeWhereInput[]
    OR?: PaymentTypeWhereInput[]
    NOT?: PaymentTypeWhereInput | PaymentTypeWhereInput[]
    isDefault?: BoolFilter<"PaymentType"> | boolean
    isDisabled?: BoolFilter<"PaymentType"> | boolean
    createdAt?: DateTimeFilter<"PaymentType"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentType"> | Date | string
    purchaseItems?: PurchaseItemListRelationFilter
  }, "id" | "name">

  export type PaymentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentTypeCountOrderByAggregateInput
    _avg?: PaymentTypeAvgOrderByAggregateInput
    _max?: PaymentTypeMaxOrderByAggregateInput
    _min?: PaymentTypeMinOrderByAggregateInput
    _sum?: PaymentTypeSumOrderByAggregateInput
  }

  export type PaymentTypeScalarWhereWithAggregatesInput = {
    AND?: PaymentTypeScalarWhereWithAggregatesInput | PaymentTypeScalarWhereWithAggregatesInput[]
    OR?: PaymentTypeScalarWhereWithAggregatesInput[]
    NOT?: PaymentTypeScalarWhereWithAggregatesInput | PaymentTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentType"> | number
    name?: StringWithAggregatesFilter<"PaymentType"> | string
    isDefault?: BoolWithAggregatesFilter<"PaymentType"> | boolean
    isDisabled?: BoolWithAggregatesFilter<"PaymentType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentType"> | Date | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: IntFilter<"Purchase"> | number
    purchaseDate?: DateTimeFilter<"Purchase"> | Date | string
    totalAmount?: DecimalNullableFilter<"Purchase"> | Decimal | DecimalJsLike | number | string | null
    createdByUserId?: IntFilter<"Purchase"> | number
    isDisabled?: BoolFilter<"Purchase"> | boolean
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    suppliers?: PurchaseSupplierListRelationFilter
    items?: PurchaseItemListRelationFilter
    productionInputs?: ProductionInputListRelationFilter
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    purchaseDate?: SortOrder
    totalAmount?: SortOrderInput | SortOrder
    createdByUserId?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByUser?: UserOrderByWithRelationInput
    suppliers?: PurchaseSupplierOrderByRelationAggregateInput
    items?: PurchaseItemOrderByRelationAggregateInput
    productionInputs?: ProductionInputOrderByRelationAggregateInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    purchaseDate?: DateTimeFilter<"Purchase"> | Date | string
    totalAmount?: DecimalNullableFilter<"Purchase"> | Decimal | DecimalJsLike | number | string | null
    createdByUserId?: IntFilter<"Purchase"> | number
    isDisabled?: BoolFilter<"Purchase"> | boolean
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    suppliers?: PurchaseSupplierListRelationFilter
    items?: PurchaseItemListRelationFilter
    productionInputs?: ProductionInputListRelationFilter
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseDate?: SortOrder
    totalAmount?: SortOrderInput | SortOrder
    createdByUserId?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Purchase"> | number
    purchaseDate?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    totalAmount?: DecimalNullableWithAggregatesFilter<"Purchase"> | Decimal | DecimalJsLike | number | string | null
    createdByUserId?: IntWithAggregatesFilter<"Purchase"> | number
    isDisabled?: BoolWithAggregatesFilter<"Purchase"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type PurchaseSupplierWhereInput = {
    AND?: PurchaseSupplierWhereInput | PurchaseSupplierWhereInput[]
    OR?: PurchaseSupplierWhereInput[]
    NOT?: PurchaseSupplierWhereInput | PurchaseSupplierWhereInput[]
    id?: IntFilter<"PurchaseSupplier"> | number
    purchaseId?: IntFilter<"PurchaseSupplier"> | number
    supplierId?: IntFilter<"PurchaseSupplier"> | number
    createdAt?: DateTimeFilter<"PurchaseSupplier"> | Date | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type PurchaseSupplierOrderByWithRelationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    purchase?: PurchaseOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type PurchaseSupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    purchaseId_supplierId?: PurchaseSupplierPurchaseIdSupplierIdCompoundUniqueInput
    AND?: PurchaseSupplierWhereInput | PurchaseSupplierWhereInput[]
    OR?: PurchaseSupplierWhereInput[]
    NOT?: PurchaseSupplierWhereInput | PurchaseSupplierWhereInput[]
    purchaseId?: IntFilter<"PurchaseSupplier"> | number
    supplierId?: IntFilter<"PurchaseSupplier"> | number
    createdAt?: DateTimeFilter<"PurchaseSupplier"> | Date | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "id" | "purchaseId_supplierId">

  export type PurchaseSupplierOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    _count?: PurchaseSupplierCountOrderByAggregateInput
    _avg?: PurchaseSupplierAvgOrderByAggregateInput
    _max?: PurchaseSupplierMaxOrderByAggregateInput
    _min?: PurchaseSupplierMinOrderByAggregateInput
    _sum?: PurchaseSupplierSumOrderByAggregateInput
  }

  export type PurchaseSupplierScalarWhereWithAggregatesInput = {
    AND?: PurchaseSupplierScalarWhereWithAggregatesInput | PurchaseSupplierScalarWhereWithAggregatesInput[]
    OR?: PurchaseSupplierScalarWhereWithAggregatesInput[]
    NOT?: PurchaseSupplierScalarWhereWithAggregatesInput | PurchaseSupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseSupplier"> | number
    purchaseId?: IntWithAggregatesFilter<"PurchaseSupplier"> | number
    supplierId?: IntWithAggregatesFilter<"PurchaseSupplier"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseSupplier"> | Date | string
  }

  export type PurchaseItemWhereInput = {
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    id?: IntFilter<"PurchaseItem"> | number
    purchaseId?: IntFilter<"PurchaseItem"> | number
    supplierId?: IntFilter<"PurchaseItem"> | number
    productId?: IntFilter<"PurchaseItem"> | number
    price?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    qty?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    paymentTypeId?: IntNullableFilter<"PurchaseItem"> | number | null
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    paymentType?: XOR<PaymentTypeNullableScalarRelationFilter, PaymentTypeWhereInput> | null
    productionInputs?: ProductionInputListRelationFilter
  }

  export type PurchaseItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    qty?: SortOrder
    amount?: SortOrder
    paymentTypeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchase?: PurchaseOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    paymentType?: PaymentTypeOrderByWithRelationInput
    productionInputs?: ProductionInputOrderByRelationAggregateInput
  }

  export type PurchaseItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    purchaseId?: IntFilter<"PurchaseItem"> | number
    supplierId?: IntFilter<"PurchaseItem"> | number
    productId?: IntFilter<"PurchaseItem"> | number
    price?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    qty?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    paymentTypeId?: IntNullableFilter<"PurchaseItem"> | number | null
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    paymentType?: XOR<PaymentTypeNullableScalarRelationFilter, PaymentTypeWhereInput> | null
    productionInputs?: ProductionInputListRelationFilter
  }, "id">

  export type PurchaseItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    qty?: SortOrder
    amount?: SortOrder
    paymentTypeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseItemCountOrderByAggregateInput
    _avg?: PurchaseItemAvgOrderByAggregateInput
    _max?: PurchaseItemMaxOrderByAggregateInput
    _min?: PurchaseItemMinOrderByAggregateInput
    _sum?: PurchaseItemSumOrderByAggregateInput
  }

  export type PurchaseItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseItem"> | number
    purchaseId?: IntWithAggregatesFilter<"PurchaseItem"> | number
    supplierId?: IntWithAggregatesFilter<"PurchaseItem"> | number
    productId?: IntWithAggregatesFilter<"PurchaseItem"> | number
    price?: DecimalWithAggregatesFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    qty?: DecimalWithAggregatesFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalWithAggregatesFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    paymentTypeId?: IntNullableWithAggregatesFilter<"PurchaseItem"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseItem"> | Date | string
  }

  export type TelegramGroupWhereInput = {
    AND?: TelegramGroupWhereInput | TelegramGroupWhereInput[]
    OR?: TelegramGroupWhereInput[]
    NOT?: TelegramGroupWhereInput | TelegramGroupWhereInput[]
    id?: IntFilter<"TelegramGroup"> | number
    chatId?: StringFilter<"TelegramGroup"> | string
    title?: StringFilter<"TelegramGroup"> | string
    username?: StringNullableFilter<"TelegramGroup"> | string | null
    isActive?: BoolFilter<"TelegramGroup"> | boolean
    lastMessageId?: IntNullableFilter<"TelegramGroup"> | number | null
    parsePatterns?: JsonNullableFilter<"TelegramGroup">
    createdAt?: DateTimeFilter<"TelegramGroup"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramGroup"> | Date | string
    orderDrafts?: TelegramOrderDraftListRelationFilter
  }

  export type TelegramGroupOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    title?: SortOrder
    username?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastMessageId?: SortOrderInput | SortOrder
    parsePatterns?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderDrafts?: TelegramOrderDraftOrderByRelationAggregateInput
  }

  export type TelegramGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    chatId?: string
    AND?: TelegramGroupWhereInput | TelegramGroupWhereInput[]
    OR?: TelegramGroupWhereInput[]
    NOT?: TelegramGroupWhereInput | TelegramGroupWhereInput[]
    title?: StringFilter<"TelegramGroup"> | string
    username?: StringNullableFilter<"TelegramGroup"> | string | null
    isActive?: BoolFilter<"TelegramGroup"> | boolean
    lastMessageId?: IntNullableFilter<"TelegramGroup"> | number | null
    parsePatterns?: JsonNullableFilter<"TelegramGroup">
    createdAt?: DateTimeFilter<"TelegramGroup"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramGroup"> | Date | string
    orderDrafts?: TelegramOrderDraftListRelationFilter
  }, "id" | "chatId">

  export type TelegramGroupOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    title?: SortOrder
    username?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastMessageId?: SortOrderInput | SortOrder
    parsePatterns?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TelegramGroupCountOrderByAggregateInput
    _avg?: TelegramGroupAvgOrderByAggregateInput
    _max?: TelegramGroupMaxOrderByAggregateInput
    _min?: TelegramGroupMinOrderByAggregateInput
    _sum?: TelegramGroupSumOrderByAggregateInput
  }

  export type TelegramGroupScalarWhereWithAggregatesInput = {
    AND?: TelegramGroupScalarWhereWithAggregatesInput | TelegramGroupScalarWhereWithAggregatesInput[]
    OR?: TelegramGroupScalarWhereWithAggregatesInput[]
    NOT?: TelegramGroupScalarWhereWithAggregatesInput | TelegramGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TelegramGroup"> | number
    chatId?: StringWithAggregatesFilter<"TelegramGroup"> | string
    title?: StringWithAggregatesFilter<"TelegramGroup"> | string
    username?: StringNullableWithAggregatesFilter<"TelegramGroup"> | string | null
    isActive?: BoolWithAggregatesFilter<"TelegramGroup"> | boolean
    lastMessageId?: IntNullableWithAggregatesFilter<"TelegramGroup"> | number | null
    parsePatterns?: JsonNullableWithAggregatesFilter<"TelegramGroup">
    createdAt?: DateTimeWithAggregatesFilter<"TelegramGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TelegramGroup"> | Date | string
  }

  export type TelegramOrderDraftWhereInput = {
    AND?: TelegramOrderDraftWhereInput | TelegramOrderDraftWhereInput[]
    OR?: TelegramOrderDraftWhereInput[]
    NOT?: TelegramOrderDraftWhereInput | TelegramOrderDraftWhereInput[]
    id?: IntFilter<"TelegramOrderDraft"> | number
    groupId?: IntFilter<"TelegramOrderDraft"> | number
    messageId?: StringFilter<"TelegramOrderDraft"> | string
    messageText?: StringFilter<"TelegramOrderDraft"> | string
    messageDate?: DateTimeFilter<"TelegramOrderDraft"> | Date | string
    senderName?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    senderId?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    parsedOrderNumber?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    parsedCustomer?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    parsedAddress?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    status?: StringFilter<"TelegramOrderDraft"> | string
    transferredOrderId?: IntNullableFilter<"TelegramOrderDraft"> | number | null
    approvedBy?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    approvedAt?: DateTimeNullableFilter<"TelegramOrderDraft"> | Date | string | null
    rejectedReason?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    createdAt?: DateTimeFilter<"TelegramOrderDraft"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramOrderDraft"> | Date | string
    group?: XOR<TelegramGroupScalarRelationFilter, TelegramGroupWhereInput>
    items?: TelegramOrderDraftItemListRelationFilter
  }

  export type TelegramOrderDraftOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    messageId?: SortOrder
    messageText?: SortOrder
    messageDate?: SortOrder
    senderName?: SortOrderInput | SortOrder
    senderId?: SortOrderInput | SortOrder
    parsedOrderNumber?: SortOrderInput | SortOrder
    parsedCustomer?: SortOrderInput | SortOrder
    parsedAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    transferredOrderId?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    group?: TelegramGroupOrderByWithRelationInput
    items?: TelegramOrderDraftItemOrderByRelationAggregateInput
  }

  export type TelegramOrderDraftWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    groupId_messageId?: TelegramOrderDraftGroupIdMessageIdCompoundUniqueInput
    AND?: TelegramOrderDraftWhereInput | TelegramOrderDraftWhereInput[]
    OR?: TelegramOrderDraftWhereInput[]
    NOT?: TelegramOrderDraftWhereInput | TelegramOrderDraftWhereInput[]
    groupId?: IntFilter<"TelegramOrderDraft"> | number
    messageId?: StringFilter<"TelegramOrderDraft"> | string
    messageText?: StringFilter<"TelegramOrderDraft"> | string
    messageDate?: DateTimeFilter<"TelegramOrderDraft"> | Date | string
    senderName?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    senderId?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    parsedOrderNumber?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    parsedCustomer?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    parsedAddress?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    status?: StringFilter<"TelegramOrderDraft"> | string
    transferredOrderId?: IntNullableFilter<"TelegramOrderDraft"> | number | null
    approvedBy?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    approvedAt?: DateTimeNullableFilter<"TelegramOrderDraft"> | Date | string | null
    rejectedReason?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    createdAt?: DateTimeFilter<"TelegramOrderDraft"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramOrderDraft"> | Date | string
    group?: XOR<TelegramGroupScalarRelationFilter, TelegramGroupWhereInput>
    items?: TelegramOrderDraftItemListRelationFilter
  }, "id" | "groupId_messageId">

  export type TelegramOrderDraftOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    messageId?: SortOrder
    messageText?: SortOrder
    messageDate?: SortOrder
    senderName?: SortOrderInput | SortOrder
    senderId?: SortOrderInput | SortOrder
    parsedOrderNumber?: SortOrderInput | SortOrder
    parsedCustomer?: SortOrderInput | SortOrder
    parsedAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    transferredOrderId?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TelegramOrderDraftCountOrderByAggregateInput
    _avg?: TelegramOrderDraftAvgOrderByAggregateInput
    _max?: TelegramOrderDraftMaxOrderByAggregateInput
    _min?: TelegramOrderDraftMinOrderByAggregateInput
    _sum?: TelegramOrderDraftSumOrderByAggregateInput
  }

  export type TelegramOrderDraftScalarWhereWithAggregatesInput = {
    AND?: TelegramOrderDraftScalarWhereWithAggregatesInput | TelegramOrderDraftScalarWhereWithAggregatesInput[]
    OR?: TelegramOrderDraftScalarWhereWithAggregatesInput[]
    NOT?: TelegramOrderDraftScalarWhereWithAggregatesInput | TelegramOrderDraftScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TelegramOrderDraft"> | number
    groupId?: IntWithAggregatesFilter<"TelegramOrderDraft"> | number
    messageId?: StringWithAggregatesFilter<"TelegramOrderDraft"> | string
    messageText?: StringWithAggregatesFilter<"TelegramOrderDraft"> | string
    messageDate?: DateTimeWithAggregatesFilter<"TelegramOrderDraft"> | Date | string
    senderName?: StringNullableWithAggregatesFilter<"TelegramOrderDraft"> | string | null
    senderId?: StringNullableWithAggregatesFilter<"TelegramOrderDraft"> | string | null
    parsedOrderNumber?: StringNullableWithAggregatesFilter<"TelegramOrderDraft"> | string | null
    parsedCustomer?: StringNullableWithAggregatesFilter<"TelegramOrderDraft"> | string | null
    parsedAddress?: StringNullableWithAggregatesFilter<"TelegramOrderDraft"> | string | null
    status?: StringWithAggregatesFilter<"TelegramOrderDraft"> | string
    transferredOrderId?: IntNullableWithAggregatesFilter<"TelegramOrderDraft"> | number | null
    approvedBy?: StringNullableWithAggregatesFilter<"TelegramOrderDraft"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"TelegramOrderDraft"> | Date | string | null
    rejectedReason?: StringNullableWithAggregatesFilter<"TelegramOrderDraft"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TelegramOrderDraft"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TelegramOrderDraft"> | Date | string
  }

  export type TelegramOrderDraftItemWhereInput = {
    AND?: TelegramOrderDraftItemWhereInput | TelegramOrderDraftItemWhereInput[]
    OR?: TelegramOrderDraftItemWhereInput[]
    NOT?: TelegramOrderDraftItemWhereInput | TelegramOrderDraftItemWhereInput[]
    id?: IntFilter<"TelegramOrderDraftItem"> | number
    draftId?: IntFilter<"TelegramOrderDraftItem"> | number
    rawProductName?: StringFilter<"TelegramOrderDraftItem"> | string
    rawQuantity?: StringFilter<"TelegramOrderDraftItem"> | string
    rawPrice?: StringNullableFilter<"TelegramOrderDraftItem"> | string | null
    productId?: IntNullableFilter<"TelegramOrderDraftItem"> | number | null
    quantity?: FloatNullableFilter<"TelegramOrderDraftItem"> | number | null
    price?: DecimalNullableFilter<"TelegramOrderDraftItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"TelegramOrderDraftItem"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramOrderDraftItem"> | Date | string
    draft?: XOR<TelegramOrderDraftScalarRelationFilter, TelegramOrderDraftWhereInput>
  }

  export type TelegramOrderDraftItemOrderByWithRelationInput = {
    id?: SortOrder
    draftId?: SortOrder
    rawProductName?: SortOrder
    rawQuantity?: SortOrder
    rawPrice?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    draft?: TelegramOrderDraftOrderByWithRelationInput
  }

  export type TelegramOrderDraftItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TelegramOrderDraftItemWhereInput | TelegramOrderDraftItemWhereInput[]
    OR?: TelegramOrderDraftItemWhereInput[]
    NOT?: TelegramOrderDraftItemWhereInput | TelegramOrderDraftItemWhereInput[]
    draftId?: IntFilter<"TelegramOrderDraftItem"> | number
    rawProductName?: StringFilter<"TelegramOrderDraftItem"> | string
    rawQuantity?: StringFilter<"TelegramOrderDraftItem"> | string
    rawPrice?: StringNullableFilter<"TelegramOrderDraftItem"> | string | null
    productId?: IntNullableFilter<"TelegramOrderDraftItem"> | number | null
    quantity?: FloatNullableFilter<"TelegramOrderDraftItem"> | number | null
    price?: DecimalNullableFilter<"TelegramOrderDraftItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"TelegramOrderDraftItem"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramOrderDraftItem"> | Date | string
    draft?: XOR<TelegramOrderDraftScalarRelationFilter, TelegramOrderDraftWhereInput>
  }, "id">

  export type TelegramOrderDraftItemOrderByWithAggregationInput = {
    id?: SortOrder
    draftId?: SortOrder
    rawProductName?: SortOrder
    rawQuantity?: SortOrder
    rawPrice?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TelegramOrderDraftItemCountOrderByAggregateInput
    _avg?: TelegramOrderDraftItemAvgOrderByAggregateInput
    _max?: TelegramOrderDraftItemMaxOrderByAggregateInput
    _min?: TelegramOrderDraftItemMinOrderByAggregateInput
    _sum?: TelegramOrderDraftItemSumOrderByAggregateInput
  }

  export type TelegramOrderDraftItemScalarWhereWithAggregatesInput = {
    AND?: TelegramOrderDraftItemScalarWhereWithAggregatesInput | TelegramOrderDraftItemScalarWhereWithAggregatesInput[]
    OR?: TelegramOrderDraftItemScalarWhereWithAggregatesInput[]
    NOT?: TelegramOrderDraftItemScalarWhereWithAggregatesInput | TelegramOrderDraftItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TelegramOrderDraftItem"> | number
    draftId?: IntWithAggregatesFilter<"TelegramOrderDraftItem"> | number
    rawProductName?: StringWithAggregatesFilter<"TelegramOrderDraftItem"> | string
    rawQuantity?: StringWithAggregatesFilter<"TelegramOrderDraftItem"> | string
    rawPrice?: StringNullableWithAggregatesFilter<"TelegramOrderDraftItem"> | string | null
    productId?: IntNullableWithAggregatesFilter<"TelegramOrderDraftItem"> | number | null
    quantity?: FloatNullableWithAggregatesFilter<"TelegramOrderDraftItem"> | number | null
    price?: DecimalNullableWithAggregatesFilter<"TelegramOrderDraftItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TelegramOrderDraftItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TelegramOrderDraftItem"> | Date | string
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    id?: IntFilter<"Warehouse"> | number
    code?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    address?: StringFilter<"Warehouse"> | string
    phone?: StringNullableFilter<"Warehouse"> | string | null
    responsibleUserId?: IntNullableFilter<"Warehouse"> | number | null
    comment?: StringNullableFilter<"Warehouse"> | string | null
    isDisabled?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    responsibleUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    productionDocs?: ProductionDocListRelationFilter
    productionInputs?: ProductionInputListRelationFilter
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrderInput | SortOrder
    responsibleUserId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    responsibleUser?: UserOrderByWithRelationInput
    productionDocs?: ProductionDocOrderByRelationAggregateInput
    productionInputs?: ProductionInputOrderByRelationAggregateInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    name?: StringFilter<"Warehouse"> | string
    address?: StringFilter<"Warehouse"> | string
    phone?: StringNullableFilter<"Warehouse"> | string | null
    responsibleUserId?: IntNullableFilter<"Warehouse"> | number | null
    comment?: StringNullableFilter<"Warehouse"> | string | null
    isDisabled?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    responsibleUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    productionDocs?: ProductionDocListRelationFilter
    productionInputs?: ProductionInputListRelationFilter
  }, "id" | "code">

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrderInput | SortOrder
    responsibleUserId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _avg?: WarehouseAvgOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
    _sum?: WarehouseSumOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Warehouse"> | number
    code?: StringWithAggregatesFilter<"Warehouse"> | string
    name?: StringWithAggregatesFilter<"Warehouse"> | string
    address?: StringWithAggregatesFilter<"Warehouse"> | string
    phone?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    responsibleUserId?: IntNullableWithAggregatesFilter<"Warehouse"> | number | null
    comment?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    isDisabled?: BoolWithAggregatesFilter<"Warehouse"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
  }

  export type SvodHeaderWhereInput = {
    AND?: SvodHeaderWhereInput | SvodHeaderWhereInput[]
    OR?: SvodHeaderWhereInput[]
    NOT?: SvodHeaderWhereInput | SvodHeaderWhereInput[]
    id?: IntFilter<"SvodHeader"> | number
    svodDate?: DateTimeFilter<"SvodHeader"> | Date | string
    status?: StringFilter<"SvodHeader"> | string
    createdAt?: DateTimeFilter<"SvodHeader"> | Date | string
    createdBy?: StringFilter<"SvodHeader"> | string
    updatedAt?: DateTimeFilter<"SvodHeader"> | Date | string
    updatedBy?: StringNullableFilter<"SvodHeader"> | string | null
    lines?: SvodLineListRelationFilter
    supplierCols?: SvodSupplierColListRelationFilter
    supplierValues?: SvodSupplierValueListRelationFilter
  }

  export type SvodHeaderOrderByWithRelationInput = {
    id?: SortOrder
    svodDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    lines?: SvodLineOrderByRelationAggregateInput
    supplierCols?: SvodSupplierColOrderByRelationAggregateInput
    supplierValues?: SvodSupplierValueOrderByRelationAggregateInput
  }

  export type SvodHeaderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    svodDate?: Date | string
    AND?: SvodHeaderWhereInput | SvodHeaderWhereInput[]
    OR?: SvodHeaderWhereInput[]
    NOT?: SvodHeaderWhereInput | SvodHeaderWhereInput[]
    status?: StringFilter<"SvodHeader"> | string
    createdAt?: DateTimeFilter<"SvodHeader"> | Date | string
    createdBy?: StringFilter<"SvodHeader"> | string
    updatedAt?: DateTimeFilter<"SvodHeader"> | Date | string
    updatedBy?: StringNullableFilter<"SvodHeader"> | string | null
    lines?: SvodLineListRelationFilter
    supplierCols?: SvodSupplierColListRelationFilter
    supplierValues?: SvodSupplierValueListRelationFilter
  }, "id" | "svodDate">

  export type SvodHeaderOrderByWithAggregationInput = {
    id?: SortOrder
    svodDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SvodHeaderCountOrderByAggregateInput
    _avg?: SvodHeaderAvgOrderByAggregateInput
    _max?: SvodHeaderMaxOrderByAggregateInput
    _min?: SvodHeaderMinOrderByAggregateInput
    _sum?: SvodHeaderSumOrderByAggregateInput
  }

  export type SvodHeaderScalarWhereWithAggregatesInput = {
    AND?: SvodHeaderScalarWhereWithAggregatesInput | SvodHeaderScalarWhereWithAggregatesInput[]
    OR?: SvodHeaderScalarWhereWithAggregatesInput[]
    NOT?: SvodHeaderScalarWhereWithAggregatesInput | SvodHeaderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SvodHeader"> | number
    svodDate?: DateTimeWithAggregatesFilter<"SvodHeader"> | Date | string
    status?: StringWithAggregatesFilter<"SvodHeader"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SvodHeader"> | Date | string
    createdBy?: StringWithAggregatesFilter<"SvodHeader"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"SvodHeader"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"SvodHeader"> | string | null
  }

  export type SvodLineWhereInput = {
    AND?: SvodLineWhereInput | SvodLineWhereInput[]
    OR?: SvodLineWhereInput[]
    NOT?: SvodLineWhereInput | SvodLineWhereInput[]
    id?: IntFilter<"SvodLine"> | number
    svodId?: IntFilter<"SvodLine"> | number
    productId?: IntFilter<"SvodLine"> | number
    shortName?: StringNullableFilter<"SvodLine"> | string | null
    category?: StringNullableFilter<"SvodLine"> | string | null
    coefficient?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFilter<"SvodLine"> | boolean
    afterPurchaseStock?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    weightToShip?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    underOver?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFilter<"SvodLine"> | number
    createdAt?: DateTimeFilter<"SvodLine"> | Date | string
    updatedAt?: DateTimeFilter<"SvodLine"> | Date | string
    svod?: XOR<SvodHeaderScalarRelationFilter, SvodHeaderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type SvodLineOrderByWithRelationInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    shortName?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    coefficient?: SortOrderInput | SortOrder
    orderQty?: SortOrder
    productionInQty?: SortOrder
    openingStock?: SortOrder
    openingStockIsManual?: SortOrder
    afterPurchaseStock?: SortOrderInput | SortOrder
    afterShipmentStock?: SortOrderInput | SortOrder
    qtyToShip?: SortOrderInput | SortOrder
    factMinusWaste?: SortOrderInput | SortOrder
    weightToShip?: SortOrderInput | SortOrder
    planFactDiff?: SortOrderInput | SortOrder
    underOver?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    svod?: SvodHeaderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type SvodLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    svodId_productId?: SvodLineSvodIdProductIdCompoundUniqueInput
    AND?: SvodLineWhereInput | SvodLineWhereInput[]
    OR?: SvodLineWhereInput[]
    NOT?: SvodLineWhereInput | SvodLineWhereInput[]
    svodId?: IntFilter<"SvodLine"> | number
    productId?: IntFilter<"SvodLine"> | number
    shortName?: StringNullableFilter<"SvodLine"> | string | null
    category?: StringNullableFilter<"SvodLine"> | string | null
    coefficient?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFilter<"SvodLine"> | boolean
    afterPurchaseStock?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    weightToShip?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    underOver?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFilter<"SvodLine"> | number
    createdAt?: DateTimeFilter<"SvodLine"> | Date | string
    updatedAt?: DateTimeFilter<"SvodLine"> | Date | string
    svod?: XOR<SvodHeaderScalarRelationFilter, SvodHeaderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "svodId_productId">

  export type SvodLineOrderByWithAggregationInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    shortName?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    coefficient?: SortOrderInput | SortOrder
    orderQty?: SortOrder
    productionInQty?: SortOrder
    openingStock?: SortOrder
    openingStockIsManual?: SortOrder
    afterPurchaseStock?: SortOrderInput | SortOrder
    afterShipmentStock?: SortOrderInput | SortOrder
    qtyToShip?: SortOrderInput | SortOrder
    factMinusWaste?: SortOrderInput | SortOrder
    weightToShip?: SortOrderInput | SortOrder
    planFactDiff?: SortOrderInput | SortOrder
    underOver?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SvodLineCountOrderByAggregateInput
    _avg?: SvodLineAvgOrderByAggregateInput
    _max?: SvodLineMaxOrderByAggregateInput
    _min?: SvodLineMinOrderByAggregateInput
    _sum?: SvodLineSumOrderByAggregateInput
  }

  export type SvodLineScalarWhereWithAggregatesInput = {
    AND?: SvodLineScalarWhereWithAggregatesInput | SvodLineScalarWhereWithAggregatesInput[]
    OR?: SvodLineScalarWhereWithAggregatesInput[]
    NOT?: SvodLineScalarWhereWithAggregatesInput | SvodLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SvodLine"> | number
    svodId?: IntWithAggregatesFilter<"SvodLine"> | number
    productId?: IntWithAggregatesFilter<"SvodLine"> | number
    shortName?: StringNullableWithAggregatesFilter<"SvodLine"> | string | null
    category?: StringNullableWithAggregatesFilter<"SvodLine"> | string | null
    coefficient?: DecimalNullableWithAggregatesFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalWithAggregatesFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalWithAggregatesFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalWithAggregatesFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolWithAggregatesFilter<"SvodLine"> | boolean
    afterPurchaseStock?: DecimalNullableWithAggregatesFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: DecimalNullableWithAggregatesFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: DecimalNullableWithAggregatesFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: DecimalNullableWithAggregatesFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    weightToShip?: DecimalNullableWithAggregatesFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: DecimalNullableWithAggregatesFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    underOver?: DecimalNullableWithAggregatesFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntWithAggregatesFilter<"SvodLine"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SvodLine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SvodLine"> | Date | string
  }

  export type SvodSupplierColWhereInput = {
    AND?: SvodSupplierColWhereInput | SvodSupplierColWhereInput[]
    OR?: SvodSupplierColWhereInput[]
    NOT?: SvodSupplierColWhereInput | SvodSupplierColWhereInput[]
    id?: IntFilter<"SvodSupplierCol"> | number
    svodId?: IntFilter<"SvodSupplierCol"> | number
    colIndex?: IntFilter<"SvodSupplierCol"> | number
    supplierId?: IntFilter<"SvodSupplierCol"> | number
    supplierName?: StringFilter<"SvodSupplierCol"> | string
    totalPurchase?: DecimalFilter<"SvodSupplierCol"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SvodSupplierCol"> | Date | string
    svod?: XOR<SvodHeaderScalarRelationFilter, SvodHeaderWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type SvodSupplierColOrderByWithRelationInput = {
    id?: SortOrder
    svodId?: SortOrder
    colIndex?: SortOrder
    supplierId?: SortOrder
    supplierName?: SortOrder
    totalPurchase?: SortOrder
    createdAt?: SortOrder
    svod?: SvodHeaderOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type SvodSupplierColWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    svodId_colIndex?: SvodSupplierColSvodIdColIndexCompoundUniqueInput
    svodId_supplierId?: SvodSupplierColSvodIdSupplierIdCompoundUniqueInput
    AND?: SvodSupplierColWhereInput | SvodSupplierColWhereInput[]
    OR?: SvodSupplierColWhereInput[]
    NOT?: SvodSupplierColWhereInput | SvodSupplierColWhereInput[]
    svodId?: IntFilter<"SvodSupplierCol"> | number
    colIndex?: IntFilter<"SvodSupplierCol"> | number
    supplierId?: IntFilter<"SvodSupplierCol"> | number
    supplierName?: StringFilter<"SvodSupplierCol"> | string
    totalPurchase?: DecimalFilter<"SvodSupplierCol"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SvodSupplierCol"> | Date | string
    svod?: XOR<SvodHeaderScalarRelationFilter, SvodHeaderWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "id" | "svodId_colIndex" | "svodId_supplierId">

  export type SvodSupplierColOrderByWithAggregationInput = {
    id?: SortOrder
    svodId?: SortOrder
    colIndex?: SortOrder
    supplierId?: SortOrder
    supplierName?: SortOrder
    totalPurchase?: SortOrder
    createdAt?: SortOrder
    _count?: SvodSupplierColCountOrderByAggregateInput
    _avg?: SvodSupplierColAvgOrderByAggregateInput
    _max?: SvodSupplierColMaxOrderByAggregateInput
    _min?: SvodSupplierColMinOrderByAggregateInput
    _sum?: SvodSupplierColSumOrderByAggregateInput
  }

  export type SvodSupplierColScalarWhereWithAggregatesInput = {
    AND?: SvodSupplierColScalarWhereWithAggregatesInput | SvodSupplierColScalarWhereWithAggregatesInput[]
    OR?: SvodSupplierColScalarWhereWithAggregatesInput[]
    NOT?: SvodSupplierColScalarWhereWithAggregatesInput | SvodSupplierColScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SvodSupplierCol"> | number
    svodId?: IntWithAggregatesFilter<"SvodSupplierCol"> | number
    colIndex?: IntWithAggregatesFilter<"SvodSupplierCol"> | number
    supplierId?: IntWithAggregatesFilter<"SvodSupplierCol"> | number
    supplierName?: StringWithAggregatesFilter<"SvodSupplierCol"> | string
    totalPurchase?: DecimalWithAggregatesFilter<"SvodSupplierCol"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SvodSupplierCol"> | Date | string
  }

  export type SvodSupplierValueWhereInput = {
    AND?: SvodSupplierValueWhereInput | SvodSupplierValueWhereInput[]
    OR?: SvodSupplierValueWhereInput[]
    NOT?: SvodSupplierValueWhereInput | SvodSupplierValueWhereInput[]
    id?: IntFilter<"SvodSupplierValue"> | number
    svodId?: IntFilter<"SvodSupplierValue"> | number
    productId?: IntFilter<"SvodSupplierValue"> | number
    supplierId?: IntFilter<"SvodSupplierValue"> | number
    purchaseQty?: DecimalFilter<"SvodSupplierValue"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SvodSupplierValue"> | Date | string
    updatedAt?: DateTimeFilter<"SvodSupplierValue"> | Date | string
    svod?: XOR<SvodHeaderScalarRelationFilter, SvodHeaderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type SvodSupplierValueOrderByWithRelationInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    supplierId?: SortOrder
    purchaseQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    svod?: SvodHeaderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type SvodSupplierValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    svodId_productId_supplierId?: SvodSupplierValueSvodIdProductIdSupplierIdCompoundUniqueInput
    AND?: SvodSupplierValueWhereInput | SvodSupplierValueWhereInput[]
    OR?: SvodSupplierValueWhereInput[]
    NOT?: SvodSupplierValueWhereInput | SvodSupplierValueWhereInput[]
    svodId?: IntFilter<"SvodSupplierValue"> | number
    productId?: IntFilter<"SvodSupplierValue"> | number
    supplierId?: IntFilter<"SvodSupplierValue"> | number
    purchaseQty?: DecimalFilter<"SvodSupplierValue"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SvodSupplierValue"> | Date | string
    updatedAt?: DateTimeFilter<"SvodSupplierValue"> | Date | string
    svod?: XOR<SvodHeaderScalarRelationFilter, SvodHeaderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "id" | "svodId_productId_supplierId">

  export type SvodSupplierValueOrderByWithAggregationInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    supplierId?: SortOrder
    purchaseQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SvodSupplierValueCountOrderByAggregateInput
    _avg?: SvodSupplierValueAvgOrderByAggregateInput
    _max?: SvodSupplierValueMaxOrderByAggregateInput
    _min?: SvodSupplierValueMinOrderByAggregateInput
    _sum?: SvodSupplierValueSumOrderByAggregateInput
  }

  export type SvodSupplierValueScalarWhereWithAggregatesInput = {
    AND?: SvodSupplierValueScalarWhereWithAggregatesInput | SvodSupplierValueScalarWhereWithAggregatesInput[]
    OR?: SvodSupplierValueScalarWhereWithAggregatesInput[]
    NOT?: SvodSupplierValueScalarWhereWithAggregatesInput | SvodSupplierValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SvodSupplierValue"> | number
    svodId?: IntWithAggregatesFilter<"SvodSupplierValue"> | number
    productId?: IntWithAggregatesFilter<"SvodSupplierValue"> | number
    supplierId?: IntWithAggregatesFilter<"SvodSupplierValue"> | number
    purchaseQty?: DecimalWithAggregatesFilter<"SvodSupplierValue"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SvodSupplierValue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SvodSupplierValue"> | Date | string
  }

  export type ProductionDocWhereInput = {
    AND?: ProductionDocWhereInput | ProductionDocWhereInput[]
    OR?: ProductionDocWhereInput[]
    NOT?: ProductionDocWhereInput | ProductionDocWhereInput[]
    id?: IntFilter<"ProductionDoc"> | number
    date?: DateTimeFilter<"ProductionDoc"> | Date | string
    warehouseId?: IntFilter<"ProductionDoc"> | number
    status?: StringFilter<"ProductionDoc"> | string
    createdByUserId?: IntFilter<"ProductionDoc"> | number
    createdAt?: DateTimeFilter<"ProductionDoc"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionDoc"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    inputs?: ProductionInputListRelationFilter
    outputs?: ProductionOutputListRelationFilter
    cuttingLines?: ProductionCuttingLineListRelationFilter
  }

  export type ProductionDocOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    inputs?: ProductionInputOrderByRelationAggregateInput
    outputs?: ProductionOutputOrderByRelationAggregateInput
    cuttingLines?: ProductionCuttingLineOrderByRelationAggregateInput
  }

  export type ProductionDocWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    date_warehouseId?: ProductionDocDateWarehouseIdCompoundUniqueInput
    AND?: ProductionDocWhereInput | ProductionDocWhereInput[]
    OR?: ProductionDocWhereInput[]
    NOT?: ProductionDocWhereInput | ProductionDocWhereInput[]
    date?: DateTimeFilter<"ProductionDoc"> | Date | string
    warehouseId?: IntFilter<"ProductionDoc"> | number
    status?: StringFilter<"ProductionDoc"> | string
    createdByUserId?: IntFilter<"ProductionDoc"> | number
    createdAt?: DateTimeFilter<"ProductionDoc"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionDoc"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    inputs?: ProductionInputListRelationFilter
    outputs?: ProductionOutputListRelationFilter
    cuttingLines?: ProductionCuttingLineListRelationFilter
  }, "id" | "date_warehouseId">

  export type ProductionDocOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionDocCountOrderByAggregateInput
    _avg?: ProductionDocAvgOrderByAggregateInput
    _max?: ProductionDocMaxOrderByAggregateInput
    _min?: ProductionDocMinOrderByAggregateInput
    _sum?: ProductionDocSumOrderByAggregateInput
  }

  export type ProductionDocScalarWhereWithAggregatesInput = {
    AND?: ProductionDocScalarWhereWithAggregatesInput | ProductionDocScalarWhereWithAggregatesInput[]
    OR?: ProductionDocScalarWhereWithAggregatesInput[]
    NOT?: ProductionDocScalarWhereWithAggregatesInput | ProductionDocScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionDoc"> | number
    date?: DateTimeWithAggregatesFilter<"ProductionDoc"> | Date | string
    warehouseId?: IntWithAggregatesFilter<"ProductionDoc"> | number
    status?: StringWithAggregatesFilter<"ProductionDoc"> | string
    createdByUserId?: IntWithAggregatesFilter<"ProductionDoc"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductionDoc"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionDoc"> | Date | string
  }

  export type ProductionInputWhereInput = {
    AND?: ProductionInputWhereInput | ProductionInputWhereInput[]
    OR?: ProductionInputWhereInput[]
    NOT?: ProductionInputWhereInput | ProductionInputWhereInput[]
    id?: IntFilter<"ProductionInput"> | number
    productionDocId?: IntFilter<"ProductionInput"> | number
    purchaseId?: IntFilter<"ProductionInput"> | number
    purchaseItemId?: IntFilter<"ProductionInput"> | number
    productId?: IntFilter<"ProductionInput"> | number
    warehouseId?: IntFilter<"ProductionInput"> | number
    qtyIn?: DecimalFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string
    priceIn?: DecimalNullableFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFilter<"ProductionInput"> | Date | string
    loadedByUserId?: IntFilter<"ProductionInput"> | number
    productionDoc?: XOR<ProductionDocScalarRelationFilter, ProductionDocWhereInput>
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    purchaseItem?: XOR<PurchaseItemScalarRelationFilter, PurchaseItemWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    loadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    cuttingLines?: ProductionCuttingLineListRelationFilter
  }

  export type ProductionInputOrderByWithRelationInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    purchaseId?: SortOrder
    purchaseItemId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    qtyIn?: SortOrder
    qtyUsed?: SortOrder
    priceIn?: SortOrderInput | SortOrder
    loadedAt?: SortOrder
    loadedByUserId?: SortOrder
    productionDoc?: ProductionDocOrderByWithRelationInput
    purchase?: PurchaseOrderByWithRelationInput
    purchaseItem?: PurchaseItemOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    loadedBy?: UserOrderByWithRelationInput
    cuttingLines?: ProductionCuttingLineOrderByRelationAggregateInput
  }

  export type ProductionInputWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productionDocId_purchaseItemId?: ProductionInputProductionDocIdPurchaseItemIdCompoundUniqueInput
    AND?: ProductionInputWhereInput | ProductionInputWhereInput[]
    OR?: ProductionInputWhereInput[]
    NOT?: ProductionInputWhereInput | ProductionInputWhereInput[]
    productionDocId?: IntFilter<"ProductionInput"> | number
    purchaseId?: IntFilter<"ProductionInput"> | number
    purchaseItemId?: IntFilter<"ProductionInput"> | number
    productId?: IntFilter<"ProductionInput"> | number
    warehouseId?: IntFilter<"ProductionInput"> | number
    qtyIn?: DecimalFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string
    priceIn?: DecimalNullableFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFilter<"ProductionInput"> | Date | string
    loadedByUserId?: IntFilter<"ProductionInput"> | number
    productionDoc?: XOR<ProductionDocScalarRelationFilter, ProductionDocWhereInput>
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    purchaseItem?: XOR<PurchaseItemScalarRelationFilter, PurchaseItemWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    loadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    cuttingLines?: ProductionCuttingLineListRelationFilter
  }, "id" | "productionDocId_purchaseItemId">

  export type ProductionInputOrderByWithAggregationInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    purchaseId?: SortOrder
    purchaseItemId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    qtyIn?: SortOrder
    qtyUsed?: SortOrder
    priceIn?: SortOrderInput | SortOrder
    loadedAt?: SortOrder
    loadedByUserId?: SortOrder
    _count?: ProductionInputCountOrderByAggregateInput
    _avg?: ProductionInputAvgOrderByAggregateInput
    _max?: ProductionInputMaxOrderByAggregateInput
    _min?: ProductionInputMinOrderByAggregateInput
    _sum?: ProductionInputSumOrderByAggregateInput
  }

  export type ProductionInputScalarWhereWithAggregatesInput = {
    AND?: ProductionInputScalarWhereWithAggregatesInput | ProductionInputScalarWhereWithAggregatesInput[]
    OR?: ProductionInputScalarWhereWithAggregatesInput[]
    NOT?: ProductionInputScalarWhereWithAggregatesInput | ProductionInputScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionInput"> | number
    productionDocId?: IntWithAggregatesFilter<"ProductionInput"> | number
    purchaseId?: IntWithAggregatesFilter<"ProductionInput"> | number
    purchaseItemId?: IntWithAggregatesFilter<"ProductionInput"> | number
    productId?: IntWithAggregatesFilter<"ProductionInput"> | number
    warehouseId?: IntWithAggregatesFilter<"ProductionInput"> | number
    qtyIn?: DecimalWithAggregatesFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalWithAggregatesFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string
    priceIn?: DecimalNullableWithAggregatesFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeWithAggregatesFilter<"ProductionInput"> | Date | string
    loadedByUserId?: IntWithAggregatesFilter<"ProductionInput"> | number
  }

  export type ProductionOutputWhereInput = {
    AND?: ProductionOutputWhereInput | ProductionOutputWhereInput[]
    OR?: ProductionOutputWhereInput[]
    NOT?: ProductionOutputWhereInput | ProductionOutputWhereInput[]
    id?: IntFilter<"ProductionOutput"> | number
    productionDocId?: IntFilter<"ProductionOutput"> | number
    productId?: IntFilter<"ProductionOutput"> | number
    qtyOut?: DecimalFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"ProductionOutput"> | string
    costTotal?: DecimalNullableFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: DecimalNullableFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductionOutput"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionOutput"> | Date | string
    productionDoc?: XOR<ProductionDocScalarRelationFilter, ProductionDocWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductionOutputOrderByWithRelationInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productId?: SortOrder
    qtyOut?: SortOrder
    uom?: SortOrder
    costTotal?: SortOrderInput | SortOrder
    costPerUnit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productionDoc?: ProductionDocOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProductionOutputWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productionDocId_productId?: ProductionOutputProductionDocIdProductIdCompoundUniqueInput
    AND?: ProductionOutputWhereInput | ProductionOutputWhereInput[]
    OR?: ProductionOutputWhereInput[]
    NOT?: ProductionOutputWhereInput | ProductionOutputWhereInput[]
    productionDocId?: IntFilter<"ProductionOutput"> | number
    productId?: IntFilter<"ProductionOutput"> | number
    qtyOut?: DecimalFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"ProductionOutput"> | string
    costTotal?: DecimalNullableFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: DecimalNullableFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductionOutput"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionOutput"> | Date | string
    productionDoc?: XOR<ProductionDocScalarRelationFilter, ProductionDocWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "productionDocId_productId">

  export type ProductionOutputOrderByWithAggregationInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productId?: SortOrder
    qtyOut?: SortOrder
    uom?: SortOrder
    costTotal?: SortOrderInput | SortOrder
    costPerUnit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionOutputCountOrderByAggregateInput
    _avg?: ProductionOutputAvgOrderByAggregateInput
    _max?: ProductionOutputMaxOrderByAggregateInput
    _min?: ProductionOutputMinOrderByAggregateInput
    _sum?: ProductionOutputSumOrderByAggregateInput
  }

  export type ProductionOutputScalarWhereWithAggregatesInput = {
    AND?: ProductionOutputScalarWhereWithAggregatesInput | ProductionOutputScalarWhereWithAggregatesInput[]
    OR?: ProductionOutputScalarWhereWithAggregatesInput[]
    NOT?: ProductionOutputScalarWhereWithAggregatesInput | ProductionOutputScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionOutput"> | number
    productionDocId?: IntWithAggregatesFilter<"ProductionOutput"> | number
    productId?: IntWithAggregatesFilter<"ProductionOutput"> | number
    qtyOut?: DecimalWithAggregatesFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string
    uom?: StringWithAggregatesFilter<"ProductionOutput"> | string
    costTotal?: DecimalNullableWithAggregatesFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: DecimalNullableWithAggregatesFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductionOutput"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionOutput"> | Date | string
  }

  export type ProductionCuttingLineWhereInput = {
    AND?: ProductionCuttingLineWhereInput | ProductionCuttingLineWhereInput[]
    OR?: ProductionCuttingLineWhereInput[]
    NOT?: ProductionCuttingLineWhereInput | ProductionCuttingLineWhereInput[]
    id?: IntFilter<"ProductionCuttingLine"> | number
    productionDocId?: IntFilter<"ProductionCuttingLine"> | number
    productionInputId?: IntFilter<"ProductionCuttingLine"> | number
    mmlId?: IntFilter<"ProductionCuttingLine"> | number
    outProductId?: IntFilter<"ProductionCuttingLine"> | number
    qtyOut?: DecimalFilter<"ProductionCuttingLine"> | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFilter<"ProductionCuttingLine"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ProductionCuttingLine"> | Date | string
    createdByUserId?: IntFilter<"ProductionCuttingLine"> | number
    productionDoc?: XOR<ProductionDocScalarRelationFilter, ProductionDocWhereInput>
    productionInput?: XOR<ProductionInputScalarRelationFilter, ProductionInputWhereInput>
    mml?: XOR<ProductionMmlScalarRelationFilter, ProductionMmlWhereInput>
    outProduct?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProductionCuttingLineOrderByWithRelationInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productionInputId?: SortOrder
    mmlId?: SortOrder
    outProductId?: SortOrder
    qtyOut?: SortOrder
    qtyInConsumed?: SortOrder
    createdAt?: SortOrder
    createdByUserId?: SortOrder
    productionDoc?: ProductionDocOrderByWithRelationInput
    productionInput?: ProductionInputOrderByWithRelationInput
    mml?: ProductionMmlOrderByWithRelationInput
    outProduct?: ProductOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type ProductionCuttingLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductionCuttingLineWhereInput | ProductionCuttingLineWhereInput[]
    OR?: ProductionCuttingLineWhereInput[]
    NOT?: ProductionCuttingLineWhereInput | ProductionCuttingLineWhereInput[]
    productionDocId?: IntFilter<"ProductionCuttingLine"> | number
    productionInputId?: IntFilter<"ProductionCuttingLine"> | number
    mmlId?: IntFilter<"ProductionCuttingLine"> | number
    outProductId?: IntFilter<"ProductionCuttingLine"> | number
    qtyOut?: DecimalFilter<"ProductionCuttingLine"> | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFilter<"ProductionCuttingLine"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ProductionCuttingLine"> | Date | string
    createdByUserId?: IntFilter<"ProductionCuttingLine"> | number
    productionDoc?: XOR<ProductionDocScalarRelationFilter, ProductionDocWhereInput>
    productionInput?: XOR<ProductionInputScalarRelationFilter, ProductionInputWhereInput>
    mml?: XOR<ProductionMmlScalarRelationFilter, ProductionMmlWhereInput>
    outProduct?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ProductionCuttingLineOrderByWithAggregationInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productionInputId?: SortOrder
    mmlId?: SortOrder
    outProductId?: SortOrder
    qtyOut?: SortOrder
    qtyInConsumed?: SortOrder
    createdAt?: SortOrder
    createdByUserId?: SortOrder
    _count?: ProductionCuttingLineCountOrderByAggregateInput
    _avg?: ProductionCuttingLineAvgOrderByAggregateInput
    _max?: ProductionCuttingLineMaxOrderByAggregateInput
    _min?: ProductionCuttingLineMinOrderByAggregateInput
    _sum?: ProductionCuttingLineSumOrderByAggregateInput
  }

  export type ProductionCuttingLineScalarWhereWithAggregatesInput = {
    AND?: ProductionCuttingLineScalarWhereWithAggregatesInput | ProductionCuttingLineScalarWhereWithAggregatesInput[]
    OR?: ProductionCuttingLineScalarWhereWithAggregatesInput[]
    NOT?: ProductionCuttingLineScalarWhereWithAggregatesInput | ProductionCuttingLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionCuttingLine"> | number
    productionDocId?: IntWithAggregatesFilter<"ProductionCuttingLine"> | number
    productionInputId?: IntWithAggregatesFilter<"ProductionCuttingLine"> | number
    mmlId?: IntWithAggregatesFilter<"ProductionCuttingLine"> | number
    outProductId?: IntWithAggregatesFilter<"ProductionCuttingLine"> | number
    qtyOut?: DecimalWithAggregatesFilter<"ProductionCuttingLine"> | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalWithAggregatesFilter<"ProductionCuttingLine"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductionCuttingLine"> | Date | string
    createdByUserId?: IntWithAggregatesFilter<"ProductionCuttingLine"> | number
  }

  export type UserCreateInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffUncheckedCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocUncheckedCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUncheckedUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUncheckedUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistrictCreateInput = {
    code: string
    name: string
    customers?: CustomerCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    customers?: CustomerUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customers?: CustomerUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customers?: CustomerUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictCreateManyInput = {
    id?: number
    code: string
    name: string
  }

  export type DistrictUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DistrictUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerCreateInput = {
    code: string
    name: string
    phone?: string | null
    customers?: CustomerCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    phone?: string | null
    customers?: CustomerUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ManagerCreateManyInput = {
    id?: number
    code: string
    name: string
    phone?: string | null
  }

  export type ManagerUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: DistrictCreateNestedOneWithoutCustomersInput
    manager?: ManagerCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneWithoutCustomersNestedInput
    manager?: ManagerUpdateOneWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductCreateInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerProductsInput
    product: ProductCreateNestedOneWithoutCustomerProductsInput
  }

  export type CustomerProductUncheckedCreateInput = {
    id?: number
    customerId: number
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductUpdateInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutCustomerProductsNestedInput
  }

  export type CustomerProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductCreateManyInput = {
    id?: number
    customerId: number
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductUpdateManyMutationInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierProductCreateInput = {
    product: ProductCreateNestedOneWithoutSuppliersInput
    supplier: SupplierCreateNestedOneWithoutProductsInput
  }

  export type SupplierProductUncheckedCreateInput = {
    supplierId: number
    productId: number
  }

  export type SupplierProductUpdateInput = {
    product?: ProductUpdateOneRequiredWithoutSuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutProductsNestedInput
  }

  export type SupplierProductUncheckedUpdateInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierProductCreateManyInput = {
    supplierId: number
    productId: number
  }

  export type SupplierProductUpdateManyMutationInput = {

  }

  export type SupplierProductUncheckedUpdateManyInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderCreateInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    expeditor?: ExpeditorCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    expeditor?: ExpeditorUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentCreateInput = {
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutAttachmentsInput
  }

  export type OrderAttachmentUncheckedCreateInput = {
    id?: number
    orderId: number
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
  }

  export type OrderAttachmentUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type OrderAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentCreateManyInput = {
    id?: number
    orderId: number
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
  }

  export type OrderAttachmentUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type OrderItemUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ExpeditorCreateInput = {
    name: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutExpeditorInput
  }

  export type ExpeditorUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutExpeditorInput
  }

  export type ExpeditorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutExpeditorNestedInput
  }

  export type ExpeditorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutExpeditorNestedInput
  }

  export type ExpeditorCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpeditorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpeditorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCreateInput = {
    quantity?: number
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStockInput
  }

  export type StockUncheckedCreateInput = {
    productId: number
    quantity?: number
    updatedAt?: Date | string
  }

  export type StockUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockNestedInput
  }

  export type StockUncheckedUpdateInput = {
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCreateManyInput = {
    productId: number
    quantity?: number
    updatedAt?: Date | string
  }

  export type StockUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockUncheckedUpdateManyInput = {
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionCreateInput = {
    type: string
    quantity: number
    note?: string | null
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutStockTransactionsInput
    product: ProductCreateNestedOneWithoutStockTransactionsInput
  }

  export type StockTransactionUncheckedCreateInput = {
    id?: number
    productId: number
    type: string
    quantity: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type StockTransactionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutStockTransactionsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockTransactionsNestedInput
  }

  export type StockTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionCreateManyInput = {
    id?: number
    productId: number
    type: string
    quantity: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type StockTransactionUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrderJournalCreateInput = {
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerName: string
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    preAssemblyStatus?: string | null
    assemblyStartedAt?: Date | string | null
    assemblyStartedBy?: string | null
    assemblyReturnedAt?: Date | string | null
    assemblyReturnedBy?: string | null
    assemblyReturnReason?: string | null
    assemblyReturnComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutSummaryJournalEntriesInput
    product?: ProductCreateNestedOneWithoutSummaryJournalEntriesInput
    events?: SummaryOrderEventCreateNestedManyWithoutSummaryOrderInput
  }

  export type SummaryOrderJournalUncheckedCreateInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerId?: number | null
    customerName: string
    productId?: number | null
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    preAssemblyStatus?: string | null
    assemblyStartedAt?: Date | string | null
    assemblyStartedBy?: string | null
    assemblyReturnedAt?: Date | string | null
    assemblyReturnedBy?: string | null
    assemblyReturnReason?: string | null
    assemblyReturnComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: SummaryOrderEventUncheckedCreateNestedManyWithoutSummaryOrderInput
  }

  export type SummaryOrderJournalUpdateInput = {
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutSummaryJournalEntriesNestedInput
    product?: ProductUpdateOneWithoutSummaryJournalEntriesNestedInput
    events?: SummaryOrderEventUpdateManyWithoutSummaryOrderNestedInput
  }

  export type SummaryOrderJournalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: SummaryOrderEventUncheckedUpdateManyWithoutSummaryOrderNestedInput
  }

  export type SummaryOrderJournalCreateManyInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerId?: number | null
    customerName: string
    productId?: number | null
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    preAssemblyStatus?: string | null
    assemblyStartedAt?: Date | string | null
    assemblyStartedBy?: string | null
    assemblyReturnedAt?: Date | string | null
    assemblyReturnedBy?: string | null
    assemblyReturnReason?: string | null
    assemblyReturnComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SummaryOrderJournalUpdateManyMutationInput = {
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrderJournalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrderEventCreateInput = {
    eventType: string
    fromStatus?: string | null
    toStatus?: string | null
    reason?: string | null
    comment?: string | null
    createdAt?: Date | string
    createdBy: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    summaryOrder: SummaryOrderJournalCreateNestedOneWithoutEventsInput
  }

  export type SummaryOrderEventUncheckedCreateInput = {
    id?: number
    summaryOrderId: number
    eventType: string
    fromStatus?: string | null
    toStatus?: string | null
    reason?: string | null
    comment?: string | null
    createdAt?: Date | string
    createdBy: string
    payload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SummaryOrderEventUpdateInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableStringFieldUpdateOperationsInput | string | null
    toStatus?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    summaryOrder?: SummaryOrderJournalUpdateOneRequiredWithoutEventsNestedInput
  }

  export type SummaryOrderEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    summaryOrderId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableStringFieldUpdateOperationsInput | string | null
    toStatus?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SummaryOrderEventCreateManyInput = {
    id?: number
    summaryOrderId: number
    eventType: string
    fromStatus?: string | null
    toStatus?: string | null
    reason?: string | null
    comment?: string | null
    createdAt?: Date | string
    createdBy: string
    payload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SummaryOrderEventUpdateManyMutationInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableStringFieldUpdateOperationsInput | string | null
    toStatus?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SummaryOrderEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    summaryOrderId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableStringFieldUpdateOperationsInput | string | null
    toStatus?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalCreateInput = {
    summaryDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    data: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalUncheckedCreateInput = {
    id?: number
    summaryDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    data: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalUpdateInput = {
    summaryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    summaryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalCreateManyInput = {
    id?: number
    summaryDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    data: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalUpdateManyMutationInput = {
    summaryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    data?: JsonNullValueInput | InputJsonValue
  }

  export type SummaryOrdersJournalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    summaryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalCreateInput = {
    assemblyDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    sourceSummaryId?: number | null
    data: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalUncheckedCreateInput = {
    id?: number
    assemblyDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    sourceSummaryId?: number | null
    data: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalUpdateInput = {
    assemblyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    sourceSummaryId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assemblyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    sourceSummaryId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalCreateManyInput = {
    id?: number
    assemblyDate: Date | string
    createdAt?: Date | string
    createdBy: string
    isHidden?: boolean
    sourceSummaryId?: number | null
    data: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalUpdateManyMutationInput = {
    assemblyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    sourceSummaryId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type AssemblyOrdersJournalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assemblyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    sourceSummaryId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: JsonNullValueInput | InputJsonValue
  }

  export type ProductionStaffCreateInput = {
    fullName: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProductionStaffInput
    journals?: ProductionJournalCreateNestedManyWithoutStaffInput
  }

  export type ProductionStaffUncheckedCreateInput = {
    id?: number
    fullName: string
    phone?: string | null
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journals?: ProductionJournalUncheckedCreateNestedManyWithoutStaffInput
  }

  export type ProductionStaffUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductionStaffNestedInput
    journals?: ProductionJournalUpdateManyWithoutStaffNestedInput
  }

  export type ProductionStaffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: ProductionJournalUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type ProductionStaffCreateManyInput = {
    id?: number
    fullName: string
    phone?: string | null
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionStaffUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionStaffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionJournalCreateInput = {
    productionDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    staff: ProductionStaffCreateNestedOneWithoutJournalsInput
    items?: ProductionItemCreateNestedManyWithoutJournalInput
  }

  export type ProductionJournalUncheckedCreateInput = {
    id?: number
    productionDate: Date | string
    staffId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: ProductionItemUncheckedCreateNestedManyWithoutJournalInput
  }

  export type ProductionJournalUpdateInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: ProductionStaffUpdateOneRequiredWithoutJournalsNestedInput
    items?: ProductionItemUpdateManyWithoutJournalNestedInput
  }

  export type ProductionJournalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ProductionItemUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type ProductionJournalCreateManyInput = {
    id?: number
    productionDate: Date | string
    staffId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionJournalUpdateManyMutationInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionJournalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemCreateInput = {
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    journal: ProductionJournalCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutProductionItemsInput
    values?: ProductionItemValueCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemUncheckedCreateInput = {
    id?: number
    journalId: number
    productId?: number | null
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    values?: ProductionItemValueUncheckedCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemUpdateInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: ProductionJournalUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutProductionItemsNestedInput
    values?: ProductionItemValueUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    journalId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    values?: ProductionItemValueUncheckedUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemCreateManyInput = {
    id?: number
    journalId: number
    productId?: number | null
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionItemUpdateManyMutationInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    journalId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueCreateInput = {
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    productionItem: ProductionItemCreateNestedOneWithoutValuesInput
  }

  export type ProductionItemValueUncheckedCreateInput = {
    id?: number
    productionItemId: number
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionItemValueUpdateInput = {
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    productionItem?: ProductionItemUpdateOneRequiredWithoutValuesNestedInput
  }

  export type ProductionItemValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionItemId?: IntFieldUpdateOperationsInput | number
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueCreateManyInput = {
    id?: number
    productionItemId: number
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionItemValueUpdateManyMutationInput = {
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionItemId?: IntFieldUpdateOperationsInput | number
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceListCreateInput = {
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    suppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPriceListInput
    items?: PurchasePriceItemCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListUncheckedCreateInput = {
    id?: number
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    suppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPriceListInput
    items?: PurchasePriceItemUncheckedCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suppliers?: PurchasePriceListSupplierUpdateManyWithoutPriceListNestedInput
    items?: PurchasePriceItemUpdateManyWithoutPriceListNestedInput
  }

  export type PurchasePriceListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPriceListNestedInput
    items?: PurchasePriceItemUncheckedUpdateManyWithoutPriceListNestedInput
  }

  export type PurchasePriceListCreateManyInput = {
    id?: number
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type PurchasePriceListUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceListSupplierCreateInput = {
    createdAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutSuppliersInput
    supplier: SupplierCreateNestedOneWithoutPurchasePriceListSuppliersInput
    primaryMml?: ProductionMmlCreateNestedOneWithoutPriceListSuppliersInput
  }

  export type PurchasePriceListSupplierUncheckedCreateInput = {
    id?: number
    priceListId: number
    supplierId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceListSupplierUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutSuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceListSuppliersNestedInput
    primaryMml?: ProductionMmlUpdateOneWithoutPriceListSuppliersNestedInput
  }

  export type PurchasePriceListSupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierCreateManyInput = {
    id?: number
    priceListId: number
    supplierId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceListSupplierUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemCreateInput = {
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutItemsInput
    supplier: SupplierCreateNestedOneWithoutPurchasePriceItemsInput
    product: ProductCreateNestedOneWithoutPurchasePriceItemsInput
  }

  export type PurchasePriceItemUncheckedCreateInput = {
    id?: number
    priceListId: number
    supplierId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceItemUpdateInput = {
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutItemsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
  }

  export type PurchasePriceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemCreateManyInput = {
    id?: number
    priceListId: number
    supplierId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceItemUpdateManyMutationInput = {
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesPriceListCreateInput = {
    listType: string
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    customer?: CustomerCreateNestedOneWithoutSalesPriceListsInput
    items?: SalesPriceItemCreateNestedManyWithoutPriceListInput
  }

  export type SalesPriceListUncheckedCreateInput = {
    id?: number
    listType: string
    customerId?: number | null
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: SalesPriceItemUncheckedCreateNestedManyWithoutPriceListInput
  }

  export type SalesPriceListUpdateInput = {
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutSalesPriceListsNestedInput
    items?: SalesPriceItemUpdateManyWithoutPriceListNestedInput
  }

  export type SalesPriceListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    listType?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: SalesPriceItemUncheckedUpdateManyWithoutPriceListNestedInput
  }

  export type SalesPriceListCreateManyInput = {
    id?: number
    listType: string
    customerId?: number | null
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type SalesPriceListUpdateManyMutationInput = {
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    listType?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceItemCreateInput = {
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    priceList: SalesPriceListCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSalesPriceItemsInput
  }

  export type SalesPriceItemUncheckedCreateInput = {
    id?: number
    priceListId: number
    productId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SalesPriceItemUpdateInput = {
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    priceList?: SalesPriceListUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSalesPriceItemsNestedInput
  }

  export type SalesPriceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceItemCreateManyInput = {
    id?: number
    priceListId: number
    productId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SalesPriceItemUpdateManyMutationInput = {
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionMmlCreateInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlUncheckedCreateInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlUpdateInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutMmlNestedInput
  }

  export type ProductionMmlCreateManyInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionMmlUpdateManyMutationInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionMmlUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionMmlNodeCreateInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutNodesInput
    parentNode?: ProductionMmlNodeCreateNestedOneWithoutChildrenInput
    children?: ProductionMmlNodeCreateNestedManyWithoutParentNodeInput
    product: ProductCreateNestedOneWithoutMmlNodesInput
    runValues?: ProductionRunValueCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUncheckedCreateInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput
    runValues?: ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUpdateInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutNodesNestedInput
    parentNode?: ProductionMmlNodeUpdateOneWithoutChildrenNestedInput
    children?: ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput
    product?: ProductUpdateOneRequiredWithoutMmlNodesNestedInput
    runValues?: ProductionRunValueUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput
    runValues?: ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeCreateManyInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionMmlNodeUpdateManyMutationInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionMmlNodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunCreateInput = {
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionRunsInput
    mml: ProductionMmlCreateNestedOneWithoutRunsInput
    user: UserCreateNestedOneWithoutProductionRunsInput
    values?: ProductionRunValueCreateNestedManyWithoutRunInput
  }

  export type ProductionRunUncheckedCreateInput = {
    id?: number
    productId: number
    mmlId: number
    userId: number
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: ProductionRunValueUncheckedCreateNestedManyWithoutRunInput
  }

  export type ProductionRunUpdateInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionRunsNestedInput
    mml?: ProductionMmlUpdateOneRequiredWithoutRunsNestedInput
    user?: UserUpdateOneRequiredWithoutProductionRunsNestedInput
    values?: ProductionRunValueUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: ProductionRunValueUncheckedUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunCreateManyInput = {
    id?: number
    productId: number
    mmlId: number
    userId: number
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunUpdateManyMutationInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueCreateInput = {
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    run: ProductionRunCreateNestedOneWithoutValuesInput
    node: ProductionMmlNodeCreateNestedOneWithoutRunValuesInput
    snapshotProduct?: ProductCreateNestedOneWithoutRunValueSnapshotsInput
  }

  export type ProductionRunValueUncheckedCreateInput = {
    id?: number
    productionRunId: number
    mmlNodeId: number
    snapshotProductId?: number | null
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueUpdateInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: ProductionRunUpdateOneRequiredWithoutValuesNestedInput
    node?: ProductionMmlNodeUpdateOneRequiredWithoutRunValuesNestedInput
    snapshotProduct?: ProductUpdateOneWithoutRunValueSnapshotsNestedInput
  }

  export type ProductionRunValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionRunId?: IntFieldUpdateOperationsInput | number
    mmlNodeId?: IntFieldUpdateOperationsInput | number
    snapshotProductId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueCreateManyInput = {
    id?: number
    productionRunId: number
    mmlNodeId: number
    snapshotProductId?: number | null
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueUpdateManyMutationInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionRunId?: IntFieldUpdateOperationsInput | number
    mmlNodeId?: IntFieldUpdateOperationsInput | number
    snapshotProductId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTypeCreateInput = {
    name: string
    isDefault?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemCreateNestedManyWithoutPaymentTypeInput
  }

  export type PaymentTypeUncheckedCreateInput = {
    id?: number
    name: string
    isDefault?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutPaymentTypeInput
  }

  export type PaymentTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemUpdateManyWithoutPaymentTypeNestedInput
  }

  export type PaymentTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutPaymentTypeNestedInput
  }

  export type PaymentTypeCreateManyInput = {
    id?: number
    name: string
    isDefault?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateInput = {
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUser: UserCreateNestedOneWithoutPurchasesInput
    suppliers?: PurchaseSupplierCreateNestedManyWithoutPurchaseInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
    productionInputs?: ProductionInputCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: number
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    createdByUserId: number
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: PurchaseSupplierUncheckedCreateNestedManyWithoutPurchaseInput
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUpdateInput = {
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    suppliers?: PurchaseSupplierUpdateManyWithoutPurchaseNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdByUserId?: IntFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: PurchaseSupplierUncheckedUpdateManyWithoutPurchaseNestedInput
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseCreateManyInput = {
    id?: number
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    createdByUserId: number
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdByUserId?: IntFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseSupplierCreateInput = {
    createdAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutSuppliersInput
    supplier: SupplierCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseSupplierUncheckedCreateInput = {
    id?: number
    purchaseId: number
    supplierId: number
    createdAt?: Date | string
  }

  export type PurchaseSupplierUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutSuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseSupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseSupplierCreateManyInput = {
    id?: number
    purchaseId: number
    supplierId: number
    createdAt?: Date | string
  }

  export type PurchaseSupplierUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseSupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateInput = {
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    supplier: SupplierCreateNestedOneWithoutPurchaseItemsInput
    product: ProductCreateNestedOneWithoutPurchaseItemsRelInput
    paymentType?: PaymentTypeCreateNestedOneWithoutPurchaseItemsInput
    productionInputs?: ProductionInputCreateNestedManyWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateInput = {
    id?: number
    purchaseId: number
    supplierId: number
    productId: number
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    paymentTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutPurchaseItemInput
  }

  export type PurchaseItemUpdateInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsRelNestedInput
    paymentType?: PaymentTypeUpdateOneWithoutPurchaseItemsNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemCreateManyInput = {
    id?: number
    purchaseId: number
    supplierId: number
    productId: number
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    paymentTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemUpdateManyMutationInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramGroupCreateInput = {
    chatId: string
    title: string
    username?: string | null
    isActive?: boolean
    lastMessageId?: number | null
    parsePatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderDrafts?: TelegramOrderDraftCreateNestedManyWithoutGroupInput
  }

  export type TelegramGroupUncheckedCreateInput = {
    id?: number
    chatId: string
    title: string
    username?: string | null
    isActive?: boolean
    lastMessageId?: number | null
    parsePatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderDrafts?: TelegramOrderDraftUncheckedCreateNestedManyWithoutGroupInput
  }

  export type TelegramGroupUpdateInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    parsePatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDrafts?: TelegramOrderDraftUpdateManyWithoutGroupNestedInput
  }

  export type TelegramGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    parsePatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDrafts?: TelegramOrderDraftUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type TelegramGroupCreateManyInput = {
    id?: number
    chatId: string
    title: string
    username?: string | null
    isActive?: boolean
    lastMessageId?: number | null
    parsePatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramGroupUpdateManyMutationInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    parsePatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    parsePatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramOrderDraftCreateInput = {
    messageId: string
    messageText: string
    messageDate: Date | string
    senderName?: string | null
    senderId?: string | null
    parsedOrderNumber?: string | null
    parsedCustomer?: string | null
    parsedAddress?: string | null
    status?: string
    transferredOrderId?: number | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    group: TelegramGroupCreateNestedOneWithoutOrderDraftsInput
    items?: TelegramOrderDraftItemCreateNestedManyWithoutDraftInput
  }

  export type TelegramOrderDraftUncheckedCreateInput = {
    id?: number
    groupId: number
    messageId: string
    messageText: string
    messageDate: Date | string
    senderName?: string | null
    senderId?: string | null
    parsedOrderNumber?: string | null
    parsedCustomer?: string | null
    parsedAddress?: string | null
    status?: string
    transferredOrderId?: number | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TelegramOrderDraftItemUncheckedCreateNestedManyWithoutDraftInput
  }

  export type TelegramOrderDraftUpdateInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parsedCustomer?: NullableStringFieldUpdateOperationsInput | string | null
    parsedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferredOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: TelegramGroupUpdateOneRequiredWithoutOrderDraftsNestedInput
    items?: TelegramOrderDraftItemUpdateManyWithoutDraftNestedInput
  }

  export type TelegramOrderDraftUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    messageId?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parsedCustomer?: NullableStringFieldUpdateOperationsInput | string | null
    parsedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferredOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TelegramOrderDraftItemUncheckedUpdateManyWithoutDraftNestedInput
  }

  export type TelegramOrderDraftCreateManyInput = {
    id?: number
    groupId: number
    messageId: string
    messageText: string
    messageDate: Date | string
    senderName?: string | null
    senderId?: string | null
    parsedOrderNumber?: string | null
    parsedCustomer?: string | null
    parsedAddress?: string | null
    status?: string
    transferredOrderId?: number | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramOrderDraftUpdateManyMutationInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parsedCustomer?: NullableStringFieldUpdateOperationsInput | string | null
    parsedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferredOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramOrderDraftUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    messageId?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parsedCustomer?: NullableStringFieldUpdateOperationsInput | string | null
    parsedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferredOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramOrderDraftItemCreateInput = {
    rawProductName: string
    rawQuantity: string
    rawPrice?: string | null
    productId?: number | null
    quantity?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    draft: TelegramOrderDraftCreateNestedOneWithoutItemsInput
  }

  export type TelegramOrderDraftItemUncheckedCreateInput = {
    id?: number
    draftId: number
    rawProductName: string
    rawQuantity: string
    rawPrice?: string | null
    productId?: number | null
    quantity?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramOrderDraftItemUpdateInput = {
    rawProductName?: StringFieldUpdateOperationsInput | string
    rawQuantity?: StringFieldUpdateOperationsInput | string
    rawPrice?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draft?: TelegramOrderDraftUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TelegramOrderDraftItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    draftId?: IntFieldUpdateOperationsInput | number
    rawProductName?: StringFieldUpdateOperationsInput | string
    rawQuantity?: StringFieldUpdateOperationsInput | string
    rawPrice?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramOrderDraftItemCreateManyInput = {
    id?: number
    draftId: number
    rawProductName: string
    rawQuantity: string
    rawPrice?: string | null
    productId?: number | null
    quantity?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramOrderDraftItemUpdateManyMutationInput = {
    rawProductName?: StringFieldUpdateOperationsInput | string
    rawQuantity?: StringFieldUpdateOperationsInput | string
    rawPrice?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramOrderDraftItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    draftId?: IntFieldUpdateOperationsInput | number
    rawProductName?: StringFieldUpdateOperationsInput | string
    rawQuantity?: StringFieldUpdateOperationsInput | string
    rawPrice?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateInput = {
    code: string
    name: string
    address: string
    phone?: string | null
    comment?: string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutWarehousesInput
    productionDocs?: ProductionDocCreateNestedManyWithoutWarehouseInput
    productionInputs?: ProductionInputCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    address: string
    phone?: string | null
    responsibleUserId?: number | null
    comment?: string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productionDocs?: ProductionDocUncheckedCreateNestedManyWithoutWarehouseInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutWarehousesNestedInput
    productionDocs?: ProductionDocUpdateManyWithoutWarehouseNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDocs?: ProductionDocUncheckedUpdateManyWithoutWarehouseNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    id?: number
    code: string
    name: string
    address: string
    phone?: string | null
    responsibleUserId?: number | null
    comment?: string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodHeaderCreateInput = {
    svodDate: Date | string
    status?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    lines?: SvodLineCreateNestedManyWithoutSvodInput
    supplierCols?: SvodSupplierColCreateNestedManyWithoutSvodInput
    supplierValues?: SvodSupplierValueCreateNestedManyWithoutSvodInput
  }

  export type SvodHeaderUncheckedCreateInput = {
    id?: number
    svodDate: Date | string
    status?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    lines?: SvodLineUncheckedCreateNestedManyWithoutSvodInput
    supplierCols?: SvodSupplierColUncheckedCreateNestedManyWithoutSvodInput
    supplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutSvodInput
  }

  export type SvodHeaderUpdateInput = {
    svodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lines?: SvodLineUpdateManyWithoutSvodNestedInput
    supplierCols?: SvodSupplierColUpdateManyWithoutSvodNestedInput
    supplierValues?: SvodSupplierValueUpdateManyWithoutSvodNestedInput
  }

  export type SvodHeaderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lines?: SvodLineUncheckedUpdateManyWithoutSvodNestedInput
    supplierCols?: SvodSupplierColUncheckedUpdateManyWithoutSvodNestedInput
    supplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutSvodNestedInput
  }

  export type SvodHeaderCreateManyInput = {
    id?: number
    svodDate: Date | string
    status?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SvodHeaderUpdateManyMutationInput = {
    svodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SvodHeaderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SvodLineCreateInput = {
    shortName?: string | null
    category?: string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    orderQty?: Decimal | DecimalJsLike | number | string
    productionInQty?: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string
    openingStockIsManual?: boolean
    afterPurchaseStock?: Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: Decimal | DecimalJsLike | number | string | null
    qtyToShip?: Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: Decimal | DecimalJsLike | number | string | null
    weightToShip?: Decimal | DecimalJsLike | number | string | null
    planFactDiff?: Decimal | DecimalJsLike | number | string | null
    underOver?: Decimal | DecimalJsLike | number | string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    svod: SvodHeaderCreateNestedOneWithoutLinesInput
    product: ProductCreateNestedOneWithoutSvodLinesInput
  }

  export type SvodLineUncheckedCreateInput = {
    id?: number
    svodId: number
    productId: number
    shortName?: string | null
    category?: string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    orderQty?: Decimal | DecimalJsLike | number | string
    productionInQty?: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string
    openingStockIsManual?: boolean
    afterPurchaseStock?: Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: Decimal | DecimalJsLike | number | string | null
    qtyToShip?: Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: Decimal | DecimalJsLike | number | string | null
    weightToShip?: Decimal | DecimalJsLike | number | string | null
    planFactDiff?: Decimal | DecimalJsLike | number | string | null
    underOver?: Decimal | DecimalJsLike | number | string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodLineUpdateInput = {
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFieldUpdateOperationsInput | boolean
    afterPurchaseStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    underOver?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    svod?: SvodHeaderUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneRequiredWithoutSvodLinesNestedInput
  }

  export type SvodLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFieldUpdateOperationsInput | boolean
    afterPurchaseStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    underOver?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodLineCreateManyInput = {
    id?: number
    svodId: number
    productId: number
    shortName?: string | null
    category?: string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    orderQty?: Decimal | DecimalJsLike | number | string
    productionInQty?: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string
    openingStockIsManual?: boolean
    afterPurchaseStock?: Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: Decimal | DecimalJsLike | number | string | null
    qtyToShip?: Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: Decimal | DecimalJsLike | number | string | null
    weightToShip?: Decimal | DecimalJsLike | number | string | null
    planFactDiff?: Decimal | DecimalJsLike | number | string | null
    underOver?: Decimal | DecimalJsLike | number | string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodLineUpdateManyMutationInput = {
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFieldUpdateOperationsInput | boolean
    afterPurchaseStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    underOver?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFieldUpdateOperationsInput | boolean
    afterPurchaseStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    underOver?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierColCreateInput = {
    colIndex: number
    supplierName: string
    totalPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    svod: SvodHeaderCreateNestedOneWithoutSupplierColsInput
    supplier: SupplierCreateNestedOneWithoutSvodSupplierColsInput
  }

  export type SvodSupplierColUncheckedCreateInput = {
    id?: number
    svodId: number
    colIndex: number
    supplierId: number
    supplierName: string
    totalPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SvodSupplierColUpdateInput = {
    colIndex?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    totalPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    svod?: SvodHeaderUpdateOneRequiredWithoutSupplierColsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutSvodSupplierColsNestedInput
  }

  export type SvodSupplierColUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    colIndex?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    totalPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierColCreateManyInput = {
    id?: number
    svodId: number
    colIndex: number
    supplierId: number
    supplierName: string
    totalPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SvodSupplierColUpdateManyMutationInput = {
    colIndex?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    totalPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierColUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    colIndex?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    totalPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierValueCreateInput = {
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    svod: SvodHeaderCreateNestedOneWithoutSupplierValuesInput
    product: ProductCreateNestedOneWithoutSvodSupplierValuesInput
    supplier: SupplierCreateNestedOneWithoutSvodSupplierValuesInput
  }

  export type SvodSupplierValueUncheckedCreateInput = {
    id?: number
    svodId: number
    productId: number
    supplierId: number
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodSupplierValueUpdateInput = {
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    svod?: SvodHeaderUpdateOneRequiredWithoutSupplierValuesNestedInput
    product?: ProductUpdateOneRequiredWithoutSvodSupplierValuesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutSvodSupplierValuesNestedInput
  }

  export type SvodSupplierValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierValueCreateManyInput = {
    id?: number
    svodId: number
    productId: number
    supplierId: number
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodSupplierValueUpdateManyMutationInput = {
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDocCreateInput = {
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutProductionDocsInput
    createdBy: UserCreateNestedOneWithoutProductionDocsInput
    inputs?: ProductionInputCreateNestedManyWithoutProductionDocInput
    outputs?: ProductionOutputCreateNestedManyWithoutProductionDocInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocUncheckedCreateInput = {
    id?: number
    date: Date | string
    warehouseId: number
    status?: string
    createdByUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: ProductionInputUncheckedCreateNestedManyWithoutProductionDocInput
    outputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductionDocInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionDocsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutProductionDocsNestedInput
    inputs?: ProductionInputUpdateManyWithoutProductionDocNestedInput
    outputs?: ProductionOutputUpdateManyWithoutProductionDocNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionDocNestedInput
  }

  export type ProductionDocUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: ProductionInputUncheckedUpdateManyWithoutProductionDocNestedInput
    outputs?: ProductionOutputUncheckedUpdateManyWithoutProductionDocNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionDocNestedInput
  }

  export type ProductionDocCreateManyInput = {
    id?: number
    date: Date | string
    warehouseId: number
    status?: string
    createdByUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionDocUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDocUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionInputCreateInput = {
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutInputsInput
    purchase: PurchaseCreateNestedOneWithoutProductionInputsInput
    purchaseItem: PurchaseItemCreateNestedOneWithoutProductionInputsInput
    product: ProductCreateNestedOneWithoutProductionInputsInput
    warehouse: WarehouseCreateNestedOneWithoutProductionInputsInput
    loadedBy: UserCreateNestedOneWithoutProductionInputsInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputUncheckedCreateInput = {
    id?: number
    productionDocId: number
    purchaseId: number
    purchaseItemId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputUpdateInput = {
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutInputsNestedInput
    purchase?: PurchaseUpdateOneRequiredWithoutProductionInputsNestedInput
    purchaseItem?: PurchaseItemUpdateOneRequiredWithoutProductionInputsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductionInputsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionInputsNestedInput
    loadedBy?: UserUpdateOneRequiredWithoutProductionInputsNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputCreateManyInput = {
    id?: number
    productionDocId: number
    purchaseId: number
    purchaseItemId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
  }

  export type ProductionInputUpdateManyMutationInput = {
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionInputUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionOutputCreateInput = {
    qtyOut: Decimal | DecimalJsLike | number | string
    uom?: string
    costTotal?: Decimal | DecimalJsLike | number | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutOutputsInput
    product: ProductCreateNestedOneWithoutProductionOutputsInput
  }

  export type ProductionOutputUncheckedCreateInput = {
    id?: number
    productionDocId: number
    productId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    uom?: string
    costTotal?: Decimal | DecimalJsLike | number | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionOutputUpdateInput = {
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    costTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutOutputsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductionOutputsNestedInput
  }

  export type ProductionOutputUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    costTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOutputCreateManyInput = {
    id?: number
    productionDocId: number
    productId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    uom?: string
    costTotal?: Decimal | DecimalJsLike | number | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionOutputUpdateManyMutationInput = {
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    costTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOutputUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    costTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionCuttingLineCreateInput = {
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutCuttingLinesInput
    productionInput: ProductionInputCreateNestedOneWithoutCuttingLinesInput
    mml: ProductionMmlCreateNestedOneWithoutCuttingLinesInput
    outProduct: ProductCreateNestedOneWithoutCuttingLineOutputsInput
    createdBy: UserCreateNestedOneWithoutCuttingLinesInput
  }

  export type ProductionCuttingLineUncheckedCreateInput = {
    id?: number
    productionDocId: number
    productionInputId: number
    mmlId: number
    outProductId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdByUserId: number
  }

  export type ProductionCuttingLineUpdateInput = {
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutCuttingLinesNestedInput
    productionInput?: ProductionInputUpdateOneRequiredWithoutCuttingLinesNestedInput
    mml?: ProductionMmlUpdateOneRequiredWithoutCuttingLinesNestedInput
    outProduct?: ProductUpdateOneRequiredWithoutCuttingLineOutputsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCuttingLinesNestedInput
  }

  export type ProductionCuttingLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    productionInputId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    outProductId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionCuttingLineCreateManyInput = {
    id?: number
    productionDocId: number
    productionInputId: number
    mmlId: number
    outProductId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdByUserId: number
  }

  export type ProductionCuttingLineUpdateManyMutationInput = {
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionCuttingLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    productionInputId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    outProductId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProductionStaffNullableScalarRelationFilter = {
    is?: ProductionStaffWhereInput | null
    isNot?: ProductionStaffWhereInput | null
  }

  export type ProductionMmlListRelationFilter = {
    every?: ProductionMmlWhereInput
    some?: ProductionMmlWhereInput
    none?: ProductionMmlWhereInput
  }

  export type ProductionRunListRelationFilter = {
    every?: ProductionRunWhereInput
    some?: ProductionRunWhereInput
    none?: ProductionRunWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type WarehouseListRelationFilter = {
    every?: WarehouseWhereInput
    some?: WarehouseWhereInput
    none?: WarehouseWhereInput
  }

  export type ProductionDocListRelationFilter = {
    every?: ProductionDocWhereInput
    some?: ProductionDocWhereInput
    none?: ProductionDocWhereInput
  }

  export type ProductionInputListRelationFilter = {
    every?: ProductionInputWhereInput
    some?: ProductionInputWhereInput
    none?: ProductionInputWhereInput
  }

  export type ProductionCuttingLineListRelationFilter = {
    every?: ProductionCuttingLineWhereInput
    some?: ProductionCuttingLineWhereInput
    none?: ProductionCuttingLineWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProductionMmlOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionDocOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionInputOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionCuttingLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DistrictCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type DistrictAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DistrictMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type DistrictMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type DistrictSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ManagerCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phone?: SortOrder
  }

  export type ManagerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phone?: SortOrder
  }

  export type ManagerMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phone?: SortOrder
  }

  export type ManagerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type StockNullableScalarRelationFilter = {
    is?: StockWhereInput | null
    isNot?: StockWhereInput | null
  }

  export type StockTransactionListRelationFilter = {
    every?: StockTransactionWhereInput
    some?: StockTransactionWhereInput
    none?: StockTransactionWhereInput
  }

  export type SupplierProductListRelationFilter = {
    every?: SupplierProductWhereInput
    some?: SupplierProductWhereInput
    none?: SupplierProductWhereInput
  }

  export type SummaryOrderJournalListRelationFilter = {
    every?: SummaryOrderJournalWhereInput
    some?: SummaryOrderJournalWhereInput
    none?: SummaryOrderJournalWhereInput
  }

  export type ProductionItemListRelationFilter = {
    every?: ProductionItemWhereInput
    some?: ProductionItemWhereInput
    none?: ProductionItemWhereInput
  }

  export type PurchasePriceItemListRelationFilter = {
    every?: PurchasePriceItemWhereInput
    some?: PurchasePriceItemWhereInput
    none?: PurchasePriceItemWhereInput
  }

  export type SalesPriceItemListRelationFilter = {
    every?: SalesPriceItemWhereInput
    some?: SalesPriceItemWhereInput
    none?: SalesPriceItemWhereInput
  }

  export type ProductionMmlNodeListRelationFilter = {
    every?: ProductionMmlNodeWhereInput
    some?: ProductionMmlNodeWhereInput
    none?: ProductionMmlNodeWhereInput
  }

  export type ProductionRunValueListRelationFilter = {
    every?: ProductionRunValueWhereInput
    some?: ProductionRunValueWhereInput
    none?: ProductionRunValueWhereInput
  }

  export type PurchaseItemListRelationFilter = {
    every?: PurchaseItemWhereInput
    some?: PurchaseItemWhereInput
    none?: PurchaseItemWhereInput
  }

  export type SvodLineListRelationFilter = {
    every?: SvodLineWhereInput
    some?: SvodLineWhereInput
    none?: SvodLineWhereInput
  }

  export type SvodSupplierValueListRelationFilter = {
    every?: SvodSupplierValueWhereInput
    some?: SvodSupplierValueWhereInput
    none?: SvodSupplierValueWhereInput
  }

  export type ProductionOutputListRelationFilter = {
    every?: ProductionOutputWhereInput
    some?: ProductionOutputWhereInput
    none?: ProductionOutputWhereInput
  }

  export type CustomerProductListRelationFilter = {
    every?: CustomerProductWhereInput
    some?: CustomerProductWhereInput
    none?: CustomerProductWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SummaryOrderJournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchasePriceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesPriceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionMmlNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionRunValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SvodLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SvodSupplierValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionOutputOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    altName?: SortOrder
    priceListName?: SortOrder
    category?: SortOrder
    status?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    altName?: SortOrder
    priceListName?: SortOrder
    category?: SortOrder
    status?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    altName?: SortOrder
    priceListName?: SortOrder
    category?: SortOrder
    status?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    coefficient?: SortOrder
    lossNorm?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DistrictNullableScalarRelationFilter = {
    is?: DistrictWhereInput | null
    isNot?: DistrictWhereInput | null
  }

  export type ManagerNullableScalarRelationFilter = {
    is?: ManagerWhereInput | null
    isNot?: ManagerWhereInput | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type SalesPriceListListRelationFilter = {
    every?: SalesPriceListWhereInput
    some?: SalesPriceListWhereInput
    none?: SalesPriceListWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesPriceListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    districtId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    districtId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    districtId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type CustomerProductCustomerIdProductIdCompoundUniqueInput = {
    customerId: number
    productId: number
  }

  export type CustomerProductCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProductAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
  }

  export type CustomerProductMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProductMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProductSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProductionMmlNullableScalarRelationFilter = {
    is?: ProductionMmlWhereInput | null
    isNot?: ProductionMmlWhereInput | null
  }

  export type PurchasePriceListSupplierListRelationFilter = {
    every?: PurchasePriceListSupplierWhereInput
    some?: PurchasePriceListSupplierWhereInput
    none?: PurchasePriceListSupplierWhereInput
  }

  export type PurchaseSupplierListRelationFilter = {
    every?: PurchaseSupplierWhereInput
    some?: PurchaseSupplierWhereInput
    none?: PurchaseSupplierWhereInput
  }

  export type SvodSupplierColListRelationFilter = {
    every?: SvodSupplierColWhereInput
    some?: SvodSupplierColWhereInput
    none?: SvodSupplierColWhereInput
  }

  export type PurchasePriceListSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SvodSupplierColOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    altName?: SortOrder
    phone?: SortOrder
    telegram?: SortOrder
    isActive?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    primaryMmlId?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    altName?: SortOrder
    phone?: SortOrder
    telegram?: SortOrder
    isActive?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    altName?: SortOrder
    phone?: SortOrder
    telegram?: SortOrder
    isActive?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    id?: SortOrder
    primaryMmlId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type SupplierProductSupplierIdProductIdCompoundUniqueInput = {
    supplierId: number
    productId: number
  }

  export type SupplierProductCountOrderByAggregateInput = {
    supplierId?: SortOrder
    productId?: SortOrder
  }

  export type SupplierProductAvgOrderByAggregateInput = {
    supplierId?: SortOrder
    productId?: SortOrder
  }

  export type SupplierProductMaxOrderByAggregateInput = {
    supplierId?: SortOrder
    productId?: SortOrder
  }

  export type SupplierProductMinOrderByAggregateInput = {
    supplierId?: SortOrder
    productId?: SortOrder
  }

  export type SupplierProductSumOrderByAggregateInput = {
    supplierId?: SortOrder
    productId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ExpeditorNullableScalarRelationFilter = {
    is?: ExpeditorWhereInput | null
    isNot?: ExpeditorWhereInput | null
  }

  export type OrderAttachmentListRelationFilter = {
    every?: OrderAttachmentWhereInput
    some?: OrderAttachmentWhereInput
    none?: OrderAttachmentWhereInput
  }

  export type OrderAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    date?: SortOrder
    status?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
    isDisabled?: SortOrder
    deliveryAddress?: SortOrder
    assignedAt?: SortOrder
    deliveryStatus?: SortOrder
    completedAt?: SortOrder
    signatureUrl?: SortOrder
    signedInvoiceUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    date?: SortOrder
    status?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
    isDisabled?: SortOrder
    deliveryAddress?: SortOrder
    assignedAt?: SortOrder
    deliveryStatus?: SortOrder
    completedAt?: SortOrder
    signatureUrl?: SortOrder
    signedInvoiceUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    date?: SortOrder
    status?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
    isDisabled?: SortOrder
    deliveryAddress?: SortOrder
    assignedAt?: SortOrder
    deliveryStatus?: SortOrder
    completedAt?: SortOrder
    signatureUrl?: SortOrder
    signedInvoiceUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    expeditorId?: SortOrder
    totalAmount?: SortOrder
    totalWeight?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type OrderAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributionCoef?: SortOrder
    sumWithRevaluation?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    distributionCoef?: SortOrder
    sumWithRevaluation?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributionCoef?: SortOrder
    sumWithRevaluation?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributionCoef?: SortOrder
    sumWithRevaluation?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    shippedQty?: SortOrder
    distributionCoef?: SortOrder
    sumWithRevaluation?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ExpeditorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpeditorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExpeditorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpeditorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpeditorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StockCountOrderByAggregateInput = {
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockAvgOrderByAggregateInput = {
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type StockMaxOrderByAggregateInput = {
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockMinOrderByAggregateInput = {
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockSumOrderByAggregateInput = {
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type StockTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type StockTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
  }

  export type StockTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type StockTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type StockTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type SummaryOrderEventListRelationFilter = {
    every?: SummaryOrderEventWhereInput
    some?: SummaryOrderEventWhereInput
    none?: SummaryOrderEventWhereInput
  }

  export type SummaryOrderEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SummaryOrderJournalCountOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    shipDate?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    productId?: SortOrder
    productCode?: SortOrder
    productFullName?: SortOrder
    category?: SortOrder
    shortNameMorning?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrder
    distributionCoef?: SortOrder
    weightToDistribute?: SortOrder
    managerId?: SortOrder
    managerName?: SortOrder
    district?: SortOrder
    pointAddress?: SortOrder
    status?: SortOrder
    preAssemblyStatus?: SortOrder
    assemblyStartedAt?: SortOrder
    assemblyStartedBy?: SortOrder
    assemblyReturnedAt?: SortOrder
    assemblyReturnedBy?: SortOrder
    assemblyReturnReason?: SortOrder
    assemblyReturnComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SummaryOrderJournalAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrder
    distributionCoef?: SortOrder
    weightToDistribute?: SortOrder
  }

  export type SummaryOrderJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    shipDate?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    productId?: SortOrder
    productCode?: SortOrder
    productFullName?: SortOrder
    category?: SortOrder
    shortNameMorning?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrder
    distributionCoef?: SortOrder
    weightToDistribute?: SortOrder
    managerId?: SortOrder
    managerName?: SortOrder
    district?: SortOrder
    pointAddress?: SortOrder
    status?: SortOrder
    preAssemblyStatus?: SortOrder
    assemblyStartedAt?: SortOrder
    assemblyStartedBy?: SortOrder
    assemblyReturnedAt?: SortOrder
    assemblyReturnedBy?: SortOrder
    assemblyReturnReason?: SortOrder
    assemblyReturnComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SummaryOrderJournalMinOrderByAggregateInput = {
    id?: SortOrder
    idn?: SortOrder
    shipDate?: SortOrder
    paymentType?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    productId?: SortOrder
    productCode?: SortOrder
    productFullName?: SortOrder
    category?: SortOrder
    shortNameMorning?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrder
    distributionCoef?: SortOrder
    weightToDistribute?: SortOrder
    managerId?: SortOrder
    managerName?: SortOrder
    district?: SortOrder
    pointAddress?: SortOrder
    status?: SortOrder
    preAssemblyStatus?: SortOrder
    assemblyStartedAt?: SortOrder
    assemblyStartedBy?: SortOrder
    assemblyReturnedAt?: SortOrder
    assemblyReturnedBy?: SortOrder
    assemblyReturnReason?: SortOrder
    assemblyReturnComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SummaryOrderJournalSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    shippedQty?: SortOrder
    orderQty?: SortOrder
    sumWithRevaluation?: SortOrder
    distributionCoef?: SortOrder
    weightToDistribute?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SummaryOrderJournalScalarRelationFilter = {
    is?: SummaryOrderJournalWhereInput
    isNot?: SummaryOrderJournalWhereInput
  }

  export type SummaryOrderEventCountOrderByAggregateInput = {
    id?: SortOrder
    summaryOrderId?: SortOrder
    eventType?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    payload?: SortOrder
  }

  export type SummaryOrderEventAvgOrderByAggregateInput = {
    id?: SortOrder
    summaryOrderId?: SortOrder
  }

  export type SummaryOrderEventMaxOrderByAggregateInput = {
    id?: SortOrder
    summaryOrderId?: SortOrder
    eventType?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SummaryOrderEventMinOrderByAggregateInput = {
    id?: SortOrder
    summaryOrderId?: SortOrder
    eventType?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SummaryOrderEventSumOrderByAggregateInput = {
    id?: SortOrder
    summaryOrderId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SummaryOrdersJournalCountOrderByAggregateInput = {
    id?: SortOrder
    summaryDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    data?: SortOrder
  }

  export type SummaryOrdersJournalAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SummaryOrdersJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    summaryDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
  }

  export type SummaryOrdersJournalMinOrderByAggregateInput = {
    id?: SortOrder
    summaryDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
  }

  export type SummaryOrdersJournalSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AssemblyOrdersJournalCountOrderByAggregateInput = {
    id?: SortOrder
    assemblyDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    sourceSummaryId?: SortOrder
    data?: SortOrder
  }

  export type AssemblyOrdersJournalAvgOrderByAggregateInput = {
    id?: SortOrder
    sourceSummaryId?: SortOrder
  }

  export type AssemblyOrdersJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    assemblyDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    sourceSummaryId?: SortOrder
  }

  export type AssemblyOrdersJournalMinOrderByAggregateInput = {
    id?: SortOrder
    assemblyDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isHidden?: SortOrder
    sourceSummaryId?: SortOrder
  }

  export type AssemblyOrdersJournalSumOrderByAggregateInput = {
    id?: SortOrder
    sourceSummaryId?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProductionJournalListRelationFilter = {
    every?: ProductionJournalWhereInput
    some?: ProductionJournalWhereInput
    none?: ProductionJournalWhereInput
  }

  export type ProductionJournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionStaffCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionStaffAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProductionStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionStaffMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionStaffSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProductionStaffScalarRelationFilter = {
    is?: ProductionStaffWhereInput
    isNot?: ProductionStaffWhereInput
  }

  export type ProductionJournalProductionDateStaffIdCompoundUniqueInput = {
    productionDate: Date | string
    staffId: number
  }

  export type ProductionJournalCountOrderByAggregateInput = {
    id?: SortOrder
    productionDate?: SortOrder
    staffId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionJournalAvgOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
  }

  export type ProductionJournalMaxOrderByAggregateInput = {
    id?: SortOrder
    productionDate?: SortOrder
    staffId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionJournalMinOrderByAggregateInput = {
    id?: SortOrder
    productionDate?: SortOrder
    staffId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionJournalSumOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
  }

  export type ProductionJournalScalarRelationFilter = {
    is?: ProductionJournalWhereInput
    isNot?: ProductionJournalWhereInput
  }

  export type ProductionItemValueListRelationFilter = {
    every?: ProductionItemValueWhereInput
    some?: ProductionItemValueWhereInput
    none?: ProductionItemValueWhereInput
  }

  export type ProductionItemValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionItemCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    state?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemAvgOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    state?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    state?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemSumOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductionItemScalarRelationFilter = {
    is?: ProductionItemWhereInput
    isNot?: ProductionItemWhereInput
  }

  export type ProductionItemValueProductionItemIdFieldKeyCompoundUniqueInput = {
    productionItemId: number
    fieldKey: string
  }

  export type ProductionItemValueCountOrderByAggregateInput = {
    id?: SortOrder
    productionItemId?: SortOrder
    fieldKey?: SortOrder
    fieldValue?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemValueAvgOrderByAggregateInput = {
    id?: SortOrder
    productionItemId?: SortOrder
  }

  export type ProductionItemValueMaxOrderByAggregateInput = {
    id?: SortOrder
    productionItemId?: SortOrder
    fieldKey?: SortOrder
    fieldValue?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemValueMinOrderByAggregateInput = {
    id?: SortOrder
    productionItemId?: SortOrder
    fieldKey?: SortOrder
    fieldValue?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductionItemValueSumOrderByAggregateInput = {
    id?: SortOrder
    productionItemId?: SortOrder
  }

  export type PurchasePriceListCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type PurchasePriceListAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PurchasePriceListMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type PurchasePriceListMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type PurchasePriceListSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PurchasePriceListScalarRelationFilter = {
    is?: PurchasePriceListWhereInput
    isNot?: PurchasePriceListWhereInput
  }

  export type PurchasePriceListSupplierPriceListIdSupplierIdCompoundUniqueInput = {
    priceListId: number
    supplierId: number
  }

  export type PurchasePriceListSupplierCountOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchasePriceListSupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrder
  }

  export type PurchasePriceListSupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchasePriceListSupplierMinOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchasePriceListSupplierSumOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    primaryMmlId?: SortOrder
  }

  export type PurchasePriceItemPriceListIdSupplierIdProductIdCompoundUniqueInput = {
    priceListId: number
    supplierId: number
    productId: number
  }

  export type PurchasePriceItemCountOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasePriceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
  }

  export type PurchasePriceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasePriceItemMinOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasePriceItemSumOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    purchasePrice?: SortOrder
  }

  export type SalesPriceListCountOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    effectiveDate?: SortOrder
    status?: SortOrder
    isCurrent?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceListAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type SalesPriceListMaxOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    effectiveDate?: SortOrder
    status?: SortOrder
    isCurrent?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceListMinOrderByAggregateInput = {
    id?: SortOrder
    listType?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    effectiveDate?: SortOrder
    status?: SortOrder
    isCurrent?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceListSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type SalesPriceListScalarRelationFilter = {
    is?: SalesPriceListWhereInput
    isNot?: SalesPriceListWhereInput
  }

  export type SalesPriceItemPriceListIdProductIdCompoundUniqueInput = {
    priceListId: number
    productId: number
  }

  export type SalesPriceItemCountOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
    rowDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
  }

  export type SalesPriceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
    rowDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceItemMinOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
    rowDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SalesPriceItemSumOrderByAggregateInput = {
    id?: SortOrder
    priceListId?: SortOrder
    productId?: SortOrder
    salePrice?: SortOrder
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionMmlCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
  }

  export type ProductionMmlMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdBy?: SortOrder
  }

  export type ProductionMmlScalarRelationFilter = {
    is?: ProductionMmlWhereInput
    isNot?: ProductionMmlWhereInput
  }

  export type ProductionMmlNodeNullableScalarRelationFilter = {
    is?: ProductionMmlNodeWhereInput | null
    isNot?: ProductionMmlNodeWhereInput | null
  }

  export type ProductionMmlNodeCountOrderByAggregateInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlNodeAvgOrderByAggregateInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductionMmlNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlNodeMinOrderByAggregateInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMmlNodeSumOrderByAggregateInput = {
    id?: SortOrder
    mmlId?: SortOrder
    parentNodeId?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductionRunCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    productionDate?: SortOrder
    plannedWeight?: SortOrder
    actualWeight?: SortOrder
    isLocked?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    plannedWeight?: SortOrder
    actualWeight?: SortOrder
  }

  export type ProductionRunMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    productionDate?: SortOrder
    plannedWeight?: SortOrder
    actualWeight?: SortOrder
    isLocked?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    productionDate?: SortOrder
    plannedWeight?: SortOrder
    actualWeight?: SortOrder
    isLocked?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mmlId?: SortOrder
    userId?: SortOrder
    plannedWeight?: SortOrder
    actualWeight?: SortOrder
  }

  export type ProductionRunScalarRelationFilter = {
    is?: ProductionRunWhereInput
    isNot?: ProductionRunWhereInput
  }

  export type ProductionMmlNodeScalarRelationFilter = {
    is?: ProductionMmlNodeWhereInput
    isNot?: ProductionMmlNodeWhereInput
  }

  export type ProductionRunValueProductionRunIdMmlNodeIdCompoundUniqueInput = {
    productionRunId: number
    mmlNodeId: number
  }

  export type ProductionRunValueCountOrderByAggregateInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    snapshotProductId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunValueAvgOrderByAggregateInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    snapshotProductId?: SortOrder
    value?: SortOrder
  }

  export type ProductionRunValueMaxOrderByAggregateInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    snapshotProductId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunValueMinOrderByAggregateInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    snapshotProductId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionRunValueSumOrderByAggregateInput = {
    id?: SortOrder
    productionRunId?: SortOrder
    mmlNodeId?: SortOrder
    snapshotProductId?: SortOrder
    value?: SortOrder
  }

  export type PaymentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PaymentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseDate?: SortOrder
    totalAmount?: SortOrder
    createdByUserId?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    createdByUserId?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseDate?: SortOrder
    totalAmount?: SortOrder
    createdByUserId?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseDate?: SortOrder
    totalAmount?: SortOrder
    createdByUserId?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    createdByUserId?: SortOrder
  }

  export type PurchaseScalarRelationFilter = {
    is?: PurchaseWhereInput
    isNot?: PurchaseWhereInput
  }

  export type PurchaseSupplierPurchaseIdSupplierIdCompoundUniqueInput = {
    purchaseId: number
    supplierId: number
  }

  export type PurchaseSupplierCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseSupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
  }

  export type PurchaseSupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseSupplierMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseSupplierSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
  }

  export type PaymentTypeNullableScalarRelationFilter = {
    is?: PaymentTypeWhereInput | null
    isNot?: PaymentTypeWhereInput | null
  }

  export type PurchaseItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    qty?: SortOrder
    amount?: SortOrder
    paymentTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseItemAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    qty?: SortOrder
    amount?: SortOrder
    paymentTypeId?: SortOrder
  }

  export type PurchaseItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    qty?: SortOrder
    amount?: SortOrder
    paymentTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    qty?: SortOrder
    amount?: SortOrder
    paymentTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseItemSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    qty?: SortOrder
    amount?: SortOrder
    paymentTypeId?: SortOrder
  }

  export type TelegramOrderDraftListRelationFilter = {
    every?: TelegramOrderDraftWhereInput
    some?: TelegramOrderDraftWhereInput
    none?: TelegramOrderDraftWhereInput
  }

  export type TelegramOrderDraftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TelegramGroupCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    title?: SortOrder
    username?: SortOrder
    isActive?: SortOrder
    lastMessageId?: SortOrder
    parsePatterns?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    lastMessageId?: SortOrder
  }

  export type TelegramGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    title?: SortOrder
    username?: SortOrder
    isActive?: SortOrder
    lastMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramGroupMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    title?: SortOrder
    username?: SortOrder
    isActive?: SortOrder
    lastMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramGroupSumOrderByAggregateInput = {
    id?: SortOrder
    lastMessageId?: SortOrder
  }

  export type TelegramGroupScalarRelationFilter = {
    is?: TelegramGroupWhereInput
    isNot?: TelegramGroupWhereInput
  }

  export type TelegramOrderDraftItemListRelationFilter = {
    every?: TelegramOrderDraftItemWhereInput
    some?: TelegramOrderDraftItemWhereInput
    none?: TelegramOrderDraftItemWhereInput
  }

  export type TelegramOrderDraftItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TelegramOrderDraftGroupIdMessageIdCompoundUniqueInput = {
    groupId: number
    messageId: string
  }

  export type TelegramOrderDraftCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    messageId?: SortOrder
    messageText?: SortOrder
    messageDate?: SortOrder
    senderName?: SortOrder
    senderId?: SortOrder
    parsedOrderNumber?: SortOrder
    parsedCustomer?: SortOrder
    parsedAddress?: SortOrder
    status?: SortOrder
    transferredOrderId?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramOrderDraftAvgOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    transferredOrderId?: SortOrder
  }

  export type TelegramOrderDraftMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    messageId?: SortOrder
    messageText?: SortOrder
    messageDate?: SortOrder
    senderName?: SortOrder
    senderId?: SortOrder
    parsedOrderNumber?: SortOrder
    parsedCustomer?: SortOrder
    parsedAddress?: SortOrder
    status?: SortOrder
    transferredOrderId?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramOrderDraftMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    messageId?: SortOrder
    messageText?: SortOrder
    messageDate?: SortOrder
    senderName?: SortOrder
    senderId?: SortOrder
    parsedOrderNumber?: SortOrder
    parsedCustomer?: SortOrder
    parsedAddress?: SortOrder
    status?: SortOrder
    transferredOrderId?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramOrderDraftSumOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    transferredOrderId?: SortOrder
  }

  export type TelegramOrderDraftScalarRelationFilter = {
    is?: TelegramOrderDraftWhereInput
    isNot?: TelegramOrderDraftWhereInput
  }

  export type TelegramOrderDraftItemCountOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    rawProductName?: SortOrder
    rawQuantity?: SortOrder
    rawPrice?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramOrderDraftItemAvgOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type TelegramOrderDraftItemMaxOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    rawProductName?: SortOrder
    rawQuantity?: SortOrder
    rawPrice?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramOrderDraftItemMinOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    rawProductName?: SortOrder
    rawQuantity?: SortOrder
    rawPrice?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramOrderDraftItemSumOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    responsibleUserId?: SortOrder
    comment?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseAvgOrderByAggregateInput = {
    id?: SortOrder
    responsibleUserId?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    responsibleUserId?: SortOrder
    comment?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    responsibleUserId?: SortOrder
    comment?: SortOrder
    isDisabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseSumOrderByAggregateInput = {
    id?: SortOrder
    responsibleUserId?: SortOrder
  }

  export type SvodHeaderCountOrderByAggregateInput = {
    id?: SortOrder
    svodDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SvodHeaderAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SvodHeaderMaxOrderByAggregateInput = {
    id?: SortOrder
    svodDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SvodHeaderMinOrderByAggregateInput = {
    id?: SortOrder
    svodDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SvodHeaderSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SvodHeaderScalarRelationFilter = {
    is?: SvodHeaderWhereInput
    isNot?: SvodHeaderWhereInput
  }

  export type SvodLineSvodIdProductIdCompoundUniqueInput = {
    svodId: number
    productId: number
  }

  export type SvodLineCountOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    shortName?: SortOrder
    category?: SortOrder
    coefficient?: SortOrder
    orderQty?: SortOrder
    productionInQty?: SortOrder
    openingStock?: SortOrder
    openingStockIsManual?: SortOrder
    afterPurchaseStock?: SortOrder
    afterShipmentStock?: SortOrder
    qtyToShip?: SortOrder
    factMinusWaste?: SortOrder
    weightToShip?: SortOrder
    planFactDiff?: SortOrder
    underOver?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SvodLineAvgOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    coefficient?: SortOrder
    orderQty?: SortOrder
    productionInQty?: SortOrder
    openingStock?: SortOrder
    afterPurchaseStock?: SortOrder
    afterShipmentStock?: SortOrder
    qtyToShip?: SortOrder
    factMinusWaste?: SortOrder
    weightToShip?: SortOrder
    planFactDiff?: SortOrder
    underOver?: SortOrder
    sortOrder?: SortOrder
  }

  export type SvodLineMaxOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    shortName?: SortOrder
    category?: SortOrder
    coefficient?: SortOrder
    orderQty?: SortOrder
    productionInQty?: SortOrder
    openingStock?: SortOrder
    openingStockIsManual?: SortOrder
    afterPurchaseStock?: SortOrder
    afterShipmentStock?: SortOrder
    qtyToShip?: SortOrder
    factMinusWaste?: SortOrder
    weightToShip?: SortOrder
    planFactDiff?: SortOrder
    underOver?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SvodLineMinOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    shortName?: SortOrder
    category?: SortOrder
    coefficient?: SortOrder
    orderQty?: SortOrder
    productionInQty?: SortOrder
    openingStock?: SortOrder
    openingStockIsManual?: SortOrder
    afterPurchaseStock?: SortOrder
    afterShipmentStock?: SortOrder
    qtyToShip?: SortOrder
    factMinusWaste?: SortOrder
    weightToShip?: SortOrder
    planFactDiff?: SortOrder
    underOver?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SvodLineSumOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    coefficient?: SortOrder
    orderQty?: SortOrder
    productionInQty?: SortOrder
    openingStock?: SortOrder
    afterPurchaseStock?: SortOrder
    afterShipmentStock?: SortOrder
    qtyToShip?: SortOrder
    factMinusWaste?: SortOrder
    weightToShip?: SortOrder
    planFactDiff?: SortOrder
    underOver?: SortOrder
    sortOrder?: SortOrder
  }

  export type SvodSupplierColSvodIdColIndexCompoundUniqueInput = {
    svodId: number
    colIndex: number
  }

  export type SvodSupplierColSvodIdSupplierIdCompoundUniqueInput = {
    svodId: number
    supplierId: number
  }

  export type SvodSupplierColCountOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    colIndex?: SortOrder
    supplierId?: SortOrder
    supplierName?: SortOrder
    totalPurchase?: SortOrder
    createdAt?: SortOrder
  }

  export type SvodSupplierColAvgOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    colIndex?: SortOrder
    supplierId?: SortOrder
    totalPurchase?: SortOrder
  }

  export type SvodSupplierColMaxOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    colIndex?: SortOrder
    supplierId?: SortOrder
    supplierName?: SortOrder
    totalPurchase?: SortOrder
    createdAt?: SortOrder
  }

  export type SvodSupplierColMinOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    colIndex?: SortOrder
    supplierId?: SortOrder
    supplierName?: SortOrder
    totalPurchase?: SortOrder
    createdAt?: SortOrder
  }

  export type SvodSupplierColSumOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    colIndex?: SortOrder
    supplierId?: SortOrder
    totalPurchase?: SortOrder
  }

  export type SvodSupplierValueSvodIdProductIdSupplierIdCompoundUniqueInput = {
    svodId: number
    productId: number
    supplierId: number
  }

  export type SvodSupplierValueCountOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    supplierId?: SortOrder
    purchaseQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SvodSupplierValueAvgOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    supplierId?: SortOrder
    purchaseQty?: SortOrder
  }

  export type SvodSupplierValueMaxOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    supplierId?: SortOrder
    purchaseQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SvodSupplierValueMinOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    supplierId?: SortOrder
    purchaseQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SvodSupplierValueSumOrderByAggregateInput = {
    id?: SortOrder
    svodId?: SortOrder
    productId?: SortOrder
    supplierId?: SortOrder
    purchaseQty?: SortOrder
  }

  export type WarehouseScalarRelationFilter = {
    is?: WarehouseWhereInput
    isNot?: WarehouseWhereInput
  }

  export type ProductionDocDateWarehouseIdCompoundUniqueInput = {
    date: Date | string
    warehouseId: number
  }

  export type ProductionDocCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionDocAvgOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    createdByUserId?: SortOrder
  }

  export type ProductionDocMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionDocMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionDocSumOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    createdByUserId?: SortOrder
  }

  export type ProductionDocScalarRelationFilter = {
    is?: ProductionDocWhereInput
    isNot?: ProductionDocWhereInput
  }

  export type PurchaseItemScalarRelationFilter = {
    is?: PurchaseItemWhereInput
    isNot?: PurchaseItemWhereInput
  }

  export type ProductionInputProductionDocIdPurchaseItemIdCompoundUniqueInput = {
    productionDocId: number
    purchaseItemId: number
  }

  export type ProductionInputCountOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    purchaseId?: SortOrder
    purchaseItemId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    qtyIn?: SortOrder
    qtyUsed?: SortOrder
    priceIn?: SortOrder
    loadedAt?: SortOrder
    loadedByUserId?: SortOrder
  }

  export type ProductionInputAvgOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    purchaseId?: SortOrder
    purchaseItemId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    qtyIn?: SortOrder
    qtyUsed?: SortOrder
    priceIn?: SortOrder
    loadedByUserId?: SortOrder
  }

  export type ProductionInputMaxOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    purchaseId?: SortOrder
    purchaseItemId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    qtyIn?: SortOrder
    qtyUsed?: SortOrder
    priceIn?: SortOrder
    loadedAt?: SortOrder
    loadedByUserId?: SortOrder
  }

  export type ProductionInputMinOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    purchaseId?: SortOrder
    purchaseItemId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    qtyIn?: SortOrder
    qtyUsed?: SortOrder
    priceIn?: SortOrder
    loadedAt?: SortOrder
    loadedByUserId?: SortOrder
  }

  export type ProductionInputSumOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    purchaseId?: SortOrder
    purchaseItemId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    qtyIn?: SortOrder
    qtyUsed?: SortOrder
    priceIn?: SortOrder
    loadedByUserId?: SortOrder
  }

  export type ProductionOutputProductionDocIdProductIdCompoundUniqueInput = {
    productionDocId: number
    productId: number
  }

  export type ProductionOutputCountOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productId?: SortOrder
    qtyOut?: SortOrder
    uom?: SortOrder
    costTotal?: SortOrder
    costPerUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionOutputAvgOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productId?: SortOrder
    qtyOut?: SortOrder
    costTotal?: SortOrder
    costPerUnit?: SortOrder
  }

  export type ProductionOutputMaxOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productId?: SortOrder
    qtyOut?: SortOrder
    uom?: SortOrder
    costTotal?: SortOrder
    costPerUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionOutputMinOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productId?: SortOrder
    qtyOut?: SortOrder
    uom?: SortOrder
    costTotal?: SortOrder
    costPerUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionOutputSumOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productId?: SortOrder
    qtyOut?: SortOrder
    costTotal?: SortOrder
    costPerUnit?: SortOrder
  }

  export type ProductionInputScalarRelationFilter = {
    is?: ProductionInputWhereInput
    isNot?: ProductionInputWhereInput
  }

  export type ProductionCuttingLineCountOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productionInputId?: SortOrder
    mmlId?: SortOrder
    outProductId?: SortOrder
    qtyOut?: SortOrder
    qtyInConsumed?: SortOrder
    createdAt?: SortOrder
    createdByUserId?: SortOrder
  }

  export type ProductionCuttingLineAvgOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productionInputId?: SortOrder
    mmlId?: SortOrder
    outProductId?: SortOrder
    qtyOut?: SortOrder
    qtyInConsumed?: SortOrder
    createdByUserId?: SortOrder
  }

  export type ProductionCuttingLineMaxOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productionInputId?: SortOrder
    mmlId?: SortOrder
    outProductId?: SortOrder
    qtyOut?: SortOrder
    qtyInConsumed?: SortOrder
    createdAt?: SortOrder
    createdByUserId?: SortOrder
  }

  export type ProductionCuttingLineMinOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productionInputId?: SortOrder
    mmlId?: SortOrder
    outProductId?: SortOrder
    qtyOut?: SortOrder
    qtyInConsumed?: SortOrder
    createdAt?: SortOrder
    createdByUserId?: SortOrder
  }

  export type ProductionCuttingLineSumOrderByAggregateInput = {
    id?: SortOrder
    productionDocId?: SortOrder
    productionInputId?: SortOrder
    mmlId?: SortOrder
    outProductId?: SortOrder
    qtyOut?: SortOrder
    qtyInConsumed?: SortOrder
    createdByUserId?: SortOrder
  }

  export type ProductionStaffCreateNestedOneWithoutUserInput = {
    create?: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutUserInput
    connect?: ProductionStaffWhereUniqueInput
  }

  export type ProductionMmlCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput> | ProductionMmlCreateWithoutCreatorInput[] | ProductionMmlUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutCreatorInput | ProductionMmlCreateOrConnectWithoutCreatorInput[]
    createMany?: ProductionMmlCreateManyCreatorInputEnvelope
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
  }

  export type ProductionRunCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput> | ProductionRunCreateWithoutUserInput[] | ProductionRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutUserInput | ProductionRunCreateOrConnectWithoutUserInput[]
    createMany?: ProductionRunCreateManyUserInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<PurchaseCreateWithoutCreatedByUserInput, PurchaseUncheckedCreateWithoutCreatedByUserInput> | PurchaseCreateWithoutCreatedByUserInput[] | PurchaseUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatedByUserInput | PurchaseCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: PurchaseCreateManyCreatedByUserInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type WarehouseCreateNestedManyWithoutResponsibleUserInput = {
    create?: XOR<WarehouseCreateWithoutResponsibleUserInput, WarehouseUncheckedCreateWithoutResponsibleUserInput> | WarehouseCreateWithoutResponsibleUserInput[] | WarehouseUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutResponsibleUserInput | WarehouseCreateOrConnectWithoutResponsibleUserInput[]
    createMany?: WarehouseCreateManyResponsibleUserInputEnvelope
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
  }

  export type ProductionDocCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProductionDocCreateWithoutCreatedByInput, ProductionDocUncheckedCreateWithoutCreatedByInput> | ProductionDocCreateWithoutCreatedByInput[] | ProductionDocUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProductionDocCreateOrConnectWithoutCreatedByInput | ProductionDocCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProductionDocCreateManyCreatedByInputEnvelope
    connect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
  }

  export type ProductionInputCreateNestedManyWithoutLoadedByInput = {
    create?: XOR<ProductionInputCreateWithoutLoadedByInput, ProductionInputUncheckedCreateWithoutLoadedByInput> | ProductionInputCreateWithoutLoadedByInput[] | ProductionInputUncheckedCreateWithoutLoadedByInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutLoadedByInput | ProductionInputCreateOrConnectWithoutLoadedByInput[]
    createMany?: ProductionInputCreateManyLoadedByInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type ProductionCuttingLineCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutCreatedByInput, ProductionCuttingLineUncheckedCreateWithoutCreatedByInput> | ProductionCuttingLineCreateWithoutCreatedByInput[] | ProductionCuttingLineUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutCreatedByInput | ProductionCuttingLineCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProductionCuttingLineCreateManyCreatedByInputEnvelope
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
  }

  export type ProductionStaffUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutUserInput
    connect?: ProductionStaffWhereUniqueInput
  }

  export type ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput> | ProductionMmlCreateWithoutCreatorInput[] | ProductionMmlUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutCreatorInput | ProductionMmlCreateOrConnectWithoutCreatorInput[]
    createMany?: ProductionMmlCreateManyCreatorInputEnvelope
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
  }

  export type ProductionRunUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput> | ProductionRunCreateWithoutUserInput[] | ProductionRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutUserInput | ProductionRunCreateOrConnectWithoutUserInput[]
    createMany?: ProductionRunCreateManyUserInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<PurchaseCreateWithoutCreatedByUserInput, PurchaseUncheckedCreateWithoutCreatedByUserInput> | PurchaseCreateWithoutCreatedByUserInput[] | PurchaseUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatedByUserInput | PurchaseCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: PurchaseCreateManyCreatedByUserInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type WarehouseUncheckedCreateNestedManyWithoutResponsibleUserInput = {
    create?: XOR<WarehouseCreateWithoutResponsibleUserInput, WarehouseUncheckedCreateWithoutResponsibleUserInput> | WarehouseCreateWithoutResponsibleUserInput[] | WarehouseUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutResponsibleUserInput | WarehouseCreateOrConnectWithoutResponsibleUserInput[]
    createMany?: WarehouseCreateManyResponsibleUserInputEnvelope
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
  }

  export type ProductionDocUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProductionDocCreateWithoutCreatedByInput, ProductionDocUncheckedCreateWithoutCreatedByInput> | ProductionDocCreateWithoutCreatedByInput[] | ProductionDocUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProductionDocCreateOrConnectWithoutCreatedByInput | ProductionDocCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProductionDocCreateManyCreatedByInputEnvelope
    connect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
  }

  export type ProductionInputUncheckedCreateNestedManyWithoutLoadedByInput = {
    create?: XOR<ProductionInputCreateWithoutLoadedByInput, ProductionInputUncheckedCreateWithoutLoadedByInput> | ProductionInputCreateWithoutLoadedByInput[] | ProductionInputUncheckedCreateWithoutLoadedByInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutLoadedByInput | ProductionInputCreateOrConnectWithoutLoadedByInput[]
    createMany?: ProductionInputCreateManyLoadedByInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type ProductionCuttingLineUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutCreatedByInput, ProductionCuttingLineUncheckedCreateWithoutCreatedByInput> | ProductionCuttingLineCreateWithoutCreatedByInput[] | ProductionCuttingLineUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutCreatedByInput | ProductionCuttingLineCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProductionCuttingLineCreateManyCreatedByInputEnvelope
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProductionStaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutUserInput
    upsert?: ProductionStaffUpsertWithoutUserInput
    disconnect?: ProductionStaffWhereInput | boolean
    delete?: ProductionStaffWhereInput | boolean
    connect?: ProductionStaffWhereUniqueInput
    update?: XOR<XOR<ProductionStaffUpdateToOneWithWhereWithoutUserInput, ProductionStaffUpdateWithoutUserInput>, ProductionStaffUncheckedUpdateWithoutUserInput>
  }

  export type ProductionMmlUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput> | ProductionMmlCreateWithoutCreatorInput[] | ProductionMmlUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutCreatorInput | ProductionMmlCreateOrConnectWithoutCreatorInput[]
    upsert?: ProductionMmlUpsertWithWhereUniqueWithoutCreatorInput | ProductionMmlUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProductionMmlCreateManyCreatorInputEnvelope
    set?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    disconnect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    delete?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    update?: ProductionMmlUpdateWithWhereUniqueWithoutCreatorInput | ProductionMmlUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProductionMmlUpdateManyWithWhereWithoutCreatorInput | ProductionMmlUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
  }

  export type ProductionRunUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput> | ProductionRunCreateWithoutUserInput[] | ProductionRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutUserInput | ProductionRunCreateOrConnectWithoutUserInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutUserInput | ProductionRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductionRunCreateManyUserInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutUserInput | ProductionRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutUserInput | ProductionRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<PurchaseCreateWithoutCreatedByUserInput, PurchaseUncheckedCreateWithoutCreatedByUserInput> | PurchaseCreateWithoutCreatedByUserInput[] | PurchaseUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatedByUserInput | PurchaseCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutCreatedByUserInput | PurchaseUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: PurchaseCreateManyCreatedByUserInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutCreatedByUserInput | PurchaseUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutCreatedByUserInput | PurchaseUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type WarehouseUpdateManyWithoutResponsibleUserNestedInput = {
    create?: XOR<WarehouseCreateWithoutResponsibleUserInput, WarehouseUncheckedCreateWithoutResponsibleUserInput> | WarehouseCreateWithoutResponsibleUserInput[] | WarehouseUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutResponsibleUserInput | WarehouseCreateOrConnectWithoutResponsibleUserInput[]
    upsert?: WarehouseUpsertWithWhereUniqueWithoutResponsibleUserInput | WarehouseUpsertWithWhereUniqueWithoutResponsibleUserInput[]
    createMany?: WarehouseCreateManyResponsibleUserInputEnvelope
    set?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    disconnect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    delete?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    update?: WarehouseUpdateWithWhereUniqueWithoutResponsibleUserInput | WarehouseUpdateWithWhereUniqueWithoutResponsibleUserInput[]
    updateMany?: WarehouseUpdateManyWithWhereWithoutResponsibleUserInput | WarehouseUpdateManyWithWhereWithoutResponsibleUserInput[]
    deleteMany?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
  }

  export type ProductionDocUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProductionDocCreateWithoutCreatedByInput, ProductionDocUncheckedCreateWithoutCreatedByInput> | ProductionDocCreateWithoutCreatedByInput[] | ProductionDocUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProductionDocCreateOrConnectWithoutCreatedByInput | ProductionDocCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProductionDocUpsertWithWhereUniqueWithoutCreatedByInput | ProductionDocUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProductionDocCreateManyCreatedByInputEnvelope
    set?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    disconnect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    delete?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    connect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    update?: ProductionDocUpdateWithWhereUniqueWithoutCreatedByInput | ProductionDocUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProductionDocUpdateManyWithWhereWithoutCreatedByInput | ProductionDocUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProductionDocScalarWhereInput | ProductionDocScalarWhereInput[]
  }

  export type ProductionInputUpdateManyWithoutLoadedByNestedInput = {
    create?: XOR<ProductionInputCreateWithoutLoadedByInput, ProductionInputUncheckedCreateWithoutLoadedByInput> | ProductionInputCreateWithoutLoadedByInput[] | ProductionInputUncheckedCreateWithoutLoadedByInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutLoadedByInput | ProductionInputCreateOrConnectWithoutLoadedByInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutLoadedByInput | ProductionInputUpsertWithWhereUniqueWithoutLoadedByInput[]
    createMany?: ProductionInputCreateManyLoadedByInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutLoadedByInput | ProductionInputUpdateWithWhereUniqueWithoutLoadedByInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutLoadedByInput | ProductionInputUpdateManyWithWhereWithoutLoadedByInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type ProductionCuttingLineUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutCreatedByInput, ProductionCuttingLineUncheckedCreateWithoutCreatedByInput> | ProductionCuttingLineCreateWithoutCreatedByInput[] | ProductionCuttingLineUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutCreatedByInput | ProductionCuttingLineCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProductionCuttingLineUpsertWithWhereUniqueWithoutCreatedByInput | ProductionCuttingLineUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProductionCuttingLineCreateManyCreatedByInputEnvelope
    set?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    disconnect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    delete?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    update?: ProductionCuttingLineUpdateWithWhereUniqueWithoutCreatedByInput | ProductionCuttingLineUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProductionCuttingLineUpdateManyWithWhereWithoutCreatedByInput | ProductionCuttingLineUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductionStaffUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutUserInput
    upsert?: ProductionStaffUpsertWithoutUserInput
    disconnect?: ProductionStaffWhereInput | boolean
    delete?: ProductionStaffWhereInput | boolean
    connect?: ProductionStaffWhereUniqueInput
    update?: XOR<XOR<ProductionStaffUpdateToOneWithWhereWithoutUserInput, ProductionStaffUpdateWithoutUserInput>, ProductionStaffUncheckedUpdateWithoutUserInput>
  }

  export type ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput> | ProductionMmlCreateWithoutCreatorInput[] | ProductionMmlUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutCreatorInput | ProductionMmlCreateOrConnectWithoutCreatorInput[]
    upsert?: ProductionMmlUpsertWithWhereUniqueWithoutCreatorInput | ProductionMmlUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProductionMmlCreateManyCreatorInputEnvelope
    set?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    disconnect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    delete?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    update?: ProductionMmlUpdateWithWhereUniqueWithoutCreatorInput | ProductionMmlUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProductionMmlUpdateManyWithWhereWithoutCreatorInput | ProductionMmlUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
  }

  export type ProductionRunUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput> | ProductionRunCreateWithoutUserInput[] | ProductionRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutUserInput | ProductionRunCreateOrConnectWithoutUserInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutUserInput | ProductionRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductionRunCreateManyUserInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutUserInput | ProductionRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutUserInput | ProductionRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<PurchaseCreateWithoutCreatedByUserInput, PurchaseUncheckedCreateWithoutCreatedByUserInput> | PurchaseCreateWithoutCreatedByUserInput[] | PurchaseUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatedByUserInput | PurchaseCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutCreatedByUserInput | PurchaseUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: PurchaseCreateManyCreatedByUserInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutCreatedByUserInput | PurchaseUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutCreatedByUserInput | PurchaseUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type WarehouseUncheckedUpdateManyWithoutResponsibleUserNestedInput = {
    create?: XOR<WarehouseCreateWithoutResponsibleUserInput, WarehouseUncheckedCreateWithoutResponsibleUserInput> | WarehouseCreateWithoutResponsibleUserInput[] | WarehouseUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutResponsibleUserInput | WarehouseCreateOrConnectWithoutResponsibleUserInput[]
    upsert?: WarehouseUpsertWithWhereUniqueWithoutResponsibleUserInput | WarehouseUpsertWithWhereUniqueWithoutResponsibleUserInput[]
    createMany?: WarehouseCreateManyResponsibleUserInputEnvelope
    set?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    disconnect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    delete?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    update?: WarehouseUpdateWithWhereUniqueWithoutResponsibleUserInput | WarehouseUpdateWithWhereUniqueWithoutResponsibleUserInput[]
    updateMany?: WarehouseUpdateManyWithWhereWithoutResponsibleUserInput | WarehouseUpdateManyWithWhereWithoutResponsibleUserInput[]
    deleteMany?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
  }

  export type ProductionDocUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProductionDocCreateWithoutCreatedByInput, ProductionDocUncheckedCreateWithoutCreatedByInput> | ProductionDocCreateWithoutCreatedByInput[] | ProductionDocUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProductionDocCreateOrConnectWithoutCreatedByInput | ProductionDocCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProductionDocUpsertWithWhereUniqueWithoutCreatedByInput | ProductionDocUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProductionDocCreateManyCreatedByInputEnvelope
    set?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    disconnect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    delete?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    connect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    update?: ProductionDocUpdateWithWhereUniqueWithoutCreatedByInput | ProductionDocUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProductionDocUpdateManyWithWhereWithoutCreatedByInput | ProductionDocUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProductionDocScalarWhereInput | ProductionDocScalarWhereInput[]
  }

  export type ProductionInputUncheckedUpdateManyWithoutLoadedByNestedInput = {
    create?: XOR<ProductionInputCreateWithoutLoadedByInput, ProductionInputUncheckedCreateWithoutLoadedByInput> | ProductionInputCreateWithoutLoadedByInput[] | ProductionInputUncheckedCreateWithoutLoadedByInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutLoadedByInput | ProductionInputCreateOrConnectWithoutLoadedByInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutLoadedByInput | ProductionInputUpsertWithWhereUniqueWithoutLoadedByInput[]
    createMany?: ProductionInputCreateManyLoadedByInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutLoadedByInput | ProductionInputUpdateWithWhereUniqueWithoutLoadedByInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutLoadedByInput | ProductionInputUpdateManyWithWhereWithoutLoadedByInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type ProductionCuttingLineUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutCreatedByInput, ProductionCuttingLineUncheckedCreateWithoutCreatedByInput> | ProductionCuttingLineCreateWithoutCreatedByInput[] | ProductionCuttingLineUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutCreatedByInput | ProductionCuttingLineCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProductionCuttingLineUpsertWithWhereUniqueWithoutCreatedByInput | ProductionCuttingLineUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProductionCuttingLineCreateManyCreatedByInputEnvelope
    set?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    disconnect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    delete?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    update?: ProductionCuttingLineUpdateWithWhereUniqueWithoutCreatedByInput | ProductionCuttingLineUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProductionCuttingLineUpdateManyWithWhereWithoutCreatedByInput | ProductionCuttingLineUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
  }

  export type CustomerCreateNestedManyWithoutDistrictInput = {
    create?: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput> | CustomerCreateWithoutDistrictInput[] | CustomerUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDistrictInput | CustomerCreateOrConnectWithoutDistrictInput[]
    createMany?: CustomerCreateManyDistrictInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput> | CustomerCreateWithoutDistrictInput[] | CustomerUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDistrictInput | CustomerCreateOrConnectWithoutDistrictInput[]
    createMany?: CustomerCreateManyDistrictInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput> | CustomerCreateWithoutDistrictInput[] | CustomerUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDistrictInput | CustomerCreateOrConnectWithoutDistrictInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutDistrictInput | CustomerUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: CustomerCreateManyDistrictInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutDistrictInput | CustomerUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutDistrictInput | CustomerUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput> | CustomerCreateWithoutDistrictInput[] | CustomerUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDistrictInput | CustomerCreateOrConnectWithoutDistrictInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutDistrictInput | CustomerUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: CustomerCreateManyDistrictInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutDistrictInput | CustomerUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutDistrictInput | CustomerUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerCreateNestedManyWithoutManagerInput = {
    create?: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput> | CustomerCreateWithoutManagerInput[] | CustomerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutManagerInput | CustomerCreateOrConnectWithoutManagerInput[]
    createMany?: CustomerCreateManyManagerInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput> | CustomerCreateWithoutManagerInput[] | CustomerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutManagerInput | CustomerCreateOrConnectWithoutManagerInput[]
    createMany?: CustomerCreateManyManagerInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUpdateManyWithoutManagerNestedInput = {
    create?: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput> | CustomerCreateWithoutManagerInput[] | CustomerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutManagerInput | CustomerCreateOrConnectWithoutManagerInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutManagerInput | CustomerUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: CustomerCreateManyManagerInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutManagerInput | CustomerUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutManagerInput | CustomerUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput> | CustomerCreateWithoutManagerInput[] | CustomerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutManagerInput | CustomerCreateOrConnectWithoutManagerInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutManagerInput | CustomerUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: CustomerCreateManyManagerInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutManagerInput | CustomerUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutManagerInput | CustomerUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StockCreateNestedOneWithoutProductInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    connect?: StockWhereUniqueInput
  }

  export type StockTransactionCreateNestedManyWithoutProductInput = {
    create?: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput> | StockTransactionCreateWithoutProductInput[] | StockTransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutProductInput | StockTransactionCreateOrConnectWithoutProductInput[]
    createMany?: StockTransactionCreateManyProductInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type SupplierProductCreateNestedManyWithoutProductInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type SummaryOrderJournalCreateNestedManyWithoutProductInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput> | SummaryOrderJournalCreateWithoutProductInput[] | SummaryOrderJournalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutProductInput | SummaryOrderJournalCreateOrConnectWithoutProductInput[]
    createMany?: SummaryOrderJournalCreateManyProductInputEnvelope
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
  }

  export type ProductionItemCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput> | ProductionItemCreateWithoutProductInput[] | ProductionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutProductInput | ProductionItemCreateOrConnectWithoutProductInput[]
    createMany?: ProductionItemCreateManyProductInputEnvelope
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
  }

  export type PurchasePriceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput> | PurchasePriceItemCreateWithoutProductInput[] | PurchasePriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutProductInput | PurchasePriceItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchasePriceItemCreateManyProductInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type SalesPriceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput> | SalesPriceItemCreateWithoutProductInput[] | SalesPriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutProductInput | SalesPriceItemCreateOrConnectWithoutProductInput[]
    createMany?: SalesPriceItemCreateManyProductInputEnvelope
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
  }

  export type ProductionMmlCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput> | ProductionMmlCreateWithoutProductInput[] | ProductionMmlUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutProductInput | ProductionMmlCreateOrConnectWithoutProductInput[]
    createMany?: ProductionMmlCreateManyProductInputEnvelope
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
  }

  export type ProductionMmlNodeCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput> | ProductionMmlNodeCreateWithoutProductInput[] | ProductionMmlNodeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutProductInput | ProductionMmlNodeCreateOrConnectWithoutProductInput[]
    createMany?: ProductionMmlNodeCreateManyProductInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductionRunCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput> | ProductionRunCreateWithoutProductInput[] | ProductionRunUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutProductInput | ProductionRunCreateOrConnectWithoutProductInput[]
    createMany?: ProductionRunCreateManyProductInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type ProductionRunValueCreateNestedManyWithoutSnapshotProductInput = {
    create?: XOR<ProductionRunValueCreateWithoutSnapshotProductInput, ProductionRunValueUncheckedCreateWithoutSnapshotProductInput> | ProductionRunValueCreateWithoutSnapshotProductInput[] | ProductionRunValueUncheckedCreateWithoutSnapshotProductInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutSnapshotProductInput | ProductionRunValueCreateOrConnectWithoutSnapshotProductInput[]
    createMany?: ProductionRunValueCreateManySnapshotProductInputEnvelope
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type SvodLineCreateNestedManyWithoutProductInput = {
    create?: XOR<SvodLineCreateWithoutProductInput, SvodLineUncheckedCreateWithoutProductInput> | SvodLineCreateWithoutProductInput[] | SvodLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SvodLineCreateOrConnectWithoutProductInput | SvodLineCreateOrConnectWithoutProductInput[]
    createMany?: SvodLineCreateManyProductInputEnvelope
    connect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
  }

  export type SvodSupplierValueCreateNestedManyWithoutProductInput = {
    create?: XOR<SvodSupplierValueCreateWithoutProductInput, SvodSupplierValueUncheckedCreateWithoutProductInput> | SvodSupplierValueCreateWithoutProductInput[] | SvodSupplierValueUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutProductInput | SvodSupplierValueCreateOrConnectWithoutProductInput[]
    createMany?: SvodSupplierValueCreateManyProductInputEnvelope
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
  }

  export type ProductionInputCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionInputCreateWithoutProductInput, ProductionInputUncheckedCreateWithoutProductInput> | ProductionInputCreateWithoutProductInput[] | ProductionInputUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutProductInput | ProductionInputCreateOrConnectWithoutProductInput[]
    createMany?: ProductionInputCreateManyProductInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type ProductionOutputCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionOutputCreateWithoutProductInput, ProductionOutputUncheckedCreateWithoutProductInput> | ProductionOutputCreateWithoutProductInput[] | ProductionOutputUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionOutputCreateOrConnectWithoutProductInput | ProductionOutputCreateOrConnectWithoutProductInput[]
    createMany?: ProductionOutputCreateManyProductInputEnvelope
    connect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
  }

  export type ProductionCuttingLineCreateNestedManyWithoutOutProductInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutOutProductInput, ProductionCuttingLineUncheckedCreateWithoutOutProductInput> | ProductionCuttingLineCreateWithoutOutProductInput[] | ProductionCuttingLineUncheckedCreateWithoutOutProductInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutOutProductInput | ProductionCuttingLineCreateOrConnectWithoutOutProductInput[]
    createMany?: ProductionCuttingLineCreateManyOutProductInputEnvelope
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
  }

  export type CustomerProductCreateNestedManyWithoutProductInput = {
    create?: XOR<CustomerProductCreateWithoutProductInput, CustomerProductUncheckedCreateWithoutProductInput> | CustomerProductCreateWithoutProductInput[] | CustomerProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerProductCreateOrConnectWithoutProductInput | CustomerProductCreateOrConnectWithoutProductInput[]
    createMany?: CustomerProductCreateManyProductInputEnvelope
    connect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StockUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    connect?: StockWhereUniqueInput
  }

  export type StockTransactionUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput> | StockTransactionCreateWithoutProductInput[] | StockTransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutProductInput | StockTransactionCreateOrConnectWithoutProductInput[]
    createMany?: StockTransactionCreateManyProductInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type SupplierProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput> | SummaryOrderJournalCreateWithoutProductInput[] | SummaryOrderJournalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutProductInput | SummaryOrderJournalCreateOrConnectWithoutProductInput[]
    createMany?: SummaryOrderJournalCreateManyProductInputEnvelope
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
  }

  export type ProductionItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput> | ProductionItemCreateWithoutProductInput[] | ProductionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutProductInput | ProductionItemCreateOrConnectWithoutProductInput[]
    createMany?: ProductionItemCreateManyProductInputEnvelope
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
  }

  export type PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput> | PurchasePriceItemCreateWithoutProductInput[] | PurchasePriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutProductInput | PurchasePriceItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchasePriceItemCreateManyProductInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type SalesPriceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput> | SalesPriceItemCreateWithoutProductInput[] | SalesPriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutProductInput | SalesPriceItemCreateOrConnectWithoutProductInput[]
    createMany?: SalesPriceItemCreateManyProductInputEnvelope
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
  }

  export type ProductionMmlUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput> | ProductionMmlCreateWithoutProductInput[] | ProductionMmlUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutProductInput | ProductionMmlCreateOrConnectWithoutProductInput[]
    createMany?: ProductionMmlCreateManyProductInputEnvelope
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
  }

  export type ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput> | ProductionMmlNodeCreateWithoutProductInput[] | ProductionMmlNodeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutProductInput | ProductionMmlNodeCreateOrConnectWithoutProductInput[]
    createMany?: ProductionMmlNodeCreateManyProductInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductionRunUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput> | ProductionRunCreateWithoutProductInput[] | ProductionRunUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutProductInput | ProductionRunCreateOrConnectWithoutProductInput[]
    createMany?: ProductionRunCreateManyProductInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput = {
    create?: XOR<ProductionRunValueCreateWithoutSnapshotProductInput, ProductionRunValueUncheckedCreateWithoutSnapshotProductInput> | ProductionRunValueCreateWithoutSnapshotProductInput[] | ProductionRunValueUncheckedCreateWithoutSnapshotProductInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutSnapshotProductInput | ProductionRunValueCreateOrConnectWithoutSnapshotProductInput[]
    createMany?: ProductionRunValueCreateManySnapshotProductInputEnvelope
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type SvodLineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SvodLineCreateWithoutProductInput, SvodLineUncheckedCreateWithoutProductInput> | SvodLineCreateWithoutProductInput[] | SvodLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SvodLineCreateOrConnectWithoutProductInput | SvodLineCreateOrConnectWithoutProductInput[]
    createMany?: SvodLineCreateManyProductInputEnvelope
    connect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
  }

  export type SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SvodSupplierValueCreateWithoutProductInput, SvodSupplierValueUncheckedCreateWithoutProductInput> | SvodSupplierValueCreateWithoutProductInput[] | SvodSupplierValueUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutProductInput | SvodSupplierValueCreateOrConnectWithoutProductInput[]
    createMany?: SvodSupplierValueCreateManyProductInputEnvelope
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
  }

  export type ProductionInputUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionInputCreateWithoutProductInput, ProductionInputUncheckedCreateWithoutProductInput> | ProductionInputCreateWithoutProductInput[] | ProductionInputUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutProductInput | ProductionInputCreateOrConnectWithoutProductInput[]
    createMany?: ProductionInputCreateManyProductInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type ProductionOutputUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductionOutputCreateWithoutProductInput, ProductionOutputUncheckedCreateWithoutProductInput> | ProductionOutputCreateWithoutProductInput[] | ProductionOutputUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionOutputCreateOrConnectWithoutProductInput | ProductionOutputCreateOrConnectWithoutProductInput[]
    createMany?: ProductionOutputCreateManyProductInputEnvelope
    connect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
  }

  export type ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutOutProductInput, ProductionCuttingLineUncheckedCreateWithoutOutProductInput> | ProductionCuttingLineCreateWithoutOutProductInput[] | ProductionCuttingLineUncheckedCreateWithoutOutProductInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutOutProductInput | ProductionCuttingLineCreateOrConnectWithoutOutProductInput[]
    createMany?: ProductionCuttingLineCreateManyOutProductInputEnvelope
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
  }

  export type CustomerProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CustomerProductCreateWithoutProductInput, CustomerProductUncheckedCreateWithoutProductInput> | CustomerProductCreateWithoutProductInput[] | CustomerProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerProductCreateOrConnectWithoutProductInput | CustomerProductCreateOrConnectWithoutProductInput[]
    createMany?: CustomerProductCreateManyProductInputEnvelope
    connect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StockUpdateOneWithoutProductNestedInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    upsert?: StockUpsertWithoutProductInput
    disconnect?: StockWhereInput | boolean
    delete?: StockWhereInput | boolean
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutProductInput, StockUpdateWithoutProductInput>, StockUncheckedUpdateWithoutProductInput>
  }

  export type StockTransactionUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput> | StockTransactionCreateWithoutProductInput[] | StockTransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutProductInput | StockTransactionCreateOrConnectWithoutProductInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutProductInput | StockTransactionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockTransactionCreateManyProductInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutProductInput | StockTransactionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutProductInput | StockTransactionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type SupplierProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutProductInput | SupplierProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutProductInput | SupplierProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutProductInput | SupplierProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type SummaryOrderJournalUpdateManyWithoutProductNestedInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput> | SummaryOrderJournalCreateWithoutProductInput[] | SummaryOrderJournalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutProductInput | SummaryOrderJournalCreateOrConnectWithoutProductInput[]
    upsert?: SummaryOrderJournalUpsertWithWhereUniqueWithoutProductInput | SummaryOrderJournalUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SummaryOrderJournalCreateManyProductInputEnvelope
    set?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    disconnect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    delete?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    update?: SummaryOrderJournalUpdateWithWhereUniqueWithoutProductInput | SummaryOrderJournalUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SummaryOrderJournalUpdateManyWithWhereWithoutProductInput | SummaryOrderJournalUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
  }

  export type ProductionItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput> | ProductionItemCreateWithoutProductInput[] | ProductionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutProductInput | ProductionItemCreateOrConnectWithoutProductInput[]
    upsert?: ProductionItemUpsertWithWhereUniqueWithoutProductInput | ProductionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionItemCreateManyProductInputEnvelope
    set?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    disconnect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    delete?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    update?: ProductionItemUpdateWithWhereUniqueWithoutProductInput | ProductionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionItemUpdateManyWithWhereWithoutProductInput | ProductionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
  }

  export type PurchasePriceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput> | PurchasePriceItemCreateWithoutProductInput[] | PurchasePriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutProductInput | PurchasePriceItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutProductInput | PurchasePriceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchasePriceItemCreateManyProductInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutProductInput | PurchasePriceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutProductInput | PurchasePriceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type SalesPriceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput> | SalesPriceItemCreateWithoutProductInput[] | SalesPriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutProductInput | SalesPriceItemCreateOrConnectWithoutProductInput[]
    upsert?: SalesPriceItemUpsertWithWhereUniqueWithoutProductInput | SalesPriceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SalesPriceItemCreateManyProductInputEnvelope
    set?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    disconnect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    delete?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    update?: SalesPriceItemUpdateWithWhereUniqueWithoutProductInput | SalesPriceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SalesPriceItemUpdateManyWithWhereWithoutProductInput | SalesPriceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
  }

  export type ProductionMmlUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput> | ProductionMmlCreateWithoutProductInput[] | ProductionMmlUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutProductInput | ProductionMmlCreateOrConnectWithoutProductInput[]
    upsert?: ProductionMmlUpsertWithWhereUniqueWithoutProductInput | ProductionMmlUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionMmlCreateManyProductInputEnvelope
    set?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    disconnect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    delete?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    update?: ProductionMmlUpdateWithWhereUniqueWithoutProductInput | ProductionMmlUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionMmlUpdateManyWithWhereWithoutProductInput | ProductionMmlUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
  }

  export type ProductionMmlNodeUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput> | ProductionMmlNodeCreateWithoutProductInput[] | ProductionMmlNodeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutProductInput | ProductionMmlNodeCreateOrConnectWithoutProductInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutProductInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionMmlNodeCreateManyProductInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutProductInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutProductInput | ProductionMmlNodeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductionRunUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput> | ProductionRunCreateWithoutProductInput[] | ProductionRunUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutProductInput | ProductionRunCreateOrConnectWithoutProductInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutProductInput | ProductionRunUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionRunCreateManyProductInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutProductInput | ProductionRunUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutProductInput | ProductionRunUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput = {
    create?: XOR<ProductionRunValueCreateWithoutSnapshotProductInput, ProductionRunValueUncheckedCreateWithoutSnapshotProductInput> | ProductionRunValueCreateWithoutSnapshotProductInput[] | ProductionRunValueUncheckedCreateWithoutSnapshotProductInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutSnapshotProductInput | ProductionRunValueCreateOrConnectWithoutSnapshotProductInput[]
    upsert?: ProductionRunValueUpsertWithWhereUniqueWithoutSnapshotProductInput | ProductionRunValueUpsertWithWhereUniqueWithoutSnapshotProductInput[]
    createMany?: ProductionRunValueCreateManySnapshotProductInputEnvelope
    set?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    disconnect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    delete?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    update?: ProductionRunValueUpdateWithWhereUniqueWithoutSnapshotProductInput | ProductionRunValueUpdateWithWhereUniqueWithoutSnapshotProductInput[]
    updateMany?: ProductionRunValueUpdateManyWithWhereWithoutSnapshotProductInput | ProductionRunValueUpdateManyWithWhereWithoutSnapshotProductInput[]
    deleteMany?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
  }

  export type PurchaseItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutProductInput | PurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutProductInput | PurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutProductInput | PurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type SvodLineUpdateManyWithoutProductNestedInput = {
    create?: XOR<SvodLineCreateWithoutProductInput, SvodLineUncheckedCreateWithoutProductInput> | SvodLineCreateWithoutProductInput[] | SvodLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SvodLineCreateOrConnectWithoutProductInput | SvodLineCreateOrConnectWithoutProductInput[]
    upsert?: SvodLineUpsertWithWhereUniqueWithoutProductInput | SvodLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SvodLineCreateManyProductInputEnvelope
    set?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    disconnect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    delete?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    connect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    update?: SvodLineUpdateWithWhereUniqueWithoutProductInput | SvodLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SvodLineUpdateManyWithWhereWithoutProductInput | SvodLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SvodLineScalarWhereInput | SvodLineScalarWhereInput[]
  }

  export type SvodSupplierValueUpdateManyWithoutProductNestedInput = {
    create?: XOR<SvodSupplierValueCreateWithoutProductInput, SvodSupplierValueUncheckedCreateWithoutProductInput> | SvodSupplierValueCreateWithoutProductInput[] | SvodSupplierValueUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutProductInput | SvodSupplierValueCreateOrConnectWithoutProductInput[]
    upsert?: SvodSupplierValueUpsertWithWhereUniqueWithoutProductInput | SvodSupplierValueUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SvodSupplierValueCreateManyProductInputEnvelope
    set?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    disconnect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    delete?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    update?: SvodSupplierValueUpdateWithWhereUniqueWithoutProductInput | SvodSupplierValueUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SvodSupplierValueUpdateManyWithWhereWithoutProductInput | SvodSupplierValueUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SvodSupplierValueScalarWhereInput | SvodSupplierValueScalarWhereInput[]
  }

  export type ProductionInputUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionInputCreateWithoutProductInput, ProductionInputUncheckedCreateWithoutProductInput> | ProductionInputCreateWithoutProductInput[] | ProductionInputUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutProductInput | ProductionInputCreateOrConnectWithoutProductInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutProductInput | ProductionInputUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionInputCreateManyProductInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutProductInput | ProductionInputUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutProductInput | ProductionInputUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type ProductionOutputUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionOutputCreateWithoutProductInput, ProductionOutputUncheckedCreateWithoutProductInput> | ProductionOutputCreateWithoutProductInput[] | ProductionOutputUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionOutputCreateOrConnectWithoutProductInput | ProductionOutputCreateOrConnectWithoutProductInput[]
    upsert?: ProductionOutputUpsertWithWhereUniqueWithoutProductInput | ProductionOutputUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionOutputCreateManyProductInputEnvelope
    set?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    disconnect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    delete?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    connect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    update?: ProductionOutputUpdateWithWhereUniqueWithoutProductInput | ProductionOutputUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionOutputUpdateManyWithWhereWithoutProductInput | ProductionOutputUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionOutputScalarWhereInput | ProductionOutputScalarWhereInput[]
  }

  export type ProductionCuttingLineUpdateManyWithoutOutProductNestedInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutOutProductInput, ProductionCuttingLineUncheckedCreateWithoutOutProductInput> | ProductionCuttingLineCreateWithoutOutProductInput[] | ProductionCuttingLineUncheckedCreateWithoutOutProductInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutOutProductInput | ProductionCuttingLineCreateOrConnectWithoutOutProductInput[]
    upsert?: ProductionCuttingLineUpsertWithWhereUniqueWithoutOutProductInput | ProductionCuttingLineUpsertWithWhereUniqueWithoutOutProductInput[]
    createMany?: ProductionCuttingLineCreateManyOutProductInputEnvelope
    set?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    disconnect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    delete?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    update?: ProductionCuttingLineUpdateWithWhereUniqueWithoutOutProductInput | ProductionCuttingLineUpdateWithWhereUniqueWithoutOutProductInput[]
    updateMany?: ProductionCuttingLineUpdateManyWithWhereWithoutOutProductInput | ProductionCuttingLineUpdateManyWithWhereWithoutOutProductInput[]
    deleteMany?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
  }

  export type CustomerProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<CustomerProductCreateWithoutProductInput, CustomerProductUncheckedCreateWithoutProductInput> | CustomerProductCreateWithoutProductInput[] | CustomerProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerProductCreateOrConnectWithoutProductInput | CustomerProductCreateOrConnectWithoutProductInput[]
    upsert?: CustomerProductUpsertWithWhereUniqueWithoutProductInput | CustomerProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CustomerProductCreateManyProductInputEnvelope
    set?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    disconnect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    delete?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    connect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    update?: CustomerProductUpdateWithWhereUniqueWithoutProductInput | CustomerProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CustomerProductUpdateManyWithWhereWithoutProductInput | CustomerProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CustomerProductScalarWhereInput | CustomerProductScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StockUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    upsert?: StockUpsertWithoutProductInput
    disconnect?: StockWhereInput | boolean
    delete?: StockWhereInput | boolean
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutProductInput, StockUpdateWithoutProductInput>, StockUncheckedUpdateWithoutProductInput>
  }

  export type StockTransactionUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput> | StockTransactionCreateWithoutProductInput[] | StockTransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutProductInput | StockTransactionCreateOrConnectWithoutProductInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutProductInput | StockTransactionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockTransactionCreateManyProductInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutProductInput | StockTransactionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutProductInput | StockTransactionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type SupplierProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutProductInput | SupplierProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutProductInput | SupplierProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutProductInput | SupplierProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput> | SummaryOrderJournalCreateWithoutProductInput[] | SummaryOrderJournalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutProductInput | SummaryOrderJournalCreateOrConnectWithoutProductInput[]
    upsert?: SummaryOrderJournalUpsertWithWhereUniqueWithoutProductInput | SummaryOrderJournalUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SummaryOrderJournalCreateManyProductInputEnvelope
    set?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    disconnect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    delete?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    update?: SummaryOrderJournalUpdateWithWhereUniqueWithoutProductInput | SummaryOrderJournalUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SummaryOrderJournalUpdateManyWithWhereWithoutProductInput | SummaryOrderJournalUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
  }

  export type ProductionItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput> | ProductionItemCreateWithoutProductInput[] | ProductionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutProductInput | ProductionItemCreateOrConnectWithoutProductInput[]
    upsert?: ProductionItemUpsertWithWhereUniqueWithoutProductInput | ProductionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionItemCreateManyProductInputEnvelope
    set?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    disconnect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    delete?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    update?: ProductionItemUpdateWithWhereUniqueWithoutProductInput | ProductionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionItemUpdateManyWithWhereWithoutProductInput | ProductionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput> | PurchasePriceItemCreateWithoutProductInput[] | PurchasePriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutProductInput | PurchasePriceItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutProductInput | PurchasePriceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchasePriceItemCreateManyProductInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutProductInput | PurchasePriceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutProductInput | PurchasePriceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput> | SalesPriceItemCreateWithoutProductInput[] | SalesPriceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutProductInput | SalesPriceItemCreateOrConnectWithoutProductInput[]
    upsert?: SalesPriceItemUpsertWithWhereUniqueWithoutProductInput | SalesPriceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SalesPriceItemCreateManyProductInputEnvelope
    set?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    disconnect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    delete?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    update?: SalesPriceItemUpdateWithWhereUniqueWithoutProductInput | SalesPriceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SalesPriceItemUpdateManyWithWhereWithoutProductInput | SalesPriceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
  }

  export type ProductionMmlUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput> | ProductionMmlCreateWithoutProductInput[] | ProductionMmlUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutProductInput | ProductionMmlCreateOrConnectWithoutProductInput[]
    upsert?: ProductionMmlUpsertWithWhereUniqueWithoutProductInput | ProductionMmlUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionMmlCreateManyProductInputEnvelope
    set?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    disconnect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    delete?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    connect?: ProductionMmlWhereUniqueInput | ProductionMmlWhereUniqueInput[]
    update?: ProductionMmlUpdateWithWhereUniqueWithoutProductInput | ProductionMmlUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionMmlUpdateManyWithWhereWithoutProductInput | ProductionMmlUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput> | ProductionMmlNodeCreateWithoutProductInput[] | ProductionMmlNodeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutProductInput | ProductionMmlNodeCreateOrConnectWithoutProductInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutProductInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionMmlNodeCreateManyProductInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutProductInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutProductInput | ProductionMmlNodeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductionRunUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput> | ProductionRunCreateWithoutProductInput[] | ProductionRunUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutProductInput | ProductionRunCreateOrConnectWithoutProductInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutProductInput | ProductionRunUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionRunCreateManyProductInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutProductInput | ProductionRunUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutProductInput | ProductionRunUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput = {
    create?: XOR<ProductionRunValueCreateWithoutSnapshotProductInput, ProductionRunValueUncheckedCreateWithoutSnapshotProductInput> | ProductionRunValueCreateWithoutSnapshotProductInput[] | ProductionRunValueUncheckedCreateWithoutSnapshotProductInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutSnapshotProductInput | ProductionRunValueCreateOrConnectWithoutSnapshotProductInput[]
    upsert?: ProductionRunValueUpsertWithWhereUniqueWithoutSnapshotProductInput | ProductionRunValueUpsertWithWhereUniqueWithoutSnapshotProductInput[]
    createMany?: ProductionRunValueCreateManySnapshotProductInputEnvelope
    set?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    disconnect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    delete?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    update?: ProductionRunValueUpdateWithWhereUniqueWithoutSnapshotProductInput | ProductionRunValueUpdateWithWhereUniqueWithoutSnapshotProductInput[]
    updateMany?: ProductionRunValueUpdateManyWithWhereWithoutSnapshotProductInput | ProductionRunValueUpdateManyWithWhereWithoutSnapshotProductInput[]
    deleteMany?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutProductInput | PurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutProductInput | PurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutProductInput | PurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type SvodLineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SvodLineCreateWithoutProductInput, SvodLineUncheckedCreateWithoutProductInput> | SvodLineCreateWithoutProductInput[] | SvodLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SvodLineCreateOrConnectWithoutProductInput | SvodLineCreateOrConnectWithoutProductInput[]
    upsert?: SvodLineUpsertWithWhereUniqueWithoutProductInput | SvodLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SvodLineCreateManyProductInputEnvelope
    set?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    disconnect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    delete?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    connect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    update?: SvodLineUpdateWithWhereUniqueWithoutProductInput | SvodLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SvodLineUpdateManyWithWhereWithoutProductInput | SvodLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SvodLineScalarWhereInput | SvodLineScalarWhereInput[]
  }

  export type SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SvodSupplierValueCreateWithoutProductInput, SvodSupplierValueUncheckedCreateWithoutProductInput> | SvodSupplierValueCreateWithoutProductInput[] | SvodSupplierValueUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutProductInput | SvodSupplierValueCreateOrConnectWithoutProductInput[]
    upsert?: SvodSupplierValueUpsertWithWhereUniqueWithoutProductInput | SvodSupplierValueUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SvodSupplierValueCreateManyProductInputEnvelope
    set?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    disconnect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    delete?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    update?: SvodSupplierValueUpdateWithWhereUniqueWithoutProductInput | SvodSupplierValueUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SvodSupplierValueUpdateManyWithWhereWithoutProductInput | SvodSupplierValueUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SvodSupplierValueScalarWhereInput | SvodSupplierValueScalarWhereInput[]
  }

  export type ProductionInputUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionInputCreateWithoutProductInput, ProductionInputUncheckedCreateWithoutProductInput> | ProductionInputCreateWithoutProductInput[] | ProductionInputUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutProductInput | ProductionInputCreateOrConnectWithoutProductInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutProductInput | ProductionInputUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionInputCreateManyProductInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutProductInput | ProductionInputUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutProductInput | ProductionInputUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type ProductionOutputUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductionOutputCreateWithoutProductInput, ProductionOutputUncheckedCreateWithoutProductInput> | ProductionOutputCreateWithoutProductInput[] | ProductionOutputUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductionOutputCreateOrConnectWithoutProductInput | ProductionOutputCreateOrConnectWithoutProductInput[]
    upsert?: ProductionOutputUpsertWithWhereUniqueWithoutProductInput | ProductionOutputUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductionOutputCreateManyProductInputEnvelope
    set?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    disconnect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    delete?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    connect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    update?: ProductionOutputUpdateWithWhereUniqueWithoutProductInput | ProductionOutputUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductionOutputUpdateManyWithWhereWithoutProductInput | ProductionOutputUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductionOutputScalarWhereInput | ProductionOutputScalarWhereInput[]
  }

  export type ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutOutProductInput, ProductionCuttingLineUncheckedCreateWithoutOutProductInput> | ProductionCuttingLineCreateWithoutOutProductInput[] | ProductionCuttingLineUncheckedCreateWithoutOutProductInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutOutProductInput | ProductionCuttingLineCreateOrConnectWithoutOutProductInput[]
    upsert?: ProductionCuttingLineUpsertWithWhereUniqueWithoutOutProductInput | ProductionCuttingLineUpsertWithWhereUniqueWithoutOutProductInput[]
    createMany?: ProductionCuttingLineCreateManyOutProductInputEnvelope
    set?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    disconnect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    delete?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    update?: ProductionCuttingLineUpdateWithWhereUniqueWithoutOutProductInput | ProductionCuttingLineUpdateWithWhereUniqueWithoutOutProductInput[]
    updateMany?: ProductionCuttingLineUpdateManyWithWhereWithoutOutProductInput | ProductionCuttingLineUpdateManyWithWhereWithoutOutProductInput[]
    deleteMany?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
  }

  export type CustomerProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CustomerProductCreateWithoutProductInput, CustomerProductUncheckedCreateWithoutProductInput> | CustomerProductCreateWithoutProductInput[] | CustomerProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerProductCreateOrConnectWithoutProductInput | CustomerProductCreateOrConnectWithoutProductInput[]
    upsert?: CustomerProductUpsertWithWhereUniqueWithoutProductInput | CustomerProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CustomerProductCreateManyProductInputEnvelope
    set?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    disconnect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    delete?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    connect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    update?: CustomerProductUpdateWithWhereUniqueWithoutProductInput | CustomerProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CustomerProductUpdateManyWithWhereWithoutProductInput | CustomerProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CustomerProductScalarWhereInput | CustomerProductScalarWhereInput[]
  }

  export type DistrictCreateNestedOneWithoutCustomersInput = {
    create?: XOR<DistrictCreateWithoutCustomersInput, DistrictUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutCustomersInput
    connect?: DistrictWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutCustomersInput = {
    create?: XOR<ManagerCreateWithoutCustomersInput, ManagerUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutCustomersInput
    connect?: ManagerWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SummaryOrderJournalCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput> | SummaryOrderJournalCreateWithoutCustomerInput[] | SummaryOrderJournalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutCustomerInput | SummaryOrderJournalCreateOrConnectWithoutCustomerInput[]
    createMany?: SummaryOrderJournalCreateManyCustomerInputEnvelope
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
  }

  export type SalesPriceListCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput> | SalesPriceListCreateWithoutCustomerInput[] | SalesPriceListUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutCustomerInput | SalesPriceListCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesPriceListCreateManyCustomerInputEnvelope
    connect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
  }

  export type CustomerProductCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerProductCreateWithoutCustomerInput, CustomerProductUncheckedCreateWithoutCustomerInput> | CustomerProductCreateWithoutCustomerInput[] | CustomerProductUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProductCreateOrConnectWithoutCustomerInput | CustomerProductCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerProductCreateManyCustomerInputEnvelope
    connect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput> | SummaryOrderJournalCreateWithoutCustomerInput[] | SummaryOrderJournalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutCustomerInput | SummaryOrderJournalCreateOrConnectWithoutCustomerInput[]
    createMany?: SummaryOrderJournalCreateManyCustomerInputEnvelope
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
  }

  export type SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput> | SalesPriceListCreateWithoutCustomerInput[] | SalesPriceListUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutCustomerInput | SalesPriceListCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesPriceListCreateManyCustomerInputEnvelope
    connect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
  }

  export type CustomerProductUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerProductCreateWithoutCustomerInput, CustomerProductUncheckedCreateWithoutCustomerInput> | CustomerProductCreateWithoutCustomerInput[] | CustomerProductUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProductCreateOrConnectWithoutCustomerInput | CustomerProductCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerProductCreateManyCustomerInputEnvelope
    connect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
  }

  export type DistrictUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<DistrictCreateWithoutCustomersInput, DistrictUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutCustomersInput
    upsert?: DistrictUpsertWithoutCustomersInput
    disconnect?: DistrictWhereInput | boolean
    delete?: DistrictWhereInput | boolean
    connect?: DistrictWhereUniqueInput
    update?: XOR<XOR<DistrictUpdateToOneWithWhereWithoutCustomersInput, DistrictUpdateWithoutCustomersInput>, DistrictUncheckedUpdateWithoutCustomersInput>
  }

  export type ManagerUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<ManagerCreateWithoutCustomersInput, ManagerUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutCustomersInput
    upsert?: ManagerUpsertWithoutCustomersInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutCustomersInput, ManagerUpdateWithoutCustomersInput>, ManagerUncheckedUpdateWithoutCustomersInput>
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SummaryOrderJournalUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput> | SummaryOrderJournalCreateWithoutCustomerInput[] | SummaryOrderJournalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutCustomerInput | SummaryOrderJournalCreateOrConnectWithoutCustomerInput[]
    upsert?: SummaryOrderJournalUpsertWithWhereUniqueWithoutCustomerInput | SummaryOrderJournalUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SummaryOrderJournalCreateManyCustomerInputEnvelope
    set?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    disconnect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    delete?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    update?: SummaryOrderJournalUpdateWithWhereUniqueWithoutCustomerInput | SummaryOrderJournalUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SummaryOrderJournalUpdateManyWithWhereWithoutCustomerInput | SummaryOrderJournalUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
  }

  export type SalesPriceListUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput> | SalesPriceListCreateWithoutCustomerInput[] | SalesPriceListUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutCustomerInput | SalesPriceListCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesPriceListUpsertWithWhereUniqueWithoutCustomerInput | SalesPriceListUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesPriceListCreateManyCustomerInputEnvelope
    set?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    disconnect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    delete?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    connect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    update?: SalesPriceListUpdateWithWhereUniqueWithoutCustomerInput | SalesPriceListUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesPriceListUpdateManyWithWhereWithoutCustomerInput | SalesPriceListUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesPriceListScalarWhereInput | SalesPriceListScalarWhereInput[]
  }

  export type CustomerProductUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerProductCreateWithoutCustomerInput, CustomerProductUncheckedCreateWithoutCustomerInput> | CustomerProductCreateWithoutCustomerInput[] | CustomerProductUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProductCreateOrConnectWithoutCustomerInput | CustomerProductCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerProductUpsertWithWhereUniqueWithoutCustomerInput | CustomerProductUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerProductCreateManyCustomerInputEnvelope
    set?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    disconnect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    delete?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    connect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    update?: CustomerProductUpdateWithWhereUniqueWithoutCustomerInput | CustomerProductUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerProductUpdateManyWithWhereWithoutCustomerInput | CustomerProductUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerProductScalarWhereInput | CustomerProductScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput> | SummaryOrderJournalCreateWithoutCustomerInput[] | SummaryOrderJournalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutCustomerInput | SummaryOrderJournalCreateOrConnectWithoutCustomerInput[]
    upsert?: SummaryOrderJournalUpsertWithWhereUniqueWithoutCustomerInput | SummaryOrderJournalUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SummaryOrderJournalCreateManyCustomerInputEnvelope
    set?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    disconnect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    delete?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    connect?: SummaryOrderJournalWhereUniqueInput | SummaryOrderJournalWhereUniqueInput[]
    update?: SummaryOrderJournalUpdateWithWhereUniqueWithoutCustomerInput | SummaryOrderJournalUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SummaryOrderJournalUpdateManyWithWhereWithoutCustomerInput | SummaryOrderJournalUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
  }

  export type SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput> | SalesPriceListCreateWithoutCustomerInput[] | SalesPriceListUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutCustomerInput | SalesPriceListCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesPriceListUpsertWithWhereUniqueWithoutCustomerInput | SalesPriceListUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesPriceListCreateManyCustomerInputEnvelope
    set?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    disconnect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    delete?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    connect?: SalesPriceListWhereUniqueInput | SalesPriceListWhereUniqueInput[]
    update?: SalesPriceListUpdateWithWhereUniqueWithoutCustomerInput | SalesPriceListUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesPriceListUpdateManyWithWhereWithoutCustomerInput | SalesPriceListUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesPriceListScalarWhereInput | SalesPriceListScalarWhereInput[]
  }

  export type CustomerProductUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerProductCreateWithoutCustomerInput, CustomerProductUncheckedCreateWithoutCustomerInput> | CustomerProductCreateWithoutCustomerInput[] | CustomerProductUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProductCreateOrConnectWithoutCustomerInput | CustomerProductCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerProductUpsertWithWhereUniqueWithoutCustomerInput | CustomerProductUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerProductCreateManyCustomerInputEnvelope
    set?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    disconnect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    delete?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    connect?: CustomerProductWhereUniqueInput | CustomerProductWhereUniqueInput[]
    update?: CustomerProductUpdateWithWhereUniqueWithoutCustomerInput | CustomerProductUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerProductUpdateManyWithWhereWithoutCustomerInput | CustomerProductUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerProductScalarWhereInput | CustomerProductScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutCustomerProductsInput = {
    create?: XOR<CustomerCreateWithoutCustomerProductsInput, CustomerUncheckedCreateWithoutCustomerProductsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerProductsInput
    connect?: CustomerWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCustomerProductsInput = {
    create?: XOR<ProductCreateWithoutCustomerProductsInput, ProductUncheckedCreateWithoutCustomerProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomerProductsNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerProductsInput, CustomerUncheckedCreateWithoutCustomerProductsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerProductsInput
    upsert?: CustomerUpsertWithoutCustomerProductsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerProductsInput, CustomerUpdateWithoutCustomerProductsInput>, CustomerUncheckedUpdateWithoutCustomerProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutCustomerProductsNestedInput = {
    create?: XOR<ProductCreateWithoutCustomerProductsInput, ProductUncheckedCreateWithoutCustomerProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerProductsInput
    upsert?: ProductUpsertWithoutCustomerProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCustomerProductsInput, ProductUpdateWithoutCustomerProductsInput>, ProductUncheckedUpdateWithoutCustomerProductsInput>
  }

  export type ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput = {
    create?: XOR<ProductionMmlCreateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedCreateWithoutSuppliersWithPrimaryMmlInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutSuppliersWithPrimaryMmlInput
    connect?: ProductionMmlWhereUniqueInput
  }

  export type SupplierProductCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput> | PurchasePriceListSupplierCreateWithoutSupplierInput[] | PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput | PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchasePriceListSupplierCreateManySupplierInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type PurchasePriceItemCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput> | PurchasePriceItemCreateWithoutSupplierInput[] | PurchasePriceItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutSupplierInput | PurchasePriceItemCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchasePriceItemCreateManySupplierInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type PurchaseSupplierCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseSupplierCreateWithoutSupplierInput, PurchaseSupplierUncheckedCreateWithoutSupplierInput> | PurchaseSupplierCreateWithoutSupplierInput[] | PurchaseSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseSupplierCreateOrConnectWithoutSupplierInput | PurchaseSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseSupplierCreateManySupplierInputEnvelope
    connect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseItemCreateWithoutSupplierInput, PurchaseItemUncheckedCreateWithoutSupplierInput> | PurchaseItemCreateWithoutSupplierInput[] | PurchaseItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutSupplierInput | PurchaseItemCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseItemCreateManySupplierInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type SvodSupplierColCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SvodSupplierColCreateWithoutSupplierInput, SvodSupplierColUncheckedCreateWithoutSupplierInput> | SvodSupplierColCreateWithoutSupplierInput[] | SvodSupplierColUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SvodSupplierColCreateOrConnectWithoutSupplierInput | SvodSupplierColCreateOrConnectWithoutSupplierInput[]
    createMany?: SvodSupplierColCreateManySupplierInputEnvelope
    connect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
  }

  export type SvodSupplierValueCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SvodSupplierValueCreateWithoutSupplierInput, SvodSupplierValueUncheckedCreateWithoutSupplierInput> | SvodSupplierValueCreateWithoutSupplierInput[] | SvodSupplierValueUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutSupplierInput | SvodSupplierValueCreateOrConnectWithoutSupplierInput[]
    createMany?: SvodSupplierValueCreateManySupplierInputEnvelope
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
  }

  export type SupplierProductUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput> | PurchasePriceListSupplierCreateWithoutSupplierInput[] | PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput | PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchasePriceListSupplierCreateManySupplierInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput> | PurchasePriceItemCreateWithoutSupplierInput[] | PurchasePriceItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutSupplierInput | PurchasePriceItemCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchasePriceItemCreateManySupplierInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type PurchaseSupplierUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseSupplierCreateWithoutSupplierInput, PurchaseSupplierUncheckedCreateWithoutSupplierInput> | PurchaseSupplierCreateWithoutSupplierInput[] | PurchaseSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseSupplierCreateOrConnectWithoutSupplierInput | PurchaseSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseSupplierCreateManySupplierInputEnvelope
    connect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseItemCreateWithoutSupplierInput, PurchaseItemUncheckedCreateWithoutSupplierInput> | PurchaseItemCreateWithoutSupplierInput[] | PurchaseItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutSupplierInput | PurchaseItemCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseItemCreateManySupplierInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type SvodSupplierColUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SvodSupplierColCreateWithoutSupplierInput, SvodSupplierColUncheckedCreateWithoutSupplierInput> | SvodSupplierColCreateWithoutSupplierInput[] | SvodSupplierColUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SvodSupplierColCreateOrConnectWithoutSupplierInput | SvodSupplierColCreateOrConnectWithoutSupplierInput[]
    createMany?: SvodSupplierColCreateManySupplierInputEnvelope
    connect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
  }

  export type SvodSupplierValueUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SvodSupplierValueCreateWithoutSupplierInput, SvodSupplierValueUncheckedCreateWithoutSupplierInput> | SvodSupplierValueCreateWithoutSupplierInput[] | SvodSupplierValueUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutSupplierInput | SvodSupplierValueCreateOrConnectWithoutSupplierInput[]
    createMany?: SvodSupplierValueCreateManySupplierInputEnvelope
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedCreateWithoutSuppliersWithPrimaryMmlInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutSuppliersWithPrimaryMmlInput
    upsert?: ProductionMmlUpsertWithoutSuppliersWithPrimaryMmlInput
    disconnect?: ProductionMmlWhereInput | boolean
    delete?: ProductionMmlWhereInput | boolean
    connect?: ProductionMmlWhereUniqueInput
    update?: XOR<XOR<ProductionMmlUpdateToOneWithWhereWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUpdateWithoutSuppliersWithPrimaryMmlInput>, ProductionMmlUncheckedUpdateWithoutSuppliersWithPrimaryMmlInput>
  }

  export type SupplierProductUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutSupplierInput | SupplierProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutSupplierInput | SupplierProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutSupplierInput | SupplierProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput> | PurchasePriceListSupplierCreateWithoutSupplierInput[] | PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput | PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutSupplierInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchasePriceListSupplierCreateManySupplierInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutSupplierInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutSupplierInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type PurchasePriceItemUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput> | PurchasePriceItemCreateWithoutSupplierInput[] | PurchasePriceItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutSupplierInput | PurchasePriceItemCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutSupplierInput | PurchasePriceItemUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchasePriceItemCreateManySupplierInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutSupplierInput | PurchasePriceItemUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutSupplierInput | PurchasePriceItemUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type PurchaseSupplierUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseSupplierCreateWithoutSupplierInput, PurchaseSupplierUncheckedCreateWithoutSupplierInput> | PurchaseSupplierCreateWithoutSupplierInput[] | PurchaseSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseSupplierCreateOrConnectWithoutSupplierInput | PurchaseSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseSupplierUpsertWithWhereUniqueWithoutSupplierInput | PurchaseSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseSupplierCreateManySupplierInputEnvelope
    set?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    disconnect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    delete?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    connect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    update?: PurchaseSupplierUpdateWithWhereUniqueWithoutSupplierInput | PurchaseSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseSupplierUpdateManyWithWhereWithoutSupplierInput | PurchaseSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseSupplierScalarWhereInput | PurchaseSupplierScalarWhereInput[]
  }

  export type PurchaseItemUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutSupplierInput, PurchaseItemUncheckedCreateWithoutSupplierInput> | PurchaseItemCreateWithoutSupplierInput[] | PurchaseItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutSupplierInput | PurchaseItemCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutSupplierInput | PurchaseItemUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseItemCreateManySupplierInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutSupplierInput | PurchaseItemUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutSupplierInput | PurchaseItemUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type SvodSupplierColUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SvodSupplierColCreateWithoutSupplierInput, SvodSupplierColUncheckedCreateWithoutSupplierInput> | SvodSupplierColCreateWithoutSupplierInput[] | SvodSupplierColUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SvodSupplierColCreateOrConnectWithoutSupplierInput | SvodSupplierColCreateOrConnectWithoutSupplierInput[]
    upsert?: SvodSupplierColUpsertWithWhereUniqueWithoutSupplierInput | SvodSupplierColUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SvodSupplierColCreateManySupplierInputEnvelope
    set?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    disconnect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    delete?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    connect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    update?: SvodSupplierColUpdateWithWhereUniqueWithoutSupplierInput | SvodSupplierColUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SvodSupplierColUpdateManyWithWhereWithoutSupplierInput | SvodSupplierColUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SvodSupplierColScalarWhereInput | SvodSupplierColScalarWhereInput[]
  }

  export type SvodSupplierValueUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SvodSupplierValueCreateWithoutSupplierInput, SvodSupplierValueUncheckedCreateWithoutSupplierInput> | SvodSupplierValueCreateWithoutSupplierInput[] | SvodSupplierValueUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutSupplierInput | SvodSupplierValueCreateOrConnectWithoutSupplierInput[]
    upsert?: SvodSupplierValueUpsertWithWhereUniqueWithoutSupplierInput | SvodSupplierValueUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SvodSupplierValueCreateManySupplierInputEnvelope
    set?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    disconnect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    delete?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    update?: SvodSupplierValueUpdateWithWhereUniqueWithoutSupplierInput | SvodSupplierValueUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SvodSupplierValueUpdateManyWithWhereWithoutSupplierInput | SvodSupplierValueUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SvodSupplierValueScalarWhereInput | SvodSupplierValueScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutSupplierInput | SupplierProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutSupplierInput | SupplierProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutSupplierInput | SupplierProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput> | PurchasePriceListSupplierCreateWithoutSupplierInput[] | PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput | PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutSupplierInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchasePriceListSupplierCreateManySupplierInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutSupplierInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutSupplierInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput> | PurchasePriceItemCreateWithoutSupplierInput[] | PurchasePriceItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutSupplierInput | PurchasePriceItemCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutSupplierInput | PurchasePriceItemUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchasePriceItemCreateManySupplierInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutSupplierInput | PurchasePriceItemUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutSupplierInput | PurchasePriceItemUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type PurchaseSupplierUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseSupplierCreateWithoutSupplierInput, PurchaseSupplierUncheckedCreateWithoutSupplierInput> | PurchaseSupplierCreateWithoutSupplierInput[] | PurchaseSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseSupplierCreateOrConnectWithoutSupplierInput | PurchaseSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseSupplierUpsertWithWhereUniqueWithoutSupplierInput | PurchaseSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseSupplierCreateManySupplierInputEnvelope
    set?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    disconnect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    delete?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    connect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    update?: PurchaseSupplierUpdateWithWhereUniqueWithoutSupplierInput | PurchaseSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseSupplierUpdateManyWithWhereWithoutSupplierInput | PurchaseSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseSupplierScalarWhereInput | PurchaseSupplierScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutSupplierInput, PurchaseItemUncheckedCreateWithoutSupplierInput> | PurchaseItemCreateWithoutSupplierInput[] | PurchaseItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutSupplierInput | PurchaseItemCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutSupplierInput | PurchaseItemUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseItemCreateManySupplierInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutSupplierInput | PurchaseItemUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutSupplierInput | PurchaseItemUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type SvodSupplierColUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SvodSupplierColCreateWithoutSupplierInput, SvodSupplierColUncheckedCreateWithoutSupplierInput> | SvodSupplierColCreateWithoutSupplierInput[] | SvodSupplierColUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SvodSupplierColCreateOrConnectWithoutSupplierInput | SvodSupplierColCreateOrConnectWithoutSupplierInput[]
    upsert?: SvodSupplierColUpsertWithWhereUniqueWithoutSupplierInput | SvodSupplierColUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SvodSupplierColCreateManySupplierInputEnvelope
    set?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    disconnect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    delete?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    connect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    update?: SvodSupplierColUpdateWithWhereUniqueWithoutSupplierInput | SvodSupplierColUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SvodSupplierColUpdateManyWithWhereWithoutSupplierInput | SvodSupplierColUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SvodSupplierColScalarWhereInput | SvodSupplierColScalarWhereInput[]
  }

  export type SvodSupplierValueUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SvodSupplierValueCreateWithoutSupplierInput, SvodSupplierValueUncheckedCreateWithoutSupplierInput> | SvodSupplierValueCreateWithoutSupplierInput[] | SvodSupplierValueUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutSupplierInput | SvodSupplierValueCreateOrConnectWithoutSupplierInput[]
    upsert?: SvodSupplierValueUpsertWithWhereUniqueWithoutSupplierInput | SvodSupplierValueUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SvodSupplierValueCreateManySupplierInputEnvelope
    set?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    disconnect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    delete?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    update?: SvodSupplierValueUpdateWithWhereUniqueWithoutSupplierInput | SvodSupplierValueUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SvodSupplierValueUpdateManyWithWhereWithoutSupplierInput | SvodSupplierValueUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SvodSupplierValueScalarWhereInput | SvodSupplierValueScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<ProductCreateWithoutSuppliersInput, ProductUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSuppliersInput
    connect?: ProductWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutProductsInput = {
    create?: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductsInput
    connect?: SupplierWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<ProductCreateWithoutSuppliersInput, ProductUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSuppliersInput
    upsert?: ProductUpsertWithoutSuppliersInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSuppliersInput, ProductUpdateWithoutSuppliersInput>, ProductUncheckedUpdateWithoutSuppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductsInput
    upsert?: SupplierUpsertWithoutProductsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutProductsInput, SupplierUpdateWithoutProductsInput>, SupplierUncheckedUpdateWithoutProductsInput>
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type ExpeditorCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ExpeditorCreateWithoutOrdersInput, ExpeditorUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ExpeditorCreateOrConnectWithoutOrdersInput
    connect?: ExpeditorWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StockTransactionCreateNestedManyWithoutOrderInput = {
    create?: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput> | StockTransactionCreateWithoutOrderInput[] | StockTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutOrderInput | StockTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: StockTransactionCreateManyOrderInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type OrderAttachmentCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput> | OrderAttachmentCreateWithoutOrderInput[] | OrderAttachmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAttachmentCreateOrConnectWithoutOrderInput | OrderAttachmentCreateOrConnectWithoutOrderInput[]
    createMany?: OrderAttachmentCreateManyOrderInputEnvelope
    connect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StockTransactionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput> | StockTransactionCreateWithoutOrderInput[] | StockTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutOrderInput | StockTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: StockTransactionCreateManyOrderInputEnvelope
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
  }

  export type OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput> | OrderAttachmentCreateWithoutOrderInput[] | OrderAttachmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAttachmentCreateOrConnectWithoutOrderInput | OrderAttachmentCreateOrConnectWithoutOrderInput[]
    createMany?: OrderAttachmentCreateManyOrderInputEnvelope
    connect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type ExpeditorUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<ExpeditorCreateWithoutOrdersInput, ExpeditorUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ExpeditorCreateOrConnectWithoutOrdersInput
    upsert?: ExpeditorUpsertWithoutOrdersInput
    disconnect?: ExpeditorWhereInput | boolean
    delete?: ExpeditorWhereInput | boolean
    connect?: ExpeditorWhereUniqueInput
    update?: XOR<XOR<ExpeditorUpdateToOneWithWhereWithoutOrdersInput, ExpeditorUpdateWithoutOrdersInput>, ExpeditorUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StockTransactionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput> | StockTransactionCreateWithoutOrderInput[] | StockTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutOrderInput | StockTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutOrderInput | StockTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: StockTransactionCreateManyOrderInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutOrderInput | StockTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutOrderInput | StockTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type OrderAttachmentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput> | OrderAttachmentCreateWithoutOrderInput[] | OrderAttachmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAttachmentCreateOrConnectWithoutOrderInput | OrderAttachmentCreateOrConnectWithoutOrderInput[]
    upsert?: OrderAttachmentUpsertWithWhereUniqueWithoutOrderInput | OrderAttachmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderAttachmentCreateManyOrderInputEnvelope
    set?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    disconnect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    delete?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    connect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    update?: OrderAttachmentUpdateWithWhereUniqueWithoutOrderInput | OrderAttachmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderAttachmentUpdateManyWithWhereWithoutOrderInput | OrderAttachmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderAttachmentScalarWhereInput | OrderAttachmentScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StockTransactionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput> | StockTransactionCreateWithoutOrderInput[] | StockTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StockTransactionCreateOrConnectWithoutOrderInput | StockTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: StockTransactionUpsertWithWhereUniqueWithoutOrderInput | StockTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: StockTransactionCreateManyOrderInputEnvelope
    set?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    disconnect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    delete?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    connect?: StockTransactionWhereUniqueInput | StockTransactionWhereUniqueInput[]
    update?: StockTransactionUpdateWithWhereUniqueWithoutOrderInput | StockTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: StockTransactionUpdateManyWithWhereWithoutOrderInput | StockTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
  }

  export type OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput> | OrderAttachmentCreateWithoutOrderInput[] | OrderAttachmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAttachmentCreateOrConnectWithoutOrderInput | OrderAttachmentCreateOrConnectWithoutOrderInput[]
    upsert?: OrderAttachmentUpsertWithWhereUniqueWithoutOrderInput | OrderAttachmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderAttachmentCreateManyOrderInputEnvelope
    set?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    disconnect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    delete?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    connect?: OrderAttachmentWhereUniqueInput | OrderAttachmentWhereUniqueInput[]
    update?: OrderAttachmentUpdateWithWhereUniqueWithoutOrderInput | OrderAttachmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderAttachmentUpdateManyWithWhereWithoutOrderInput | OrderAttachmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderAttachmentScalarWhereInput | OrderAttachmentScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<OrderCreateWithoutAttachmentsInput, OrderUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAttachmentsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<OrderCreateWithoutAttachmentsInput, OrderUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAttachmentsInput
    upsert?: OrderUpsertWithoutAttachmentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutAttachmentsInput, OrderUpdateWithoutAttachmentsInput>, OrderUncheckedUpdateWithoutAttachmentsInput>
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderCreateNestedManyWithoutExpeditorInput = {
    create?: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput> | OrderCreateWithoutExpeditorInput[] | OrderUncheckedCreateWithoutExpeditorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutExpeditorInput | OrderCreateOrConnectWithoutExpeditorInput[]
    createMany?: OrderCreateManyExpeditorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutExpeditorInput = {
    create?: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput> | OrderCreateWithoutExpeditorInput[] | OrderUncheckedCreateWithoutExpeditorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutExpeditorInput | OrderCreateOrConnectWithoutExpeditorInput[]
    createMany?: OrderCreateManyExpeditorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutExpeditorNestedInput = {
    create?: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput> | OrderCreateWithoutExpeditorInput[] | OrderUncheckedCreateWithoutExpeditorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutExpeditorInput | OrderCreateOrConnectWithoutExpeditorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutExpeditorInput | OrderUpsertWithWhereUniqueWithoutExpeditorInput[]
    createMany?: OrderCreateManyExpeditorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutExpeditorInput | OrderUpdateWithWhereUniqueWithoutExpeditorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutExpeditorInput | OrderUpdateManyWithWhereWithoutExpeditorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutExpeditorNestedInput = {
    create?: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput> | OrderCreateWithoutExpeditorInput[] | OrderUncheckedCreateWithoutExpeditorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutExpeditorInput | OrderCreateOrConnectWithoutExpeditorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutExpeditorInput | OrderUpsertWithWhereUniqueWithoutExpeditorInput[]
    createMany?: OrderCreateManyExpeditorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutExpeditorInput | OrderUpdateWithWhereUniqueWithoutExpeditorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutExpeditorInput | OrderUpdateManyWithWhereWithoutExpeditorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutStockInput = {
    create?: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutStockNestedInput = {
    create?: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockInput
    upsert?: ProductUpsertWithoutStockInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockInput, ProductUpdateWithoutStockInput>, ProductUncheckedUpdateWithoutStockInput>
  }

  export type OrderCreateNestedOneWithoutStockTransactionsInput = {
    create?: XOR<OrderCreateWithoutStockTransactionsInput, OrderUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStockTransactionsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutStockTransactionsInput = {
    create?: XOR<ProductCreateWithoutStockTransactionsInput, ProductUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockTransactionsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneWithoutStockTransactionsNestedInput = {
    create?: XOR<OrderCreateWithoutStockTransactionsInput, OrderUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStockTransactionsInput
    upsert?: OrderUpsertWithoutStockTransactionsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutStockTransactionsInput, OrderUpdateWithoutStockTransactionsInput>, OrderUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type ProductUpdateOneRequiredWithoutStockTransactionsNestedInput = {
    create?: XOR<ProductCreateWithoutStockTransactionsInput, ProductUncheckedCreateWithoutStockTransactionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockTransactionsInput
    upsert?: ProductUpsertWithoutStockTransactionsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockTransactionsInput, ProductUpdateWithoutStockTransactionsInput>, ProductUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type CustomerCreateNestedOneWithoutSummaryJournalEntriesInput = {
    create?: XOR<CustomerCreateWithoutSummaryJournalEntriesInput, CustomerUncheckedCreateWithoutSummaryJournalEntriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSummaryJournalEntriesInput
    connect?: CustomerWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSummaryJournalEntriesInput = {
    create?: XOR<ProductCreateWithoutSummaryJournalEntriesInput, ProductUncheckedCreateWithoutSummaryJournalEntriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSummaryJournalEntriesInput
    connect?: ProductWhereUniqueInput
  }

  export type SummaryOrderEventCreateNestedManyWithoutSummaryOrderInput = {
    create?: XOR<SummaryOrderEventCreateWithoutSummaryOrderInput, SummaryOrderEventUncheckedCreateWithoutSummaryOrderInput> | SummaryOrderEventCreateWithoutSummaryOrderInput[] | SummaryOrderEventUncheckedCreateWithoutSummaryOrderInput[]
    connectOrCreate?: SummaryOrderEventCreateOrConnectWithoutSummaryOrderInput | SummaryOrderEventCreateOrConnectWithoutSummaryOrderInput[]
    createMany?: SummaryOrderEventCreateManySummaryOrderInputEnvelope
    connect?: SummaryOrderEventWhereUniqueInput | SummaryOrderEventWhereUniqueInput[]
  }

  export type SummaryOrderEventUncheckedCreateNestedManyWithoutSummaryOrderInput = {
    create?: XOR<SummaryOrderEventCreateWithoutSummaryOrderInput, SummaryOrderEventUncheckedCreateWithoutSummaryOrderInput> | SummaryOrderEventCreateWithoutSummaryOrderInput[] | SummaryOrderEventUncheckedCreateWithoutSummaryOrderInput[]
    connectOrCreate?: SummaryOrderEventCreateOrConnectWithoutSummaryOrderInput | SummaryOrderEventCreateOrConnectWithoutSummaryOrderInput[]
    createMany?: SummaryOrderEventCreateManySummaryOrderInputEnvelope
    connect?: SummaryOrderEventWhereUniqueInput | SummaryOrderEventWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutSummaryJournalEntriesNestedInput = {
    create?: XOR<CustomerCreateWithoutSummaryJournalEntriesInput, CustomerUncheckedCreateWithoutSummaryJournalEntriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSummaryJournalEntriesInput
    upsert?: CustomerUpsertWithoutSummaryJournalEntriesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSummaryJournalEntriesInput, CustomerUpdateWithoutSummaryJournalEntriesInput>, CustomerUncheckedUpdateWithoutSummaryJournalEntriesInput>
  }

  export type ProductUpdateOneWithoutSummaryJournalEntriesNestedInput = {
    create?: XOR<ProductCreateWithoutSummaryJournalEntriesInput, ProductUncheckedCreateWithoutSummaryJournalEntriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSummaryJournalEntriesInput
    upsert?: ProductUpsertWithoutSummaryJournalEntriesInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSummaryJournalEntriesInput, ProductUpdateWithoutSummaryJournalEntriesInput>, ProductUncheckedUpdateWithoutSummaryJournalEntriesInput>
  }

  export type SummaryOrderEventUpdateManyWithoutSummaryOrderNestedInput = {
    create?: XOR<SummaryOrderEventCreateWithoutSummaryOrderInput, SummaryOrderEventUncheckedCreateWithoutSummaryOrderInput> | SummaryOrderEventCreateWithoutSummaryOrderInput[] | SummaryOrderEventUncheckedCreateWithoutSummaryOrderInput[]
    connectOrCreate?: SummaryOrderEventCreateOrConnectWithoutSummaryOrderInput | SummaryOrderEventCreateOrConnectWithoutSummaryOrderInput[]
    upsert?: SummaryOrderEventUpsertWithWhereUniqueWithoutSummaryOrderInput | SummaryOrderEventUpsertWithWhereUniqueWithoutSummaryOrderInput[]
    createMany?: SummaryOrderEventCreateManySummaryOrderInputEnvelope
    set?: SummaryOrderEventWhereUniqueInput | SummaryOrderEventWhereUniqueInput[]
    disconnect?: SummaryOrderEventWhereUniqueInput | SummaryOrderEventWhereUniqueInput[]
    delete?: SummaryOrderEventWhereUniqueInput | SummaryOrderEventWhereUniqueInput[]
    connect?: SummaryOrderEventWhereUniqueInput | SummaryOrderEventWhereUniqueInput[]
    update?: SummaryOrderEventUpdateWithWhereUniqueWithoutSummaryOrderInput | SummaryOrderEventUpdateWithWhereUniqueWithoutSummaryOrderInput[]
    updateMany?: SummaryOrderEventUpdateManyWithWhereWithoutSummaryOrderInput | SummaryOrderEventUpdateManyWithWhereWithoutSummaryOrderInput[]
    deleteMany?: SummaryOrderEventScalarWhereInput | SummaryOrderEventScalarWhereInput[]
  }

  export type SummaryOrderEventUncheckedUpdateManyWithoutSummaryOrderNestedInput = {
    create?: XOR<SummaryOrderEventCreateWithoutSummaryOrderInput, SummaryOrderEventUncheckedCreateWithoutSummaryOrderInput> | SummaryOrderEventCreateWithoutSummaryOrderInput[] | SummaryOrderEventUncheckedCreateWithoutSummaryOrderInput[]
    connectOrCreate?: SummaryOrderEventCreateOrConnectWithoutSummaryOrderInput | SummaryOrderEventCreateOrConnectWithoutSummaryOrderInput[]
    upsert?: SummaryOrderEventUpsertWithWhereUniqueWithoutSummaryOrderInput | SummaryOrderEventUpsertWithWhereUniqueWithoutSummaryOrderInput[]
    createMany?: SummaryOrderEventCreateManySummaryOrderInputEnvelope
    set?: SummaryOrderEventWhereUniqueInput | SummaryOrderEventWhereUniqueInput[]
    disconnect?: SummaryOrderEventWhereUniqueInput | SummaryOrderEventWhereUniqueInput[]
    delete?: SummaryOrderEventWhereUniqueInput | SummaryOrderEventWhereUniqueInput[]
    connect?: SummaryOrderEventWhereUniqueInput | SummaryOrderEventWhereUniqueInput[]
    update?: SummaryOrderEventUpdateWithWhereUniqueWithoutSummaryOrderInput | SummaryOrderEventUpdateWithWhereUniqueWithoutSummaryOrderInput[]
    updateMany?: SummaryOrderEventUpdateManyWithWhereWithoutSummaryOrderInput | SummaryOrderEventUpdateManyWithWhereWithoutSummaryOrderInput[]
    deleteMany?: SummaryOrderEventScalarWhereInput | SummaryOrderEventScalarWhereInput[]
  }

  export type SummaryOrderJournalCreateNestedOneWithoutEventsInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutEventsInput, SummaryOrderJournalUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutEventsInput
    connect?: SummaryOrderJournalWhereUniqueInput
  }

  export type SummaryOrderJournalUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<SummaryOrderJournalCreateWithoutEventsInput, SummaryOrderJournalUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SummaryOrderJournalCreateOrConnectWithoutEventsInput
    upsert?: SummaryOrderJournalUpsertWithoutEventsInput
    connect?: SummaryOrderJournalWhereUniqueInput
    update?: XOR<XOR<SummaryOrderJournalUpdateToOneWithWhereWithoutEventsInput, SummaryOrderJournalUpdateWithoutEventsInput>, SummaryOrderJournalUncheckedUpdateWithoutEventsInput>
  }

  export type UserCreateNestedOneWithoutProductionStaffInput = {
    create?: XOR<UserCreateWithoutProductionStaffInput, UserUncheckedCreateWithoutProductionStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionStaffInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionJournalCreateNestedManyWithoutStaffInput = {
    create?: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput> | ProductionJournalCreateWithoutStaffInput[] | ProductionJournalUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutStaffInput | ProductionJournalCreateOrConnectWithoutStaffInput[]
    createMany?: ProductionJournalCreateManyStaffInputEnvelope
    connect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
  }

  export type ProductionJournalUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput> | ProductionJournalCreateWithoutStaffInput[] | ProductionJournalUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutStaffInput | ProductionJournalCreateOrConnectWithoutStaffInput[]
    createMany?: ProductionJournalCreateManyStaffInputEnvelope
    connect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutProductionStaffNestedInput = {
    create?: XOR<UserCreateWithoutProductionStaffInput, UserUncheckedCreateWithoutProductionStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionStaffInput
    upsert?: UserUpsertWithoutProductionStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductionStaffInput, UserUpdateWithoutProductionStaffInput>, UserUncheckedUpdateWithoutProductionStaffInput>
  }

  export type ProductionJournalUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput> | ProductionJournalCreateWithoutStaffInput[] | ProductionJournalUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutStaffInput | ProductionJournalCreateOrConnectWithoutStaffInput[]
    upsert?: ProductionJournalUpsertWithWhereUniqueWithoutStaffInput | ProductionJournalUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ProductionJournalCreateManyStaffInputEnvelope
    set?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    disconnect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    delete?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    connect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    update?: ProductionJournalUpdateWithWhereUniqueWithoutStaffInput | ProductionJournalUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ProductionJournalUpdateManyWithWhereWithoutStaffInput | ProductionJournalUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ProductionJournalScalarWhereInput | ProductionJournalScalarWhereInput[]
  }

  export type ProductionJournalUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput> | ProductionJournalCreateWithoutStaffInput[] | ProductionJournalUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutStaffInput | ProductionJournalCreateOrConnectWithoutStaffInput[]
    upsert?: ProductionJournalUpsertWithWhereUniqueWithoutStaffInput | ProductionJournalUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ProductionJournalCreateManyStaffInputEnvelope
    set?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    disconnect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    delete?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    connect?: ProductionJournalWhereUniqueInput | ProductionJournalWhereUniqueInput[]
    update?: ProductionJournalUpdateWithWhereUniqueWithoutStaffInput | ProductionJournalUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ProductionJournalUpdateManyWithWhereWithoutStaffInput | ProductionJournalUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ProductionJournalScalarWhereInput | ProductionJournalScalarWhereInput[]
  }

  export type ProductionStaffCreateNestedOneWithoutJournalsInput = {
    create?: XOR<ProductionStaffCreateWithoutJournalsInput, ProductionStaffUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutJournalsInput
    connect?: ProductionStaffWhereUniqueInput
  }

  export type ProductionItemCreateNestedManyWithoutJournalInput = {
    create?: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput> | ProductionItemCreateWithoutJournalInput[] | ProductionItemUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutJournalInput | ProductionItemCreateOrConnectWithoutJournalInput[]
    createMany?: ProductionItemCreateManyJournalInputEnvelope
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
  }

  export type ProductionItemUncheckedCreateNestedManyWithoutJournalInput = {
    create?: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput> | ProductionItemCreateWithoutJournalInput[] | ProductionItemUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutJournalInput | ProductionItemCreateOrConnectWithoutJournalInput[]
    createMany?: ProductionItemCreateManyJournalInputEnvelope
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
  }

  export type ProductionStaffUpdateOneRequiredWithoutJournalsNestedInput = {
    create?: XOR<ProductionStaffCreateWithoutJournalsInput, ProductionStaffUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: ProductionStaffCreateOrConnectWithoutJournalsInput
    upsert?: ProductionStaffUpsertWithoutJournalsInput
    connect?: ProductionStaffWhereUniqueInput
    update?: XOR<XOR<ProductionStaffUpdateToOneWithWhereWithoutJournalsInput, ProductionStaffUpdateWithoutJournalsInput>, ProductionStaffUncheckedUpdateWithoutJournalsInput>
  }

  export type ProductionItemUpdateManyWithoutJournalNestedInput = {
    create?: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput> | ProductionItemCreateWithoutJournalInput[] | ProductionItemUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutJournalInput | ProductionItemCreateOrConnectWithoutJournalInput[]
    upsert?: ProductionItemUpsertWithWhereUniqueWithoutJournalInput | ProductionItemUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: ProductionItemCreateManyJournalInputEnvelope
    set?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    disconnect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    delete?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    update?: ProductionItemUpdateWithWhereUniqueWithoutJournalInput | ProductionItemUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: ProductionItemUpdateManyWithWhereWithoutJournalInput | ProductionItemUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
  }

  export type ProductionItemUncheckedUpdateManyWithoutJournalNestedInput = {
    create?: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput> | ProductionItemCreateWithoutJournalInput[] | ProductionItemUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: ProductionItemCreateOrConnectWithoutJournalInput | ProductionItemCreateOrConnectWithoutJournalInput[]
    upsert?: ProductionItemUpsertWithWhereUniqueWithoutJournalInput | ProductionItemUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: ProductionItemCreateManyJournalInputEnvelope
    set?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    disconnect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    delete?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    connect?: ProductionItemWhereUniqueInput | ProductionItemWhereUniqueInput[]
    update?: ProductionItemUpdateWithWhereUniqueWithoutJournalInput | ProductionItemUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: ProductionItemUpdateManyWithWhereWithoutJournalInput | ProductionItemUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
  }

  export type ProductionJournalCreateNestedOneWithoutItemsInput = {
    create?: XOR<ProductionJournalCreateWithoutItemsInput, ProductionJournalUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutItemsInput
    connect?: ProductionJournalWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProductionItemsInput = {
    create?: XOR<ProductCreateWithoutProductionItemsInput, ProductUncheckedCreateWithoutProductionItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductionItemValueCreateNestedManyWithoutProductionItemInput = {
    create?: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput> | ProductionItemValueCreateWithoutProductionItemInput[] | ProductionItemValueUncheckedCreateWithoutProductionItemInput[]
    connectOrCreate?: ProductionItemValueCreateOrConnectWithoutProductionItemInput | ProductionItemValueCreateOrConnectWithoutProductionItemInput[]
    createMany?: ProductionItemValueCreateManyProductionItemInputEnvelope
    connect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
  }

  export type ProductionItemValueUncheckedCreateNestedManyWithoutProductionItemInput = {
    create?: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput> | ProductionItemValueCreateWithoutProductionItemInput[] | ProductionItemValueUncheckedCreateWithoutProductionItemInput[]
    connectOrCreate?: ProductionItemValueCreateOrConnectWithoutProductionItemInput | ProductionItemValueCreateOrConnectWithoutProductionItemInput[]
    createMany?: ProductionItemValueCreateManyProductionItemInputEnvelope
    connect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
  }

  export type ProductionJournalUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ProductionJournalCreateWithoutItemsInput, ProductionJournalUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ProductionJournalCreateOrConnectWithoutItemsInput
    upsert?: ProductionJournalUpsertWithoutItemsInput
    connect?: ProductionJournalWhereUniqueInput
    update?: XOR<XOR<ProductionJournalUpdateToOneWithWhereWithoutItemsInput, ProductionJournalUpdateWithoutItemsInput>, ProductionJournalUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneWithoutProductionItemsNestedInput = {
    create?: XOR<ProductCreateWithoutProductionItemsInput, ProductUncheckedCreateWithoutProductionItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionItemsInput
    upsert?: ProductUpsertWithoutProductionItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductionItemsInput, ProductUpdateWithoutProductionItemsInput>, ProductUncheckedUpdateWithoutProductionItemsInput>
  }

  export type ProductionItemValueUpdateManyWithoutProductionItemNestedInput = {
    create?: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput> | ProductionItemValueCreateWithoutProductionItemInput[] | ProductionItemValueUncheckedCreateWithoutProductionItemInput[]
    connectOrCreate?: ProductionItemValueCreateOrConnectWithoutProductionItemInput | ProductionItemValueCreateOrConnectWithoutProductionItemInput[]
    upsert?: ProductionItemValueUpsertWithWhereUniqueWithoutProductionItemInput | ProductionItemValueUpsertWithWhereUniqueWithoutProductionItemInput[]
    createMany?: ProductionItemValueCreateManyProductionItemInputEnvelope
    set?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    disconnect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    delete?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    connect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    update?: ProductionItemValueUpdateWithWhereUniqueWithoutProductionItemInput | ProductionItemValueUpdateWithWhereUniqueWithoutProductionItemInput[]
    updateMany?: ProductionItemValueUpdateManyWithWhereWithoutProductionItemInput | ProductionItemValueUpdateManyWithWhereWithoutProductionItemInput[]
    deleteMany?: ProductionItemValueScalarWhereInput | ProductionItemValueScalarWhereInput[]
  }

  export type ProductionItemValueUncheckedUpdateManyWithoutProductionItemNestedInput = {
    create?: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput> | ProductionItemValueCreateWithoutProductionItemInput[] | ProductionItemValueUncheckedCreateWithoutProductionItemInput[]
    connectOrCreate?: ProductionItemValueCreateOrConnectWithoutProductionItemInput | ProductionItemValueCreateOrConnectWithoutProductionItemInput[]
    upsert?: ProductionItemValueUpsertWithWhereUniqueWithoutProductionItemInput | ProductionItemValueUpsertWithWhereUniqueWithoutProductionItemInput[]
    createMany?: ProductionItemValueCreateManyProductionItemInputEnvelope
    set?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    disconnect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    delete?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    connect?: ProductionItemValueWhereUniqueInput | ProductionItemValueWhereUniqueInput[]
    update?: ProductionItemValueUpdateWithWhereUniqueWithoutProductionItemInput | ProductionItemValueUpdateWithWhereUniqueWithoutProductionItemInput[]
    updateMany?: ProductionItemValueUpdateManyWithWhereWithoutProductionItemInput | ProductionItemValueUpdateManyWithWhereWithoutProductionItemInput[]
    deleteMany?: ProductionItemValueScalarWhereInput | ProductionItemValueScalarWhereInput[]
  }

  export type ProductionItemCreateNestedOneWithoutValuesInput = {
    create?: XOR<ProductionItemCreateWithoutValuesInput, ProductionItemUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductionItemCreateOrConnectWithoutValuesInput
    connect?: ProductionItemWhereUniqueInput
  }

  export type ProductionItemUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<ProductionItemCreateWithoutValuesInput, ProductionItemUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductionItemCreateOrConnectWithoutValuesInput
    upsert?: ProductionItemUpsertWithoutValuesInput
    connect?: ProductionItemWhereUniqueInput
    update?: XOR<XOR<ProductionItemUpdateToOneWithWhereWithoutValuesInput, ProductionItemUpdateWithoutValuesInput>, ProductionItemUncheckedUpdateWithoutValuesInput>
  }

  export type PurchasePriceListSupplierCreateNestedManyWithoutPriceListInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput> | PurchasePriceListSupplierCreateWithoutPriceListInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput | PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput[]
    createMany?: PurchasePriceListSupplierCreateManyPriceListInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type PurchasePriceItemCreateNestedManyWithoutPriceListInput = {
    create?: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput> | PurchasePriceItemCreateWithoutPriceListInput[] | PurchasePriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutPriceListInput | PurchasePriceItemCreateOrConnectWithoutPriceListInput[]
    createMany?: PurchasePriceItemCreateManyPriceListInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPriceListInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput> | PurchasePriceListSupplierCreateWithoutPriceListInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput | PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput[]
    createMany?: PurchasePriceListSupplierCreateManyPriceListInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type PurchasePriceItemUncheckedCreateNestedManyWithoutPriceListInput = {
    create?: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput> | PurchasePriceItemCreateWithoutPriceListInput[] | PurchasePriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutPriceListInput | PurchasePriceItemCreateOrConnectWithoutPriceListInput[]
    createMany?: PurchasePriceItemCreateManyPriceListInputEnvelope
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput> | PurchasePriceListSupplierCreateWithoutPriceListInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput | PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPriceListInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: PurchasePriceListSupplierCreateManyPriceListInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPriceListInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutPriceListInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type PurchasePriceItemUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput> | PurchasePriceItemCreateWithoutPriceListInput[] | PurchasePriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutPriceListInput | PurchasePriceItemCreateOrConnectWithoutPriceListInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutPriceListInput | PurchasePriceItemUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: PurchasePriceItemCreateManyPriceListInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutPriceListInput | PurchasePriceItemUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutPriceListInput | PurchasePriceItemUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput> | PurchasePriceListSupplierCreateWithoutPriceListInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput | PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPriceListInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: PurchasePriceListSupplierCreateManyPriceListInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPriceListInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutPriceListInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput> | PurchasePriceItemCreateWithoutPriceListInput[] | PurchasePriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: PurchasePriceItemCreateOrConnectWithoutPriceListInput | PurchasePriceItemCreateOrConnectWithoutPriceListInput[]
    upsert?: PurchasePriceItemUpsertWithWhereUniqueWithoutPriceListInput | PurchasePriceItemUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: PurchasePriceItemCreateManyPriceListInputEnvelope
    set?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    disconnect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    delete?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    connect?: PurchasePriceItemWhereUniqueInput | PurchasePriceItemWhereUniqueInput[]
    update?: PurchasePriceItemUpdateWithWhereUniqueWithoutPriceListInput | PurchasePriceItemUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: PurchasePriceItemUpdateManyWithWhereWithoutPriceListInput | PurchasePriceItemUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
  }

  export type PurchasePriceListCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<PurchasePriceListCreateWithoutSuppliersInput, PurchasePriceListUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: PurchasePriceListCreateOrConnectWithoutSuppliersInput
    connect?: PurchasePriceListWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchasePriceListSuppliersInput = {
    create?: XOR<SupplierCreateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedCreateWithoutPurchasePriceListSuppliersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasePriceListSuppliersInput
    connect?: SupplierWhereUniqueInput
  }

  export type ProductionMmlCreateNestedOneWithoutPriceListSuppliersInput = {
    create?: XOR<ProductionMmlCreateWithoutPriceListSuppliersInput, ProductionMmlUncheckedCreateWithoutPriceListSuppliersInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutPriceListSuppliersInput
    connect?: ProductionMmlWhereUniqueInput
  }

  export type PurchasePriceListUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<PurchasePriceListCreateWithoutSuppliersInput, PurchasePriceListUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: PurchasePriceListCreateOrConnectWithoutSuppliersInput
    upsert?: PurchasePriceListUpsertWithoutSuppliersInput
    connect?: PurchasePriceListWhereUniqueInput
    update?: XOR<XOR<PurchasePriceListUpdateToOneWithWhereWithoutSuppliersInput, PurchasePriceListUpdateWithoutSuppliersInput>, PurchasePriceListUncheckedUpdateWithoutSuppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutPurchasePriceListSuppliersNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedCreateWithoutPurchasePriceListSuppliersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasePriceListSuppliersInput
    upsert?: SupplierUpsertWithoutPurchasePriceListSuppliersInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchasePriceListSuppliersInput, SupplierUpdateWithoutPurchasePriceListSuppliersInput>, SupplierUncheckedUpdateWithoutPurchasePriceListSuppliersInput>
  }

  export type ProductionMmlUpdateOneWithoutPriceListSuppliersNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutPriceListSuppliersInput, ProductionMmlUncheckedCreateWithoutPriceListSuppliersInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutPriceListSuppliersInput
    upsert?: ProductionMmlUpsertWithoutPriceListSuppliersInput
    disconnect?: ProductionMmlWhereInput | boolean
    delete?: ProductionMmlWhereInput | boolean
    connect?: ProductionMmlWhereUniqueInput
    update?: XOR<XOR<ProductionMmlUpdateToOneWithWhereWithoutPriceListSuppliersInput, ProductionMmlUpdateWithoutPriceListSuppliersInput>, ProductionMmlUncheckedUpdateWithoutPriceListSuppliersInput>
  }

  export type PurchasePriceListCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchasePriceListCreateWithoutItemsInput, PurchasePriceListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchasePriceListCreateOrConnectWithoutItemsInput
    connect?: PurchasePriceListWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchasePriceItemsInput = {
    create?: XOR<SupplierCreateWithoutPurchasePriceItemsInput, SupplierUncheckedCreateWithoutPurchasePriceItemsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasePriceItemsInput
    connect?: SupplierWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchasePriceItemsInput = {
    create?: XOR<ProductCreateWithoutPurchasePriceItemsInput, ProductUncheckedCreateWithoutPurchasePriceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchasePriceItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type PurchasePriceListUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchasePriceListCreateWithoutItemsInput, PurchasePriceListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchasePriceListCreateOrConnectWithoutItemsInput
    upsert?: PurchasePriceListUpsertWithoutItemsInput
    connect?: PurchasePriceListWhereUniqueInput
    update?: XOR<XOR<PurchasePriceListUpdateToOneWithWhereWithoutItemsInput, PurchasePriceListUpdateWithoutItemsInput>, PurchasePriceListUncheckedUpdateWithoutItemsInput>
  }

  export type SupplierUpdateOneRequiredWithoutPurchasePriceItemsNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchasePriceItemsInput, SupplierUncheckedCreateWithoutPurchasePriceItemsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasePriceItemsInput
    upsert?: SupplierUpsertWithoutPurchasePriceItemsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchasePriceItemsInput, SupplierUpdateWithoutPurchasePriceItemsInput>, SupplierUncheckedUpdateWithoutPurchasePriceItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchasePriceItemsNestedInput = {
    create?: XOR<ProductCreateWithoutPurchasePriceItemsInput, ProductUncheckedCreateWithoutPurchasePriceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchasePriceItemsInput
    upsert?: ProductUpsertWithoutPurchasePriceItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchasePriceItemsInput, ProductUpdateWithoutPurchasePriceItemsInput>, ProductUncheckedUpdateWithoutPurchasePriceItemsInput>
  }

  export type CustomerCreateNestedOneWithoutSalesPriceListsInput = {
    create?: XOR<CustomerCreateWithoutSalesPriceListsInput, CustomerUncheckedCreateWithoutSalesPriceListsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesPriceListsInput
    connect?: CustomerWhereUniqueInput
  }

  export type SalesPriceItemCreateNestedManyWithoutPriceListInput = {
    create?: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput> | SalesPriceItemCreateWithoutPriceListInput[] | SalesPriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutPriceListInput | SalesPriceItemCreateOrConnectWithoutPriceListInput[]
    createMany?: SalesPriceItemCreateManyPriceListInputEnvelope
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
  }

  export type SalesPriceItemUncheckedCreateNestedManyWithoutPriceListInput = {
    create?: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput> | SalesPriceItemCreateWithoutPriceListInput[] | SalesPriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutPriceListInput | SalesPriceItemCreateOrConnectWithoutPriceListInput[]
    createMany?: SalesPriceItemCreateManyPriceListInputEnvelope
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutSalesPriceListsNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesPriceListsInput, CustomerUncheckedCreateWithoutSalesPriceListsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesPriceListsInput
    upsert?: CustomerUpsertWithoutSalesPriceListsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesPriceListsInput, CustomerUpdateWithoutSalesPriceListsInput>, CustomerUncheckedUpdateWithoutSalesPriceListsInput>
  }

  export type SalesPriceItemUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput> | SalesPriceItemCreateWithoutPriceListInput[] | SalesPriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutPriceListInput | SalesPriceItemCreateOrConnectWithoutPriceListInput[]
    upsert?: SalesPriceItemUpsertWithWhereUniqueWithoutPriceListInput | SalesPriceItemUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: SalesPriceItemCreateManyPriceListInputEnvelope
    set?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    disconnect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    delete?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    update?: SalesPriceItemUpdateWithWhereUniqueWithoutPriceListInput | SalesPriceItemUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: SalesPriceItemUpdateManyWithWhereWithoutPriceListInput | SalesPriceItemUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
  }

  export type SalesPriceItemUncheckedUpdateManyWithoutPriceListNestedInput = {
    create?: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput> | SalesPriceItemCreateWithoutPriceListInput[] | SalesPriceItemUncheckedCreateWithoutPriceListInput[]
    connectOrCreate?: SalesPriceItemCreateOrConnectWithoutPriceListInput | SalesPriceItemCreateOrConnectWithoutPriceListInput[]
    upsert?: SalesPriceItemUpsertWithWhereUniqueWithoutPriceListInput | SalesPriceItemUpsertWithWhereUniqueWithoutPriceListInput[]
    createMany?: SalesPriceItemCreateManyPriceListInputEnvelope
    set?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    disconnect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    delete?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    connect?: SalesPriceItemWhereUniqueInput | SalesPriceItemWhereUniqueInput[]
    update?: SalesPriceItemUpdateWithWhereUniqueWithoutPriceListInput | SalesPriceItemUpdateWithWhereUniqueWithoutPriceListInput[]
    updateMany?: SalesPriceItemUpdateManyWithWhereWithoutPriceListInput | SalesPriceItemUpdateManyWithWhereWithoutPriceListInput[]
    deleteMany?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
  }

  export type SalesPriceListCreateNestedOneWithoutItemsInput = {
    create?: XOR<SalesPriceListCreateWithoutItemsInput, SalesPriceListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutItemsInput
    connect?: SalesPriceListWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSalesPriceItemsInput = {
    create?: XOR<ProductCreateWithoutSalesPriceItemsInput, ProductUncheckedCreateWithoutSalesPriceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSalesPriceItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type SalesPriceListUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SalesPriceListCreateWithoutItemsInput, SalesPriceListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SalesPriceListCreateOrConnectWithoutItemsInput
    upsert?: SalesPriceListUpsertWithoutItemsInput
    connect?: SalesPriceListWhereUniqueInput
    update?: XOR<XOR<SalesPriceListUpdateToOneWithWhereWithoutItemsInput, SalesPriceListUpdateWithoutItemsInput>, SalesPriceListUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutSalesPriceItemsNestedInput = {
    create?: XOR<ProductCreateWithoutSalesPriceItemsInput, ProductUncheckedCreateWithoutSalesPriceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSalesPriceItemsInput
    upsert?: ProductUpsertWithoutSalesPriceItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSalesPriceItemsInput, ProductUpdateWithoutSalesPriceItemsInput>, ProductUncheckedUpdateWithoutSalesPriceItemsInput>
  }

  export type ProductCreateNestedOneWithoutProductionMmlsInput = {
    create?: XOR<ProductCreateWithoutProductionMmlsInput, ProductUncheckedCreateWithoutProductionMmlsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionMmlsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedMmlsInput = {
    create?: XOR<UserCreateWithoutCreatedMmlsInput, UserUncheckedCreateWithoutCreatedMmlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedMmlsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionMmlNodeCreateNestedManyWithoutMmlInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput> | ProductionMmlNodeCreateWithoutMmlInput[] | ProductionMmlNodeUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutMmlInput | ProductionMmlNodeCreateOrConnectWithoutMmlInput[]
    createMany?: ProductionMmlNodeCreateManyMmlInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductionRunCreateNestedManyWithoutMmlInput = {
    create?: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput> | ProductionRunCreateWithoutMmlInput[] | ProductionRunUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutMmlInput | ProductionRunCreateOrConnectWithoutMmlInput[]
    createMany?: ProductionRunCreateManyMmlInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutPrimaryMmlInput = {
    create?: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput> | SupplierCreateWithoutPrimaryMmlInput[] | SupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutPrimaryMmlInput | SupplierCreateOrConnectWithoutPrimaryMmlInput[]
    createMany?: SupplierCreateManyPrimaryMmlInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput> | PurchasePriceListSupplierCreateWithoutPrimaryMmlInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput | PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput[]
    createMany?: PurchasePriceListSupplierCreateManyPrimaryMmlInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type ProductionCuttingLineCreateNestedManyWithoutMmlInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutMmlInput, ProductionCuttingLineUncheckedCreateWithoutMmlInput> | ProductionCuttingLineCreateWithoutMmlInput[] | ProductionCuttingLineUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutMmlInput | ProductionCuttingLineCreateOrConnectWithoutMmlInput[]
    createMany?: ProductionCuttingLineCreateManyMmlInputEnvelope
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
  }

  export type ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput> | ProductionMmlNodeCreateWithoutMmlInput[] | ProductionMmlNodeUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutMmlInput | ProductionMmlNodeCreateOrConnectWithoutMmlInput[]
    createMany?: ProductionMmlNodeCreateManyMmlInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductionRunUncheckedCreateNestedManyWithoutMmlInput = {
    create?: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput> | ProductionRunCreateWithoutMmlInput[] | ProductionRunUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutMmlInput | ProductionRunCreateOrConnectWithoutMmlInput[]
    createMany?: ProductionRunCreateManyMmlInputEnvelope
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput = {
    create?: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput> | SupplierCreateWithoutPrimaryMmlInput[] | SupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutPrimaryMmlInput | SupplierCreateOrConnectWithoutPrimaryMmlInput[]
    createMany?: SupplierCreateManyPrimaryMmlInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput> | PurchasePriceListSupplierCreateWithoutPrimaryMmlInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput | PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput[]
    createMany?: PurchasePriceListSupplierCreateManyPrimaryMmlInputEnvelope
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
  }

  export type ProductionCuttingLineUncheckedCreateNestedManyWithoutMmlInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutMmlInput, ProductionCuttingLineUncheckedCreateWithoutMmlInput> | ProductionCuttingLineCreateWithoutMmlInput[] | ProductionCuttingLineUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutMmlInput | ProductionCuttingLineCreateOrConnectWithoutMmlInput[]
    createMany?: ProductionCuttingLineCreateManyMmlInputEnvelope
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutProductionMmlsNestedInput = {
    create?: XOR<ProductCreateWithoutProductionMmlsInput, ProductUncheckedCreateWithoutProductionMmlsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionMmlsInput
    upsert?: ProductUpsertWithoutProductionMmlsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductionMmlsInput, ProductUpdateWithoutProductionMmlsInput>, ProductUncheckedUpdateWithoutProductionMmlsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedMmlsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedMmlsInput, UserUncheckedCreateWithoutCreatedMmlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedMmlsInput
    upsert?: UserUpsertWithoutCreatedMmlsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedMmlsInput, UserUpdateWithoutCreatedMmlsInput>, UserUncheckedUpdateWithoutCreatedMmlsInput>
  }

  export type ProductionMmlNodeUpdateManyWithoutMmlNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput> | ProductionMmlNodeCreateWithoutMmlInput[] | ProductionMmlNodeUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutMmlInput | ProductionMmlNodeCreateOrConnectWithoutMmlInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutMmlInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutMmlInput[]
    createMany?: ProductionMmlNodeCreateManyMmlInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutMmlInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutMmlInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutMmlInput | ProductionMmlNodeUpdateManyWithWhereWithoutMmlInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductionRunUpdateManyWithoutMmlNestedInput = {
    create?: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput> | ProductionRunCreateWithoutMmlInput[] | ProductionRunUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutMmlInput | ProductionRunCreateOrConnectWithoutMmlInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutMmlInput | ProductionRunUpsertWithWhereUniqueWithoutMmlInput[]
    createMany?: ProductionRunCreateManyMmlInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutMmlInput | ProductionRunUpdateWithWhereUniqueWithoutMmlInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutMmlInput | ProductionRunUpdateManyWithWhereWithoutMmlInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutPrimaryMmlNestedInput = {
    create?: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput> | SupplierCreateWithoutPrimaryMmlInput[] | SupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutPrimaryMmlInput | SupplierCreateOrConnectWithoutPrimaryMmlInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput | SupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput[]
    createMany?: SupplierCreateManyPrimaryMmlInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput | SupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutPrimaryMmlInput | SupplierUpdateManyWithWhereWithoutPrimaryMmlInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput> | PurchasePriceListSupplierCreateWithoutPrimaryMmlInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput | PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput[]
    createMany?: PurchasePriceListSupplierCreateManyPrimaryMmlInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutPrimaryMmlInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutPrimaryMmlInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type ProductionCuttingLineUpdateManyWithoutMmlNestedInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutMmlInput, ProductionCuttingLineUncheckedCreateWithoutMmlInput> | ProductionCuttingLineCreateWithoutMmlInput[] | ProductionCuttingLineUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutMmlInput | ProductionCuttingLineCreateOrConnectWithoutMmlInput[]
    upsert?: ProductionCuttingLineUpsertWithWhereUniqueWithoutMmlInput | ProductionCuttingLineUpsertWithWhereUniqueWithoutMmlInput[]
    createMany?: ProductionCuttingLineCreateManyMmlInputEnvelope
    set?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    disconnect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    delete?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    update?: ProductionCuttingLineUpdateWithWhereUniqueWithoutMmlInput | ProductionCuttingLineUpdateWithWhereUniqueWithoutMmlInput[]
    updateMany?: ProductionCuttingLineUpdateManyWithWhereWithoutMmlInput | ProductionCuttingLineUpdateManyWithWhereWithoutMmlInput[]
    deleteMany?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput> | ProductionMmlNodeCreateWithoutMmlInput[] | ProductionMmlNodeUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutMmlInput | ProductionMmlNodeCreateOrConnectWithoutMmlInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutMmlInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutMmlInput[]
    createMany?: ProductionMmlNodeCreateManyMmlInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutMmlInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutMmlInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutMmlInput | ProductionMmlNodeUpdateManyWithWhereWithoutMmlInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductionRunUncheckedUpdateManyWithoutMmlNestedInput = {
    create?: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput> | ProductionRunCreateWithoutMmlInput[] | ProductionRunUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionRunCreateOrConnectWithoutMmlInput | ProductionRunCreateOrConnectWithoutMmlInput[]
    upsert?: ProductionRunUpsertWithWhereUniqueWithoutMmlInput | ProductionRunUpsertWithWhereUniqueWithoutMmlInput[]
    createMany?: ProductionRunCreateManyMmlInputEnvelope
    set?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    disconnect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    delete?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    connect?: ProductionRunWhereUniqueInput | ProductionRunWhereUniqueInput[]
    update?: ProductionRunUpdateWithWhereUniqueWithoutMmlInput | ProductionRunUpdateWithWhereUniqueWithoutMmlInput[]
    updateMany?: ProductionRunUpdateManyWithWhereWithoutMmlInput | ProductionRunUpdateManyWithWhereWithoutMmlInput[]
    deleteMany?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput = {
    create?: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput> | SupplierCreateWithoutPrimaryMmlInput[] | SupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutPrimaryMmlInput | SupplierCreateOrConnectWithoutPrimaryMmlInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput | SupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput[]
    createMany?: SupplierCreateManyPrimaryMmlInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput | SupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutPrimaryMmlInput | SupplierUpdateManyWithWhereWithoutPrimaryMmlInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput = {
    create?: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput> | PurchasePriceListSupplierCreateWithoutPrimaryMmlInput[] | PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput[]
    connectOrCreate?: PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput | PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput[]
    upsert?: PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput | PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput[]
    createMany?: PurchasePriceListSupplierCreateManyPrimaryMmlInputEnvelope
    set?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    disconnect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    delete?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    connect?: PurchasePriceListSupplierWhereUniqueInput | PurchasePriceListSupplierWhereUniqueInput[]
    update?: PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput | PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput[]
    updateMany?: PurchasePriceListSupplierUpdateManyWithWhereWithoutPrimaryMmlInput | PurchasePriceListSupplierUpdateManyWithWhereWithoutPrimaryMmlInput[]
    deleteMany?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
  }

  export type ProductionCuttingLineUncheckedUpdateManyWithoutMmlNestedInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutMmlInput, ProductionCuttingLineUncheckedCreateWithoutMmlInput> | ProductionCuttingLineCreateWithoutMmlInput[] | ProductionCuttingLineUncheckedCreateWithoutMmlInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutMmlInput | ProductionCuttingLineCreateOrConnectWithoutMmlInput[]
    upsert?: ProductionCuttingLineUpsertWithWhereUniqueWithoutMmlInput | ProductionCuttingLineUpsertWithWhereUniqueWithoutMmlInput[]
    createMany?: ProductionCuttingLineCreateManyMmlInputEnvelope
    set?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    disconnect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    delete?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    update?: ProductionCuttingLineUpdateWithWhereUniqueWithoutMmlInput | ProductionCuttingLineUpdateWithWhereUniqueWithoutMmlInput[]
    updateMany?: ProductionCuttingLineUpdateManyWithWhereWithoutMmlInput | ProductionCuttingLineUpdateManyWithWhereWithoutMmlInput[]
    deleteMany?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
  }

  export type ProductionMmlCreateNestedOneWithoutNodesInput = {
    create?: XOR<ProductionMmlCreateWithoutNodesInput, ProductionMmlUncheckedCreateWithoutNodesInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutNodesInput
    connect?: ProductionMmlWhereUniqueInput
  }

  export type ProductionMmlNodeCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutChildrenInput, ProductionMmlNodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutChildrenInput
    connect?: ProductionMmlNodeWhereUniqueInput
  }

  export type ProductionMmlNodeCreateNestedManyWithoutParentNodeInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput> | ProductionMmlNodeCreateWithoutParentNodeInput[] | ProductionMmlNodeUncheckedCreateWithoutParentNodeInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutParentNodeInput | ProductionMmlNodeCreateOrConnectWithoutParentNodeInput[]
    createMany?: ProductionMmlNodeCreateManyParentNodeInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductCreateNestedOneWithoutMmlNodesInput = {
    create?: XOR<ProductCreateWithoutMmlNodesInput, ProductUncheckedCreateWithoutMmlNodesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMmlNodesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductionRunValueCreateNestedManyWithoutNodeInput = {
    create?: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput> | ProductionRunValueCreateWithoutNodeInput[] | ProductionRunValueUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutNodeInput | ProductionRunValueCreateOrConnectWithoutNodeInput[]
    createMany?: ProductionRunValueCreateManyNodeInputEnvelope
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
  }

  export type ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput> | ProductionMmlNodeCreateWithoutParentNodeInput[] | ProductionMmlNodeUncheckedCreateWithoutParentNodeInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutParentNodeInput | ProductionMmlNodeCreateOrConnectWithoutParentNodeInput[]
    createMany?: ProductionMmlNodeCreateManyParentNodeInputEnvelope
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
  }

  export type ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput = {
    create?: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput> | ProductionRunValueCreateWithoutNodeInput[] | ProductionRunValueUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutNodeInput | ProductionRunValueCreateOrConnectWithoutNodeInput[]
    createMany?: ProductionRunValueCreateManyNodeInputEnvelope
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
  }

  export type ProductionMmlUpdateOneRequiredWithoutNodesNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutNodesInput, ProductionMmlUncheckedCreateWithoutNodesInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutNodesInput
    upsert?: ProductionMmlUpsertWithoutNodesInput
    connect?: ProductionMmlWhereUniqueInput
    update?: XOR<XOR<ProductionMmlUpdateToOneWithWhereWithoutNodesInput, ProductionMmlUpdateWithoutNodesInput>, ProductionMmlUncheckedUpdateWithoutNodesInput>
  }

  export type ProductionMmlNodeUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutChildrenInput, ProductionMmlNodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutChildrenInput
    upsert?: ProductionMmlNodeUpsertWithoutChildrenInput
    disconnect?: ProductionMmlNodeWhereInput | boolean
    delete?: ProductionMmlNodeWhereInput | boolean
    connect?: ProductionMmlNodeWhereUniqueInput
    update?: XOR<XOR<ProductionMmlNodeUpdateToOneWithWhereWithoutChildrenInput, ProductionMmlNodeUpdateWithoutChildrenInput>, ProductionMmlNodeUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput> | ProductionMmlNodeCreateWithoutParentNodeInput[] | ProductionMmlNodeUncheckedCreateWithoutParentNodeInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutParentNodeInput | ProductionMmlNodeCreateOrConnectWithoutParentNodeInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutParentNodeInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutParentNodeInput[]
    createMany?: ProductionMmlNodeCreateManyParentNodeInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutParentNodeInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutParentNodeInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutParentNodeInput | ProductionMmlNodeUpdateManyWithWhereWithoutParentNodeInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductUpdateOneRequiredWithoutMmlNodesNestedInput = {
    create?: XOR<ProductCreateWithoutMmlNodesInput, ProductUncheckedCreateWithoutMmlNodesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMmlNodesInput
    upsert?: ProductUpsertWithoutMmlNodesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutMmlNodesInput, ProductUpdateWithoutMmlNodesInput>, ProductUncheckedUpdateWithoutMmlNodesInput>
  }

  export type ProductionRunValueUpdateManyWithoutNodeNestedInput = {
    create?: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput> | ProductionRunValueCreateWithoutNodeInput[] | ProductionRunValueUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutNodeInput | ProductionRunValueCreateOrConnectWithoutNodeInput[]
    upsert?: ProductionRunValueUpsertWithWhereUniqueWithoutNodeInput | ProductionRunValueUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: ProductionRunValueCreateManyNodeInputEnvelope
    set?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    disconnect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    delete?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    update?: ProductionRunValueUpdateWithWhereUniqueWithoutNodeInput | ProductionRunValueUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: ProductionRunValueUpdateManyWithWhereWithoutNodeInput | ProductionRunValueUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput> | ProductionMmlNodeCreateWithoutParentNodeInput[] | ProductionMmlNodeUncheckedCreateWithoutParentNodeInput[]
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutParentNodeInput | ProductionMmlNodeCreateOrConnectWithoutParentNodeInput[]
    upsert?: ProductionMmlNodeUpsertWithWhereUniqueWithoutParentNodeInput | ProductionMmlNodeUpsertWithWhereUniqueWithoutParentNodeInput[]
    createMany?: ProductionMmlNodeCreateManyParentNodeInputEnvelope
    set?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    disconnect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    delete?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    connect?: ProductionMmlNodeWhereUniqueInput | ProductionMmlNodeWhereUniqueInput[]
    update?: ProductionMmlNodeUpdateWithWhereUniqueWithoutParentNodeInput | ProductionMmlNodeUpdateWithWhereUniqueWithoutParentNodeInput[]
    updateMany?: ProductionMmlNodeUpdateManyWithWhereWithoutParentNodeInput | ProductionMmlNodeUpdateManyWithWhereWithoutParentNodeInput[]
    deleteMany?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
  }

  export type ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput = {
    create?: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput> | ProductionRunValueCreateWithoutNodeInput[] | ProductionRunValueUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutNodeInput | ProductionRunValueCreateOrConnectWithoutNodeInput[]
    upsert?: ProductionRunValueUpsertWithWhereUniqueWithoutNodeInput | ProductionRunValueUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: ProductionRunValueCreateManyNodeInputEnvelope
    set?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    disconnect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    delete?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    update?: ProductionRunValueUpdateWithWhereUniqueWithoutNodeInput | ProductionRunValueUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: ProductionRunValueUpdateManyWithWhereWithoutNodeInput | ProductionRunValueUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductionRunsInput = {
    create?: XOR<ProductCreateWithoutProductionRunsInput, ProductUncheckedCreateWithoutProductionRunsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionRunsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductionMmlCreateNestedOneWithoutRunsInput = {
    create?: XOR<ProductionMmlCreateWithoutRunsInput, ProductionMmlUncheckedCreateWithoutRunsInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutRunsInput
    connect?: ProductionMmlWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductionRunsInput = {
    create?: XOR<UserCreateWithoutProductionRunsInput, UserUncheckedCreateWithoutProductionRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionRunsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionRunValueCreateNestedManyWithoutRunInput = {
    create?: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput> | ProductionRunValueCreateWithoutRunInput[] | ProductionRunValueUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutRunInput | ProductionRunValueCreateOrConnectWithoutRunInput[]
    createMany?: ProductionRunValueCreateManyRunInputEnvelope
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
  }

  export type ProductionRunValueUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput> | ProductionRunValueCreateWithoutRunInput[] | ProductionRunValueUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutRunInput | ProductionRunValueCreateOrConnectWithoutRunInput[]
    createMany?: ProductionRunValueCreateManyRunInputEnvelope
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutProductionRunsNestedInput = {
    create?: XOR<ProductCreateWithoutProductionRunsInput, ProductUncheckedCreateWithoutProductionRunsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionRunsInput
    upsert?: ProductUpsertWithoutProductionRunsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductionRunsInput, ProductUpdateWithoutProductionRunsInput>, ProductUncheckedUpdateWithoutProductionRunsInput>
  }

  export type ProductionMmlUpdateOneRequiredWithoutRunsNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutRunsInput, ProductionMmlUncheckedCreateWithoutRunsInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutRunsInput
    upsert?: ProductionMmlUpsertWithoutRunsInput
    connect?: ProductionMmlWhereUniqueInput
    update?: XOR<XOR<ProductionMmlUpdateToOneWithWhereWithoutRunsInput, ProductionMmlUpdateWithoutRunsInput>, ProductionMmlUncheckedUpdateWithoutRunsInput>
  }

  export type UserUpdateOneRequiredWithoutProductionRunsNestedInput = {
    create?: XOR<UserCreateWithoutProductionRunsInput, UserUncheckedCreateWithoutProductionRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionRunsInput
    upsert?: UserUpsertWithoutProductionRunsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductionRunsInput, UserUpdateWithoutProductionRunsInput>, UserUncheckedUpdateWithoutProductionRunsInput>
  }

  export type ProductionRunValueUpdateManyWithoutRunNestedInput = {
    create?: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput> | ProductionRunValueCreateWithoutRunInput[] | ProductionRunValueUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutRunInput | ProductionRunValueCreateOrConnectWithoutRunInput[]
    upsert?: ProductionRunValueUpsertWithWhereUniqueWithoutRunInput | ProductionRunValueUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: ProductionRunValueCreateManyRunInputEnvelope
    set?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    disconnect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    delete?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    update?: ProductionRunValueUpdateWithWhereUniqueWithoutRunInput | ProductionRunValueUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: ProductionRunValueUpdateManyWithWhereWithoutRunInput | ProductionRunValueUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
  }

  export type ProductionRunValueUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput> | ProductionRunValueCreateWithoutRunInput[] | ProductionRunValueUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ProductionRunValueCreateOrConnectWithoutRunInput | ProductionRunValueCreateOrConnectWithoutRunInput[]
    upsert?: ProductionRunValueUpsertWithWhereUniqueWithoutRunInput | ProductionRunValueUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: ProductionRunValueCreateManyRunInputEnvelope
    set?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    disconnect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    delete?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    connect?: ProductionRunValueWhereUniqueInput | ProductionRunValueWhereUniqueInput[]
    update?: ProductionRunValueUpdateWithWhereUniqueWithoutRunInput | ProductionRunValueUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: ProductionRunValueUpdateManyWithWhereWithoutRunInput | ProductionRunValueUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
  }

  export type ProductionRunCreateNestedOneWithoutValuesInput = {
    create?: XOR<ProductionRunCreateWithoutValuesInput, ProductionRunUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductionRunCreateOrConnectWithoutValuesInput
    connect?: ProductionRunWhereUniqueInput
  }

  export type ProductionMmlNodeCreateNestedOneWithoutRunValuesInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutRunValuesInput, ProductionMmlNodeUncheckedCreateWithoutRunValuesInput>
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutRunValuesInput
    connect?: ProductionMmlNodeWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutRunValueSnapshotsInput = {
    create?: XOR<ProductCreateWithoutRunValueSnapshotsInput, ProductUncheckedCreateWithoutRunValueSnapshotsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRunValueSnapshotsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductionRunUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<ProductionRunCreateWithoutValuesInput, ProductionRunUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductionRunCreateOrConnectWithoutValuesInput
    upsert?: ProductionRunUpsertWithoutValuesInput
    connect?: ProductionRunWhereUniqueInput
    update?: XOR<XOR<ProductionRunUpdateToOneWithWhereWithoutValuesInput, ProductionRunUpdateWithoutValuesInput>, ProductionRunUncheckedUpdateWithoutValuesInput>
  }

  export type ProductionMmlNodeUpdateOneRequiredWithoutRunValuesNestedInput = {
    create?: XOR<ProductionMmlNodeCreateWithoutRunValuesInput, ProductionMmlNodeUncheckedCreateWithoutRunValuesInput>
    connectOrCreate?: ProductionMmlNodeCreateOrConnectWithoutRunValuesInput
    upsert?: ProductionMmlNodeUpsertWithoutRunValuesInput
    connect?: ProductionMmlNodeWhereUniqueInput
    update?: XOR<XOR<ProductionMmlNodeUpdateToOneWithWhereWithoutRunValuesInput, ProductionMmlNodeUpdateWithoutRunValuesInput>, ProductionMmlNodeUncheckedUpdateWithoutRunValuesInput>
  }

  export type ProductUpdateOneWithoutRunValueSnapshotsNestedInput = {
    create?: XOR<ProductCreateWithoutRunValueSnapshotsInput, ProductUncheckedCreateWithoutRunValueSnapshotsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRunValueSnapshotsInput
    upsert?: ProductUpsertWithoutRunValueSnapshotsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRunValueSnapshotsInput, ProductUpdateWithoutRunValueSnapshotsInput>, ProductUncheckedUpdateWithoutRunValueSnapshotsInput>
  }

  export type PurchaseItemCreateNestedManyWithoutPaymentTypeInput = {
    create?: XOR<PurchaseItemCreateWithoutPaymentTypeInput, PurchaseItemUncheckedCreateWithoutPaymentTypeInput> | PurchaseItemCreateWithoutPaymentTypeInput[] | PurchaseItemUncheckedCreateWithoutPaymentTypeInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPaymentTypeInput | PurchaseItemCreateOrConnectWithoutPaymentTypeInput[]
    createMany?: PurchaseItemCreateManyPaymentTypeInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutPaymentTypeInput = {
    create?: XOR<PurchaseItemCreateWithoutPaymentTypeInput, PurchaseItemUncheckedCreateWithoutPaymentTypeInput> | PurchaseItemCreateWithoutPaymentTypeInput[] | PurchaseItemUncheckedCreateWithoutPaymentTypeInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPaymentTypeInput | PurchaseItemCreateOrConnectWithoutPaymentTypeInput[]
    createMany?: PurchaseItemCreateManyPaymentTypeInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type PurchaseItemUpdateManyWithoutPaymentTypeNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPaymentTypeInput, PurchaseItemUncheckedCreateWithoutPaymentTypeInput> | PurchaseItemCreateWithoutPaymentTypeInput[] | PurchaseItemUncheckedCreateWithoutPaymentTypeInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPaymentTypeInput | PurchaseItemCreateOrConnectWithoutPaymentTypeInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPaymentTypeInput | PurchaseItemUpsertWithWhereUniqueWithoutPaymentTypeInput[]
    createMany?: PurchaseItemCreateManyPaymentTypeInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPaymentTypeInput | PurchaseItemUpdateWithWhereUniqueWithoutPaymentTypeInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPaymentTypeInput | PurchaseItemUpdateManyWithWhereWithoutPaymentTypeInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPaymentTypeNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPaymentTypeInput, PurchaseItemUncheckedCreateWithoutPaymentTypeInput> | PurchaseItemCreateWithoutPaymentTypeInput[] | PurchaseItemUncheckedCreateWithoutPaymentTypeInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPaymentTypeInput | PurchaseItemCreateOrConnectWithoutPaymentTypeInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPaymentTypeInput | PurchaseItemUpsertWithWhereUniqueWithoutPaymentTypeInput[]
    createMany?: PurchaseItemCreateManyPaymentTypeInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPaymentTypeInput | PurchaseItemUpdateWithWhereUniqueWithoutPaymentTypeInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPaymentTypeInput | PurchaseItemUpdateManyWithWhereWithoutPaymentTypeInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseSupplierCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseSupplierCreateWithoutPurchaseInput, PurchaseSupplierUncheckedCreateWithoutPurchaseInput> | PurchaseSupplierCreateWithoutPurchaseInput[] | PurchaseSupplierUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseSupplierCreateOrConnectWithoutPurchaseInput | PurchaseSupplierCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseSupplierCreateManyPurchaseInputEnvelope
    connect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type ProductionInputCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<ProductionInputCreateWithoutPurchaseInput, ProductionInputUncheckedCreateWithoutPurchaseInput> | ProductionInputCreateWithoutPurchaseInput[] | ProductionInputUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutPurchaseInput | ProductionInputCreateOrConnectWithoutPurchaseInput[]
    createMany?: ProductionInputCreateManyPurchaseInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type PurchaseSupplierUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseSupplierCreateWithoutPurchaseInput, PurchaseSupplierUncheckedCreateWithoutPurchaseInput> | PurchaseSupplierCreateWithoutPurchaseInput[] | PurchaseSupplierUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseSupplierCreateOrConnectWithoutPurchaseInput | PurchaseSupplierCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseSupplierCreateManyPurchaseInputEnvelope
    connect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type ProductionInputUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<ProductionInputCreateWithoutPurchaseInput, ProductionInputUncheckedCreateWithoutPurchaseInput> | ProductionInputCreateWithoutPurchaseInput[] | ProductionInputUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutPurchaseInput | ProductionInputCreateOrConnectWithoutPurchaseInput[]
    createMany?: ProductionInputCreateManyPurchaseInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    upsert?: UserUpsertWithoutPurchasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchasesInput, UserUpdateWithoutPurchasesInput>, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type PurchaseSupplierUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseSupplierCreateWithoutPurchaseInput, PurchaseSupplierUncheckedCreateWithoutPurchaseInput> | PurchaseSupplierCreateWithoutPurchaseInput[] | PurchaseSupplierUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseSupplierCreateOrConnectWithoutPurchaseInput | PurchaseSupplierCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseSupplierUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseSupplierUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseSupplierCreateManyPurchaseInputEnvelope
    set?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    disconnect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    delete?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    connect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    update?: PurchaseSupplierUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseSupplierUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseSupplierUpdateManyWithWhereWithoutPurchaseInput | PurchaseSupplierUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseSupplierScalarWhereInput | PurchaseSupplierScalarWhereInput[]
  }

  export type PurchaseItemUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type ProductionInputUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<ProductionInputCreateWithoutPurchaseInput, ProductionInputUncheckedCreateWithoutPurchaseInput> | ProductionInputCreateWithoutPurchaseInput[] | ProductionInputUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutPurchaseInput | ProductionInputCreateOrConnectWithoutPurchaseInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutPurchaseInput | ProductionInputUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: ProductionInputCreateManyPurchaseInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutPurchaseInput | ProductionInputUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutPurchaseInput | ProductionInputUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type PurchaseSupplierUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseSupplierCreateWithoutPurchaseInput, PurchaseSupplierUncheckedCreateWithoutPurchaseInput> | PurchaseSupplierCreateWithoutPurchaseInput[] | PurchaseSupplierUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseSupplierCreateOrConnectWithoutPurchaseInput | PurchaseSupplierCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseSupplierUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseSupplierUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseSupplierCreateManyPurchaseInputEnvelope
    set?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    disconnect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    delete?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    connect?: PurchaseSupplierWhereUniqueInput | PurchaseSupplierWhereUniqueInput[]
    update?: PurchaseSupplierUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseSupplierUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseSupplierUpdateManyWithWhereWithoutPurchaseInput | PurchaseSupplierUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseSupplierScalarWhereInput | PurchaseSupplierScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type ProductionInputUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<ProductionInputCreateWithoutPurchaseInput, ProductionInputUncheckedCreateWithoutPurchaseInput> | ProductionInputCreateWithoutPurchaseInput[] | ProductionInputUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutPurchaseInput | ProductionInputCreateOrConnectWithoutPurchaseInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutPurchaseInput | ProductionInputUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: ProductionInputCreateManyPurchaseInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutPurchaseInput | ProductionInputUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutPurchaseInput | ProductionInputUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type PurchaseCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<PurchaseCreateWithoutSuppliersInput, PurchaseUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutSuppliersInput
    connect?: PurchaseWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<SupplierCreateWithoutPurchasesInput, SupplierUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasesInput
    connect?: SupplierWhereUniqueInput
  }

  export type PurchaseUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<PurchaseCreateWithoutSuppliersInput, PurchaseUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutSuppliersInput
    upsert?: PurchaseUpsertWithoutSuppliersInput
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutSuppliersInput, PurchaseUpdateWithoutSuppliersInput>, PurchaseUncheckedUpdateWithoutSuppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchasesInput, SupplierUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchasesInput
    upsert?: SupplierUpsertWithoutPurchasesInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchasesInput, SupplierUpdateWithoutPurchasesInput>, SupplierUncheckedUpdateWithoutPurchasesInput>
  }

  export type PurchaseCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutItemsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchaseItemsInput = {
    create?: XOR<SupplierCreateWithoutPurchaseItemsInput, SupplierUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseItemsInput
    connect?: SupplierWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchaseItemsRelInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemsRelInput, ProductUncheckedCreateWithoutPurchaseItemsRelInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemsRelInput
    connect?: ProductWhereUniqueInput
  }

  export type PaymentTypeCreateNestedOneWithoutPurchaseItemsInput = {
    create?: XOR<PaymentTypeCreateWithoutPurchaseItemsInput, PaymentTypeUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: PaymentTypeCreateOrConnectWithoutPurchaseItemsInput
    connect?: PaymentTypeWhereUniqueInput
  }

  export type ProductionInputCreateNestedManyWithoutPurchaseItemInput = {
    create?: XOR<ProductionInputCreateWithoutPurchaseItemInput, ProductionInputUncheckedCreateWithoutPurchaseItemInput> | ProductionInputCreateWithoutPurchaseItemInput[] | ProductionInputUncheckedCreateWithoutPurchaseItemInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutPurchaseItemInput | ProductionInputCreateOrConnectWithoutPurchaseItemInput[]
    createMany?: ProductionInputCreateManyPurchaseItemInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type ProductionInputUncheckedCreateNestedManyWithoutPurchaseItemInput = {
    create?: XOR<ProductionInputCreateWithoutPurchaseItemInput, ProductionInputUncheckedCreateWithoutPurchaseItemInput> | ProductionInputCreateWithoutPurchaseItemInput[] | ProductionInputUncheckedCreateWithoutPurchaseItemInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutPurchaseItemInput | ProductionInputCreateOrConnectWithoutPurchaseItemInput[]
    createMany?: ProductionInputCreateManyPurchaseItemInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type PurchaseUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutItemsInput
    upsert?: PurchaseUpsertWithoutItemsInput
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutItemsInput, PurchaseUpdateWithoutItemsInput>, PurchaseUncheckedUpdateWithoutItemsInput>
  }

  export type SupplierUpdateOneRequiredWithoutPurchaseItemsNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseItemsInput, SupplierUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseItemsInput
    upsert?: SupplierUpsertWithoutPurchaseItemsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseItemsInput, SupplierUpdateWithoutPurchaseItemsInput>, SupplierUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchaseItemsRelNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemsRelInput, ProductUncheckedCreateWithoutPurchaseItemsRelInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemsRelInput
    upsert?: ProductUpsertWithoutPurchaseItemsRelInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseItemsRelInput, ProductUpdateWithoutPurchaseItemsRelInput>, ProductUncheckedUpdateWithoutPurchaseItemsRelInput>
  }

  export type PaymentTypeUpdateOneWithoutPurchaseItemsNestedInput = {
    create?: XOR<PaymentTypeCreateWithoutPurchaseItemsInput, PaymentTypeUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: PaymentTypeCreateOrConnectWithoutPurchaseItemsInput
    upsert?: PaymentTypeUpsertWithoutPurchaseItemsInput
    disconnect?: PaymentTypeWhereInput | boolean
    delete?: PaymentTypeWhereInput | boolean
    connect?: PaymentTypeWhereUniqueInput
    update?: XOR<XOR<PaymentTypeUpdateToOneWithWhereWithoutPurchaseItemsInput, PaymentTypeUpdateWithoutPurchaseItemsInput>, PaymentTypeUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type ProductionInputUpdateManyWithoutPurchaseItemNestedInput = {
    create?: XOR<ProductionInputCreateWithoutPurchaseItemInput, ProductionInputUncheckedCreateWithoutPurchaseItemInput> | ProductionInputCreateWithoutPurchaseItemInput[] | ProductionInputUncheckedCreateWithoutPurchaseItemInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutPurchaseItemInput | ProductionInputCreateOrConnectWithoutPurchaseItemInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutPurchaseItemInput | ProductionInputUpsertWithWhereUniqueWithoutPurchaseItemInput[]
    createMany?: ProductionInputCreateManyPurchaseItemInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutPurchaseItemInput | ProductionInputUpdateWithWhereUniqueWithoutPurchaseItemInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutPurchaseItemInput | ProductionInputUpdateManyWithWhereWithoutPurchaseItemInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type ProductionInputUncheckedUpdateManyWithoutPurchaseItemNestedInput = {
    create?: XOR<ProductionInputCreateWithoutPurchaseItemInput, ProductionInputUncheckedCreateWithoutPurchaseItemInput> | ProductionInputCreateWithoutPurchaseItemInput[] | ProductionInputUncheckedCreateWithoutPurchaseItemInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutPurchaseItemInput | ProductionInputCreateOrConnectWithoutPurchaseItemInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutPurchaseItemInput | ProductionInputUpsertWithWhereUniqueWithoutPurchaseItemInput[]
    createMany?: ProductionInputCreateManyPurchaseItemInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutPurchaseItemInput | ProductionInputUpdateWithWhereUniqueWithoutPurchaseItemInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutPurchaseItemInput | ProductionInputUpdateManyWithWhereWithoutPurchaseItemInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type TelegramOrderDraftCreateNestedManyWithoutGroupInput = {
    create?: XOR<TelegramOrderDraftCreateWithoutGroupInput, TelegramOrderDraftUncheckedCreateWithoutGroupInput> | TelegramOrderDraftCreateWithoutGroupInput[] | TelegramOrderDraftUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TelegramOrderDraftCreateOrConnectWithoutGroupInput | TelegramOrderDraftCreateOrConnectWithoutGroupInput[]
    createMany?: TelegramOrderDraftCreateManyGroupInputEnvelope
    connect?: TelegramOrderDraftWhereUniqueInput | TelegramOrderDraftWhereUniqueInput[]
  }

  export type TelegramOrderDraftUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<TelegramOrderDraftCreateWithoutGroupInput, TelegramOrderDraftUncheckedCreateWithoutGroupInput> | TelegramOrderDraftCreateWithoutGroupInput[] | TelegramOrderDraftUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TelegramOrderDraftCreateOrConnectWithoutGroupInput | TelegramOrderDraftCreateOrConnectWithoutGroupInput[]
    createMany?: TelegramOrderDraftCreateManyGroupInputEnvelope
    connect?: TelegramOrderDraftWhereUniqueInput | TelegramOrderDraftWhereUniqueInput[]
  }

  export type TelegramOrderDraftUpdateManyWithoutGroupNestedInput = {
    create?: XOR<TelegramOrderDraftCreateWithoutGroupInput, TelegramOrderDraftUncheckedCreateWithoutGroupInput> | TelegramOrderDraftCreateWithoutGroupInput[] | TelegramOrderDraftUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TelegramOrderDraftCreateOrConnectWithoutGroupInput | TelegramOrderDraftCreateOrConnectWithoutGroupInput[]
    upsert?: TelegramOrderDraftUpsertWithWhereUniqueWithoutGroupInput | TelegramOrderDraftUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: TelegramOrderDraftCreateManyGroupInputEnvelope
    set?: TelegramOrderDraftWhereUniqueInput | TelegramOrderDraftWhereUniqueInput[]
    disconnect?: TelegramOrderDraftWhereUniqueInput | TelegramOrderDraftWhereUniqueInput[]
    delete?: TelegramOrderDraftWhereUniqueInput | TelegramOrderDraftWhereUniqueInput[]
    connect?: TelegramOrderDraftWhereUniqueInput | TelegramOrderDraftWhereUniqueInput[]
    update?: TelegramOrderDraftUpdateWithWhereUniqueWithoutGroupInput | TelegramOrderDraftUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: TelegramOrderDraftUpdateManyWithWhereWithoutGroupInput | TelegramOrderDraftUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: TelegramOrderDraftScalarWhereInput | TelegramOrderDraftScalarWhereInput[]
  }

  export type TelegramOrderDraftUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<TelegramOrderDraftCreateWithoutGroupInput, TelegramOrderDraftUncheckedCreateWithoutGroupInput> | TelegramOrderDraftCreateWithoutGroupInput[] | TelegramOrderDraftUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TelegramOrderDraftCreateOrConnectWithoutGroupInput | TelegramOrderDraftCreateOrConnectWithoutGroupInput[]
    upsert?: TelegramOrderDraftUpsertWithWhereUniqueWithoutGroupInput | TelegramOrderDraftUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: TelegramOrderDraftCreateManyGroupInputEnvelope
    set?: TelegramOrderDraftWhereUniqueInput | TelegramOrderDraftWhereUniqueInput[]
    disconnect?: TelegramOrderDraftWhereUniqueInput | TelegramOrderDraftWhereUniqueInput[]
    delete?: TelegramOrderDraftWhereUniqueInput | TelegramOrderDraftWhereUniqueInput[]
    connect?: TelegramOrderDraftWhereUniqueInput | TelegramOrderDraftWhereUniqueInput[]
    update?: TelegramOrderDraftUpdateWithWhereUniqueWithoutGroupInput | TelegramOrderDraftUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: TelegramOrderDraftUpdateManyWithWhereWithoutGroupInput | TelegramOrderDraftUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: TelegramOrderDraftScalarWhereInput | TelegramOrderDraftScalarWhereInput[]
  }

  export type TelegramGroupCreateNestedOneWithoutOrderDraftsInput = {
    create?: XOR<TelegramGroupCreateWithoutOrderDraftsInput, TelegramGroupUncheckedCreateWithoutOrderDraftsInput>
    connectOrCreate?: TelegramGroupCreateOrConnectWithoutOrderDraftsInput
    connect?: TelegramGroupWhereUniqueInput
  }

  export type TelegramOrderDraftItemCreateNestedManyWithoutDraftInput = {
    create?: XOR<TelegramOrderDraftItemCreateWithoutDraftInput, TelegramOrderDraftItemUncheckedCreateWithoutDraftInput> | TelegramOrderDraftItemCreateWithoutDraftInput[] | TelegramOrderDraftItemUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: TelegramOrderDraftItemCreateOrConnectWithoutDraftInput | TelegramOrderDraftItemCreateOrConnectWithoutDraftInput[]
    createMany?: TelegramOrderDraftItemCreateManyDraftInputEnvelope
    connect?: TelegramOrderDraftItemWhereUniqueInput | TelegramOrderDraftItemWhereUniqueInput[]
  }

  export type TelegramOrderDraftItemUncheckedCreateNestedManyWithoutDraftInput = {
    create?: XOR<TelegramOrderDraftItemCreateWithoutDraftInput, TelegramOrderDraftItemUncheckedCreateWithoutDraftInput> | TelegramOrderDraftItemCreateWithoutDraftInput[] | TelegramOrderDraftItemUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: TelegramOrderDraftItemCreateOrConnectWithoutDraftInput | TelegramOrderDraftItemCreateOrConnectWithoutDraftInput[]
    createMany?: TelegramOrderDraftItemCreateManyDraftInputEnvelope
    connect?: TelegramOrderDraftItemWhereUniqueInput | TelegramOrderDraftItemWhereUniqueInput[]
  }

  export type TelegramGroupUpdateOneRequiredWithoutOrderDraftsNestedInput = {
    create?: XOR<TelegramGroupCreateWithoutOrderDraftsInput, TelegramGroupUncheckedCreateWithoutOrderDraftsInput>
    connectOrCreate?: TelegramGroupCreateOrConnectWithoutOrderDraftsInput
    upsert?: TelegramGroupUpsertWithoutOrderDraftsInput
    connect?: TelegramGroupWhereUniqueInput
    update?: XOR<XOR<TelegramGroupUpdateToOneWithWhereWithoutOrderDraftsInput, TelegramGroupUpdateWithoutOrderDraftsInput>, TelegramGroupUncheckedUpdateWithoutOrderDraftsInput>
  }

  export type TelegramOrderDraftItemUpdateManyWithoutDraftNestedInput = {
    create?: XOR<TelegramOrderDraftItemCreateWithoutDraftInput, TelegramOrderDraftItemUncheckedCreateWithoutDraftInput> | TelegramOrderDraftItemCreateWithoutDraftInput[] | TelegramOrderDraftItemUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: TelegramOrderDraftItemCreateOrConnectWithoutDraftInput | TelegramOrderDraftItemCreateOrConnectWithoutDraftInput[]
    upsert?: TelegramOrderDraftItemUpsertWithWhereUniqueWithoutDraftInput | TelegramOrderDraftItemUpsertWithWhereUniqueWithoutDraftInput[]
    createMany?: TelegramOrderDraftItemCreateManyDraftInputEnvelope
    set?: TelegramOrderDraftItemWhereUniqueInput | TelegramOrderDraftItemWhereUniqueInput[]
    disconnect?: TelegramOrderDraftItemWhereUniqueInput | TelegramOrderDraftItemWhereUniqueInput[]
    delete?: TelegramOrderDraftItemWhereUniqueInput | TelegramOrderDraftItemWhereUniqueInput[]
    connect?: TelegramOrderDraftItemWhereUniqueInput | TelegramOrderDraftItemWhereUniqueInput[]
    update?: TelegramOrderDraftItemUpdateWithWhereUniqueWithoutDraftInput | TelegramOrderDraftItemUpdateWithWhereUniqueWithoutDraftInput[]
    updateMany?: TelegramOrderDraftItemUpdateManyWithWhereWithoutDraftInput | TelegramOrderDraftItemUpdateManyWithWhereWithoutDraftInput[]
    deleteMany?: TelegramOrderDraftItemScalarWhereInput | TelegramOrderDraftItemScalarWhereInput[]
  }

  export type TelegramOrderDraftItemUncheckedUpdateManyWithoutDraftNestedInput = {
    create?: XOR<TelegramOrderDraftItemCreateWithoutDraftInput, TelegramOrderDraftItemUncheckedCreateWithoutDraftInput> | TelegramOrderDraftItemCreateWithoutDraftInput[] | TelegramOrderDraftItemUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: TelegramOrderDraftItemCreateOrConnectWithoutDraftInput | TelegramOrderDraftItemCreateOrConnectWithoutDraftInput[]
    upsert?: TelegramOrderDraftItemUpsertWithWhereUniqueWithoutDraftInput | TelegramOrderDraftItemUpsertWithWhereUniqueWithoutDraftInput[]
    createMany?: TelegramOrderDraftItemCreateManyDraftInputEnvelope
    set?: TelegramOrderDraftItemWhereUniqueInput | TelegramOrderDraftItemWhereUniqueInput[]
    disconnect?: TelegramOrderDraftItemWhereUniqueInput | TelegramOrderDraftItemWhereUniqueInput[]
    delete?: TelegramOrderDraftItemWhereUniqueInput | TelegramOrderDraftItemWhereUniqueInput[]
    connect?: TelegramOrderDraftItemWhereUniqueInput | TelegramOrderDraftItemWhereUniqueInput[]
    update?: TelegramOrderDraftItemUpdateWithWhereUniqueWithoutDraftInput | TelegramOrderDraftItemUpdateWithWhereUniqueWithoutDraftInput[]
    updateMany?: TelegramOrderDraftItemUpdateManyWithWhereWithoutDraftInput | TelegramOrderDraftItemUpdateManyWithWhereWithoutDraftInput[]
    deleteMany?: TelegramOrderDraftItemScalarWhereInput | TelegramOrderDraftItemScalarWhereInput[]
  }

  export type TelegramOrderDraftCreateNestedOneWithoutItemsInput = {
    create?: XOR<TelegramOrderDraftCreateWithoutItemsInput, TelegramOrderDraftUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TelegramOrderDraftCreateOrConnectWithoutItemsInput
    connect?: TelegramOrderDraftWhereUniqueInput
  }

  export type TelegramOrderDraftUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TelegramOrderDraftCreateWithoutItemsInput, TelegramOrderDraftUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TelegramOrderDraftCreateOrConnectWithoutItemsInput
    upsert?: TelegramOrderDraftUpsertWithoutItemsInput
    connect?: TelegramOrderDraftWhereUniqueInput
    update?: XOR<XOR<TelegramOrderDraftUpdateToOneWithWhereWithoutItemsInput, TelegramOrderDraftUpdateWithoutItemsInput>, TelegramOrderDraftUncheckedUpdateWithoutItemsInput>
  }

  export type UserCreateNestedOneWithoutWarehousesInput = {
    create?: XOR<UserCreateWithoutWarehousesInput, UserUncheckedCreateWithoutWarehousesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarehousesInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionDocCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ProductionDocCreateWithoutWarehouseInput, ProductionDocUncheckedCreateWithoutWarehouseInput> | ProductionDocCreateWithoutWarehouseInput[] | ProductionDocUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionDocCreateOrConnectWithoutWarehouseInput | ProductionDocCreateOrConnectWithoutWarehouseInput[]
    createMany?: ProductionDocCreateManyWarehouseInputEnvelope
    connect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
  }

  export type ProductionInputCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ProductionInputCreateWithoutWarehouseInput, ProductionInputUncheckedCreateWithoutWarehouseInput> | ProductionInputCreateWithoutWarehouseInput[] | ProductionInputUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutWarehouseInput | ProductionInputCreateOrConnectWithoutWarehouseInput[]
    createMany?: ProductionInputCreateManyWarehouseInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type ProductionDocUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ProductionDocCreateWithoutWarehouseInput, ProductionDocUncheckedCreateWithoutWarehouseInput> | ProductionDocCreateWithoutWarehouseInput[] | ProductionDocUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionDocCreateOrConnectWithoutWarehouseInput | ProductionDocCreateOrConnectWithoutWarehouseInput[]
    createMany?: ProductionDocCreateManyWarehouseInputEnvelope
    connect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
  }

  export type ProductionInputUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ProductionInputCreateWithoutWarehouseInput, ProductionInputUncheckedCreateWithoutWarehouseInput> | ProductionInputCreateWithoutWarehouseInput[] | ProductionInputUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutWarehouseInput | ProductionInputCreateOrConnectWithoutWarehouseInput[]
    createMany?: ProductionInputCreateManyWarehouseInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutWarehousesNestedInput = {
    create?: XOR<UserCreateWithoutWarehousesInput, UserUncheckedCreateWithoutWarehousesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarehousesInput
    upsert?: UserUpsertWithoutWarehousesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWarehousesInput, UserUpdateWithoutWarehousesInput>, UserUncheckedUpdateWithoutWarehousesInput>
  }

  export type ProductionDocUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ProductionDocCreateWithoutWarehouseInput, ProductionDocUncheckedCreateWithoutWarehouseInput> | ProductionDocCreateWithoutWarehouseInput[] | ProductionDocUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionDocCreateOrConnectWithoutWarehouseInput | ProductionDocCreateOrConnectWithoutWarehouseInput[]
    upsert?: ProductionDocUpsertWithWhereUniqueWithoutWarehouseInput | ProductionDocUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ProductionDocCreateManyWarehouseInputEnvelope
    set?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    disconnect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    delete?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    connect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    update?: ProductionDocUpdateWithWhereUniqueWithoutWarehouseInput | ProductionDocUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ProductionDocUpdateManyWithWhereWithoutWarehouseInput | ProductionDocUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ProductionDocScalarWhereInput | ProductionDocScalarWhereInput[]
  }

  export type ProductionInputUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ProductionInputCreateWithoutWarehouseInput, ProductionInputUncheckedCreateWithoutWarehouseInput> | ProductionInputCreateWithoutWarehouseInput[] | ProductionInputUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutWarehouseInput | ProductionInputCreateOrConnectWithoutWarehouseInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutWarehouseInput | ProductionInputUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ProductionInputCreateManyWarehouseInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutWarehouseInput | ProductionInputUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutWarehouseInput | ProductionInputUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type ProductionDocUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ProductionDocCreateWithoutWarehouseInput, ProductionDocUncheckedCreateWithoutWarehouseInput> | ProductionDocCreateWithoutWarehouseInput[] | ProductionDocUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionDocCreateOrConnectWithoutWarehouseInput | ProductionDocCreateOrConnectWithoutWarehouseInput[]
    upsert?: ProductionDocUpsertWithWhereUniqueWithoutWarehouseInput | ProductionDocUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ProductionDocCreateManyWarehouseInputEnvelope
    set?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    disconnect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    delete?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    connect?: ProductionDocWhereUniqueInput | ProductionDocWhereUniqueInput[]
    update?: ProductionDocUpdateWithWhereUniqueWithoutWarehouseInput | ProductionDocUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ProductionDocUpdateManyWithWhereWithoutWarehouseInput | ProductionDocUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ProductionDocScalarWhereInput | ProductionDocScalarWhereInput[]
  }

  export type ProductionInputUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ProductionInputCreateWithoutWarehouseInput, ProductionInputUncheckedCreateWithoutWarehouseInput> | ProductionInputCreateWithoutWarehouseInput[] | ProductionInputUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutWarehouseInput | ProductionInputCreateOrConnectWithoutWarehouseInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutWarehouseInput | ProductionInputUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ProductionInputCreateManyWarehouseInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutWarehouseInput | ProductionInputUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutWarehouseInput | ProductionInputUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type SvodLineCreateNestedManyWithoutSvodInput = {
    create?: XOR<SvodLineCreateWithoutSvodInput, SvodLineUncheckedCreateWithoutSvodInput> | SvodLineCreateWithoutSvodInput[] | SvodLineUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodLineCreateOrConnectWithoutSvodInput | SvodLineCreateOrConnectWithoutSvodInput[]
    createMany?: SvodLineCreateManySvodInputEnvelope
    connect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
  }

  export type SvodSupplierColCreateNestedManyWithoutSvodInput = {
    create?: XOR<SvodSupplierColCreateWithoutSvodInput, SvodSupplierColUncheckedCreateWithoutSvodInput> | SvodSupplierColCreateWithoutSvodInput[] | SvodSupplierColUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodSupplierColCreateOrConnectWithoutSvodInput | SvodSupplierColCreateOrConnectWithoutSvodInput[]
    createMany?: SvodSupplierColCreateManySvodInputEnvelope
    connect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
  }

  export type SvodSupplierValueCreateNestedManyWithoutSvodInput = {
    create?: XOR<SvodSupplierValueCreateWithoutSvodInput, SvodSupplierValueUncheckedCreateWithoutSvodInput> | SvodSupplierValueCreateWithoutSvodInput[] | SvodSupplierValueUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutSvodInput | SvodSupplierValueCreateOrConnectWithoutSvodInput[]
    createMany?: SvodSupplierValueCreateManySvodInputEnvelope
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
  }

  export type SvodLineUncheckedCreateNestedManyWithoutSvodInput = {
    create?: XOR<SvodLineCreateWithoutSvodInput, SvodLineUncheckedCreateWithoutSvodInput> | SvodLineCreateWithoutSvodInput[] | SvodLineUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodLineCreateOrConnectWithoutSvodInput | SvodLineCreateOrConnectWithoutSvodInput[]
    createMany?: SvodLineCreateManySvodInputEnvelope
    connect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
  }

  export type SvodSupplierColUncheckedCreateNestedManyWithoutSvodInput = {
    create?: XOR<SvodSupplierColCreateWithoutSvodInput, SvodSupplierColUncheckedCreateWithoutSvodInput> | SvodSupplierColCreateWithoutSvodInput[] | SvodSupplierColUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodSupplierColCreateOrConnectWithoutSvodInput | SvodSupplierColCreateOrConnectWithoutSvodInput[]
    createMany?: SvodSupplierColCreateManySvodInputEnvelope
    connect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
  }

  export type SvodSupplierValueUncheckedCreateNestedManyWithoutSvodInput = {
    create?: XOR<SvodSupplierValueCreateWithoutSvodInput, SvodSupplierValueUncheckedCreateWithoutSvodInput> | SvodSupplierValueCreateWithoutSvodInput[] | SvodSupplierValueUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutSvodInput | SvodSupplierValueCreateOrConnectWithoutSvodInput[]
    createMany?: SvodSupplierValueCreateManySvodInputEnvelope
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
  }

  export type SvodLineUpdateManyWithoutSvodNestedInput = {
    create?: XOR<SvodLineCreateWithoutSvodInput, SvodLineUncheckedCreateWithoutSvodInput> | SvodLineCreateWithoutSvodInput[] | SvodLineUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodLineCreateOrConnectWithoutSvodInput | SvodLineCreateOrConnectWithoutSvodInput[]
    upsert?: SvodLineUpsertWithWhereUniqueWithoutSvodInput | SvodLineUpsertWithWhereUniqueWithoutSvodInput[]
    createMany?: SvodLineCreateManySvodInputEnvelope
    set?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    disconnect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    delete?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    connect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    update?: SvodLineUpdateWithWhereUniqueWithoutSvodInput | SvodLineUpdateWithWhereUniqueWithoutSvodInput[]
    updateMany?: SvodLineUpdateManyWithWhereWithoutSvodInput | SvodLineUpdateManyWithWhereWithoutSvodInput[]
    deleteMany?: SvodLineScalarWhereInput | SvodLineScalarWhereInput[]
  }

  export type SvodSupplierColUpdateManyWithoutSvodNestedInput = {
    create?: XOR<SvodSupplierColCreateWithoutSvodInput, SvodSupplierColUncheckedCreateWithoutSvodInput> | SvodSupplierColCreateWithoutSvodInput[] | SvodSupplierColUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodSupplierColCreateOrConnectWithoutSvodInput | SvodSupplierColCreateOrConnectWithoutSvodInput[]
    upsert?: SvodSupplierColUpsertWithWhereUniqueWithoutSvodInput | SvodSupplierColUpsertWithWhereUniqueWithoutSvodInput[]
    createMany?: SvodSupplierColCreateManySvodInputEnvelope
    set?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    disconnect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    delete?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    connect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    update?: SvodSupplierColUpdateWithWhereUniqueWithoutSvodInput | SvodSupplierColUpdateWithWhereUniqueWithoutSvodInput[]
    updateMany?: SvodSupplierColUpdateManyWithWhereWithoutSvodInput | SvodSupplierColUpdateManyWithWhereWithoutSvodInput[]
    deleteMany?: SvodSupplierColScalarWhereInput | SvodSupplierColScalarWhereInput[]
  }

  export type SvodSupplierValueUpdateManyWithoutSvodNestedInput = {
    create?: XOR<SvodSupplierValueCreateWithoutSvodInput, SvodSupplierValueUncheckedCreateWithoutSvodInput> | SvodSupplierValueCreateWithoutSvodInput[] | SvodSupplierValueUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutSvodInput | SvodSupplierValueCreateOrConnectWithoutSvodInput[]
    upsert?: SvodSupplierValueUpsertWithWhereUniqueWithoutSvodInput | SvodSupplierValueUpsertWithWhereUniqueWithoutSvodInput[]
    createMany?: SvodSupplierValueCreateManySvodInputEnvelope
    set?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    disconnect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    delete?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    update?: SvodSupplierValueUpdateWithWhereUniqueWithoutSvodInput | SvodSupplierValueUpdateWithWhereUniqueWithoutSvodInput[]
    updateMany?: SvodSupplierValueUpdateManyWithWhereWithoutSvodInput | SvodSupplierValueUpdateManyWithWhereWithoutSvodInput[]
    deleteMany?: SvodSupplierValueScalarWhereInput | SvodSupplierValueScalarWhereInput[]
  }

  export type SvodLineUncheckedUpdateManyWithoutSvodNestedInput = {
    create?: XOR<SvodLineCreateWithoutSvodInput, SvodLineUncheckedCreateWithoutSvodInput> | SvodLineCreateWithoutSvodInput[] | SvodLineUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodLineCreateOrConnectWithoutSvodInput | SvodLineCreateOrConnectWithoutSvodInput[]
    upsert?: SvodLineUpsertWithWhereUniqueWithoutSvodInput | SvodLineUpsertWithWhereUniqueWithoutSvodInput[]
    createMany?: SvodLineCreateManySvodInputEnvelope
    set?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    disconnect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    delete?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    connect?: SvodLineWhereUniqueInput | SvodLineWhereUniqueInput[]
    update?: SvodLineUpdateWithWhereUniqueWithoutSvodInput | SvodLineUpdateWithWhereUniqueWithoutSvodInput[]
    updateMany?: SvodLineUpdateManyWithWhereWithoutSvodInput | SvodLineUpdateManyWithWhereWithoutSvodInput[]
    deleteMany?: SvodLineScalarWhereInput | SvodLineScalarWhereInput[]
  }

  export type SvodSupplierColUncheckedUpdateManyWithoutSvodNestedInput = {
    create?: XOR<SvodSupplierColCreateWithoutSvodInput, SvodSupplierColUncheckedCreateWithoutSvodInput> | SvodSupplierColCreateWithoutSvodInput[] | SvodSupplierColUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodSupplierColCreateOrConnectWithoutSvodInput | SvodSupplierColCreateOrConnectWithoutSvodInput[]
    upsert?: SvodSupplierColUpsertWithWhereUniqueWithoutSvodInput | SvodSupplierColUpsertWithWhereUniqueWithoutSvodInput[]
    createMany?: SvodSupplierColCreateManySvodInputEnvelope
    set?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    disconnect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    delete?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    connect?: SvodSupplierColWhereUniqueInput | SvodSupplierColWhereUniqueInput[]
    update?: SvodSupplierColUpdateWithWhereUniqueWithoutSvodInput | SvodSupplierColUpdateWithWhereUniqueWithoutSvodInput[]
    updateMany?: SvodSupplierColUpdateManyWithWhereWithoutSvodInput | SvodSupplierColUpdateManyWithWhereWithoutSvodInput[]
    deleteMany?: SvodSupplierColScalarWhereInput | SvodSupplierColScalarWhereInput[]
  }

  export type SvodSupplierValueUncheckedUpdateManyWithoutSvodNestedInput = {
    create?: XOR<SvodSupplierValueCreateWithoutSvodInput, SvodSupplierValueUncheckedCreateWithoutSvodInput> | SvodSupplierValueCreateWithoutSvodInput[] | SvodSupplierValueUncheckedCreateWithoutSvodInput[]
    connectOrCreate?: SvodSupplierValueCreateOrConnectWithoutSvodInput | SvodSupplierValueCreateOrConnectWithoutSvodInput[]
    upsert?: SvodSupplierValueUpsertWithWhereUniqueWithoutSvodInput | SvodSupplierValueUpsertWithWhereUniqueWithoutSvodInput[]
    createMany?: SvodSupplierValueCreateManySvodInputEnvelope
    set?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    disconnect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    delete?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    connect?: SvodSupplierValueWhereUniqueInput | SvodSupplierValueWhereUniqueInput[]
    update?: SvodSupplierValueUpdateWithWhereUniqueWithoutSvodInput | SvodSupplierValueUpdateWithWhereUniqueWithoutSvodInput[]
    updateMany?: SvodSupplierValueUpdateManyWithWhereWithoutSvodInput | SvodSupplierValueUpdateManyWithWhereWithoutSvodInput[]
    deleteMany?: SvodSupplierValueScalarWhereInput | SvodSupplierValueScalarWhereInput[]
  }

  export type SvodHeaderCreateNestedOneWithoutLinesInput = {
    create?: XOR<SvodHeaderCreateWithoutLinesInput, SvodHeaderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SvodHeaderCreateOrConnectWithoutLinesInput
    connect?: SvodHeaderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSvodLinesInput = {
    create?: XOR<ProductCreateWithoutSvodLinesInput, ProductUncheckedCreateWithoutSvodLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSvodLinesInput
    connect?: ProductWhereUniqueInput
  }

  export type SvodHeaderUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<SvodHeaderCreateWithoutLinesInput, SvodHeaderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SvodHeaderCreateOrConnectWithoutLinesInput
    upsert?: SvodHeaderUpsertWithoutLinesInput
    connect?: SvodHeaderWhereUniqueInput
    update?: XOR<XOR<SvodHeaderUpdateToOneWithWhereWithoutLinesInput, SvodHeaderUpdateWithoutLinesInput>, SvodHeaderUncheckedUpdateWithoutLinesInput>
  }

  export type ProductUpdateOneRequiredWithoutSvodLinesNestedInput = {
    create?: XOR<ProductCreateWithoutSvodLinesInput, ProductUncheckedCreateWithoutSvodLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSvodLinesInput
    upsert?: ProductUpsertWithoutSvodLinesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSvodLinesInput, ProductUpdateWithoutSvodLinesInput>, ProductUncheckedUpdateWithoutSvodLinesInput>
  }

  export type SvodHeaderCreateNestedOneWithoutSupplierColsInput = {
    create?: XOR<SvodHeaderCreateWithoutSupplierColsInput, SvodHeaderUncheckedCreateWithoutSupplierColsInput>
    connectOrCreate?: SvodHeaderCreateOrConnectWithoutSupplierColsInput
    connect?: SvodHeaderWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutSvodSupplierColsInput = {
    create?: XOR<SupplierCreateWithoutSvodSupplierColsInput, SupplierUncheckedCreateWithoutSvodSupplierColsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSvodSupplierColsInput
    connect?: SupplierWhereUniqueInput
  }

  export type SvodHeaderUpdateOneRequiredWithoutSupplierColsNestedInput = {
    create?: XOR<SvodHeaderCreateWithoutSupplierColsInput, SvodHeaderUncheckedCreateWithoutSupplierColsInput>
    connectOrCreate?: SvodHeaderCreateOrConnectWithoutSupplierColsInput
    upsert?: SvodHeaderUpsertWithoutSupplierColsInput
    connect?: SvodHeaderWhereUniqueInput
    update?: XOR<XOR<SvodHeaderUpdateToOneWithWhereWithoutSupplierColsInput, SvodHeaderUpdateWithoutSupplierColsInput>, SvodHeaderUncheckedUpdateWithoutSupplierColsInput>
  }

  export type SupplierUpdateOneRequiredWithoutSvodSupplierColsNestedInput = {
    create?: XOR<SupplierCreateWithoutSvodSupplierColsInput, SupplierUncheckedCreateWithoutSvodSupplierColsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSvodSupplierColsInput
    upsert?: SupplierUpsertWithoutSvodSupplierColsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutSvodSupplierColsInput, SupplierUpdateWithoutSvodSupplierColsInput>, SupplierUncheckedUpdateWithoutSvodSupplierColsInput>
  }

  export type SvodHeaderCreateNestedOneWithoutSupplierValuesInput = {
    create?: XOR<SvodHeaderCreateWithoutSupplierValuesInput, SvodHeaderUncheckedCreateWithoutSupplierValuesInput>
    connectOrCreate?: SvodHeaderCreateOrConnectWithoutSupplierValuesInput
    connect?: SvodHeaderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSvodSupplierValuesInput = {
    create?: XOR<ProductCreateWithoutSvodSupplierValuesInput, ProductUncheckedCreateWithoutSvodSupplierValuesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSvodSupplierValuesInput
    connect?: ProductWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutSvodSupplierValuesInput = {
    create?: XOR<SupplierCreateWithoutSvodSupplierValuesInput, SupplierUncheckedCreateWithoutSvodSupplierValuesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSvodSupplierValuesInput
    connect?: SupplierWhereUniqueInput
  }

  export type SvodHeaderUpdateOneRequiredWithoutSupplierValuesNestedInput = {
    create?: XOR<SvodHeaderCreateWithoutSupplierValuesInput, SvodHeaderUncheckedCreateWithoutSupplierValuesInput>
    connectOrCreate?: SvodHeaderCreateOrConnectWithoutSupplierValuesInput
    upsert?: SvodHeaderUpsertWithoutSupplierValuesInput
    connect?: SvodHeaderWhereUniqueInput
    update?: XOR<XOR<SvodHeaderUpdateToOneWithWhereWithoutSupplierValuesInput, SvodHeaderUpdateWithoutSupplierValuesInput>, SvodHeaderUncheckedUpdateWithoutSupplierValuesInput>
  }

  export type ProductUpdateOneRequiredWithoutSvodSupplierValuesNestedInput = {
    create?: XOR<ProductCreateWithoutSvodSupplierValuesInput, ProductUncheckedCreateWithoutSvodSupplierValuesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSvodSupplierValuesInput
    upsert?: ProductUpsertWithoutSvodSupplierValuesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSvodSupplierValuesInput, ProductUpdateWithoutSvodSupplierValuesInput>, ProductUncheckedUpdateWithoutSvodSupplierValuesInput>
  }

  export type SupplierUpdateOneRequiredWithoutSvodSupplierValuesNestedInput = {
    create?: XOR<SupplierCreateWithoutSvodSupplierValuesInput, SupplierUncheckedCreateWithoutSvodSupplierValuesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSvodSupplierValuesInput
    upsert?: SupplierUpsertWithoutSvodSupplierValuesInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutSvodSupplierValuesInput, SupplierUpdateWithoutSvodSupplierValuesInput>, SupplierUncheckedUpdateWithoutSvodSupplierValuesInput>
  }

  export type WarehouseCreateNestedOneWithoutProductionDocsInput = {
    create?: XOR<WarehouseCreateWithoutProductionDocsInput, WarehouseUncheckedCreateWithoutProductionDocsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutProductionDocsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductionDocsInput = {
    create?: XOR<UserCreateWithoutProductionDocsInput, UserUncheckedCreateWithoutProductionDocsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionDocsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionInputCreateNestedManyWithoutProductionDocInput = {
    create?: XOR<ProductionInputCreateWithoutProductionDocInput, ProductionInputUncheckedCreateWithoutProductionDocInput> | ProductionInputCreateWithoutProductionDocInput[] | ProductionInputUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutProductionDocInput | ProductionInputCreateOrConnectWithoutProductionDocInput[]
    createMany?: ProductionInputCreateManyProductionDocInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type ProductionOutputCreateNestedManyWithoutProductionDocInput = {
    create?: XOR<ProductionOutputCreateWithoutProductionDocInput, ProductionOutputUncheckedCreateWithoutProductionDocInput> | ProductionOutputCreateWithoutProductionDocInput[] | ProductionOutputUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionOutputCreateOrConnectWithoutProductionDocInput | ProductionOutputCreateOrConnectWithoutProductionDocInput[]
    createMany?: ProductionOutputCreateManyProductionDocInputEnvelope
    connect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
  }

  export type ProductionCuttingLineCreateNestedManyWithoutProductionDocInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutProductionDocInput, ProductionCuttingLineUncheckedCreateWithoutProductionDocInput> | ProductionCuttingLineCreateWithoutProductionDocInput[] | ProductionCuttingLineUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutProductionDocInput | ProductionCuttingLineCreateOrConnectWithoutProductionDocInput[]
    createMany?: ProductionCuttingLineCreateManyProductionDocInputEnvelope
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
  }

  export type ProductionInputUncheckedCreateNestedManyWithoutProductionDocInput = {
    create?: XOR<ProductionInputCreateWithoutProductionDocInput, ProductionInputUncheckedCreateWithoutProductionDocInput> | ProductionInputCreateWithoutProductionDocInput[] | ProductionInputUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutProductionDocInput | ProductionInputCreateOrConnectWithoutProductionDocInput[]
    createMany?: ProductionInputCreateManyProductionDocInputEnvelope
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
  }

  export type ProductionOutputUncheckedCreateNestedManyWithoutProductionDocInput = {
    create?: XOR<ProductionOutputCreateWithoutProductionDocInput, ProductionOutputUncheckedCreateWithoutProductionDocInput> | ProductionOutputCreateWithoutProductionDocInput[] | ProductionOutputUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionOutputCreateOrConnectWithoutProductionDocInput | ProductionOutputCreateOrConnectWithoutProductionDocInput[]
    createMany?: ProductionOutputCreateManyProductionDocInputEnvelope
    connect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
  }

  export type ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionDocInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutProductionDocInput, ProductionCuttingLineUncheckedCreateWithoutProductionDocInput> | ProductionCuttingLineCreateWithoutProductionDocInput[] | ProductionCuttingLineUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutProductionDocInput | ProductionCuttingLineCreateOrConnectWithoutProductionDocInput[]
    createMany?: ProductionCuttingLineCreateManyProductionDocInputEnvelope
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
  }

  export type WarehouseUpdateOneRequiredWithoutProductionDocsNestedInput = {
    create?: XOR<WarehouseCreateWithoutProductionDocsInput, WarehouseUncheckedCreateWithoutProductionDocsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutProductionDocsInput
    upsert?: WarehouseUpsertWithoutProductionDocsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutProductionDocsInput, WarehouseUpdateWithoutProductionDocsInput>, WarehouseUncheckedUpdateWithoutProductionDocsInput>
  }

  export type UserUpdateOneRequiredWithoutProductionDocsNestedInput = {
    create?: XOR<UserCreateWithoutProductionDocsInput, UserUncheckedCreateWithoutProductionDocsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionDocsInput
    upsert?: UserUpsertWithoutProductionDocsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductionDocsInput, UserUpdateWithoutProductionDocsInput>, UserUncheckedUpdateWithoutProductionDocsInput>
  }

  export type ProductionInputUpdateManyWithoutProductionDocNestedInput = {
    create?: XOR<ProductionInputCreateWithoutProductionDocInput, ProductionInputUncheckedCreateWithoutProductionDocInput> | ProductionInputCreateWithoutProductionDocInput[] | ProductionInputUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutProductionDocInput | ProductionInputCreateOrConnectWithoutProductionDocInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutProductionDocInput | ProductionInputUpsertWithWhereUniqueWithoutProductionDocInput[]
    createMany?: ProductionInputCreateManyProductionDocInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutProductionDocInput | ProductionInputUpdateWithWhereUniqueWithoutProductionDocInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutProductionDocInput | ProductionInputUpdateManyWithWhereWithoutProductionDocInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type ProductionOutputUpdateManyWithoutProductionDocNestedInput = {
    create?: XOR<ProductionOutputCreateWithoutProductionDocInput, ProductionOutputUncheckedCreateWithoutProductionDocInput> | ProductionOutputCreateWithoutProductionDocInput[] | ProductionOutputUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionOutputCreateOrConnectWithoutProductionDocInput | ProductionOutputCreateOrConnectWithoutProductionDocInput[]
    upsert?: ProductionOutputUpsertWithWhereUniqueWithoutProductionDocInput | ProductionOutputUpsertWithWhereUniqueWithoutProductionDocInput[]
    createMany?: ProductionOutputCreateManyProductionDocInputEnvelope
    set?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    disconnect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    delete?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    connect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    update?: ProductionOutputUpdateWithWhereUniqueWithoutProductionDocInput | ProductionOutputUpdateWithWhereUniqueWithoutProductionDocInput[]
    updateMany?: ProductionOutputUpdateManyWithWhereWithoutProductionDocInput | ProductionOutputUpdateManyWithWhereWithoutProductionDocInput[]
    deleteMany?: ProductionOutputScalarWhereInput | ProductionOutputScalarWhereInput[]
  }

  export type ProductionCuttingLineUpdateManyWithoutProductionDocNestedInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutProductionDocInput, ProductionCuttingLineUncheckedCreateWithoutProductionDocInput> | ProductionCuttingLineCreateWithoutProductionDocInput[] | ProductionCuttingLineUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutProductionDocInput | ProductionCuttingLineCreateOrConnectWithoutProductionDocInput[]
    upsert?: ProductionCuttingLineUpsertWithWhereUniqueWithoutProductionDocInput | ProductionCuttingLineUpsertWithWhereUniqueWithoutProductionDocInput[]
    createMany?: ProductionCuttingLineCreateManyProductionDocInputEnvelope
    set?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    disconnect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    delete?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    update?: ProductionCuttingLineUpdateWithWhereUniqueWithoutProductionDocInput | ProductionCuttingLineUpdateWithWhereUniqueWithoutProductionDocInput[]
    updateMany?: ProductionCuttingLineUpdateManyWithWhereWithoutProductionDocInput | ProductionCuttingLineUpdateManyWithWhereWithoutProductionDocInput[]
    deleteMany?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
  }

  export type ProductionInputUncheckedUpdateManyWithoutProductionDocNestedInput = {
    create?: XOR<ProductionInputCreateWithoutProductionDocInput, ProductionInputUncheckedCreateWithoutProductionDocInput> | ProductionInputCreateWithoutProductionDocInput[] | ProductionInputUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionInputCreateOrConnectWithoutProductionDocInput | ProductionInputCreateOrConnectWithoutProductionDocInput[]
    upsert?: ProductionInputUpsertWithWhereUniqueWithoutProductionDocInput | ProductionInputUpsertWithWhereUniqueWithoutProductionDocInput[]
    createMany?: ProductionInputCreateManyProductionDocInputEnvelope
    set?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    disconnect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    delete?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    connect?: ProductionInputWhereUniqueInput | ProductionInputWhereUniqueInput[]
    update?: ProductionInputUpdateWithWhereUniqueWithoutProductionDocInput | ProductionInputUpdateWithWhereUniqueWithoutProductionDocInput[]
    updateMany?: ProductionInputUpdateManyWithWhereWithoutProductionDocInput | ProductionInputUpdateManyWithWhereWithoutProductionDocInput[]
    deleteMany?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
  }

  export type ProductionOutputUncheckedUpdateManyWithoutProductionDocNestedInput = {
    create?: XOR<ProductionOutputCreateWithoutProductionDocInput, ProductionOutputUncheckedCreateWithoutProductionDocInput> | ProductionOutputCreateWithoutProductionDocInput[] | ProductionOutputUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionOutputCreateOrConnectWithoutProductionDocInput | ProductionOutputCreateOrConnectWithoutProductionDocInput[]
    upsert?: ProductionOutputUpsertWithWhereUniqueWithoutProductionDocInput | ProductionOutputUpsertWithWhereUniqueWithoutProductionDocInput[]
    createMany?: ProductionOutputCreateManyProductionDocInputEnvelope
    set?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    disconnect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    delete?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    connect?: ProductionOutputWhereUniqueInput | ProductionOutputWhereUniqueInput[]
    update?: ProductionOutputUpdateWithWhereUniqueWithoutProductionDocInput | ProductionOutputUpdateWithWhereUniqueWithoutProductionDocInput[]
    updateMany?: ProductionOutputUpdateManyWithWhereWithoutProductionDocInput | ProductionOutputUpdateManyWithWhereWithoutProductionDocInput[]
    deleteMany?: ProductionOutputScalarWhereInput | ProductionOutputScalarWhereInput[]
  }

  export type ProductionCuttingLineUncheckedUpdateManyWithoutProductionDocNestedInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutProductionDocInput, ProductionCuttingLineUncheckedCreateWithoutProductionDocInput> | ProductionCuttingLineCreateWithoutProductionDocInput[] | ProductionCuttingLineUncheckedCreateWithoutProductionDocInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutProductionDocInput | ProductionCuttingLineCreateOrConnectWithoutProductionDocInput[]
    upsert?: ProductionCuttingLineUpsertWithWhereUniqueWithoutProductionDocInput | ProductionCuttingLineUpsertWithWhereUniqueWithoutProductionDocInput[]
    createMany?: ProductionCuttingLineCreateManyProductionDocInputEnvelope
    set?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    disconnect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    delete?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    update?: ProductionCuttingLineUpdateWithWhereUniqueWithoutProductionDocInput | ProductionCuttingLineUpdateWithWhereUniqueWithoutProductionDocInput[]
    updateMany?: ProductionCuttingLineUpdateManyWithWhereWithoutProductionDocInput | ProductionCuttingLineUpdateManyWithWhereWithoutProductionDocInput[]
    deleteMany?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
  }

  export type ProductionDocCreateNestedOneWithoutInputsInput = {
    create?: XOR<ProductionDocCreateWithoutInputsInput, ProductionDocUncheckedCreateWithoutInputsInput>
    connectOrCreate?: ProductionDocCreateOrConnectWithoutInputsInput
    connect?: ProductionDocWhereUniqueInput
  }

  export type PurchaseCreateNestedOneWithoutProductionInputsInput = {
    create?: XOR<PurchaseCreateWithoutProductionInputsInput, PurchaseUncheckedCreateWithoutProductionInputsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductionInputsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type PurchaseItemCreateNestedOneWithoutProductionInputsInput = {
    create?: XOR<PurchaseItemCreateWithoutProductionInputsInput, PurchaseItemUncheckedCreateWithoutProductionInputsInput>
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductionInputsInput
    connect?: PurchaseItemWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProductionInputsInput = {
    create?: XOR<ProductCreateWithoutProductionInputsInput, ProductUncheckedCreateWithoutProductionInputsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionInputsInput
    connect?: ProductWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutProductionInputsInput = {
    create?: XOR<WarehouseCreateWithoutProductionInputsInput, WarehouseUncheckedCreateWithoutProductionInputsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutProductionInputsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductionInputsInput = {
    create?: XOR<UserCreateWithoutProductionInputsInput, UserUncheckedCreateWithoutProductionInputsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionInputsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionCuttingLineCreateNestedManyWithoutProductionInputInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutProductionInputInput, ProductionCuttingLineUncheckedCreateWithoutProductionInputInput> | ProductionCuttingLineCreateWithoutProductionInputInput[] | ProductionCuttingLineUncheckedCreateWithoutProductionInputInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutProductionInputInput | ProductionCuttingLineCreateOrConnectWithoutProductionInputInput[]
    createMany?: ProductionCuttingLineCreateManyProductionInputInputEnvelope
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
  }

  export type ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionInputInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutProductionInputInput, ProductionCuttingLineUncheckedCreateWithoutProductionInputInput> | ProductionCuttingLineCreateWithoutProductionInputInput[] | ProductionCuttingLineUncheckedCreateWithoutProductionInputInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutProductionInputInput | ProductionCuttingLineCreateOrConnectWithoutProductionInputInput[]
    createMany?: ProductionCuttingLineCreateManyProductionInputInputEnvelope
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
  }

  export type ProductionDocUpdateOneRequiredWithoutInputsNestedInput = {
    create?: XOR<ProductionDocCreateWithoutInputsInput, ProductionDocUncheckedCreateWithoutInputsInput>
    connectOrCreate?: ProductionDocCreateOrConnectWithoutInputsInput
    upsert?: ProductionDocUpsertWithoutInputsInput
    connect?: ProductionDocWhereUniqueInput
    update?: XOR<XOR<ProductionDocUpdateToOneWithWhereWithoutInputsInput, ProductionDocUpdateWithoutInputsInput>, ProductionDocUncheckedUpdateWithoutInputsInput>
  }

  export type PurchaseUpdateOneRequiredWithoutProductionInputsNestedInput = {
    create?: XOR<PurchaseCreateWithoutProductionInputsInput, PurchaseUncheckedCreateWithoutProductionInputsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductionInputsInput
    upsert?: PurchaseUpsertWithoutProductionInputsInput
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutProductionInputsInput, PurchaseUpdateWithoutProductionInputsInput>, PurchaseUncheckedUpdateWithoutProductionInputsInput>
  }

  export type PurchaseItemUpdateOneRequiredWithoutProductionInputsNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutProductionInputsInput, PurchaseItemUncheckedCreateWithoutProductionInputsInput>
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductionInputsInput
    upsert?: PurchaseItemUpsertWithoutProductionInputsInput
    connect?: PurchaseItemWhereUniqueInput
    update?: XOR<XOR<PurchaseItemUpdateToOneWithWhereWithoutProductionInputsInput, PurchaseItemUpdateWithoutProductionInputsInput>, PurchaseItemUncheckedUpdateWithoutProductionInputsInput>
  }

  export type ProductUpdateOneRequiredWithoutProductionInputsNestedInput = {
    create?: XOR<ProductCreateWithoutProductionInputsInput, ProductUncheckedCreateWithoutProductionInputsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionInputsInput
    upsert?: ProductUpsertWithoutProductionInputsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductionInputsInput, ProductUpdateWithoutProductionInputsInput>, ProductUncheckedUpdateWithoutProductionInputsInput>
  }

  export type WarehouseUpdateOneRequiredWithoutProductionInputsNestedInput = {
    create?: XOR<WarehouseCreateWithoutProductionInputsInput, WarehouseUncheckedCreateWithoutProductionInputsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutProductionInputsInput
    upsert?: WarehouseUpsertWithoutProductionInputsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutProductionInputsInput, WarehouseUpdateWithoutProductionInputsInput>, WarehouseUncheckedUpdateWithoutProductionInputsInput>
  }

  export type UserUpdateOneRequiredWithoutProductionInputsNestedInput = {
    create?: XOR<UserCreateWithoutProductionInputsInput, UserUncheckedCreateWithoutProductionInputsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionInputsInput
    upsert?: UserUpsertWithoutProductionInputsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductionInputsInput, UserUpdateWithoutProductionInputsInput>, UserUncheckedUpdateWithoutProductionInputsInput>
  }

  export type ProductionCuttingLineUpdateManyWithoutProductionInputNestedInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutProductionInputInput, ProductionCuttingLineUncheckedCreateWithoutProductionInputInput> | ProductionCuttingLineCreateWithoutProductionInputInput[] | ProductionCuttingLineUncheckedCreateWithoutProductionInputInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutProductionInputInput | ProductionCuttingLineCreateOrConnectWithoutProductionInputInput[]
    upsert?: ProductionCuttingLineUpsertWithWhereUniqueWithoutProductionInputInput | ProductionCuttingLineUpsertWithWhereUniqueWithoutProductionInputInput[]
    createMany?: ProductionCuttingLineCreateManyProductionInputInputEnvelope
    set?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    disconnect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    delete?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    update?: ProductionCuttingLineUpdateWithWhereUniqueWithoutProductionInputInput | ProductionCuttingLineUpdateWithWhereUniqueWithoutProductionInputInput[]
    updateMany?: ProductionCuttingLineUpdateManyWithWhereWithoutProductionInputInput | ProductionCuttingLineUpdateManyWithWhereWithoutProductionInputInput[]
    deleteMany?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
  }

  export type ProductionCuttingLineUncheckedUpdateManyWithoutProductionInputNestedInput = {
    create?: XOR<ProductionCuttingLineCreateWithoutProductionInputInput, ProductionCuttingLineUncheckedCreateWithoutProductionInputInput> | ProductionCuttingLineCreateWithoutProductionInputInput[] | ProductionCuttingLineUncheckedCreateWithoutProductionInputInput[]
    connectOrCreate?: ProductionCuttingLineCreateOrConnectWithoutProductionInputInput | ProductionCuttingLineCreateOrConnectWithoutProductionInputInput[]
    upsert?: ProductionCuttingLineUpsertWithWhereUniqueWithoutProductionInputInput | ProductionCuttingLineUpsertWithWhereUniqueWithoutProductionInputInput[]
    createMany?: ProductionCuttingLineCreateManyProductionInputInputEnvelope
    set?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    disconnect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    delete?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    connect?: ProductionCuttingLineWhereUniqueInput | ProductionCuttingLineWhereUniqueInput[]
    update?: ProductionCuttingLineUpdateWithWhereUniqueWithoutProductionInputInput | ProductionCuttingLineUpdateWithWhereUniqueWithoutProductionInputInput[]
    updateMany?: ProductionCuttingLineUpdateManyWithWhereWithoutProductionInputInput | ProductionCuttingLineUpdateManyWithWhereWithoutProductionInputInput[]
    deleteMany?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
  }

  export type ProductionDocCreateNestedOneWithoutOutputsInput = {
    create?: XOR<ProductionDocCreateWithoutOutputsInput, ProductionDocUncheckedCreateWithoutOutputsInput>
    connectOrCreate?: ProductionDocCreateOrConnectWithoutOutputsInput
    connect?: ProductionDocWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProductionOutputsInput = {
    create?: XOR<ProductCreateWithoutProductionOutputsInput, ProductUncheckedCreateWithoutProductionOutputsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionOutputsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductionDocUpdateOneRequiredWithoutOutputsNestedInput = {
    create?: XOR<ProductionDocCreateWithoutOutputsInput, ProductionDocUncheckedCreateWithoutOutputsInput>
    connectOrCreate?: ProductionDocCreateOrConnectWithoutOutputsInput
    upsert?: ProductionDocUpsertWithoutOutputsInput
    connect?: ProductionDocWhereUniqueInput
    update?: XOR<XOR<ProductionDocUpdateToOneWithWhereWithoutOutputsInput, ProductionDocUpdateWithoutOutputsInput>, ProductionDocUncheckedUpdateWithoutOutputsInput>
  }

  export type ProductUpdateOneRequiredWithoutProductionOutputsNestedInput = {
    create?: XOR<ProductCreateWithoutProductionOutputsInput, ProductUncheckedCreateWithoutProductionOutputsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductionOutputsInput
    upsert?: ProductUpsertWithoutProductionOutputsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductionOutputsInput, ProductUpdateWithoutProductionOutputsInput>, ProductUncheckedUpdateWithoutProductionOutputsInput>
  }

  export type ProductionDocCreateNestedOneWithoutCuttingLinesInput = {
    create?: XOR<ProductionDocCreateWithoutCuttingLinesInput, ProductionDocUncheckedCreateWithoutCuttingLinesInput>
    connectOrCreate?: ProductionDocCreateOrConnectWithoutCuttingLinesInput
    connect?: ProductionDocWhereUniqueInput
  }

  export type ProductionInputCreateNestedOneWithoutCuttingLinesInput = {
    create?: XOR<ProductionInputCreateWithoutCuttingLinesInput, ProductionInputUncheckedCreateWithoutCuttingLinesInput>
    connectOrCreate?: ProductionInputCreateOrConnectWithoutCuttingLinesInput
    connect?: ProductionInputWhereUniqueInput
  }

  export type ProductionMmlCreateNestedOneWithoutCuttingLinesInput = {
    create?: XOR<ProductionMmlCreateWithoutCuttingLinesInput, ProductionMmlUncheckedCreateWithoutCuttingLinesInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutCuttingLinesInput
    connect?: ProductionMmlWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCuttingLineOutputsInput = {
    create?: XOR<ProductCreateWithoutCuttingLineOutputsInput, ProductUncheckedCreateWithoutCuttingLineOutputsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCuttingLineOutputsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCuttingLinesInput = {
    create?: XOR<UserCreateWithoutCuttingLinesInput, UserUncheckedCreateWithoutCuttingLinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCuttingLinesInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionDocUpdateOneRequiredWithoutCuttingLinesNestedInput = {
    create?: XOR<ProductionDocCreateWithoutCuttingLinesInput, ProductionDocUncheckedCreateWithoutCuttingLinesInput>
    connectOrCreate?: ProductionDocCreateOrConnectWithoutCuttingLinesInput
    upsert?: ProductionDocUpsertWithoutCuttingLinesInput
    connect?: ProductionDocWhereUniqueInput
    update?: XOR<XOR<ProductionDocUpdateToOneWithWhereWithoutCuttingLinesInput, ProductionDocUpdateWithoutCuttingLinesInput>, ProductionDocUncheckedUpdateWithoutCuttingLinesInput>
  }

  export type ProductionInputUpdateOneRequiredWithoutCuttingLinesNestedInput = {
    create?: XOR<ProductionInputCreateWithoutCuttingLinesInput, ProductionInputUncheckedCreateWithoutCuttingLinesInput>
    connectOrCreate?: ProductionInputCreateOrConnectWithoutCuttingLinesInput
    upsert?: ProductionInputUpsertWithoutCuttingLinesInput
    connect?: ProductionInputWhereUniqueInput
    update?: XOR<XOR<ProductionInputUpdateToOneWithWhereWithoutCuttingLinesInput, ProductionInputUpdateWithoutCuttingLinesInput>, ProductionInputUncheckedUpdateWithoutCuttingLinesInput>
  }

  export type ProductionMmlUpdateOneRequiredWithoutCuttingLinesNestedInput = {
    create?: XOR<ProductionMmlCreateWithoutCuttingLinesInput, ProductionMmlUncheckedCreateWithoutCuttingLinesInput>
    connectOrCreate?: ProductionMmlCreateOrConnectWithoutCuttingLinesInput
    upsert?: ProductionMmlUpsertWithoutCuttingLinesInput
    connect?: ProductionMmlWhereUniqueInput
    update?: XOR<XOR<ProductionMmlUpdateToOneWithWhereWithoutCuttingLinesInput, ProductionMmlUpdateWithoutCuttingLinesInput>, ProductionMmlUncheckedUpdateWithoutCuttingLinesInput>
  }

  export type ProductUpdateOneRequiredWithoutCuttingLineOutputsNestedInput = {
    create?: XOR<ProductCreateWithoutCuttingLineOutputsInput, ProductUncheckedCreateWithoutCuttingLineOutputsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCuttingLineOutputsInput
    upsert?: ProductUpsertWithoutCuttingLineOutputsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCuttingLineOutputsInput, ProductUpdateWithoutCuttingLineOutputsInput>, ProductUncheckedUpdateWithoutCuttingLineOutputsInput>
  }

  export type UserUpdateOneRequiredWithoutCuttingLinesNestedInput = {
    create?: XOR<UserCreateWithoutCuttingLinesInput, UserUncheckedCreateWithoutCuttingLinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCuttingLinesInput
    upsert?: UserUpsertWithoutCuttingLinesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCuttingLinesInput, UserUpdateWithoutCuttingLinesInput>, UserUncheckedUpdateWithoutCuttingLinesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProductionStaffCreateWithoutUserInput = {
    fullName: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journals?: ProductionJournalCreateNestedManyWithoutStaffInput
  }

  export type ProductionStaffUncheckedCreateWithoutUserInput = {
    id?: number
    fullName: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journals?: ProductionJournalUncheckedCreateNestedManyWithoutStaffInput
  }

  export type ProductionStaffCreateOrConnectWithoutUserInput = {
    where: ProductionStaffWhereUniqueInput
    create: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
  }

  export type ProductionMmlCreateWithoutCreatorInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutCreatorInput = {
    id?: number
    productId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutCreatorInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput>
  }

  export type ProductionMmlCreateManyCreatorInputEnvelope = {
    data: ProductionMmlCreateManyCreatorInput | ProductionMmlCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProductionRunCreateWithoutUserInput = {
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionRunsInput
    mml: ProductionMmlCreateNestedOneWithoutRunsInput
    values?: ProductionRunValueCreateNestedManyWithoutRunInput
  }

  export type ProductionRunUncheckedCreateWithoutUserInput = {
    id?: number
    productId: number
    mmlId: number
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: ProductionRunValueUncheckedCreateNestedManyWithoutRunInput
  }

  export type ProductionRunCreateOrConnectWithoutUserInput = {
    where: ProductionRunWhereUniqueInput
    create: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput>
  }

  export type ProductionRunCreateManyUserInputEnvelope = {
    data: ProductionRunCreateManyUserInput | ProductionRunCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutCreatedByUserInput = {
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: PurchaseSupplierCreateNestedManyWithoutPurchaseInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
    productionInputs?: ProductionInputCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutCreatedByUserInput = {
    id?: number
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: PurchaseSupplierUncheckedCreateNestedManyWithoutPurchaseInput
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutCreatedByUserInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutCreatedByUserInput, PurchaseUncheckedCreateWithoutCreatedByUserInput>
  }

  export type PurchaseCreateManyCreatedByUserInputEnvelope = {
    data: PurchaseCreateManyCreatedByUserInput | PurchaseCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseCreateWithoutResponsibleUserInput = {
    code: string
    name: string
    address: string
    phone?: string | null
    comment?: string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productionDocs?: ProductionDocCreateNestedManyWithoutWarehouseInput
    productionInputs?: ProductionInputCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutResponsibleUserInput = {
    id?: number
    code: string
    name: string
    address: string
    phone?: string | null
    comment?: string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productionDocs?: ProductionDocUncheckedCreateNestedManyWithoutWarehouseInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutResponsibleUserInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutResponsibleUserInput, WarehouseUncheckedCreateWithoutResponsibleUserInput>
  }

  export type WarehouseCreateManyResponsibleUserInputEnvelope = {
    data: WarehouseCreateManyResponsibleUserInput | WarehouseCreateManyResponsibleUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductionDocCreateWithoutCreatedByInput = {
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutProductionDocsInput
    inputs?: ProductionInputCreateNestedManyWithoutProductionDocInput
    outputs?: ProductionOutputCreateNestedManyWithoutProductionDocInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocUncheckedCreateWithoutCreatedByInput = {
    id?: number
    date: Date | string
    warehouseId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: ProductionInputUncheckedCreateNestedManyWithoutProductionDocInput
    outputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductionDocInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocCreateOrConnectWithoutCreatedByInput = {
    where: ProductionDocWhereUniqueInput
    create: XOR<ProductionDocCreateWithoutCreatedByInput, ProductionDocUncheckedCreateWithoutCreatedByInput>
  }

  export type ProductionDocCreateManyCreatedByInputEnvelope = {
    data: ProductionDocCreateManyCreatedByInput | ProductionDocCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ProductionInputCreateWithoutLoadedByInput = {
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutInputsInput
    purchase: PurchaseCreateNestedOneWithoutProductionInputsInput
    purchaseItem: PurchaseItemCreateNestedOneWithoutProductionInputsInput
    product: ProductCreateNestedOneWithoutProductionInputsInput
    warehouse: WarehouseCreateNestedOneWithoutProductionInputsInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputUncheckedCreateWithoutLoadedByInput = {
    id?: number
    productionDocId: number
    purchaseId: number
    purchaseItemId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputCreateOrConnectWithoutLoadedByInput = {
    where: ProductionInputWhereUniqueInput
    create: XOR<ProductionInputCreateWithoutLoadedByInput, ProductionInputUncheckedCreateWithoutLoadedByInput>
  }

  export type ProductionInputCreateManyLoadedByInputEnvelope = {
    data: ProductionInputCreateManyLoadedByInput | ProductionInputCreateManyLoadedByInput[]
    skipDuplicates?: boolean
  }

  export type ProductionCuttingLineCreateWithoutCreatedByInput = {
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutCuttingLinesInput
    productionInput: ProductionInputCreateNestedOneWithoutCuttingLinesInput
    mml: ProductionMmlCreateNestedOneWithoutCuttingLinesInput
    outProduct: ProductCreateNestedOneWithoutCuttingLineOutputsInput
  }

  export type ProductionCuttingLineUncheckedCreateWithoutCreatedByInput = {
    id?: number
    productionDocId: number
    productionInputId: number
    mmlId: number
    outProductId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ProductionCuttingLineCreateOrConnectWithoutCreatedByInput = {
    where: ProductionCuttingLineWhereUniqueInput
    create: XOR<ProductionCuttingLineCreateWithoutCreatedByInput, ProductionCuttingLineUncheckedCreateWithoutCreatedByInput>
  }

  export type ProductionCuttingLineCreateManyCreatedByInputEnvelope = {
    data: ProductionCuttingLineCreateManyCreatedByInput | ProductionCuttingLineCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ProductionStaffUpsertWithoutUserInput = {
    update: XOR<ProductionStaffUpdateWithoutUserInput, ProductionStaffUncheckedUpdateWithoutUserInput>
    create: XOR<ProductionStaffCreateWithoutUserInput, ProductionStaffUncheckedCreateWithoutUserInput>
    where?: ProductionStaffWhereInput
  }

  export type ProductionStaffUpdateToOneWithWhereWithoutUserInput = {
    where?: ProductionStaffWhereInput
    data: XOR<ProductionStaffUpdateWithoutUserInput, ProductionStaffUncheckedUpdateWithoutUserInput>
  }

  export type ProductionStaffUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: ProductionJournalUpdateManyWithoutStaffNestedInput
  }

  export type ProductionStaffUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: ProductionJournalUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type ProductionMmlUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProductionMmlWhereUniqueInput
    update: XOR<ProductionMmlUpdateWithoutCreatorInput, ProductionMmlUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProductionMmlCreateWithoutCreatorInput, ProductionMmlUncheckedCreateWithoutCreatorInput>
  }

  export type ProductionMmlUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProductionMmlWhereUniqueInput
    data: XOR<ProductionMmlUpdateWithoutCreatorInput, ProductionMmlUncheckedUpdateWithoutCreatorInput>
  }

  export type ProductionMmlUpdateManyWithWhereWithoutCreatorInput = {
    where: ProductionMmlScalarWhereInput
    data: XOR<ProductionMmlUpdateManyMutationInput, ProductionMmlUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProductionMmlScalarWhereInput = {
    AND?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
    OR?: ProductionMmlScalarWhereInput[]
    NOT?: ProductionMmlScalarWhereInput | ProductionMmlScalarWhereInput[]
    id?: IntFilter<"ProductionMml"> | number
    productId?: IntFilter<"ProductionMml"> | number
    createdBy?: IntFilter<"ProductionMml"> | number
    isLocked?: BoolFilter<"ProductionMml"> | boolean
    createdAt?: DateTimeFilter<"ProductionMml"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMml"> | Date | string
  }

  export type ProductionRunUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductionRunWhereUniqueInput
    update: XOR<ProductionRunUpdateWithoutUserInput, ProductionRunUncheckedUpdateWithoutUserInput>
    create: XOR<ProductionRunCreateWithoutUserInput, ProductionRunUncheckedCreateWithoutUserInput>
  }

  export type ProductionRunUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductionRunWhereUniqueInput
    data: XOR<ProductionRunUpdateWithoutUserInput, ProductionRunUncheckedUpdateWithoutUserInput>
  }

  export type ProductionRunUpdateManyWithWhereWithoutUserInput = {
    where: ProductionRunScalarWhereInput
    data: XOR<ProductionRunUpdateManyMutationInput, ProductionRunUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductionRunScalarWhereInput = {
    AND?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
    OR?: ProductionRunScalarWhereInput[]
    NOT?: ProductionRunScalarWhereInput | ProductionRunScalarWhereInput[]
    id?: IntFilter<"ProductionRun"> | number
    productId?: IntFilter<"ProductionRun"> | number
    mmlId?: IntFilter<"ProductionRun"> | number
    userId?: IntFilter<"ProductionRun"> | number
    productionDate?: DateTimeFilter<"ProductionRun"> | Date | string
    plannedWeight?: DecimalNullableFilter<"ProductionRun"> | Decimal | DecimalJsLike | number | string | null
    actualWeight?: DecimalNullableFilter<"ProductionRun"> | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFilter<"ProductionRun"> | boolean
    isHidden?: BoolFilter<"ProductionRun"> | boolean
    createdAt?: DateTimeFilter<"ProductionRun"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRun"> | Date | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutCreatedByUserInput, PurchaseUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<PurchaseCreateWithoutCreatedByUserInput, PurchaseUncheckedCreateWithoutCreatedByUserInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutCreatedByUserInput, PurchaseUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: IntFilter<"Purchase"> | number
    purchaseDate?: DateTimeFilter<"Purchase"> | Date | string
    totalAmount?: DecimalNullableFilter<"Purchase"> | Decimal | DecimalJsLike | number | string | null
    createdByUserId?: IntFilter<"Purchase"> | number
    isDisabled?: BoolFilter<"Purchase"> | boolean
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type WarehouseUpsertWithWhereUniqueWithoutResponsibleUserInput = {
    where: WarehouseWhereUniqueInput
    update: XOR<WarehouseUpdateWithoutResponsibleUserInput, WarehouseUncheckedUpdateWithoutResponsibleUserInput>
    create: XOR<WarehouseCreateWithoutResponsibleUserInput, WarehouseUncheckedCreateWithoutResponsibleUserInput>
  }

  export type WarehouseUpdateWithWhereUniqueWithoutResponsibleUserInput = {
    where: WarehouseWhereUniqueInput
    data: XOR<WarehouseUpdateWithoutResponsibleUserInput, WarehouseUncheckedUpdateWithoutResponsibleUserInput>
  }

  export type WarehouseUpdateManyWithWhereWithoutResponsibleUserInput = {
    where: WarehouseScalarWhereInput
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyWithoutResponsibleUserInput>
  }

  export type WarehouseScalarWhereInput = {
    AND?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
    OR?: WarehouseScalarWhereInput[]
    NOT?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
    id?: IntFilter<"Warehouse"> | number
    code?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    address?: StringFilter<"Warehouse"> | string
    phone?: StringNullableFilter<"Warehouse"> | string | null
    responsibleUserId?: IntNullableFilter<"Warehouse"> | number | null
    comment?: StringNullableFilter<"Warehouse"> | string | null
    isDisabled?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
  }

  export type ProductionDocUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ProductionDocWhereUniqueInput
    update: XOR<ProductionDocUpdateWithoutCreatedByInput, ProductionDocUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ProductionDocCreateWithoutCreatedByInput, ProductionDocUncheckedCreateWithoutCreatedByInput>
  }

  export type ProductionDocUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ProductionDocWhereUniqueInput
    data: XOR<ProductionDocUpdateWithoutCreatedByInput, ProductionDocUncheckedUpdateWithoutCreatedByInput>
  }

  export type ProductionDocUpdateManyWithWhereWithoutCreatedByInput = {
    where: ProductionDocScalarWhereInput
    data: XOR<ProductionDocUpdateManyMutationInput, ProductionDocUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ProductionDocScalarWhereInput = {
    AND?: ProductionDocScalarWhereInput | ProductionDocScalarWhereInput[]
    OR?: ProductionDocScalarWhereInput[]
    NOT?: ProductionDocScalarWhereInput | ProductionDocScalarWhereInput[]
    id?: IntFilter<"ProductionDoc"> | number
    date?: DateTimeFilter<"ProductionDoc"> | Date | string
    warehouseId?: IntFilter<"ProductionDoc"> | number
    status?: StringFilter<"ProductionDoc"> | string
    createdByUserId?: IntFilter<"ProductionDoc"> | number
    createdAt?: DateTimeFilter<"ProductionDoc"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionDoc"> | Date | string
  }

  export type ProductionInputUpsertWithWhereUniqueWithoutLoadedByInput = {
    where: ProductionInputWhereUniqueInput
    update: XOR<ProductionInputUpdateWithoutLoadedByInput, ProductionInputUncheckedUpdateWithoutLoadedByInput>
    create: XOR<ProductionInputCreateWithoutLoadedByInput, ProductionInputUncheckedCreateWithoutLoadedByInput>
  }

  export type ProductionInputUpdateWithWhereUniqueWithoutLoadedByInput = {
    where: ProductionInputWhereUniqueInput
    data: XOR<ProductionInputUpdateWithoutLoadedByInput, ProductionInputUncheckedUpdateWithoutLoadedByInput>
  }

  export type ProductionInputUpdateManyWithWhereWithoutLoadedByInput = {
    where: ProductionInputScalarWhereInput
    data: XOR<ProductionInputUpdateManyMutationInput, ProductionInputUncheckedUpdateManyWithoutLoadedByInput>
  }

  export type ProductionInputScalarWhereInput = {
    AND?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
    OR?: ProductionInputScalarWhereInput[]
    NOT?: ProductionInputScalarWhereInput | ProductionInputScalarWhereInput[]
    id?: IntFilter<"ProductionInput"> | number
    productionDocId?: IntFilter<"ProductionInput"> | number
    purchaseId?: IntFilter<"ProductionInput"> | number
    purchaseItemId?: IntFilter<"ProductionInput"> | number
    productId?: IntFilter<"ProductionInput"> | number
    warehouseId?: IntFilter<"ProductionInput"> | number
    qtyIn?: DecimalFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string
    priceIn?: DecimalNullableFilter<"ProductionInput"> | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFilter<"ProductionInput"> | Date | string
    loadedByUserId?: IntFilter<"ProductionInput"> | number
  }

  export type ProductionCuttingLineUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ProductionCuttingLineWhereUniqueInput
    update: XOR<ProductionCuttingLineUpdateWithoutCreatedByInput, ProductionCuttingLineUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ProductionCuttingLineCreateWithoutCreatedByInput, ProductionCuttingLineUncheckedCreateWithoutCreatedByInput>
  }

  export type ProductionCuttingLineUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ProductionCuttingLineWhereUniqueInput
    data: XOR<ProductionCuttingLineUpdateWithoutCreatedByInput, ProductionCuttingLineUncheckedUpdateWithoutCreatedByInput>
  }

  export type ProductionCuttingLineUpdateManyWithWhereWithoutCreatedByInput = {
    where: ProductionCuttingLineScalarWhereInput
    data: XOR<ProductionCuttingLineUpdateManyMutationInput, ProductionCuttingLineUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ProductionCuttingLineScalarWhereInput = {
    AND?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
    OR?: ProductionCuttingLineScalarWhereInput[]
    NOT?: ProductionCuttingLineScalarWhereInput | ProductionCuttingLineScalarWhereInput[]
    id?: IntFilter<"ProductionCuttingLine"> | number
    productionDocId?: IntFilter<"ProductionCuttingLine"> | number
    productionInputId?: IntFilter<"ProductionCuttingLine"> | number
    mmlId?: IntFilter<"ProductionCuttingLine"> | number
    outProductId?: IntFilter<"ProductionCuttingLine"> | number
    qtyOut?: DecimalFilter<"ProductionCuttingLine"> | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFilter<"ProductionCuttingLine"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ProductionCuttingLine"> | Date | string
    createdByUserId?: IntFilter<"ProductionCuttingLine"> | number
  }

  export type CustomerCreateWithoutDistrictInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: ManagerCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutDistrictInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutDistrictInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput>
  }

  export type CustomerCreateManyDistrictInputEnvelope = {
    data: CustomerCreateManyDistrictInput | CustomerCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithWhereUniqueWithoutDistrictInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutDistrictInput, CustomerUncheckedUpdateWithoutDistrictInput>
    create: XOR<CustomerCreateWithoutDistrictInput, CustomerUncheckedCreateWithoutDistrictInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutDistrictInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutDistrictInput, CustomerUncheckedUpdateWithoutDistrictInput>
  }

  export type CustomerUpdateManyWithWhereWithoutDistrictInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutDistrictInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: IntFilter<"Customer"> | number
    code?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    legalName?: StringNullableFilter<"Customer"> | string | null
    districtId?: StringNullableFilter<"Customer"> | string | null
    managerId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type CustomerCreateWithoutManagerInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: DistrictCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutManagerInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutManagerInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput>
  }

  export type CustomerCreateManyManagerInputEnvelope = {
    data: CustomerCreateManyManagerInput | CustomerCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithWhereUniqueWithoutManagerInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutManagerInput, CustomerUncheckedUpdateWithoutManagerInput>
    create: XOR<CustomerCreateWithoutManagerInput, CustomerUncheckedCreateWithoutManagerInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutManagerInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutManagerInput, CustomerUncheckedUpdateWithoutManagerInput>
  }

  export type CustomerUpdateManyWithWhereWithoutManagerInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutManagerInput>
  }

  export type OrderItemCreateWithoutProductInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: number
    orderId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockCreateWithoutProductInput = {
    quantity?: number
    updatedAt?: Date | string
  }

  export type StockUncheckedCreateWithoutProductInput = {
    quantity?: number
    updatedAt?: Date | string
  }

  export type StockCreateOrConnectWithoutProductInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
  }

  export type StockTransactionCreateWithoutProductInput = {
    type: string
    quantity: number
    note?: string | null
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutStockTransactionsInput
  }

  export type StockTransactionUncheckedCreateWithoutProductInput = {
    id?: number
    type: string
    quantity: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type StockTransactionCreateOrConnectWithoutProductInput = {
    where: StockTransactionWhereUniqueInput
    create: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput>
  }

  export type StockTransactionCreateManyProductInputEnvelope = {
    data: StockTransactionCreateManyProductInput | StockTransactionCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SupplierProductCreateWithoutProductInput = {
    supplier: SupplierCreateNestedOneWithoutProductsInput
  }

  export type SupplierProductUncheckedCreateWithoutProductInput = {
    supplierId: number
  }

  export type SupplierProductCreateOrConnectWithoutProductInput = {
    where: SupplierProductWhereUniqueInput
    create: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput>
  }

  export type SupplierProductCreateManyProductInputEnvelope = {
    data: SupplierProductCreateManyProductInput | SupplierProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SummaryOrderJournalCreateWithoutProductInput = {
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerName: string
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    preAssemblyStatus?: string | null
    assemblyStartedAt?: Date | string | null
    assemblyStartedBy?: string | null
    assemblyReturnedAt?: Date | string | null
    assemblyReturnedBy?: string | null
    assemblyReturnReason?: string | null
    assemblyReturnComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutSummaryJournalEntriesInput
    events?: SummaryOrderEventCreateNestedManyWithoutSummaryOrderInput
  }

  export type SummaryOrderJournalUncheckedCreateWithoutProductInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerId?: number | null
    customerName: string
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    preAssemblyStatus?: string | null
    assemblyStartedAt?: Date | string | null
    assemblyStartedBy?: string | null
    assemblyReturnedAt?: Date | string | null
    assemblyReturnedBy?: string | null
    assemblyReturnReason?: string | null
    assemblyReturnComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: SummaryOrderEventUncheckedCreateNestedManyWithoutSummaryOrderInput
  }

  export type SummaryOrderJournalCreateOrConnectWithoutProductInput = {
    where: SummaryOrderJournalWhereUniqueInput
    create: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput>
  }

  export type SummaryOrderJournalCreateManyProductInputEnvelope = {
    data: SummaryOrderJournalCreateManyProductInput | SummaryOrderJournalCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionItemCreateWithoutProductInput = {
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    journal: ProductionJournalCreateNestedOneWithoutItemsInput
    values?: ProductionItemValueCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemUncheckedCreateWithoutProductInput = {
    id?: number
    journalId: number
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    values?: ProductionItemValueUncheckedCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemCreateOrConnectWithoutProductInput = {
    where: ProductionItemWhereUniqueInput
    create: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput>
  }

  export type ProductionItemCreateManyProductInputEnvelope = {
    data: ProductionItemCreateManyProductInput | ProductionItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceItemCreateWithoutProductInput = {
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutItemsInput
    supplier: SupplierCreateNestedOneWithoutPurchasePriceItemsInput
  }

  export type PurchasePriceItemUncheckedCreateWithoutProductInput = {
    id?: number
    priceListId: number
    supplierId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceItemCreateOrConnectWithoutProductInput = {
    where: PurchasePriceItemWhereUniqueInput
    create: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput>
  }

  export type PurchasePriceItemCreateManyProductInputEnvelope = {
    data: PurchasePriceItemCreateManyProductInput | PurchasePriceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SalesPriceItemCreateWithoutProductInput = {
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    priceList: SalesPriceListCreateNestedOneWithoutItemsInput
  }

  export type SalesPriceItemUncheckedCreateWithoutProductInput = {
    id?: number
    priceListId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SalesPriceItemCreateOrConnectWithoutProductInput = {
    where: SalesPriceItemWhereUniqueInput
    create: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput>
  }

  export type SalesPriceItemCreateManyProductInputEnvelope = {
    data: SalesPriceItemCreateManyProductInput | SalesPriceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionMmlCreateWithoutProductInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutProductInput = {
    id?: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutProductInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput>
  }

  export type ProductionMmlCreateManyProductInputEnvelope = {
    data: ProductionMmlCreateManyProductInput | ProductionMmlCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionMmlNodeCreateWithoutProductInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutNodesInput
    parentNode?: ProductionMmlNodeCreateNestedOneWithoutChildrenInput
    children?: ProductionMmlNodeCreateNestedManyWithoutParentNodeInput
    runValues?: ProductionRunValueCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUncheckedCreateWithoutProductInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput
    runValues?: ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeCreateOrConnectWithoutProductInput = {
    where: ProductionMmlNodeWhereUniqueInput
    create: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput>
  }

  export type ProductionMmlNodeCreateManyProductInputEnvelope = {
    data: ProductionMmlNodeCreateManyProductInput | ProductionMmlNodeCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionRunCreateWithoutProductInput = {
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutRunsInput
    user: UserCreateNestedOneWithoutProductionRunsInput
    values?: ProductionRunValueCreateNestedManyWithoutRunInput
  }

  export type ProductionRunUncheckedCreateWithoutProductInput = {
    id?: number
    mmlId: number
    userId: number
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: ProductionRunValueUncheckedCreateNestedManyWithoutRunInput
  }

  export type ProductionRunCreateOrConnectWithoutProductInput = {
    where: ProductionRunWhereUniqueInput
    create: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput>
  }

  export type ProductionRunCreateManyProductInputEnvelope = {
    data: ProductionRunCreateManyProductInput | ProductionRunCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionRunValueCreateWithoutSnapshotProductInput = {
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    run: ProductionRunCreateNestedOneWithoutValuesInput
    node: ProductionMmlNodeCreateNestedOneWithoutRunValuesInput
  }

  export type ProductionRunValueUncheckedCreateWithoutSnapshotProductInput = {
    id?: number
    productionRunId: number
    mmlNodeId: number
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueCreateOrConnectWithoutSnapshotProductInput = {
    where: ProductionRunValueWhereUniqueInput
    create: XOR<ProductionRunValueCreateWithoutSnapshotProductInput, ProductionRunValueUncheckedCreateWithoutSnapshotProductInput>
  }

  export type ProductionRunValueCreateManySnapshotProductInputEnvelope = {
    data: ProductionRunValueCreateManySnapshotProductInput | ProductionRunValueCreateManySnapshotProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseItemCreateWithoutProductInput = {
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    supplier: SupplierCreateNestedOneWithoutPurchaseItemsInput
    paymentType?: PaymentTypeCreateNestedOneWithoutPurchaseItemsInput
    productionInputs?: ProductionInputCreateNestedManyWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateWithoutProductInput = {
    id?: number
    purchaseId: number
    supplierId: number
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    paymentTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutPurchaseItemInput
  }

  export type PurchaseItemCreateOrConnectWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemCreateManyProductInputEnvelope = {
    data: PurchaseItemCreateManyProductInput | PurchaseItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SvodLineCreateWithoutProductInput = {
    shortName?: string | null
    category?: string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    orderQty?: Decimal | DecimalJsLike | number | string
    productionInQty?: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string
    openingStockIsManual?: boolean
    afterPurchaseStock?: Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: Decimal | DecimalJsLike | number | string | null
    qtyToShip?: Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: Decimal | DecimalJsLike | number | string | null
    weightToShip?: Decimal | DecimalJsLike | number | string | null
    planFactDiff?: Decimal | DecimalJsLike | number | string | null
    underOver?: Decimal | DecimalJsLike | number | string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    svod: SvodHeaderCreateNestedOneWithoutLinesInput
  }

  export type SvodLineUncheckedCreateWithoutProductInput = {
    id?: number
    svodId: number
    shortName?: string | null
    category?: string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    orderQty?: Decimal | DecimalJsLike | number | string
    productionInQty?: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string
    openingStockIsManual?: boolean
    afterPurchaseStock?: Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: Decimal | DecimalJsLike | number | string | null
    qtyToShip?: Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: Decimal | DecimalJsLike | number | string | null
    weightToShip?: Decimal | DecimalJsLike | number | string | null
    planFactDiff?: Decimal | DecimalJsLike | number | string | null
    underOver?: Decimal | DecimalJsLike | number | string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodLineCreateOrConnectWithoutProductInput = {
    where: SvodLineWhereUniqueInput
    create: XOR<SvodLineCreateWithoutProductInput, SvodLineUncheckedCreateWithoutProductInput>
  }

  export type SvodLineCreateManyProductInputEnvelope = {
    data: SvodLineCreateManyProductInput | SvodLineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SvodSupplierValueCreateWithoutProductInput = {
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    svod: SvodHeaderCreateNestedOneWithoutSupplierValuesInput
    supplier: SupplierCreateNestedOneWithoutSvodSupplierValuesInput
  }

  export type SvodSupplierValueUncheckedCreateWithoutProductInput = {
    id?: number
    svodId: number
    supplierId: number
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodSupplierValueCreateOrConnectWithoutProductInput = {
    where: SvodSupplierValueWhereUniqueInput
    create: XOR<SvodSupplierValueCreateWithoutProductInput, SvodSupplierValueUncheckedCreateWithoutProductInput>
  }

  export type SvodSupplierValueCreateManyProductInputEnvelope = {
    data: SvodSupplierValueCreateManyProductInput | SvodSupplierValueCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionInputCreateWithoutProductInput = {
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutInputsInput
    purchase: PurchaseCreateNestedOneWithoutProductionInputsInput
    purchaseItem: PurchaseItemCreateNestedOneWithoutProductionInputsInput
    warehouse: WarehouseCreateNestedOneWithoutProductionInputsInput
    loadedBy: UserCreateNestedOneWithoutProductionInputsInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputUncheckedCreateWithoutProductInput = {
    id?: number
    productionDocId: number
    purchaseId: number
    purchaseItemId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputCreateOrConnectWithoutProductInput = {
    where: ProductionInputWhereUniqueInput
    create: XOR<ProductionInputCreateWithoutProductInput, ProductionInputUncheckedCreateWithoutProductInput>
  }

  export type ProductionInputCreateManyProductInputEnvelope = {
    data: ProductionInputCreateManyProductInput | ProductionInputCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionOutputCreateWithoutProductInput = {
    qtyOut: Decimal | DecimalJsLike | number | string
    uom?: string
    costTotal?: Decimal | DecimalJsLike | number | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutOutputsInput
  }

  export type ProductionOutputUncheckedCreateWithoutProductInput = {
    id?: number
    productionDocId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    uom?: string
    costTotal?: Decimal | DecimalJsLike | number | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionOutputCreateOrConnectWithoutProductInput = {
    where: ProductionOutputWhereUniqueInput
    create: XOR<ProductionOutputCreateWithoutProductInput, ProductionOutputUncheckedCreateWithoutProductInput>
  }

  export type ProductionOutputCreateManyProductInputEnvelope = {
    data: ProductionOutputCreateManyProductInput | ProductionOutputCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductionCuttingLineCreateWithoutOutProductInput = {
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutCuttingLinesInput
    productionInput: ProductionInputCreateNestedOneWithoutCuttingLinesInput
    mml: ProductionMmlCreateNestedOneWithoutCuttingLinesInput
    createdBy: UserCreateNestedOneWithoutCuttingLinesInput
  }

  export type ProductionCuttingLineUncheckedCreateWithoutOutProductInput = {
    id?: number
    productionDocId: number
    productionInputId: number
    mmlId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdByUserId: number
  }

  export type ProductionCuttingLineCreateOrConnectWithoutOutProductInput = {
    where: ProductionCuttingLineWhereUniqueInput
    create: XOR<ProductionCuttingLineCreateWithoutOutProductInput, ProductionCuttingLineUncheckedCreateWithoutOutProductInput>
  }

  export type ProductionCuttingLineCreateManyOutProductInputEnvelope = {
    data: ProductionCuttingLineCreateManyOutProductInput | ProductionCuttingLineCreateManyOutProductInput[]
    skipDuplicates?: boolean
  }

  export type CustomerProductCreateWithoutProductInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerProductsInput
  }

  export type CustomerProductUncheckedCreateWithoutProductInput = {
    id?: number
    customerId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductCreateOrConnectWithoutProductInput = {
    where: CustomerProductWhereUniqueInput
    create: XOR<CustomerProductCreateWithoutProductInput, CustomerProductUncheckedCreateWithoutProductInput>
  }

  export type CustomerProductCreateManyProductInputEnvelope = {
    data: CustomerProductCreateManyProductInput | CustomerProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: FloatFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    distributionCoef?: FloatNullableFilter<"OrderItem"> | number | null
    sumWithRevaluation?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: FloatNullableFilter<"OrderItem"> | number | null
  }

  export type StockUpsertWithoutProductInput = {
    update: XOR<StockUpdateWithoutProductInput, StockUncheckedUpdateWithoutProductInput>
    create: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutProductInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutProductInput, StockUncheckedUpdateWithoutProductInput>
  }

  export type StockUpdateWithoutProductInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockUncheckedUpdateWithoutProductInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUpsertWithWhereUniqueWithoutProductInput = {
    where: StockTransactionWhereUniqueInput
    update: XOR<StockTransactionUpdateWithoutProductInput, StockTransactionUncheckedUpdateWithoutProductInput>
    create: XOR<StockTransactionCreateWithoutProductInput, StockTransactionUncheckedCreateWithoutProductInput>
  }

  export type StockTransactionUpdateWithWhereUniqueWithoutProductInput = {
    where: StockTransactionWhereUniqueInput
    data: XOR<StockTransactionUpdateWithoutProductInput, StockTransactionUncheckedUpdateWithoutProductInput>
  }

  export type StockTransactionUpdateManyWithWhereWithoutProductInput = {
    where: StockTransactionScalarWhereInput
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyWithoutProductInput>
  }

  export type StockTransactionScalarWhereInput = {
    AND?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
    OR?: StockTransactionScalarWhereInput[]
    NOT?: StockTransactionScalarWhereInput | StockTransactionScalarWhereInput[]
    id?: IntFilter<"StockTransaction"> | number
    productId?: IntFilter<"StockTransaction"> | number
    type?: StringFilter<"StockTransaction"> | string
    quantity?: FloatFilter<"StockTransaction"> | number
    orderId?: IntNullableFilter<"StockTransaction"> | number | null
    note?: StringNullableFilter<"StockTransaction"> | string | null
    createdAt?: DateTimeFilter<"StockTransaction"> | Date | string
  }

  export type SupplierProductUpsertWithWhereUniqueWithoutProductInput = {
    where: SupplierProductWhereUniqueInput
    update: XOR<SupplierProductUpdateWithoutProductInput, SupplierProductUncheckedUpdateWithoutProductInput>
    create: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput>
  }

  export type SupplierProductUpdateWithWhereUniqueWithoutProductInput = {
    where: SupplierProductWhereUniqueInput
    data: XOR<SupplierProductUpdateWithoutProductInput, SupplierProductUncheckedUpdateWithoutProductInput>
  }

  export type SupplierProductUpdateManyWithWhereWithoutProductInput = {
    where: SupplierProductScalarWhereInput
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyWithoutProductInput>
  }

  export type SupplierProductScalarWhereInput = {
    AND?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
    OR?: SupplierProductScalarWhereInput[]
    NOT?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
    supplierId?: IntFilter<"SupplierProduct"> | number
    productId?: IntFilter<"SupplierProduct"> | number
  }

  export type SummaryOrderJournalUpsertWithWhereUniqueWithoutProductInput = {
    where: SummaryOrderJournalWhereUniqueInput
    update: XOR<SummaryOrderJournalUpdateWithoutProductInput, SummaryOrderJournalUncheckedUpdateWithoutProductInput>
    create: XOR<SummaryOrderJournalCreateWithoutProductInput, SummaryOrderJournalUncheckedCreateWithoutProductInput>
  }

  export type SummaryOrderJournalUpdateWithWhereUniqueWithoutProductInput = {
    where: SummaryOrderJournalWhereUniqueInput
    data: XOR<SummaryOrderJournalUpdateWithoutProductInput, SummaryOrderJournalUncheckedUpdateWithoutProductInput>
  }

  export type SummaryOrderJournalUpdateManyWithWhereWithoutProductInput = {
    where: SummaryOrderJournalScalarWhereInput
    data: XOR<SummaryOrderJournalUpdateManyMutationInput, SummaryOrderJournalUncheckedUpdateManyWithoutProductInput>
  }

  export type SummaryOrderJournalScalarWhereInput = {
    AND?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
    OR?: SummaryOrderJournalScalarWhereInput[]
    NOT?: SummaryOrderJournalScalarWhereInput | SummaryOrderJournalScalarWhereInput[]
    id?: IntFilter<"SummaryOrderJournal"> | number
    idn?: StringFilter<"SummaryOrderJournal"> | string
    shipDate?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    paymentType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    customerId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    customerName?: StringFilter<"SummaryOrderJournal"> | string
    productId?: IntNullableFilter<"SummaryOrderJournal"> | number | null
    productCode?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    productFullName?: StringFilter<"SummaryOrderJournal"> | string
    category?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    shortNameMorning?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    priceType?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    price?: DecimalFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFilter<"SummaryOrderJournal"> | number
    orderQty?: FloatFilter<"SummaryOrderJournal"> | number
    sumWithRevaluation?: DecimalNullableFilter<"SummaryOrderJournal"> | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    weightToDistribute?: FloatNullableFilter<"SummaryOrderJournal"> | number | null
    managerId?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    managerName?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    district?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    pointAddress?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    status?: StringFilter<"SummaryOrderJournal"> | string
    preAssemblyStatus?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyStartedAt?: DateTimeNullableFilter<"SummaryOrderJournal"> | Date | string | null
    assemblyStartedBy?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnedAt?: DateTimeNullableFilter<"SummaryOrderJournal"> | Date | string | null
    assemblyReturnedBy?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnReason?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    assemblyReturnComment?: StringNullableFilter<"SummaryOrderJournal"> | string | null
    createdAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
    updatedAt?: DateTimeFilter<"SummaryOrderJournal"> | Date | string
  }

  export type ProductionItemUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductionItemWhereUniqueInput
    update: XOR<ProductionItemUpdateWithoutProductInput, ProductionItemUncheckedUpdateWithoutProductInput>
    create: XOR<ProductionItemCreateWithoutProductInput, ProductionItemUncheckedCreateWithoutProductInput>
  }

  export type ProductionItemUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductionItemWhereUniqueInput
    data: XOR<ProductionItemUpdateWithoutProductInput, ProductionItemUncheckedUpdateWithoutProductInput>
  }

  export type ProductionItemUpdateManyWithWhereWithoutProductInput = {
    where: ProductionItemScalarWhereInput
    data: XOR<ProductionItemUpdateManyMutationInput, ProductionItemUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductionItemScalarWhereInput = {
    AND?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
    OR?: ProductionItemScalarWhereInput[]
    NOT?: ProductionItemScalarWhereInput | ProductionItemScalarWhereInput[]
    id?: IntFilter<"ProductionItem"> | number
    journalId?: IntFilter<"ProductionItem"> | number
    productId?: IntNullableFilter<"ProductionItem"> | number | null
    productName?: StringNullableFilter<"ProductionItem"> | string | null
    state?: StringFilter<"ProductionItem"> | string
    sortOrder?: IntFilter<"ProductionItem"> | number
    isDeleted?: BoolFilter<"ProductionItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"ProductionItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"ProductionItem"> | string | null
    createdAt?: DateTimeFilter<"ProductionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionItem"> | Date | string
    createdBy?: StringFilter<"ProductionItem"> | string
    updatedBy?: StringNullableFilter<"ProductionItem"> | string | null
  }

  export type PurchasePriceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchasePriceItemWhereUniqueInput
    update: XOR<PurchasePriceItemUpdateWithoutProductInput, PurchasePriceItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchasePriceItemCreateWithoutProductInput, PurchasePriceItemUncheckedCreateWithoutProductInput>
  }

  export type PurchasePriceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchasePriceItemWhereUniqueInput
    data: XOR<PurchasePriceItemUpdateWithoutProductInput, PurchasePriceItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchasePriceItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchasePriceItemScalarWhereInput
    data: XOR<PurchasePriceItemUpdateManyMutationInput, PurchasePriceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchasePriceItemScalarWhereInput = {
    AND?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
    OR?: PurchasePriceItemScalarWhereInput[]
    NOT?: PurchasePriceItemScalarWhereInput | PurchasePriceItemScalarWhereInput[]
    id?: IntFilter<"PurchasePriceItem"> | number
    priceListId?: IntFilter<"PurchasePriceItem"> | number
    supplierId?: IntFilter<"PurchasePriceItem"> | number
    productId?: IntFilter<"PurchasePriceItem"> | number
    purchasePrice?: DecimalFilter<"PurchasePriceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasePriceItem"> | Date | string
  }

  export type SalesPriceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: SalesPriceItemWhereUniqueInput
    update: XOR<SalesPriceItemUpdateWithoutProductInput, SalesPriceItemUncheckedUpdateWithoutProductInput>
    create: XOR<SalesPriceItemCreateWithoutProductInput, SalesPriceItemUncheckedCreateWithoutProductInput>
  }

  export type SalesPriceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: SalesPriceItemWhereUniqueInput
    data: XOR<SalesPriceItemUpdateWithoutProductInput, SalesPriceItemUncheckedUpdateWithoutProductInput>
  }

  export type SalesPriceItemUpdateManyWithWhereWithoutProductInput = {
    where: SalesPriceItemScalarWhereInput
    data: XOR<SalesPriceItemUpdateManyMutationInput, SalesPriceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type SalesPriceItemScalarWhereInput = {
    AND?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
    OR?: SalesPriceItemScalarWhereInput[]
    NOT?: SalesPriceItemScalarWhereInput | SalesPriceItemScalarWhereInput[]
    id?: IntFilter<"SalesPriceItem"> | number
    priceListId?: IntFilter<"SalesPriceItem"> | number
    productId?: IntFilter<"SalesPriceItem"> | number
    salePrice?: DecimalFilter<"SalesPriceItem"> | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFilter<"SalesPriceItem"> | Date | string
    createdAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceItem"> | Date | string
    updatedBy?: StringNullableFilter<"SalesPriceItem"> | string | null
  }

  export type ProductionMmlUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductionMmlWhereUniqueInput
    update: XOR<ProductionMmlUpdateWithoutProductInput, ProductionMmlUncheckedUpdateWithoutProductInput>
    create: XOR<ProductionMmlCreateWithoutProductInput, ProductionMmlUncheckedCreateWithoutProductInput>
  }

  export type ProductionMmlUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductionMmlWhereUniqueInput
    data: XOR<ProductionMmlUpdateWithoutProductInput, ProductionMmlUncheckedUpdateWithoutProductInput>
  }

  export type ProductionMmlUpdateManyWithWhereWithoutProductInput = {
    where: ProductionMmlScalarWhereInput
    data: XOR<ProductionMmlUpdateManyMutationInput, ProductionMmlUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductionMmlNodeUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductionMmlNodeWhereUniqueInput
    update: XOR<ProductionMmlNodeUpdateWithoutProductInput, ProductionMmlNodeUncheckedUpdateWithoutProductInput>
    create: XOR<ProductionMmlNodeCreateWithoutProductInput, ProductionMmlNodeUncheckedCreateWithoutProductInput>
  }

  export type ProductionMmlNodeUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductionMmlNodeWhereUniqueInput
    data: XOR<ProductionMmlNodeUpdateWithoutProductInput, ProductionMmlNodeUncheckedUpdateWithoutProductInput>
  }

  export type ProductionMmlNodeUpdateManyWithWhereWithoutProductInput = {
    where: ProductionMmlNodeScalarWhereInput
    data: XOR<ProductionMmlNodeUpdateManyMutationInput, ProductionMmlNodeUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductionMmlNodeScalarWhereInput = {
    AND?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
    OR?: ProductionMmlNodeScalarWhereInput[]
    NOT?: ProductionMmlNodeScalarWhereInput | ProductionMmlNodeScalarWhereInput[]
    id?: IntFilter<"ProductionMmlNode"> | number
    mmlId?: IntFilter<"ProductionMmlNode"> | number
    parentNodeId?: IntNullableFilter<"ProductionMmlNode"> | number | null
    productId?: IntFilter<"ProductionMmlNode"> | number
    sortOrder?: IntFilter<"ProductionMmlNode"> | number
    createdAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionMmlNode"> | Date | string
  }

  export type ProductionRunUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductionRunWhereUniqueInput
    update: XOR<ProductionRunUpdateWithoutProductInput, ProductionRunUncheckedUpdateWithoutProductInput>
    create: XOR<ProductionRunCreateWithoutProductInput, ProductionRunUncheckedCreateWithoutProductInput>
  }

  export type ProductionRunUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductionRunWhereUniqueInput
    data: XOR<ProductionRunUpdateWithoutProductInput, ProductionRunUncheckedUpdateWithoutProductInput>
  }

  export type ProductionRunUpdateManyWithWhereWithoutProductInput = {
    where: ProductionRunScalarWhereInput
    data: XOR<ProductionRunUpdateManyMutationInput, ProductionRunUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductionRunValueUpsertWithWhereUniqueWithoutSnapshotProductInput = {
    where: ProductionRunValueWhereUniqueInput
    update: XOR<ProductionRunValueUpdateWithoutSnapshotProductInput, ProductionRunValueUncheckedUpdateWithoutSnapshotProductInput>
    create: XOR<ProductionRunValueCreateWithoutSnapshotProductInput, ProductionRunValueUncheckedCreateWithoutSnapshotProductInput>
  }

  export type ProductionRunValueUpdateWithWhereUniqueWithoutSnapshotProductInput = {
    where: ProductionRunValueWhereUniqueInput
    data: XOR<ProductionRunValueUpdateWithoutSnapshotProductInput, ProductionRunValueUncheckedUpdateWithoutSnapshotProductInput>
  }

  export type ProductionRunValueUpdateManyWithWhereWithoutSnapshotProductInput = {
    where: ProductionRunValueScalarWhereInput
    data: XOR<ProductionRunValueUpdateManyMutationInput, ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductInput>
  }

  export type ProductionRunValueScalarWhereInput = {
    AND?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
    OR?: ProductionRunValueScalarWhereInput[]
    NOT?: ProductionRunValueScalarWhereInput | ProductionRunValueScalarWhereInput[]
    id?: IntFilter<"ProductionRunValue"> | number
    productionRunId?: IntFilter<"ProductionRunValue"> | number
    mmlNodeId?: IntFilter<"ProductionRunValue"> | number
    snapshotProductId?: IntNullableFilter<"ProductionRunValue"> | number | null
    value?: DecimalNullableFilter<"ProductionRunValue"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionRunValue"> | Date | string
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutProductInput, PurchaseItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutProductInput, PurchaseItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseItemScalarWhereInput = {
    AND?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    OR?: PurchaseItemScalarWhereInput[]
    NOT?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    id?: IntFilter<"PurchaseItem"> | number
    purchaseId?: IntFilter<"PurchaseItem"> | number
    supplierId?: IntFilter<"PurchaseItem"> | number
    productId?: IntFilter<"PurchaseItem"> | number
    price?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    qty?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    paymentTypeId?: IntNullableFilter<"PurchaseItem"> | number | null
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseItem"> | Date | string
  }

  export type SvodLineUpsertWithWhereUniqueWithoutProductInput = {
    where: SvodLineWhereUniqueInput
    update: XOR<SvodLineUpdateWithoutProductInput, SvodLineUncheckedUpdateWithoutProductInput>
    create: XOR<SvodLineCreateWithoutProductInput, SvodLineUncheckedCreateWithoutProductInput>
  }

  export type SvodLineUpdateWithWhereUniqueWithoutProductInput = {
    where: SvodLineWhereUniqueInput
    data: XOR<SvodLineUpdateWithoutProductInput, SvodLineUncheckedUpdateWithoutProductInput>
  }

  export type SvodLineUpdateManyWithWhereWithoutProductInput = {
    where: SvodLineScalarWhereInput
    data: XOR<SvodLineUpdateManyMutationInput, SvodLineUncheckedUpdateManyWithoutProductInput>
  }

  export type SvodLineScalarWhereInput = {
    AND?: SvodLineScalarWhereInput | SvodLineScalarWhereInput[]
    OR?: SvodLineScalarWhereInput[]
    NOT?: SvodLineScalarWhereInput | SvodLineScalarWhereInput[]
    id?: IntFilter<"SvodLine"> | number
    svodId?: IntFilter<"SvodLine"> | number
    productId?: IntFilter<"SvodLine"> | number
    shortName?: StringNullableFilter<"SvodLine"> | string | null
    category?: StringNullableFilter<"SvodLine"> | string | null
    coefficient?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFilter<"SvodLine"> | boolean
    afterPurchaseStock?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    weightToShip?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    underOver?: DecimalNullableFilter<"SvodLine"> | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFilter<"SvodLine"> | number
    createdAt?: DateTimeFilter<"SvodLine"> | Date | string
    updatedAt?: DateTimeFilter<"SvodLine"> | Date | string
  }

  export type SvodSupplierValueUpsertWithWhereUniqueWithoutProductInput = {
    where: SvodSupplierValueWhereUniqueInput
    update: XOR<SvodSupplierValueUpdateWithoutProductInput, SvodSupplierValueUncheckedUpdateWithoutProductInput>
    create: XOR<SvodSupplierValueCreateWithoutProductInput, SvodSupplierValueUncheckedCreateWithoutProductInput>
  }

  export type SvodSupplierValueUpdateWithWhereUniqueWithoutProductInput = {
    where: SvodSupplierValueWhereUniqueInput
    data: XOR<SvodSupplierValueUpdateWithoutProductInput, SvodSupplierValueUncheckedUpdateWithoutProductInput>
  }

  export type SvodSupplierValueUpdateManyWithWhereWithoutProductInput = {
    where: SvodSupplierValueScalarWhereInput
    data: XOR<SvodSupplierValueUpdateManyMutationInput, SvodSupplierValueUncheckedUpdateManyWithoutProductInput>
  }

  export type SvodSupplierValueScalarWhereInput = {
    AND?: SvodSupplierValueScalarWhereInput | SvodSupplierValueScalarWhereInput[]
    OR?: SvodSupplierValueScalarWhereInput[]
    NOT?: SvodSupplierValueScalarWhereInput | SvodSupplierValueScalarWhereInput[]
    id?: IntFilter<"SvodSupplierValue"> | number
    svodId?: IntFilter<"SvodSupplierValue"> | number
    productId?: IntFilter<"SvodSupplierValue"> | number
    supplierId?: IntFilter<"SvodSupplierValue"> | number
    purchaseQty?: DecimalFilter<"SvodSupplierValue"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SvodSupplierValue"> | Date | string
    updatedAt?: DateTimeFilter<"SvodSupplierValue"> | Date | string
  }

  export type ProductionInputUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductionInputWhereUniqueInput
    update: XOR<ProductionInputUpdateWithoutProductInput, ProductionInputUncheckedUpdateWithoutProductInput>
    create: XOR<ProductionInputCreateWithoutProductInput, ProductionInputUncheckedCreateWithoutProductInput>
  }

  export type ProductionInputUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductionInputWhereUniqueInput
    data: XOR<ProductionInputUpdateWithoutProductInput, ProductionInputUncheckedUpdateWithoutProductInput>
  }

  export type ProductionInputUpdateManyWithWhereWithoutProductInput = {
    where: ProductionInputScalarWhereInput
    data: XOR<ProductionInputUpdateManyMutationInput, ProductionInputUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductionOutputUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductionOutputWhereUniqueInput
    update: XOR<ProductionOutputUpdateWithoutProductInput, ProductionOutputUncheckedUpdateWithoutProductInput>
    create: XOR<ProductionOutputCreateWithoutProductInput, ProductionOutputUncheckedCreateWithoutProductInput>
  }

  export type ProductionOutputUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductionOutputWhereUniqueInput
    data: XOR<ProductionOutputUpdateWithoutProductInput, ProductionOutputUncheckedUpdateWithoutProductInput>
  }

  export type ProductionOutputUpdateManyWithWhereWithoutProductInput = {
    where: ProductionOutputScalarWhereInput
    data: XOR<ProductionOutputUpdateManyMutationInput, ProductionOutputUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductionOutputScalarWhereInput = {
    AND?: ProductionOutputScalarWhereInput | ProductionOutputScalarWhereInput[]
    OR?: ProductionOutputScalarWhereInput[]
    NOT?: ProductionOutputScalarWhereInput | ProductionOutputScalarWhereInput[]
    id?: IntFilter<"ProductionOutput"> | number
    productionDocId?: IntFilter<"ProductionOutput"> | number
    productId?: IntFilter<"ProductionOutput"> | number
    qtyOut?: DecimalFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"ProductionOutput"> | string
    costTotal?: DecimalNullableFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: DecimalNullableFilter<"ProductionOutput"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductionOutput"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionOutput"> | Date | string
  }

  export type ProductionCuttingLineUpsertWithWhereUniqueWithoutOutProductInput = {
    where: ProductionCuttingLineWhereUniqueInput
    update: XOR<ProductionCuttingLineUpdateWithoutOutProductInput, ProductionCuttingLineUncheckedUpdateWithoutOutProductInput>
    create: XOR<ProductionCuttingLineCreateWithoutOutProductInput, ProductionCuttingLineUncheckedCreateWithoutOutProductInput>
  }

  export type ProductionCuttingLineUpdateWithWhereUniqueWithoutOutProductInput = {
    where: ProductionCuttingLineWhereUniqueInput
    data: XOR<ProductionCuttingLineUpdateWithoutOutProductInput, ProductionCuttingLineUncheckedUpdateWithoutOutProductInput>
  }

  export type ProductionCuttingLineUpdateManyWithWhereWithoutOutProductInput = {
    where: ProductionCuttingLineScalarWhereInput
    data: XOR<ProductionCuttingLineUpdateManyMutationInput, ProductionCuttingLineUncheckedUpdateManyWithoutOutProductInput>
  }

  export type CustomerProductUpsertWithWhereUniqueWithoutProductInput = {
    where: CustomerProductWhereUniqueInput
    update: XOR<CustomerProductUpdateWithoutProductInput, CustomerProductUncheckedUpdateWithoutProductInput>
    create: XOR<CustomerProductCreateWithoutProductInput, CustomerProductUncheckedCreateWithoutProductInput>
  }

  export type CustomerProductUpdateWithWhereUniqueWithoutProductInput = {
    where: CustomerProductWhereUniqueInput
    data: XOR<CustomerProductUpdateWithoutProductInput, CustomerProductUncheckedUpdateWithoutProductInput>
  }

  export type CustomerProductUpdateManyWithWhereWithoutProductInput = {
    where: CustomerProductScalarWhereInput
    data: XOR<CustomerProductUpdateManyMutationInput, CustomerProductUncheckedUpdateManyWithoutProductInput>
  }

  export type CustomerProductScalarWhereInput = {
    AND?: CustomerProductScalarWhereInput | CustomerProductScalarWhereInput[]
    OR?: CustomerProductScalarWhereInput[]
    NOT?: CustomerProductScalarWhereInput | CustomerProductScalarWhereInput[]
    id?: IntFilter<"CustomerProduct"> | number
    customerId?: IntFilter<"CustomerProduct"> | number
    productId?: IntFilter<"CustomerProduct"> | number
    sortOrder?: IntFilter<"CustomerProduct"> | number
    createdAt?: DateTimeFilter<"CustomerProduct"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerProduct"> | Date | string
  }

  export type DistrictCreateWithoutCustomersInput = {
    code: string
    name: string
  }

  export type DistrictUncheckedCreateWithoutCustomersInput = {
    id?: number
    code: string
    name: string
  }

  export type DistrictCreateOrConnectWithoutCustomersInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutCustomersInput, DistrictUncheckedCreateWithoutCustomersInput>
  }

  export type ManagerCreateWithoutCustomersInput = {
    code: string
    name: string
    phone?: string | null
  }

  export type ManagerUncheckedCreateWithoutCustomersInput = {
    id?: number
    code: string
    name: string
    phone?: string | null
  }

  export type ManagerCreateOrConnectWithoutCustomersInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutCustomersInput, ManagerUncheckedCreateWithoutCustomersInput>
  }

  export type OrderCreateWithoutCustomerInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expeditor?: ExpeditorCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SummaryOrderJournalCreateWithoutCustomerInput = {
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerName: string
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    preAssemblyStatus?: string | null
    assemblyStartedAt?: Date | string | null
    assemblyStartedBy?: string | null
    assemblyReturnedAt?: Date | string | null
    assemblyReturnedBy?: string | null
    assemblyReturnReason?: string | null
    assemblyReturnComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutSummaryJournalEntriesInput
    events?: SummaryOrderEventCreateNestedManyWithoutSummaryOrderInput
  }

  export type SummaryOrderJournalUncheckedCreateWithoutCustomerInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerName: string
    productId?: number | null
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    preAssemblyStatus?: string | null
    assemblyStartedAt?: Date | string | null
    assemblyStartedBy?: string | null
    assemblyReturnedAt?: Date | string | null
    assemblyReturnedBy?: string | null
    assemblyReturnReason?: string | null
    assemblyReturnComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: SummaryOrderEventUncheckedCreateNestedManyWithoutSummaryOrderInput
  }

  export type SummaryOrderJournalCreateOrConnectWithoutCustomerInput = {
    where: SummaryOrderJournalWhereUniqueInput
    create: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput>
  }

  export type SummaryOrderJournalCreateManyCustomerInputEnvelope = {
    data: SummaryOrderJournalCreateManyCustomerInput | SummaryOrderJournalCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SalesPriceListCreateWithoutCustomerInput = {
    listType: string
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: SalesPriceItemCreateNestedManyWithoutPriceListInput
  }

  export type SalesPriceListUncheckedCreateWithoutCustomerInput = {
    id?: number
    listType: string
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: SalesPriceItemUncheckedCreateNestedManyWithoutPriceListInput
  }

  export type SalesPriceListCreateOrConnectWithoutCustomerInput = {
    where: SalesPriceListWhereUniqueInput
    create: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput>
  }

  export type SalesPriceListCreateManyCustomerInputEnvelope = {
    data: SalesPriceListCreateManyCustomerInput | SalesPriceListCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerProductCreateWithoutCustomerInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCustomerProductsInput
  }

  export type CustomerProductUncheckedCreateWithoutCustomerInput = {
    id?: number
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductCreateOrConnectWithoutCustomerInput = {
    where: CustomerProductWhereUniqueInput
    create: XOR<CustomerProductCreateWithoutCustomerInput, CustomerProductUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerProductCreateManyCustomerInputEnvelope = {
    data: CustomerProductCreateManyCustomerInput | CustomerProductCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type DistrictUpsertWithoutCustomersInput = {
    update: XOR<DistrictUpdateWithoutCustomersInput, DistrictUncheckedUpdateWithoutCustomersInput>
    create: XOR<DistrictCreateWithoutCustomersInput, DistrictUncheckedCreateWithoutCustomersInput>
    where?: DistrictWhereInput
  }

  export type DistrictUpdateToOneWithWhereWithoutCustomersInput = {
    where?: DistrictWhereInput
    data: XOR<DistrictUpdateWithoutCustomersInput, DistrictUncheckedUpdateWithoutCustomersInput>
  }

  export type DistrictUpdateWithoutCustomersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DistrictUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerUpsertWithoutCustomersInput = {
    update: XOR<ManagerUpdateWithoutCustomersInput, ManagerUncheckedUpdateWithoutCustomersInput>
    create: XOR<ManagerCreateWithoutCustomersInput, ManagerUncheckedCreateWithoutCustomersInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutCustomersInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutCustomersInput, ManagerUncheckedUpdateWithoutCustomersInput>
  }

  export type ManagerUpdateWithoutCustomersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    idn?: StringNullableFilter<"Order"> | string | null
    date?: DateTimeFilter<"Order"> | Date | string
    status?: StringFilter<"Order"> | string
    paymentType?: StringNullableFilter<"Order"> | string | null
    customerId?: IntFilter<"Order"> | number
    expeditorId?: IntNullableFilter<"Order"> | number | null
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFilter<"Order"> | number
    isDisabled?: BoolFilter<"Order"> | boolean
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    assignedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryStatus?: StringFilter<"Order"> | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    signatureUrl?: StringNullableFilter<"Order"> | string | null
    signedInvoiceUrl?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type SummaryOrderJournalUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SummaryOrderJournalWhereUniqueInput
    update: XOR<SummaryOrderJournalUpdateWithoutCustomerInput, SummaryOrderJournalUncheckedUpdateWithoutCustomerInput>
    create: XOR<SummaryOrderJournalCreateWithoutCustomerInput, SummaryOrderJournalUncheckedCreateWithoutCustomerInput>
  }

  export type SummaryOrderJournalUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SummaryOrderJournalWhereUniqueInput
    data: XOR<SummaryOrderJournalUpdateWithoutCustomerInput, SummaryOrderJournalUncheckedUpdateWithoutCustomerInput>
  }

  export type SummaryOrderJournalUpdateManyWithWhereWithoutCustomerInput = {
    where: SummaryOrderJournalScalarWhereInput
    data: XOR<SummaryOrderJournalUpdateManyMutationInput, SummaryOrderJournalUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SalesPriceListUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SalesPriceListWhereUniqueInput
    update: XOR<SalesPriceListUpdateWithoutCustomerInput, SalesPriceListUncheckedUpdateWithoutCustomerInput>
    create: XOR<SalesPriceListCreateWithoutCustomerInput, SalesPriceListUncheckedCreateWithoutCustomerInput>
  }

  export type SalesPriceListUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SalesPriceListWhereUniqueInput
    data: XOR<SalesPriceListUpdateWithoutCustomerInput, SalesPriceListUncheckedUpdateWithoutCustomerInput>
  }

  export type SalesPriceListUpdateManyWithWhereWithoutCustomerInput = {
    where: SalesPriceListScalarWhereInput
    data: XOR<SalesPriceListUpdateManyMutationInput, SalesPriceListUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SalesPriceListScalarWhereInput = {
    AND?: SalesPriceListScalarWhereInput | SalesPriceListScalarWhereInput[]
    OR?: SalesPriceListScalarWhereInput[]
    NOT?: SalesPriceListScalarWhereInput | SalesPriceListScalarWhereInput[]
    id?: IntFilter<"SalesPriceList"> | number
    listType?: StringFilter<"SalesPriceList"> | string
    customerId?: IntNullableFilter<"SalesPriceList"> | number | null
    title?: StringNullableFilter<"SalesPriceList"> | string | null
    effectiveDate?: DateTimeFilter<"SalesPriceList"> | Date | string
    status?: StringFilter<"SalesPriceList"> | string
    isCurrent?: BoolFilter<"SalesPriceList"> | boolean
    isHidden?: BoolFilter<"SalesPriceList"> | boolean
    createdAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    updatedAt?: DateTimeFilter<"SalesPriceList"> | Date | string
    createdBy?: StringFilter<"SalesPriceList"> | string
    updatedBy?: StringNullableFilter<"SalesPriceList"> | string | null
  }

  export type CustomerProductUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerProductWhereUniqueInput
    update: XOR<CustomerProductUpdateWithoutCustomerInput, CustomerProductUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerProductCreateWithoutCustomerInput, CustomerProductUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerProductUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerProductWhereUniqueInput
    data: XOR<CustomerProductUpdateWithoutCustomerInput, CustomerProductUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerProductUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerProductScalarWhereInput
    data: XOR<CustomerProductUpdateManyMutationInput, CustomerProductUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutCustomerProductsInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: DistrictCreateNestedOneWithoutCustomersInput
    manager?: ManagerCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomerProductsInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomerProductsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerProductsInput, CustomerUncheckedCreateWithoutCustomerProductsInput>
  }

  export type ProductCreateWithoutCustomerProductsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
  }

  export type ProductUncheckedCreateWithoutCustomerProductsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
  }

  export type ProductCreateOrConnectWithoutCustomerProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCustomerProductsInput, ProductUncheckedCreateWithoutCustomerProductsInput>
  }

  export type CustomerUpsertWithoutCustomerProductsInput = {
    update: XOR<CustomerUpdateWithoutCustomerProductsInput, CustomerUncheckedUpdateWithoutCustomerProductsInput>
    create: XOR<CustomerCreateWithoutCustomerProductsInput, CustomerUncheckedCreateWithoutCustomerProductsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerProductsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerProductsInput, CustomerUncheckedUpdateWithoutCustomerProductsInput>
  }

  export type CustomerUpdateWithoutCustomerProductsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneWithoutCustomersNestedInput
    manager?: ManagerUpdateOneWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ProductUpsertWithoutCustomerProductsInput = {
    update: XOR<ProductUpdateWithoutCustomerProductsInput, ProductUncheckedUpdateWithoutCustomerProductsInput>
    create: XOR<ProductCreateWithoutCustomerProductsInput, ProductUncheckedCreateWithoutCustomerProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCustomerProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCustomerProductsInput, ProductUncheckedUpdateWithoutCustomerProductsInput>
  }

  export type ProductUpdateWithoutCustomerProductsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCustomerProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
  }

  export type ProductionMmlCreateWithoutSuppliersWithPrimaryMmlInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutSuppliersWithPrimaryMmlInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutSuppliersWithPrimaryMmlInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedCreateWithoutSuppliersWithPrimaryMmlInput>
  }

  export type SupplierProductCreateWithoutSupplierInput = {
    product: ProductCreateNestedOneWithoutSuppliersInput
  }

  export type SupplierProductUncheckedCreateWithoutSupplierInput = {
    productId: number
  }

  export type SupplierProductCreateOrConnectWithoutSupplierInput = {
    where: SupplierProductWhereUniqueInput
    create: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierProductCreateManySupplierInputEnvelope = {
    data: SupplierProductCreateManySupplierInput | SupplierProductCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceListSupplierCreateWithoutSupplierInput = {
    createdAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutSuppliersInput
    primaryMml?: ProductionMmlCreateNestedOneWithoutPriceListSuppliersInput
  }

  export type PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput = {
    id?: number
    priceListId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceListSupplierCreateOrConnectWithoutSupplierInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    create: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type PurchasePriceListSupplierCreateManySupplierInputEnvelope = {
    data: PurchasePriceListSupplierCreateManySupplierInput | PurchasePriceListSupplierCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceItemCreateWithoutSupplierInput = {
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchasePriceItemsInput
  }

  export type PurchasePriceItemUncheckedCreateWithoutSupplierInput = {
    id?: number
    priceListId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceItemCreateOrConnectWithoutSupplierInput = {
    where: PurchasePriceItemWhereUniqueInput
    create: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput>
  }

  export type PurchasePriceItemCreateManySupplierInputEnvelope = {
    data: PurchasePriceItemCreateManySupplierInput | PurchasePriceItemCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseSupplierCreateWithoutSupplierInput = {
    createdAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutSuppliersInput
  }

  export type PurchaseSupplierUncheckedCreateWithoutSupplierInput = {
    id?: number
    purchaseId: number
    createdAt?: Date | string
  }

  export type PurchaseSupplierCreateOrConnectWithoutSupplierInput = {
    where: PurchaseSupplierWhereUniqueInput
    create: XOR<PurchaseSupplierCreateWithoutSupplierInput, PurchaseSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseSupplierCreateManySupplierInputEnvelope = {
    data: PurchaseSupplierCreateManySupplierInput | PurchaseSupplierCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseItemCreateWithoutSupplierInput = {
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchaseItemsRelInput
    paymentType?: PaymentTypeCreateNestedOneWithoutPurchaseItemsInput
    productionInputs?: ProductionInputCreateNestedManyWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateWithoutSupplierInput = {
    id?: number
    purchaseId: number
    productId: number
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    paymentTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutPurchaseItemInput
  }

  export type PurchaseItemCreateOrConnectWithoutSupplierInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutSupplierInput, PurchaseItemUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseItemCreateManySupplierInputEnvelope = {
    data: PurchaseItemCreateManySupplierInput | PurchaseItemCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type SvodSupplierColCreateWithoutSupplierInput = {
    colIndex: number
    supplierName: string
    totalPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    svod: SvodHeaderCreateNestedOneWithoutSupplierColsInput
  }

  export type SvodSupplierColUncheckedCreateWithoutSupplierInput = {
    id?: number
    svodId: number
    colIndex: number
    supplierName: string
    totalPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SvodSupplierColCreateOrConnectWithoutSupplierInput = {
    where: SvodSupplierColWhereUniqueInput
    create: XOR<SvodSupplierColCreateWithoutSupplierInput, SvodSupplierColUncheckedCreateWithoutSupplierInput>
  }

  export type SvodSupplierColCreateManySupplierInputEnvelope = {
    data: SvodSupplierColCreateManySupplierInput | SvodSupplierColCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type SvodSupplierValueCreateWithoutSupplierInput = {
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    svod: SvodHeaderCreateNestedOneWithoutSupplierValuesInput
    product: ProductCreateNestedOneWithoutSvodSupplierValuesInput
  }

  export type SvodSupplierValueUncheckedCreateWithoutSupplierInput = {
    id?: number
    svodId: number
    productId: number
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodSupplierValueCreateOrConnectWithoutSupplierInput = {
    where: SvodSupplierValueWhereUniqueInput
    create: XOR<SvodSupplierValueCreateWithoutSupplierInput, SvodSupplierValueUncheckedCreateWithoutSupplierInput>
  }

  export type SvodSupplierValueCreateManySupplierInputEnvelope = {
    data: SvodSupplierValueCreateManySupplierInput | SvodSupplierValueCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ProductionMmlUpsertWithoutSuppliersWithPrimaryMmlInput = {
    update: XOR<ProductionMmlUpdateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedUpdateWithoutSuppliersWithPrimaryMmlInput>
    create: XOR<ProductionMmlCreateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedCreateWithoutSuppliersWithPrimaryMmlInput>
    where?: ProductionMmlWhereInput
  }

  export type ProductionMmlUpdateToOneWithWhereWithoutSuppliersWithPrimaryMmlInput = {
    where?: ProductionMmlWhereInput
    data: XOR<ProductionMmlUpdateWithoutSuppliersWithPrimaryMmlInput, ProductionMmlUncheckedUpdateWithoutSuppliersWithPrimaryMmlInput>
  }

  export type ProductionMmlUpdateWithoutSuppliersWithPrimaryMmlInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutSuppliersWithPrimaryMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutMmlNestedInput
  }

  export type SupplierProductUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierProductWhereUniqueInput
    update: XOR<SupplierProductUpdateWithoutSupplierInput, SupplierProductUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierProductUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierProductWhereUniqueInput
    data: XOR<SupplierProductUpdateWithoutSupplierInput, SupplierProductUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierProductUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierProductScalarWhereInput
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchasePriceListSupplierUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    update: XOR<PurchasePriceListSupplierUpdateWithoutSupplierInput, PurchasePriceListSupplierUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchasePriceListSupplierCreateWithoutSupplierInput, PurchasePriceListSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type PurchasePriceListSupplierUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    data: XOR<PurchasePriceListSupplierUpdateWithoutSupplierInput, PurchasePriceListSupplierUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchasePriceListSupplierUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchasePriceListSupplierScalarWhereInput
    data: XOR<PurchasePriceListSupplierUpdateManyMutationInput, PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchasePriceListSupplierScalarWhereInput = {
    AND?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
    OR?: PurchasePriceListSupplierScalarWhereInput[]
    NOT?: PurchasePriceListSupplierScalarWhereInput | PurchasePriceListSupplierScalarWhereInput[]
    id?: IntFilter<"PurchasePriceListSupplier"> | number
    priceListId?: IntFilter<"PurchasePriceListSupplier"> | number
    supplierId?: IntFilter<"PurchasePriceListSupplier"> | number
    primaryMmlId?: IntNullableFilter<"PurchasePriceListSupplier"> | number | null
    createdAt?: DateTimeFilter<"PurchasePriceListSupplier"> | Date | string
  }

  export type PurchasePriceItemUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchasePriceItemWhereUniqueInput
    update: XOR<PurchasePriceItemUpdateWithoutSupplierInput, PurchasePriceItemUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchasePriceItemCreateWithoutSupplierInput, PurchasePriceItemUncheckedCreateWithoutSupplierInput>
  }

  export type PurchasePriceItemUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchasePriceItemWhereUniqueInput
    data: XOR<PurchasePriceItemUpdateWithoutSupplierInput, PurchasePriceItemUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchasePriceItemUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchasePriceItemScalarWhereInput
    data: XOR<PurchasePriceItemUpdateManyMutationInput, PurchasePriceItemUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchaseSupplierUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseSupplierWhereUniqueInput
    update: XOR<PurchaseSupplierUpdateWithoutSupplierInput, PurchaseSupplierUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseSupplierCreateWithoutSupplierInput, PurchaseSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseSupplierUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseSupplierWhereUniqueInput
    data: XOR<PurchaseSupplierUpdateWithoutSupplierInput, PurchaseSupplierUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseSupplierUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseSupplierScalarWhereInput
    data: XOR<PurchaseSupplierUpdateManyMutationInput, PurchaseSupplierUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchaseSupplierScalarWhereInput = {
    AND?: PurchaseSupplierScalarWhereInput | PurchaseSupplierScalarWhereInput[]
    OR?: PurchaseSupplierScalarWhereInput[]
    NOT?: PurchaseSupplierScalarWhereInput | PurchaseSupplierScalarWhereInput[]
    id?: IntFilter<"PurchaseSupplier"> | number
    purchaseId?: IntFilter<"PurchaseSupplier"> | number
    supplierId?: IntFilter<"PurchaseSupplier"> | number
    createdAt?: DateTimeFilter<"PurchaseSupplier"> | Date | string
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutSupplierInput, PurchaseItemUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseItemCreateWithoutSupplierInput, PurchaseItemUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutSupplierInput, PurchaseItemUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SvodSupplierColUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SvodSupplierColWhereUniqueInput
    update: XOR<SvodSupplierColUpdateWithoutSupplierInput, SvodSupplierColUncheckedUpdateWithoutSupplierInput>
    create: XOR<SvodSupplierColCreateWithoutSupplierInput, SvodSupplierColUncheckedCreateWithoutSupplierInput>
  }

  export type SvodSupplierColUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SvodSupplierColWhereUniqueInput
    data: XOR<SvodSupplierColUpdateWithoutSupplierInput, SvodSupplierColUncheckedUpdateWithoutSupplierInput>
  }

  export type SvodSupplierColUpdateManyWithWhereWithoutSupplierInput = {
    where: SvodSupplierColScalarWhereInput
    data: XOR<SvodSupplierColUpdateManyMutationInput, SvodSupplierColUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SvodSupplierColScalarWhereInput = {
    AND?: SvodSupplierColScalarWhereInput | SvodSupplierColScalarWhereInput[]
    OR?: SvodSupplierColScalarWhereInput[]
    NOT?: SvodSupplierColScalarWhereInput | SvodSupplierColScalarWhereInput[]
    id?: IntFilter<"SvodSupplierCol"> | number
    svodId?: IntFilter<"SvodSupplierCol"> | number
    colIndex?: IntFilter<"SvodSupplierCol"> | number
    supplierId?: IntFilter<"SvodSupplierCol"> | number
    supplierName?: StringFilter<"SvodSupplierCol"> | string
    totalPurchase?: DecimalFilter<"SvodSupplierCol"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SvodSupplierCol"> | Date | string
  }

  export type SvodSupplierValueUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SvodSupplierValueWhereUniqueInput
    update: XOR<SvodSupplierValueUpdateWithoutSupplierInput, SvodSupplierValueUncheckedUpdateWithoutSupplierInput>
    create: XOR<SvodSupplierValueCreateWithoutSupplierInput, SvodSupplierValueUncheckedCreateWithoutSupplierInput>
  }

  export type SvodSupplierValueUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SvodSupplierValueWhereUniqueInput
    data: XOR<SvodSupplierValueUpdateWithoutSupplierInput, SvodSupplierValueUncheckedUpdateWithoutSupplierInput>
  }

  export type SvodSupplierValueUpdateManyWithWhereWithoutSupplierInput = {
    where: SvodSupplierValueScalarWhereInput
    data: XOR<SvodSupplierValueUpdateManyMutationInput, SvodSupplierValueUncheckedUpdateManyWithoutSupplierInput>
  }

  export type ProductCreateWithoutSuppliersInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSuppliersInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSuppliersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSuppliersInput, ProductUncheckedCreateWithoutSuppliersInput>
  }

  export type SupplierCreateWithoutProductsInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutProductsInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutProductsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
  }

  export type ProductUpsertWithoutSuppliersInput = {
    update: XOR<ProductUpdateWithoutSuppliersInput, ProductUncheckedUpdateWithoutSuppliersInput>
    create: XOR<ProductCreateWithoutSuppliersInput, ProductUncheckedCreateWithoutSuppliersInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSuppliersInput, ProductUncheckedUpdateWithoutSuppliersInput>
  }

  export type ProductUpdateWithoutSuppliersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SupplierUpsertWithoutProductsInput = {
    update: XOR<SupplierUpdateWithoutProductsInput, SupplierUncheckedUpdateWithoutProductsInput>
    create: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutProductsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutProductsInput, SupplierUncheckedUpdateWithoutProductsInput>
  }

  export type SupplierUpdateWithoutProductsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type CustomerCreateWithoutOrdersInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: DistrictCreateNestedOneWithoutCustomersInput
    manager?: ManagerCreateNestedOneWithoutCustomersInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type ExpeditorCreateWithoutOrdersInput = {
    name: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpeditorUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpeditorCreateOrConnectWithoutOrdersInput = {
    where: ExpeditorWhereUniqueInput
    create: XOR<ExpeditorCreateWithoutOrdersInput, ExpeditorUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    productId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type StockTransactionCreateWithoutOrderInput = {
    type: string
    quantity: number
    note?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockTransactionsInput
  }

  export type StockTransactionUncheckedCreateWithoutOrderInput = {
    id?: number
    productId: number
    type: string
    quantity: number
    note?: string | null
    createdAt?: Date | string
  }

  export type StockTransactionCreateOrConnectWithoutOrderInput = {
    where: StockTransactionWhereUniqueInput
    create: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput>
  }

  export type StockTransactionCreateManyOrderInputEnvelope = {
    data: StockTransactionCreateManyOrderInput | StockTransactionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderAttachmentCreateWithoutOrderInput = {
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
  }

  export type OrderAttachmentUncheckedCreateWithoutOrderInput = {
    id?: number
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
  }

  export type OrderAttachmentCreateOrConnectWithoutOrderInput = {
    where: OrderAttachmentWhereUniqueInput
    create: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput>
  }

  export type OrderAttachmentCreateManyOrderInputEnvelope = {
    data: OrderAttachmentCreateManyOrderInput | OrderAttachmentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneWithoutCustomersNestedInput
    manager?: ManagerUpdateOneWithoutCustomersNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ExpeditorUpsertWithoutOrdersInput = {
    update: XOR<ExpeditorUpdateWithoutOrdersInput, ExpeditorUncheckedUpdateWithoutOrdersInput>
    create: XOR<ExpeditorCreateWithoutOrdersInput, ExpeditorUncheckedCreateWithoutOrdersInput>
    where?: ExpeditorWhereInput
  }

  export type ExpeditorUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ExpeditorWhereInput
    data: XOR<ExpeditorUpdateWithoutOrdersInput, ExpeditorUncheckedUpdateWithoutOrdersInput>
  }

  export type ExpeditorUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpeditorUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type StockTransactionUpsertWithWhereUniqueWithoutOrderInput = {
    where: StockTransactionWhereUniqueInput
    update: XOR<StockTransactionUpdateWithoutOrderInput, StockTransactionUncheckedUpdateWithoutOrderInput>
    create: XOR<StockTransactionCreateWithoutOrderInput, StockTransactionUncheckedCreateWithoutOrderInput>
  }

  export type StockTransactionUpdateWithWhereUniqueWithoutOrderInput = {
    where: StockTransactionWhereUniqueInput
    data: XOR<StockTransactionUpdateWithoutOrderInput, StockTransactionUncheckedUpdateWithoutOrderInput>
  }

  export type StockTransactionUpdateManyWithWhereWithoutOrderInput = {
    where: StockTransactionScalarWhereInput
    data: XOR<StockTransactionUpdateManyMutationInput, StockTransactionUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderAttachmentUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderAttachmentWhereUniqueInput
    update: XOR<OrderAttachmentUpdateWithoutOrderInput, OrderAttachmentUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderAttachmentCreateWithoutOrderInput, OrderAttachmentUncheckedCreateWithoutOrderInput>
  }

  export type OrderAttachmentUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderAttachmentWhereUniqueInput
    data: XOR<OrderAttachmentUpdateWithoutOrderInput, OrderAttachmentUncheckedUpdateWithoutOrderInput>
  }

  export type OrderAttachmentUpdateManyWithWhereWithoutOrderInput = {
    where: OrderAttachmentScalarWhereInput
    data: XOR<OrderAttachmentUpdateManyMutationInput, OrderAttachmentUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderAttachmentScalarWhereInput = {
    AND?: OrderAttachmentScalarWhereInput | OrderAttachmentScalarWhereInput[]
    OR?: OrderAttachmentScalarWhereInput[]
    NOT?: OrderAttachmentScalarWhereInput | OrderAttachmentScalarWhereInput[]
    id?: IntFilter<"OrderAttachment"> | number
    orderId?: IntFilter<"OrderAttachment"> | number
    type?: StringFilter<"OrderAttachment"> | string
    filename?: StringFilter<"OrderAttachment"> | string
    url?: StringFilter<"OrderAttachment"> | string
    mimeType?: StringNullableFilter<"OrderAttachment"> | string | null
    createdAt?: DateTimeFilter<"OrderAttachment"> | Date | string
  }

  export type OrderCreateWithoutAttachmentsInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    expeditor?: ExpeditorCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAttachmentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAttachmentsInput, OrderUncheckedCreateWithoutAttachmentsInput>
  }

  export type OrderUpsertWithoutAttachmentsInput = {
    update: XOR<OrderUpdateWithoutAttachmentsInput, OrderUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<OrderCreateWithoutAttachmentsInput, OrderUncheckedCreateWithoutAttachmentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutAttachmentsInput, OrderUncheckedUpdateWithoutAttachmentsInput>
  }

  export type OrderUpdateWithoutAttachmentsInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    expeditor?: ExpeditorUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateWithoutItemsInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    expeditor?: ExpeditorCreateNestedOneWithoutOrdersInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    expeditor?: ExpeditorUpdateOneWithoutOrdersNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutExpeditorInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutExpeditorInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutExpeditorInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput>
  }

  export type OrderCreateManyExpeditorInputEnvelope = {
    data: OrderCreateManyExpeditorInput | OrderCreateManyExpeditorInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutExpeditorInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutExpeditorInput, OrderUncheckedUpdateWithoutExpeditorInput>
    create: XOR<OrderCreateWithoutExpeditorInput, OrderUncheckedCreateWithoutExpeditorInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutExpeditorInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutExpeditorInput, OrderUncheckedUpdateWithoutExpeditorInput>
  }

  export type OrderUpdateManyWithWhereWithoutExpeditorInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutExpeditorInput>
  }

  export type ProductCreateWithoutStockInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
  }

  export type ProductUpsertWithoutStockInput = {
    update: XOR<ProductUpdateWithoutStockInput, ProductUncheckedUpdateWithoutStockInput>
    create: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockInput, ProductUncheckedUpdateWithoutStockInput>
  }

  export type ProductUpdateWithoutStockInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutStockTransactionsInput = {
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    expeditor?: ExpeditorCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutStockTransactionsInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    attachments?: OrderAttachmentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStockTransactionsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStockTransactionsInput, OrderUncheckedCreateWithoutStockTransactionsInput>
  }

  export type ProductCreateWithoutStockTransactionsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockTransactionsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockTransactionsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockTransactionsInput, ProductUncheckedCreateWithoutStockTransactionsInput>
  }

  export type OrderUpsertWithoutStockTransactionsInput = {
    update: XOR<OrderUpdateWithoutStockTransactionsInput, OrderUncheckedUpdateWithoutStockTransactionsInput>
    create: XOR<OrderCreateWithoutStockTransactionsInput, OrderUncheckedCreateWithoutStockTransactionsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutStockTransactionsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutStockTransactionsInput, OrderUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type OrderUpdateWithoutStockTransactionsInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    expeditor?: ExpeditorUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutStockTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutStockTransactionsInput = {
    update: XOR<ProductUpdateWithoutStockTransactionsInput, ProductUncheckedUpdateWithoutStockTransactionsInput>
    create: XOR<ProductCreateWithoutStockTransactionsInput, ProductUncheckedCreateWithoutStockTransactionsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockTransactionsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockTransactionsInput, ProductUncheckedUpdateWithoutStockTransactionsInput>
  }

  export type ProductUpdateWithoutStockTransactionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CustomerCreateWithoutSummaryJournalEntriesInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: DistrictCreateNestedOneWithoutCustomersInput
    manager?: ManagerCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSummaryJournalEntriesInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    salesPriceLists?: SalesPriceListUncheckedCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSummaryJournalEntriesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSummaryJournalEntriesInput, CustomerUncheckedCreateWithoutSummaryJournalEntriesInput>
  }

  export type ProductCreateWithoutSummaryJournalEntriesInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSummaryJournalEntriesInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSummaryJournalEntriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSummaryJournalEntriesInput, ProductUncheckedCreateWithoutSummaryJournalEntriesInput>
  }

  export type SummaryOrderEventCreateWithoutSummaryOrderInput = {
    eventType: string
    fromStatus?: string | null
    toStatus?: string | null
    reason?: string | null
    comment?: string | null
    createdAt?: Date | string
    createdBy: string
    payload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SummaryOrderEventUncheckedCreateWithoutSummaryOrderInput = {
    id?: number
    eventType: string
    fromStatus?: string | null
    toStatus?: string | null
    reason?: string | null
    comment?: string | null
    createdAt?: Date | string
    createdBy: string
    payload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SummaryOrderEventCreateOrConnectWithoutSummaryOrderInput = {
    where: SummaryOrderEventWhereUniqueInput
    create: XOR<SummaryOrderEventCreateWithoutSummaryOrderInput, SummaryOrderEventUncheckedCreateWithoutSummaryOrderInput>
  }

  export type SummaryOrderEventCreateManySummaryOrderInputEnvelope = {
    data: SummaryOrderEventCreateManySummaryOrderInput | SummaryOrderEventCreateManySummaryOrderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutSummaryJournalEntriesInput = {
    update: XOR<CustomerUpdateWithoutSummaryJournalEntriesInput, CustomerUncheckedUpdateWithoutSummaryJournalEntriesInput>
    create: XOR<CustomerCreateWithoutSummaryJournalEntriesInput, CustomerUncheckedCreateWithoutSummaryJournalEntriesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSummaryJournalEntriesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSummaryJournalEntriesInput, CustomerUncheckedUpdateWithoutSummaryJournalEntriesInput>
  }

  export type CustomerUpdateWithoutSummaryJournalEntriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneWithoutCustomersNestedInput
    manager?: ManagerUpdateOneWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSummaryJournalEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ProductUpsertWithoutSummaryJournalEntriesInput = {
    update: XOR<ProductUpdateWithoutSummaryJournalEntriesInput, ProductUncheckedUpdateWithoutSummaryJournalEntriesInput>
    create: XOR<ProductCreateWithoutSummaryJournalEntriesInput, ProductUncheckedCreateWithoutSummaryJournalEntriesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSummaryJournalEntriesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSummaryJournalEntriesInput, ProductUncheckedUpdateWithoutSummaryJournalEntriesInput>
  }

  export type ProductUpdateWithoutSummaryJournalEntriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSummaryJournalEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SummaryOrderEventUpsertWithWhereUniqueWithoutSummaryOrderInput = {
    where: SummaryOrderEventWhereUniqueInput
    update: XOR<SummaryOrderEventUpdateWithoutSummaryOrderInput, SummaryOrderEventUncheckedUpdateWithoutSummaryOrderInput>
    create: XOR<SummaryOrderEventCreateWithoutSummaryOrderInput, SummaryOrderEventUncheckedCreateWithoutSummaryOrderInput>
  }

  export type SummaryOrderEventUpdateWithWhereUniqueWithoutSummaryOrderInput = {
    where: SummaryOrderEventWhereUniqueInput
    data: XOR<SummaryOrderEventUpdateWithoutSummaryOrderInput, SummaryOrderEventUncheckedUpdateWithoutSummaryOrderInput>
  }

  export type SummaryOrderEventUpdateManyWithWhereWithoutSummaryOrderInput = {
    where: SummaryOrderEventScalarWhereInput
    data: XOR<SummaryOrderEventUpdateManyMutationInput, SummaryOrderEventUncheckedUpdateManyWithoutSummaryOrderInput>
  }

  export type SummaryOrderEventScalarWhereInput = {
    AND?: SummaryOrderEventScalarWhereInput | SummaryOrderEventScalarWhereInput[]
    OR?: SummaryOrderEventScalarWhereInput[]
    NOT?: SummaryOrderEventScalarWhereInput | SummaryOrderEventScalarWhereInput[]
    id?: IntFilter<"SummaryOrderEvent"> | number
    summaryOrderId?: IntFilter<"SummaryOrderEvent"> | number
    eventType?: StringFilter<"SummaryOrderEvent"> | string
    fromStatus?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    toStatus?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    reason?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    comment?: StringNullableFilter<"SummaryOrderEvent"> | string | null
    createdAt?: DateTimeFilter<"SummaryOrderEvent"> | Date | string
    createdBy?: StringFilter<"SummaryOrderEvent"> | string
    payload?: JsonNullableFilter<"SummaryOrderEvent">
  }

  export type SummaryOrderJournalCreateWithoutEventsInput = {
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerName: string
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    preAssemblyStatus?: string | null
    assemblyStartedAt?: Date | string | null
    assemblyStartedBy?: string | null
    assemblyReturnedAt?: Date | string | null
    assemblyReturnedBy?: string | null
    assemblyReturnReason?: string | null
    assemblyReturnComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutSummaryJournalEntriesInput
    product?: ProductCreateNestedOneWithoutSummaryJournalEntriesInput
  }

  export type SummaryOrderJournalUncheckedCreateWithoutEventsInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerId?: number | null
    customerName: string
    productId?: number | null
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    preAssemblyStatus?: string | null
    assemblyStartedAt?: Date | string | null
    assemblyStartedBy?: string | null
    assemblyReturnedAt?: Date | string | null
    assemblyReturnedBy?: string | null
    assemblyReturnReason?: string | null
    assemblyReturnComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SummaryOrderJournalCreateOrConnectWithoutEventsInput = {
    where: SummaryOrderJournalWhereUniqueInput
    create: XOR<SummaryOrderJournalCreateWithoutEventsInput, SummaryOrderJournalUncheckedCreateWithoutEventsInput>
  }

  export type SummaryOrderJournalUpsertWithoutEventsInput = {
    update: XOR<SummaryOrderJournalUpdateWithoutEventsInput, SummaryOrderJournalUncheckedUpdateWithoutEventsInput>
    create: XOR<SummaryOrderJournalCreateWithoutEventsInput, SummaryOrderJournalUncheckedCreateWithoutEventsInput>
    where?: SummaryOrderJournalWhereInput
  }

  export type SummaryOrderJournalUpdateToOneWithWhereWithoutEventsInput = {
    where?: SummaryOrderJournalWhereInput
    data: XOR<SummaryOrderJournalUpdateWithoutEventsInput, SummaryOrderJournalUncheckedUpdateWithoutEventsInput>
  }

  export type SummaryOrderJournalUpdateWithoutEventsInput = {
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutSummaryJournalEntriesNestedInput
    product?: ProductUpdateOneWithoutSummaryJournalEntriesNestedInput
  }

  export type SummaryOrderJournalUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutProductionStaffInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMmls?: ProductionMmlCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutProductionStaffInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMmls?: ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocUncheckedCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutProductionStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductionStaffInput, UserUncheckedCreateWithoutProductionStaffInput>
  }

  export type ProductionJournalCreateWithoutStaffInput = {
    productionDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: ProductionItemCreateNestedManyWithoutJournalInput
  }

  export type ProductionJournalUncheckedCreateWithoutStaffInput = {
    id?: number
    productionDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: ProductionItemUncheckedCreateNestedManyWithoutJournalInput
  }

  export type ProductionJournalCreateOrConnectWithoutStaffInput = {
    where: ProductionJournalWhereUniqueInput
    create: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput>
  }

  export type ProductionJournalCreateManyStaffInputEnvelope = {
    data: ProductionJournalCreateManyStaffInput | ProductionJournalCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProductionStaffInput = {
    update: XOR<UserUpdateWithoutProductionStaffInput, UserUncheckedUpdateWithoutProductionStaffInput>
    create: XOR<UserCreateWithoutProductionStaffInput, UserUncheckedCreateWithoutProductionStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductionStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductionStaffInput, UserUncheckedUpdateWithoutProductionStaffInput>
  }

  export type UserUpdateWithoutProductionStaffInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMmls?: ProductionMmlUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProductionStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMmls?: ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUncheckedUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProductionJournalUpsertWithWhereUniqueWithoutStaffInput = {
    where: ProductionJournalWhereUniqueInput
    update: XOR<ProductionJournalUpdateWithoutStaffInput, ProductionJournalUncheckedUpdateWithoutStaffInput>
    create: XOR<ProductionJournalCreateWithoutStaffInput, ProductionJournalUncheckedCreateWithoutStaffInput>
  }

  export type ProductionJournalUpdateWithWhereUniqueWithoutStaffInput = {
    where: ProductionJournalWhereUniqueInput
    data: XOR<ProductionJournalUpdateWithoutStaffInput, ProductionJournalUncheckedUpdateWithoutStaffInput>
  }

  export type ProductionJournalUpdateManyWithWhereWithoutStaffInput = {
    where: ProductionJournalScalarWhereInput
    data: XOR<ProductionJournalUpdateManyMutationInput, ProductionJournalUncheckedUpdateManyWithoutStaffInput>
  }

  export type ProductionJournalScalarWhereInput = {
    AND?: ProductionJournalScalarWhereInput | ProductionJournalScalarWhereInput[]
    OR?: ProductionJournalScalarWhereInput[]
    NOT?: ProductionJournalScalarWhereInput | ProductionJournalScalarWhereInput[]
    id?: IntFilter<"ProductionJournal"> | number
    productionDate?: DateTimeFilter<"ProductionJournal"> | Date | string
    staffId?: IntFilter<"ProductionJournal"> | number
    status?: StringFilter<"ProductionJournal"> | string
    createdAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionJournal"> | Date | string
    createdBy?: StringFilter<"ProductionJournal"> | string
    updatedBy?: StringNullableFilter<"ProductionJournal"> | string | null
  }

  export type ProductionStaffCreateWithoutJournalsInput = {
    fullName: string
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProductionStaffInput
  }

  export type ProductionStaffUncheckedCreateWithoutJournalsInput = {
    id?: number
    fullName: string
    phone?: string | null
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionStaffCreateOrConnectWithoutJournalsInput = {
    where: ProductionStaffWhereUniqueInput
    create: XOR<ProductionStaffCreateWithoutJournalsInput, ProductionStaffUncheckedCreateWithoutJournalsInput>
  }

  export type ProductionItemCreateWithoutJournalInput = {
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    product?: ProductCreateNestedOneWithoutProductionItemsInput
    values?: ProductionItemValueCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemUncheckedCreateWithoutJournalInput = {
    id?: number
    productId?: number | null
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    values?: ProductionItemValueUncheckedCreateNestedManyWithoutProductionItemInput
  }

  export type ProductionItemCreateOrConnectWithoutJournalInput = {
    where: ProductionItemWhereUniqueInput
    create: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput>
  }

  export type ProductionItemCreateManyJournalInputEnvelope = {
    data: ProductionItemCreateManyJournalInput | ProductionItemCreateManyJournalInput[]
    skipDuplicates?: boolean
  }

  export type ProductionStaffUpsertWithoutJournalsInput = {
    update: XOR<ProductionStaffUpdateWithoutJournalsInput, ProductionStaffUncheckedUpdateWithoutJournalsInput>
    create: XOR<ProductionStaffCreateWithoutJournalsInput, ProductionStaffUncheckedCreateWithoutJournalsInput>
    where?: ProductionStaffWhereInput
  }

  export type ProductionStaffUpdateToOneWithWhereWithoutJournalsInput = {
    where?: ProductionStaffWhereInput
    data: XOR<ProductionStaffUpdateWithoutJournalsInput, ProductionStaffUncheckedUpdateWithoutJournalsInput>
  }

  export type ProductionStaffUpdateWithoutJournalsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductionStaffNestedInput
  }

  export type ProductionStaffUncheckedUpdateWithoutJournalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionItemUpsertWithWhereUniqueWithoutJournalInput = {
    where: ProductionItemWhereUniqueInput
    update: XOR<ProductionItemUpdateWithoutJournalInput, ProductionItemUncheckedUpdateWithoutJournalInput>
    create: XOR<ProductionItemCreateWithoutJournalInput, ProductionItemUncheckedCreateWithoutJournalInput>
  }

  export type ProductionItemUpdateWithWhereUniqueWithoutJournalInput = {
    where: ProductionItemWhereUniqueInput
    data: XOR<ProductionItemUpdateWithoutJournalInput, ProductionItemUncheckedUpdateWithoutJournalInput>
  }

  export type ProductionItemUpdateManyWithWhereWithoutJournalInput = {
    where: ProductionItemScalarWhereInput
    data: XOR<ProductionItemUpdateManyMutationInput, ProductionItemUncheckedUpdateManyWithoutJournalInput>
  }

  export type ProductionJournalCreateWithoutItemsInput = {
    productionDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    staff: ProductionStaffCreateNestedOneWithoutJournalsInput
  }

  export type ProductionJournalUncheckedCreateWithoutItemsInput = {
    id?: number
    productionDate: Date | string
    staffId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionJournalCreateOrConnectWithoutItemsInput = {
    where: ProductionJournalWhereUniqueInput
    create: XOR<ProductionJournalCreateWithoutItemsInput, ProductionJournalUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutProductionItemsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductionItemsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductionItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductionItemsInput, ProductUncheckedCreateWithoutProductionItemsInput>
  }

  export type ProductionItemValueCreateWithoutProductionItemInput = {
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionItemValueUncheckedCreateWithoutProductionItemInput = {
    id?: number
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionItemValueCreateOrConnectWithoutProductionItemInput = {
    where: ProductionItemValueWhereUniqueInput
    create: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput>
  }

  export type ProductionItemValueCreateManyProductionItemInputEnvelope = {
    data: ProductionItemValueCreateManyProductionItemInput | ProductionItemValueCreateManyProductionItemInput[]
    skipDuplicates?: boolean
  }

  export type ProductionJournalUpsertWithoutItemsInput = {
    update: XOR<ProductionJournalUpdateWithoutItemsInput, ProductionJournalUncheckedUpdateWithoutItemsInput>
    create: XOR<ProductionJournalCreateWithoutItemsInput, ProductionJournalUncheckedCreateWithoutItemsInput>
    where?: ProductionJournalWhereInput
  }

  export type ProductionJournalUpdateToOneWithWhereWithoutItemsInput = {
    where?: ProductionJournalWhereInput
    data: XOR<ProductionJournalUpdateWithoutItemsInput, ProductionJournalUncheckedUpdateWithoutItemsInput>
  }

  export type ProductionJournalUpdateWithoutItemsInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: ProductionStaffUpdateOneRequiredWithoutJournalsNestedInput
  }

  export type ProductionJournalUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithoutProductionItemsInput = {
    update: XOR<ProductUpdateWithoutProductionItemsInput, ProductUncheckedUpdateWithoutProductionItemsInput>
    create: XOR<ProductCreateWithoutProductionItemsInput, ProductUncheckedCreateWithoutProductionItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductionItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductionItemsInput, ProductUncheckedUpdateWithoutProductionItemsInput>
  }

  export type ProductUpdateWithoutProductionItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductionItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductionItemValueUpsertWithWhereUniqueWithoutProductionItemInput = {
    where: ProductionItemValueWhereUniqueInput
    update: XOR<ProductionItemValueUpdateWithoutProductionItemInput, ProductionItemValueUncheckedUpdateWithoutProductionItemInput>
    create: XOR<ProductionItemValueCreateWithoutProductionItemInput, ProductionItemValueUncheckedCreateWithoutProductionItemInput>
  }

  export type ProductionItemValueUpdateWithWhereUniqueWithoutProductionItemInput = {
    where: ProductionItemValueWhereUniqueInput
    data: XOR<ProductionItemValueUpdateWithoutProductionItemInput, ProductionItemValueUncheckedUpdateWithoutProductionItemInput>
  }

  export type ProductionItemValueUpdateManyWithWhereWithoutProductionItemInput = {
    where: ProductionItemValueScalarWhereInput
    data: XOR<ProductionItemValueUpdateManyMutationInput, ProductionItemValueUncheckedUpdateManyWithoutProductionItemInput>
  }

  export type ProductionItemValueScalarWhereInput = {
    AND?: ProductionItemValueScalarWhereInput | ProductionItemValueScalarWhereInput[]
    OR?: ProductionItemValueScalarWhereInput[]
    NOT?: ProductionItemValueScalarWhereInput | ProductionItemValueScalarWhereInput[]
    id?: IntFilter<"ProductionItemValue"> | number
    productionItemId?: IntFilter<"ProductionItemValue"> | number
    fieldKey?: StringFilter<"ProductionItemValue"> | string
    fieldValue?: StringNullableFilter<"ProductionItemValue"> | string | null
    updatedAt?: DateTimeFilter<"ProductionItemValue"> | Date | string
    updatedBy?: StringNullableFilter<"ProductionItemValue"> | string | null
  }

  export type ProductionItemCreateWithoutValuesInput = {
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    journal: ProductionJournalCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutProductionItemsInput
  }

  export type ProductionItemUncheckedCreateWithoutValuesInput = {
    id?: number
    journalId: number
    productId?: number | null
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionItemCreateOrConnectWithoutValuesInput = {
    where: ProductionItemWhereUniqueInput
    create: XOR<ProductionItemCreateWithoutValuesInput, ProductionItemUncheckedCreateWithoutValuesInput>
  }

  export type ProductionItemUpsertWithoutValuesInput = {
    update: XOR<ProductionItemUpdateWithoutValuesInput, ProductionItemUncheckedUpdateWithoutValuesInput>
    create: XOR<ProductionItemCreateWithoutValuesInput, ProductionItemUncheckedCreateWithoutValuesInput>
    where?: ProductionItemWhereInput
  }

  export type ProductionItemUpdateToOneWithWhereWithoutValuesInput = {
    where?: ProductionItemWhereInput
    data: XOR<ProductionItemUpdateWithoutValuesInput, ProductionItemUncheckedUpdateWithoutValuesInput>
  }

  export type ProductionItemUpdateWithoutValuesInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: ProductionJournalUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutProductionItemsNestedInput
  }

  export type ProductionItemUncheckedUpdateWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    journalId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceListSupplierCreateWithoutPriceListInput = {
    createdAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchasePriceListSuppliersInput
    primaryMml?: ProductionMmlCreateNestedOneWithoutPriceListSuppliersInput
  }

  export type PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput = {
    id?: number
    supplierId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceListSupplierCreateOrConnectWithoutPriceListInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    create: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput>
  }

  export type PurchasePriceListSupplierCreateManyPriceListInputEnvelope = {
    data: PurchasePriceListSupplierCreateManyPriceListInput | PurchasePriceListSupplierCreateManyPriceListInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceItemCreateWithoutPriceListInput = {
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchasePriceItemsInput
    product: ProductCreateNestedOneWithoutPurchasePriceItemsInput
  }

  export type PurchasePriceItemUncheckedCreateWithoutPriceListInput = {
    id?: number
    supplierId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceItemCreateOrConnectWithoutPriceListInput = {
    where: PurchasePriceItemWhereUniqueInput
    create: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput>
  }

  export type PurchasePriceItemCreateManyPriceListInputEnvelope = {
    data: PurchasePriceItemCreateManyPriceListInput | PurchasePriceItemCreateManyPriceListInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPriceListInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    update: XOR<PurchasePriceListSupplierUpdateWithoutPriceListInput, PurchasePriceListSupplierUncheckedUpdateWithoutPriceListInput>
    create: XOR<PurchasePriceListSupplierCreateWithoutPriceListInput, PurchasePriceListSupplierUncheckedCreateWithoutPriceListInput>
  }

  export type PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPriceListInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    data: XOR<PurchasePriceListSupplierUpdateWithoutPriceListInput, PurchasePriceListSupplierUncheckedUpdateWithoutPriceListInput>
  }

  export type PurchasePriceListSupplierUpdateManyWithWhereWithoutPriceListInput = {
    where: PurchasePriceListSupplierScalarWhereInput
    data: XOR<PurchasePriceListSupplierUpdateManyMutationInput, PurchasePriceListSupplierUncheckedUpdateManyWithoutPriceListInput>
  }

  export type PurchasePriceItemUpsertWithWhereUniqueWithoutPriceListInput = {
    where: PurchasePriceItemWhereUniqueInput
    update: XOR<PurchasePriceItemUpdateWithoutPriceListInput, PurchasePriceItemUncheckedUpdateWithoutPriceListInput>
    create: XOR<PurchasePriceItemCreateWithoutPriceListInput, PurchasePriceItemUncheckedCreateWithoutPriceListInput>
  }

  export type PurchasePriceItemUpdateWithWhereUniqueWithoutPriceListInput = {
    where: PurchasePriceItemWhereUniqueInput
    data: XOR<PurchasePriceItemUpdateWithoutPriceListInput, PurchasePriceItemUncheckedUpdateWithoutPriceListInput>
  }

  export type PurchasePriceItemUpdateManyWithWhereWithoutPriceListInput = {
    where: PurchasePriceItemScalarWhereInput
    data: XOR<PurchasePriceItemUpdateManyMutationInput, PurchasePriceItemUncheckedUpdateManyWithoutPriceListInput>
  }

  export type PurchasePriceListCreateWithoutSuppliersInput = {
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: PurchasePriceItemCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListUncheckedCreateWithoutSuppliersInput = {
    id?: number
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    items?: PurchasePriceItemUncheckedCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListCreateOrConnectWithoutSuppliersInput = {
    where: PurchasePriceListWhereUniqueInput
    create: XOR<PurchasePriceListCreateWithoutSuppliersInput, PurchasePriceListUncheckedCreateWithoutSuppliersInput>
  }

  export type SupplierCreateWithoutPurchasePriceListSuppliersInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchasePriceListSuppliersInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPurchasePriceListSuppliersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedCreateWithoutPurchasePriceListSuppliersInput>
  }

  export type ProductionMmlCreateWithoutPriceListSuppliersInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutPriceListSuppliersInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutPriceListSuppliersInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutPriceListSuppliersInput, ProductionMmlUncheckedCreateWithoutPriceListSuppliersInput>
  }

  export type PurchasePriceListUpsertWithoutSuppliersInput = {
    update: XOR<PurchasePriceListUpdateWithoutSuppliersInput, PurchasePriceListUncheckedUpdateWithoutSuppliersInput>
    create: XOR<PurchasePriceListCreateWithoutSuppliersInput, PurchasePriceListUncheckedCreateWithoutSuppliersInput>
    where?: PurchasePriceListWhereInput
  }

  export type PurchasePriceListUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: PurchasePriceListWhereInput
    data: XOR<PurchasePriceListUpdateWithoutSuppliersInput, PurchasePriceListUncheckedUpdateWithoutSuppliersInput>
  }

  export type PurchasePriceListUpdateWithoutSuppliersInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PurchasePriceItemUpdateManyWithoutPriceListNestedInput
  }

  export type PurchasePriceListUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PurchasePriceItemUncheckedUpdateManyWithoutPriceListNestedInput
  }

  export type SupplierUpsertWithoutPurchasePriceListSuppliersInput = {
    update: XOR<SupplierUpdateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedUpdateWithoutPurchasePriceListSuppliersInput>
    create: XOR<SupplierCreateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedCreateWithoutPurchasePriceListSuppliersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchasePriceListSuppliersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchasePriceListSuppliersInput, SupplierUncheckedUpdateWithoutPurchasePriceListSuppliersInput>
  }

  export type SupplierUpdateWithoutPurchasePriceListSuppliersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchasePriceListSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ProductionMmlUpsertWithoutPriceListSuppliersInput = {
    update: XOR<ProductionMmlUpdateWithoutPriceListSuppliersInput, ProductionMmlUncheckedUpdateWithoutPriceListSuppliersInput>
    create: XOR<ProductionMmlCreateWithoutPriceListSuppliersInput, ProductionMmlUncheckedCreateWithoutPriceListSuppliersInput>
    where?: ProductionMmlWhereInput
  }

  export type ProductionMmlUpdateToOneWithWhereWithoutPriceListSuppliersInput = {
    where?: ProductionMmlWhereInput
    data: XOR<ProductionMmlUpdateWithoutPriceListSuppliersInput, ProductionMmlUncheckedUpdateWithoutPriceListSuppliersInput>
  }

  export type ProductionMmlUpdateWithoutPriceListSuppliersInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutPriceListSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutMmlNestedInput
  }

  export type PurchasePriceListCreateWithoutItemsInput = {
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    suppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListUncheckedCreateWithoutItemsInput = {
    id?: number
    date: Date | string
    name?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    suppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPriceListInput
  }

  export type PurchasePriceListCreateOrConnectWithoutItemsInput = {
    where: PurchasePriceListWhereUniqueInput
    create: XOR<PurchasePriceListCreateWithoutItemsInput, PurchasePriceListUncheckedCreateWithoutItemsInput>
  }

  export type SupplierCreateWithoutPurchasePriceItemsInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchasePriceItemsInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPurchasePriceItemsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchasePriceItemsInput, SupplierUncheckedCreateWithoutPurchasePriceItemsInput>
  }

  export type ProductCreateWithoutPurchasePriceItemsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchasePriceItemsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchasePriceItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchasePriceItemsInput, ProductUncheckedCreateWithoutPurchasePriceItemsInput>
  }

  export type PurchasePriceListUpsertWithoutItemsInput = {
    update: XOR<PurchasePriceListUpdateWithoutItemsInput, PurchasePriceListUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchasePriceListCreateWithoutItemsInput, PurchasePriceListUncheckedCreateWithoutItemsInput>
    where?: PurchasePriceListWhereInput
  }

  export type PurchasePriceListUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchasePriceListWhereInput
    data: XOR<PurchasePriceListUpdateWithoutItemsInput, PurchasePriceListUncheckedUpdateWithoutItemsInput>
  }

  export type PurchasePriceListUpdateWithoutItemsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suppliers?: PurchasePriceListSupplierUpdateManyWithoutPriceListNestedInput
  }

  export type PurchasePriceListUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPriceListNestedInput
  }

  export type SupplierUpsertWithoutPurchasePriceItemsInput = {
    update: XOR<SupplierUpdateWithoutPurchasePriceItemsInput, SupplierUncheckedUpdateWithoutPurchasePriceItemsInput>
    create: XOR<SupplierCreateWithoutPurchasePriceItemsInput, SupplierUncheckedCreateWithoutPurchasePriceItemsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchasePriceItemsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchasePriceItemsInput, SupplierUncheckedUpdateWithoutPurchasePriceItemsInput>
  }

  export type SupplierUpdateWithoutPurchasePriceItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchasePriceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ProductUpsertWithoutPurchasePriceItemsInput = {
    update: XOR<ProductUpdateWithoutPurchasePriceItemsInput, ProductUncheckedUpdateWithoutPurchasePriceItemsInput>
    create: XOR<ProductCreateWithoutPurchasePriceItemsInput, ProductUncheckedCreateWithoutPurchasePriceItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchasePriceItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchasePriceItemsInput, ProductUncheckedUpdateWithoutPurchasePriceItemsInput>
  }

  export type ProductUpdateWithoutPurchasePriceItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchasePriceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CustomerCreateWithoutSalesPriceListsInput = {
    code: string
    name: string
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: DistrictCreateNestedOneWithoutCustomersInput
    manager?: ManagerCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesPriceListsInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutCustomerInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesPriceListsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesPriceListsInput, CustomerUncheckedCreateWithoutSalesPriceListsInput>
  }

  export type SalesPriceItemCreateWithoutPriceListInput = {
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    product: ProductCreateNestedOneWithoutSalesPriceItemsInput
  }

  export type SalesPriceItemUncheckedCreateWithoutPriceListInput = {
    id?: number
    productId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SalesPriceItemCreateOrConnectWithoutPriceListInput = {
    where: SalesPriceItemWhereUniqueInput
    create: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput>
  }

  export type SalesPriceItemCreateManyPriceListInputEnvelope = {
    data: SalesPriceItemCreateManyPriceListInput | SalesPriceItemCreateManyPriceListInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutSalesPriceListsInput = {
    update: XOR<CustomerUpdateWithoutSalesPriceListsInput, CustomerUncheckedUpdateWithoutSalesPriceListsInput>
    create: XOR<CustomerCreateWithoutSalesPriceListsInput, CustomerUncheckedCreateWithoutSalesPriceListsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesPriceListsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesPriceListsInput, CustomerUncheckedUpdateWithoutSalesPriceListsInput>
  }

  export type CustomerUpdateWithoutSalesPriceListsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneWithoutCustomersNestedInput
    manager?: ManagerUpdateOneWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesPriceListsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SalesPriceItemUpsertWithWhereUniqueWithoutPriceListInput = {
    where: SalesPriceItemWhereUniqueInput
    update: XOR<SalesPriceItemUpdateWithoutPriceListInput, SalesPriceItemUncheckedUpdateWithoutPriceListInput>
    create: XOR<SalesPriceItemCreateWithoutPriceListInput, SalesPriceItemUncheckedCreateWithoutPriceListInput>
  }

  export type SalesPriceItemUpdateWithWhereUniqueWithoutPriceListInput = {
    where: SalesPriceItemWhereUniqueInput
    data: XOR<SalesPriceItemUpdateWithoutPriceListInput, SalesPriceItemUncheckedUpdateWithoutPriceListInput>
  }

  export type SalesPriceItemUpdateManyWithWhereWithoutPriceListInput = {
    where: SalesPriceItemScalarWhereInput
    data: XOR<SalesPriceItemUpdateManyMutationInput, SalesPriceItemUncheckedUpdateManyWithoutPriceListInput>
  }

  export type SalesPriceListCreateWithoutItemsInput = {
    listType: string
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    customer?: CustomerCreateNestedOneWithoutSalesPriceListsInput
  }

  export type SalesPriceListUncheckedCreateWithoutItemsInput = {
    id?: number
    listType: string
    customerId?: number | null
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type SalesPriceListCreateOrConnectWithoutItemsInput = {
    where: SalesPriceListWhereUniqueInput
    create: XOR<SalesPriceListCreateWithoutItemsInput, SalesPriceListUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutSalesPriceItemsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSalesPriceItemsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSalesPriceItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSalesPriceItemsInput, ProductUncheckedCreateWithoutSalesPriceItemsInput>
  }

  export type SalesPriceListUpsertWithoutItemsInput = {
    update: XOR<SalesPriceListUpdateWithoutItemsInput, SalesPriceListUncheckedUpdateWithoutItemsInput>
    create: XOR<SalesPriceListCreateWithoutItemsInput, SalesPriceListUncheckedCreateWithoutItemsInput>
    where?: SalesPriceListWhereInput
  }

  export type SalesPriceListUpdateToOneWithWhereWithoutItemsInput = {
    where?: SalesPriceListWhereInput
    data: XOR<SalesPriceListUpdateWithoutItemsInput, SalesPriceListUncheckedUpdateWithoutItemsInput>
  }

  export type SalesPriceListUpdateWithoutItemsInput = {
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutSalesPriceListsNestedInput
  }

  export type SalesPriceListUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    listType?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithoutSalesPriceItemsInput = {
    update: XOR<ProductUpdateWithoutSalesPriceItemsInput, ProductUncheckedUpdateWithoutSalesPriceItemsInput>
    create: XOR<ProductCreateWithoutSalesPriceItemsInput, ProductUncheckedCreateWithoutSalesPriceItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSalesPriceItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSalesPriceItemsInput, ProductUncheckedUpdateWithoutSalesPriceItemsInput>
  }

  export type ProductUpdateWithoutSalesPriceItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSalesPriceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutProductionMmlsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductionMmlsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductionMmlsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductionMmlsInput, ProductUncheckedCreateWithoutProductionMmlsInput>
  }

  export type UserCreateWithoutCreatedMmlsInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffCreateNestedOneWithoutUserInput
    productionRuns?: ProductionRunCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedMmlsInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffUncheckedCreateNestedOneWithoutUserInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocUncheckedCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedMmlsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedMmlsInput, UserUncheckedCreateWithoutCreatedMmlsInput>
  }

  export type ProductionMmlNodeCreateWithoutMmlInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentNode?: ProductionMmlNodeCreateNestedOneWithoutChildrenInput
    children?: ProductionMmlNodeCreateNestedManyWithoutParentNodeInput
    product: ProductCreateNestedOneWithoutMmlNodesInput
    runValues?: ProductionRunValueCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUncheckedCreateWithoutMmlInput = {
    id?: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput
    runValues?: ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeCreateOrConnectWithoutMmlInput = {
    where: ProductionMmlNodeWhereUniqueInput
    create: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput>
  }

  export type ProductionMmlNodeCreateManyMmlInputEnvelope = {
    data: ProductionMmlNodeCreateManyMmlInput | ProductionMmlNodeCreateManyMmlInput[]
    skipDuplicates?: boolean
  }

  export type ProductionRunCreateWithoutMmlInput = {
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionRunsInput
    user: UserCreateNestedOneWithoutProductionRunsInput
    values?: ProductionRunValueCreateNestedManyWithoutRunInput
  }

  export type ProductionRunUncheckedCreateWithoutMmlInput = {
    id?: number
    productId: number
    userId: number
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: ProductionRunValueUncheckedCreateNestedManyWithoutRunInput
  }

  export type ProductionRunCreateOrConnectWithoutMmlInput = {
    where: ProductionRunWhereUniqueInput
    create: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput>
  }

  export type ProductionRunCreateManyMmlInputEnvelope = {
    data: ProductionRunCreateManyMmlInput | ProductionRunCreateManyMmlInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutPrimaryMmlInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPrimaryMmlInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPrimaryMmlInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput>
  }

  export type SupplierCreateManyPrimaryMmlInputEnvelope = {
    data: SupplierCreateManyPrimaryMmlInput | SupplierCreateManyPrimaryMmlInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePriceListSupplierCreateWithoutPrimaryMmlInput = {
    createdAt?: Date | string
    priceList: PurchasePriceListCreateNestedOneWithoutSuppliersInput
    supplier: SupplierCreateNestedOneWithoutPurchasePriceListSuppliersInput
  }

  export type PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput = {
    id?: number
    priceListId: number
    supplierId: number
    createdAt?: Date | string
  }

  export type PurchasePriceListSupplierCreateOrConnectWithoutPrimaryMmlInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    create: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput>
  }

  export type PurchasePriceListSupplierCreateManyPrimaryMmlInputEnvelope = {
    data: PurchasePriceListSupplierCreateManyPrimaryMmlInput | PurchasePriceListSupplierCreateManyPrimaryMmlInput[]
    skipDuplicates?: boolean
  }

  export type ProductionCuttingLineCreateWithoutMmlInput = {
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutCuttingLinesInput
    productionInput: ProductionInputCreateNestedOneWithoutCuttingLinesInput
    outProduct: ProductCreateNestedOneWithoutCuttingLineOutputsInput
    createdBy: UserCreateNestedOneWithoutCuttingLinesInput
  }

  export type ProductionCuttingLineUncheckedCreateWithoutMmlInput = {
    id?: number
    productionDocId: number
    productionInputId: number
    outProductId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdByUserId: number
  }

  export type ProductionCuttingLineCreateOrConnectWithoutMmlInput = {
    where: ProductionCuttingLineWhereUniqueInput
    create: XOR<ProductionCuttingLineCreateWithoutMmlInput, ProductionCuttingLineUncheckedCreateWithoutMmlInput>
  }

  export type ProductionCuttingLineCreateManyMmlInputEnvelope = {
    data: ProductionCuttingLineCreateManyMmlInput | ProductionCuttingLineCreateManyMmlInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutProductionMmlsInput = {
    update: XOR<ProductUpdateWithoutProductionMmlsInput, ProductUncheckedUpdateWithoutProductionMmlsInput>
    create: XOR<ProductCreateWithoutProductionMmlsInput, ProductUncheckedCreateWithoutProductionMmlsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductionMmlsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductionMmlsInput, ProductUncheckedUpdateWithoutProductionMmlsInput>
  }

  export type ProductUpdateWithoutProductionMmlsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductionMmlsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutCreatedMmlsInput = {
    update: XOR<UserUpdateWithoutCreatedMmlsInput, UserUncheckedUpdateWithoutCreatedMmlsInput>
    create: XOR<UserCreateWithoutCreatedMmlsInput, UserUncheckedCreateWithoutCreatedMmlsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedMmlsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedMmlsInput, UserUncheckedUpdateWithoutCreatedMmlsInput>
  }

  export type UserUpdateWithoutCreatedMmlsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUpdateOneWithoutUserNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedMmlsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUncheckedUpdateOneWithoutUserNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUncheckedUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProductionMmlNodeUpsertWithWhereUniqueWithoutMmlInput = {
    where: ProductionMmlNodeWhereUniqueInput
    update: XOR<ProductionMmlNodeUpdateWithoutMmlInput, ProductionMmlNodeUncheckedUpdateWithoutMmlInput>
    create: XOR<ProductionMmlNodeCreateWithoutMmlInput, ProductionMmlNodeUncheckedCreateWithoutMmlInput>
  }

  export type ProductionMmlNodeUpdateWithWhereUniqueWithoutMmlInput = {
    where: ProductionMmlNodeWhereUniqueInput
    data: XOR<ProductionMmlNodeUpdateWithoutMmlInput, ProductionMmlNodeUncheckedUpdateWithoutMmlInput>
  }

  export type ProductionMmlNodeUpdateManyWithWhereWithoutMmlInput = {
    where: ProductionMmlNodeScalarWhereInput
    data: XOR<ProductionMmlNodeUpdateManyMutationInput, ProductionMmlNodeUncheckedUpdateManyWithoutMmlInput>
  }

  export type ProductionRunUpsertWithWhereUniqueWithoutMmlInput = {
    where: ProductionRunWhereUniqueInput
    update: XOR<ProductionRunUpdateWithoutMmlInput, ProductionRunUncheckedUpdateWithoutMmlInput>
    create: XOR<ProductionRunCreateWithoutMmlInput, ProductionRunUncheckedCreateWithoutMmlInput>
  }

  export type ProductionRunUpdateWithWhereUniqueWithoutMmlInput = {
    where: ProductionRunWhereUniqueInput
    data: XOR<ProductionRunUpdateWithoutMmlInput, ProductionRunUncheckedUpdateWithoutMmlInput>
  }

  export type ProductionRunUpdateManyWithWhereWithoutMmlInput = {
    where: ProductionRunScalarWhereInput
    data: XOR<ProductionRunUpdateManyMutationInput, ProductionRunUncheckedUpdateManyWithoutMmlInput>
  }

  export type SupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutPrimaryMmlInput, SupplierUncheckedUpdateWithoutPrimaryMmlInput>
    create: XOR<SupplierCreateWithoutPrimaryMmlInput, SupplierUncheckedCreateWithoutPrimaryMmlInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutPrimaryMmlInput, SupplierUncheckedUpdateWithoutPrimaryMmlInput>
  }

  export type SupplierUpdateManyWithWhereWithoutPrimaryMmlInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutPrimaryMmlInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: IntFilter<"Supplier"> | number
    code?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    legalName?: StringNullableFilter<"Supplier"> | string | null
    altName?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    telegram?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    primaryMmlId?: IntNullableFilter<"Supplier"> | number | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
  }

  export type PurchasePriceListSupplierUpsertWithWhereUniqueWithoutPrimaryMmlInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    update: XOR<PurchasePriceListSupplierUpdateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedUpdateWithoutPrimaryMmlInput>
    create: XOR<PurchasePriceListSupplierCreateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedCreateWithoutPrimaryMmlInput>
  }

  export type PurchasePriceListSupplierUpdateWithWhereUniqueWithoutPrimaryMmlInput = {
    where: PurchasePriceListSupplierWhereUniqueInput
    data: XOR<PurchasePriceListSupplierUpdateWithoutPrimaryMmlInput, PurchasePriceListSupplierUncheckedUpdateWithoutPrimaryMmlInput>
  }

  export type PurchasePriceListSupplierUpdateManyWithWhereWithoutPrimaryMmlInput = {
    where: PurchasePriceListSupplierScalarWhereInput
    data: XOR<PurchasePriceListSupplierUpdateManyMutationInput, PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlInput>
  }

  export type ProductionCuttingLineUpsertWithWhereUniqueWithoutMmlInput = {
    where: ProductionCuttingLineWhereUniqueInput
    update: XOR<ProductionCuttingLineUpdateWithoutMmlInput, ProductionCuttingLineUncheckedUpdateWithoutMmlInput>
    create: XOR<ProductionCuttingLineCreateWithoutMmlInput, ProductionCuttingLineUncheckedCreateWithoutMmlInput>
  }

  export type ProductionCuttingLineUpdateWithWhereUniqueWithoutMmlInput = {
    where: ProductionCuttingLineWhereUniqueInput
    data: XOR<ProductionCuttingLineUpdateWithoutMmlInput, ProductionCuttingLineUncheckedUpdateWithoutMmlInput>
  }

  export type ProductionCuttingLineUpdateManyWithWhereWithoutMmlInput = {
    where: ProductionCuttingLineScalarWhereInput
    data: XOR<ProductionCuttingLineUpdateManyMutationInput, ProductionCuttingLineUncheckedUpdateManyWithoutMmlInput>
  }

  export type ProductionMmlCreateWithoutNodesInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutNodesInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutNodesInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutNodesInput, ProductionMmlUncheckedCreateWithoutNodesInput>
  }

  export type ProductionMmlNodeCreateWithoutChildrenInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutNodesInput
    parentNode?: ProductionMmlNodeCreateNestedOneWithoutChildrenInput
    product: ProductCreateNestedOneWithoutMmlNodesInput
    runValues?: ProductionRunValueCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUncheckedCreateWithoutChildrenInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    runValues?: ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeCreateOrConnectWithoutChildrenInput = {
    where: ProductionMmlNodeWhereUniqueInput
    create: XOR<ProductionMmlNodeCreateWithoutChildrenInput, ProductionMmlNodeUncheckedCreateWithoutChildrenInput>
  }

  export type ProductionMmlNodeCreateWithoutParentNodeInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutNodesInput
    children?: ProductionMmlNodeCreateNestedManyWithoutParentNodeInput
    product: ProductCreateNestedOneWithoutMmlNodesInput
    runValues?: ProductionRunValueCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeUncheckedCreateWithoutParentNodeInput = {
    id?: number
    mmlId: number
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput
    runValues?: ProductionRunValueUncheckedCreateNestedManyWithoutNodeInput
  }

  export type ProductionMmlNodeCreateOrConnectWithoutParentNodeInput = {
    where: ProductionMmlNodeWhereUniqueInput
    create: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput>
  }

  export type ProductionMmlNodeCreateManyParentNodeInputEnvelope = {
    data: ProductionMmlNodeCreateManyParentNodeInput | ProductionMmlNodeCreateManyParentNodeInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutMmlNodesInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutMmlNodesInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutMmlNodesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMmlNodesInput, ProductUncheckedCreateWithoutMmlNodesInput>
  }

  export type ProductionRunValueCreateWithoutNodeInput = {
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    run: ProductionRunCreateNestedOneWithoutValuesInput
    snapshotProduct?: ProductCreateNestedOneWithoutRunValueSnapshotsInput
  }

  export type ProductionRunValueUncheckedCreateWithoutNodeInput = {
    id?: number
    productionRunId: number
    snapshotProductId?: number | null
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueCreateOrConnectWithoutNodeInput = {
    where: ProductionRunValueWhereUniqueInput
    create: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput>
  }

  export type ProductionRunValueCreateManyNodeInputEnvelope = {
    data: ProductionRunValueCreateManyNodeInput | ProductionRunValueCreateManyNodeInput[]
    skipDuplicates?: boolean
  }

  export type ProductionMmlUpsertWithoutNodesInput = {
    update: XOR<ProductionMmlUpdateWithoutNodesInput, ProductionMmlUncheckedUpdateWithoutNodesInput>
    create: XOR<ProductionMmlCreateWithoutNodesInput, ProductionMmlUncheckedCreateWithoutNodesInput>
    where?: ProductionMmlWhereInput
  }

  export type ProductionMmlUpdateToOneWithWhereWithoutNodesInput = {
    where?: ProductionMmlWhereInput
    data: XOR<ProductionMmlUpdateWithoutNodesInput, ProductionMmlUncheckedUpdateWithoutNodesInput>
  }

  export type ProductionMmlUpdateWithoutNodesInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutNodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutMmlNestedInput
  }

  export type ProductionMmlNodeUpsertWithoutChildrenInput = {
    update: XOR<ProductionMmlNodeUpdateWithoutChildrenInput, ProductionMmlNodeUncheckedUpdateWithoutChildrenInput>
    create: XOR<ProductionMmlNodeCreateWithoutChildrenInput, ProductionMmlNodeUncheckedCreateWithoutChildrenInput>
    where?: ProductionMmlNodeWhereInput
  }

  export type ProductionMmlNodeUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ProductionMmlNodeWhereInput
    data: XOR<ProductionMmlNodeUpdateWithoutChildrenInput, ProductionMmlNodeUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductionMmlNodeUpdateWithoutChildrenInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutNodesNestedInput
    parentNode?: ProductionMmlNodeUpdateOneWithoutChildrenNestedInput
    product?: ProductUpdateOneRequiredWithoutMmlNodesNestedInput
    runValues?: ProductionRunValueUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runValues?: ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUpsertWithWhereUniqueWithoutParentNodeInput = {
    where: ProductionMmlNodeWhereUniqueInput
    update: XOR<ProductionMmlNodeUpdateWithoutParentNodeInput, ProductionMmlNodeUncheckedUpdateWithoutParentNodeInput>
    create: XOR<ProductionMmlNodeCreateWithoutParentNodeInput, ProductionMmlNodeUncheckedCreateWithoutParentNodeInput>
  }

  export type ProductionMmlNodeUpdateWithWhereUniqueWithoutParentNodeInput = {
    where: ProductionMmlNodeWhereUniqueInput
    data: XOR<ProductionMmlNodeUpdateWithoutParentNodeInput, ProductionMmlNodeUncheckedUpdateWithoutParentNodeInput>
  }

  export type ProductionMmlNodeUpdateManyWithWhereWithoutParentNodeInput = {
    where: ProductionMmlNodeScalarWhereInput
    data: XOR<ProductionMmlNodeUpdateManyMutationInput, ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeInput>
  }

  export type ProductUpsertWithoutMmlNodesInput = {
    update: XOR<ProductUpdateWithoutMmlNodesInput, ProductUncheckedUpdateWithoutMmlNodesInput>
    create: XOR<ProductCreateWithoutMmlNodesInput, ProductUncheckedCreateWithoutMmlNodesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutMmlNodesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutMmlNodesInput, ProductUncheckedUpdateWithoutMmlNodesInput>
  }

  export type ProductUpdateWithoutMmlNodesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutMmlNodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductionRunValueUpsertWithWhereUniqueWithoutNodeInput = {
    where: ProductionRunValueWhereUniqueInput
    update: XOR<ProductionRunValueUpdateWithoutNodeInput, ProductionRunValueUncheckedUpdateWithoutNodeInput>
    create: XOR<ProductionRunValueCreateWithoutNodeInput, ProductionRunValueUncheckedCreateWithoutNodeInput>
  }

  export type ProductionRunValueUpdateWithWhereUniqueWithoutNodeInput = {
    where: ProductionRunValueWhereUniqueInput
    data: XOR<ProductionRunValueUpdateWithoutNodeInput, ProductionRunValueUncheckedUpdateWithoutNodeInput>
  }

  export type ProductionRunValueUpdateManyWithWhereWithoutNodeInput = {
    where: ProductionRunValueScalarWhereInput
    data: XOR<ProductionRunValueUpdateManyMutationInput, ProductionRunValueUncheckedUpdateManyWithoutNodeInput>
  }

  export type ProductCreateWithoutProductionRunsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductionRunsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductionRunsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductionRunsInput, ProductUncheckedCreateWithoutProductionRunsInput>
  }

  export type ProductionMmlCreateWithoutRunsInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutRunsInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutRunsInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutRunsInput, ProductionMmlUncheckedCreateWithoutRunsInput>
  }

  export type UserCreateWithoutProductionRunsInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutProductionRunsInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffUncheckedCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocUncheckedCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutProductionRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductionRunsInput, UserUncheckedCreateWithoutProductionRunsInput>
  }

  export type ProductionRunValueCreateWithoutRunInput = {
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    node: ProductionMmlNodeCreateNestedOneWithoutRunValuesInput
    snapshotProduct?: ProductCreateNestedOneWithoutRunValueSnapshotsInput
  }

  export type ProductionRunValueUncheckedCreateWithoutRunInput = {
    id?: number
    mmlNodeId: number
    snapshotProductId?: number | null
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueCreateOrConnectWithoutRunInput = {
    where: ProductionRunValueWhereUniqueInput
    create: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput>
  }

  export type ProductionRunValueCreateManyRunInputEnvelope = {
    data: ProductionRunValueCreateManyRunInput | ProductionRunValueCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutProductionRunsInput = {
    update: XOR<ProductUpdateWithoutProductionRunsInput, ProductUncheckedUpdateWithoutProductionRunsInput>
    create: XOR<ProductCreateWithoutProductionRunsInput, ProductUncheckedCreateWithoutProductionRunsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductionRunsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductionRunsInput, ProductUncheckedUpdateWithoutProductionRunsInput>
  }

  export type ProductUpdateWithoutProductionRunsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductionRunsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductionMmlUpsertWithoutRunsInput = {
    update: XOR<ProductionMmlUpdateWithoutRunsInput, ProductionMmlUncheckedUpdateWithoutRunsInput>
    create: XOR<ProductionMmlCreateWithoutRunsInput, ProductionMmlUncheckedCreateWithoutRunsInput>
    where?: ProductionMmlWhereInput
  }

  export type ProductionMmlUpdateToOneWithWhereWithoutRunsInput = {
    where?: ProductionMmlWhereInput
    data: XOR<ProductionMmlUpdateWithoutRunsInput, ProductionMmlUncheckedUpdateWithoutRunsInput>
  }

  export type ProductionMmlUpdateWithoutRunsInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutRunsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutMmlNestedInput
  }

  export type UserUpsertWithoutProductionRunsInput = {
    update: XOR<UserUpdateWithoutProductionRunsInput, UserUncheckedUpdateWithoutProductionRunsInput>
    create: XOR<UserCreateWithoutProductionRunsInput, UserUncheckedCreateWithoutProductionRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductionRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductionRunsInput, UserUncheckedUpdateWithoutProductionRunsInput>
  }

  export type UserUpdateWithoutProductionRunsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProductionRunsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUncheckedUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUncheckedUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProductionRunValueUpsertWithWhereUniqueWithoutRunInput = {
    where: ProductionRunValueWhereUniqueInput
    update: XOR<ProductionRunValueUpdateWithoutRunInput, ProductionRunValueUncheckedUpdateWithoutRunInput>
    create: XOR<ProductionRunValueCreateWithoutRunInput, ProductionRunValueUncheckedCreateWithoutRunInput>
  }

  export type ProductionRunValueUpdateWithWhereUniqueWithoutRunInput = {
    where: ProductionRunValueWhereUniqueInput
    data: XOR<ProductionRunValueUpdateWithoutRunInput, ProductionRunValueUncheckedUpdateWithoutRunInput>
  }

  export type ProductionRunValueUpdateManyWithWhereWithoutRunInput = {
    where: ProductionRunValueScalarWhereInput
    data: XOR<ProductionRunValueUpdateManyMutationInput, ProductionRunValueUncheckedUpdateManyWithoutRunInput>
  }

  export type ProductionRunCreateWithoutValuesInput = {
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionRunsInput
    mml: ProductionMmlCreateNestedOneWithoutRunsInput
    user: UserCreateNestedOneWithoutProductionRunsInput
  }

  export type ProductionRunUncheckedCreateWithoutValuesInput = {
    id?: number
    productId: number
    mmlId: number
    userId: number
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunCreateOrConnectWithoutValuesInput = {
    where: ProductionRunWhereUniqueInput
    create: XOR<ProductionRunCreateWithoutValuesInput, ProductionRunUncheckedCreateWithoutValuesInput>
  }

  export type ProductionMmlNodeCreateWithoutRunValuesInput = {
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mml: ProductionMmlCreateNestedOneWithoutNodesInput
    parentNode?: ProductionMmlNodeCreateNestedOneWithoutChildrenInput
    children?: ProductionMmlNodeCreateNestedManyWithoutParentNodeInput
    product: ProductCreateNestedOneWithoutMmlNodesInput
  }

  export type ProductionMmlNodeUncheckedCreateWithoutRunValuesInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductionMmlNodeUncheckedCreateNestedManyWithoutParentNodeInput
  }

  export type ProductionMmlNodeCreateOrConnectWithoutRunValuesInput = {
    where: ProductionMmlNodeWhereUniqueInput
    create: XOR<ProductionMmlNodeCreateWithoutRunValuesInput, ProductionMmlNodeUncheckedCreateWithoutRunValuesInput>
  }

  export type ProductCreateWithoutRunValueSnapshotsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRunValueSnapshotsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRunValueSnapshotsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRunValueSnapshotsInput, ProductUncheckedCreateWithoutRunValueSnapshotsInput>
  }

  export type ProductionRunUpsertWithoutValuesInput = {
    update: XOR<ProductionRunUpdateWithoutValuesInput, ProductionRunUncheckedUpdateWithoutValuesInput>
    create: XOR<ProductionRunCreateWithoutValuesInput, ProductionRunUncheckedCreateWithoutValuesInput>
    where?: ProductionRunWhereInput
  }

  export type ProductionRunUpdateToOneWithWhereWithoutValuesInput = {
    where?: ProductionRunWhereInput
    data: XOR<ProductionRunUpdateWithoutValuesInput, ProductionRunUncheckedUpdateWithoutValuesInput>
  }

  export type ProductionRunUpdateWithoutValuesInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionRunsNestedInput
    mml?: ProductionMmlUpdateOneRequiredWithoutRunsNestedInput
    user?: UserUpdateOneRequiredWithoutProductionRunsNestedInput
  }

  export type ProductionRunUncheckedUpdateWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionMmlNodeUpsertWithoutRunValuesInput = {
    update: XOR<ProductionMmlNodeUpdateWithoutRunValuesInput, ProductionMmlNodeUncheckedUpdateWithoutRunValuesInput>
    create: XOR<ProductionMmlNodeCreateWithoutRunValuesInput, ProductionMmlNodeUncheckedCreateWithoutRunValuesInput>
    where?: ProductionMmlNodeWhereInput
  }

  export type ProductionMmlNodeUpdateToOneWithWhereWithoutRunValuesInput = {
    where?: ProductionMmlNodeWhereInput
    data: XOR<ProductionMmlNodeUpdateWithoutRunValuesInput, ProductionMmlNodeUncheckedUpdateWithoutRunValuesInput>
  }

  export type ProductionMmlNodeUpdateWithoutRunValuesInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutNodesNestedInput
    parentNode?: ProductionMmlNodeUpdateOneWithoutChildrenNestedInput
    children?: ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput
    product?: ProductUpdateOneRequiredWithoutMmlNodesNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateWithoutRunValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput
  }

  export type ProductUpsertWithoutRunValueSnapshotsInput = {
    update: XOR<ProductUpdateWithoutRunValueSnapshotsInput, ProductUncheckedUpdateWithoutRunValueSnapshotsInput>
    create: XOR<ProductCreateWithoutRunValueSnapshotsInput, ProductUncheckedCreateWithoutRunValueSnapshotsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRunValueSnapshotsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRunValueSnapshotsInput, ProductUncheckedUpdateWithoutRunValueSnapshotsInput>
  }

  export type ProductUpdateWithoutRunValueSnapshotsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRunValueSnapshotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PurchaseItemCreateWithoutPaymentTypeInput = {
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    supplier: SupplierCreateNestedOneWithoutPurchaseItemsInput
    product: ProductCreateNestedOneWithoutPurchaseItemsRelInput
    productionInputs?: ProductionInputCreateNestedManyWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateWithoutPaymentTypeInput = {
    id?: number
    purchaseId: number
    supplierId: number
    productId: number
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutPurchaseItemInput
  }

  export type PurchaseItemCreateOrConnectWithoutPaymentTypeInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutPaymentTypeInput, PurchaseItemUncheckedCreateWithoutPaymentTypeInput>
  }

  export type PurchaseItemCreateManyPaymentTypeInputEnvelope = {
    data: PurchaseItemCreateManyPaymentTypeInput | PurchaseItemCreateManyPaymentTypeInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutPaymentTypeInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutPaymentTypeInput, PurchaseItemUncheckedUpdateWithoutPaymentTypeInput>
    create: XOR<PurchaseItemCreateWithoutPaymentTypeInput, PurchaseItemUncheckedCreateWithoutPaymentTypeInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutPaymentTypeInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutPaymentTypeInput, PurchaseItemUncheckedUpdateWithoutPaymentTypeInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutPaymentTypeInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutPaymentTypeInput>
  }

  export type UserCreateWithoutPurchasesInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunCreateNestedManyWithoutUserInput
    warehouses?: WarehouseCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutPurchasesInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffUncheckedCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutUserInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocUncheckedCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutPurchasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchaseSupplierCreateWithoutPurchaseInput = {
    createdAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseSupplierUncheckedCreateWithoutPurchaseInput = {
    id?: number
    supplierId: number
    createdAt?: Date | string
  }

  export type PurchaseSupplierCreateOrConnectWithoutPurchaseInput = {
    where: PurchaseSupplierWhereUniqueInput
    create: XOR<PurchaseSupplierCreateWithoutPurchaseInput, PurchaseSupplierUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseSupplierCreateManyPurchaseInputEnvelope = {
    data: PurchaseSupplierCreateManyPurchaseInput | PurchaseSupplierCreateManyPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseItemCreateWithoutPurchaseInput = {
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseItemsInput
    product: ProductCreateNestedOneWithoutPurchaseItemsRelInput
    paymentType?: PaymentTypeCreateNestedOneWithoutPurchaseItemsInput
    productionInputs?: ProductionInputCreateNestedManyWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateWithoutPurchaseInput = {
    id?: number
    supplierId: number
    productId: number
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    paymentTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutPurchaseItemInput
  }

  export type PurchaseItemCreateOrConnectWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemCreateManyPurchaseInputEnvelope = {
    data: PurchaseItemCreateManyPurchaseInput | PurchaseItemCreateManyPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type ProductionInputCreateWithoutPurchaseInput = {
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutInputsInput
    purchaseItem: PurchaseItemCreateNestedOneWithoutProductionInputsInput
    product: ProductCreateNestedOneWithoutProductionInputsInput
    warehouse: WarehouseCreateNestedOneWithoutProductionInputsInput
    loadedBy: UserCreateNestedOneWithoutProductionInputsInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputUncheckedCreateWithoutPurchaseInput = {
    id?: number
    productionDocId: number
    purchaseItemId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputCreateOrConnectWithoutPurchaseInput = {
    where: ProductionInputWhereUniqueInput
    create: XOR<ProductionInputCreateWithoutPurchaseInput, ProductionInputUncheckedCreateWithoutPurchaseInput>
  }

  export type ProductionInputCreateManyPurchaseInputEnvelope = {
    data: ProductionInputCreateManyPurchaseInput | ProductionInputCreateManyPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPurchasesInput = {
    update: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserUpdateWithoutPurchasesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutUserNestedInput
    warehouses?: WarehouseUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUncheckedUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutUserNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUncheckedUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type PurchaseSupplierUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseSupplierWhereUniqueInput
    update: XOR<PurchaseSupplierUpdateWithoutPurchaseInput, PurchaseSupplierUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PurchaseSupplierCreateWithoutPurchaseInput, PurchaseSupplierUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseSupplierUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseSupplierWhereUniqueInput
    data: XOR<PurchaseSupplierUpdateWithoutPurchaseInput, PurchaseSupplierUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchaseSupplierUpdateManyWithWhereWithoutPurchaseInput = {
    where: PurchaseSupplierScalarWhereInput
    data: XOR<PurchaseSupplierUpdateManyMutationInput, PurchaseSupplierUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutPurchaseInput, PurchaseItemUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutPurchaseInput, PurchaseItemUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutPurchaseInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type ProductionInputUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: ProductionInputWhereUniqueInput
    update: XOR<ProductionInputUpdateWithoutPurchaseInput, ProductionInputUncheckedUpdateWithoutPurchaseInput>
    create: XOR<ProductionInputCreateWithoutPurchaseInput, ProductionInputUncheckedCreateWithoutPurchaseInput>
  }

  export type ProductionInputUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: ProductionInputWhereUniqueInput
    data: XOR<ProductionInputUpdateWithoutPurchaseInput, ProductionInputUncheckedUpdateWithoutPurchaseInput>
  }

  export type ProductionInputUpdateManyWithWhereWithoutPurchaseInput = {
    where: ProductionInputScalarWhereInput
    data: XOR<ProductionInputUpdateManyMutationInput, ProductionInputUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type PurchaseCreateWithoutSuppliersInput = {
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUser: UserCreateNestedOneWithoutPurchasesInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
    productionInputs?: ProductionInputCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutSuppliersInput = {
    id?: number
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    createdByUserId: number
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutSuppliersInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutSuppliersInput, PurchaseUncheckedCreateWithoutSuppliersInput>
  }

  export type SupplierCreateWithoutPurchasesInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchasesInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPurchasesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchasesInput, SupplierUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchaseUpsertWithoutSuppliersInput = {
    update: XOR<PurchaseUpdateWithoutSuppliersInput, PurchaseUncheckedUpdateWithoutSuppliersInput>
    create: XOR<PurchaseCreateWithoutSuppliersInput, PurchaseUncheckedCreateWithoutSuppliersInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutSuppliersInput, PurchaseUncheckedUpdateWithoutSuppliersInput>
  }

  export type PurchaseUpdateWithoutSuppliersInput = {
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdByUserId?: IntFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type SupplierUpsertWithoutPurchasesInput = {
    update: XOR<SupplierUpdateWithoutPurchasesInput, SupplierUncheckedUpdateWithoutPurchasesInput>
    create: XOR<SupplierCreateWithoutPurchasesInput, SupplierUncheckedCreateWithoutPurchasesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchasesInput, SupplierUncheckedUpdateWithoutPurchasesInput>
  }

  export type SupplierUpdateWithoutPurchasesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type PurchaseCreateWithoutItemsInput = {
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUser: UserCreateNestedOneWithoutPurchasesInput
    suppliers?: PurchaseSupplierCreateNestedManyWithoutPurchaseInput
    productionInputs?: ProductionInputCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutItemsInput = {
    id?: number
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    createdByUserId: number
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: PurchaseSupplierUncheckedCreateNestedManyWithoutPurchaseInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutItemsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
  }

  export type SupplierCreateWithoutPurchaseItemsInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchaseItemsInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPurchaseItemsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseItemsInput, SupplierUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type ProductCreateWithoutPurchaseItemsRelInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseItemsRelInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseItemsRelInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseItemsRelInput, ProductUncheckedCreateWithoutPurchaseItemsRelInput>
  }

  export type PaymentTypeCreateWithoutPurchaseItemsInput = {
    name: string
    isDefault?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTypeUncheckedCreateWithoutPurchaseItemsInput = {
    id?: number
    name: string
    isDefault?: boolean
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTypeCreateOrConnectWithoutPurchaseItemsInput = {
    where: PaymentTypeWhereUniqueInput
    create: XOR<PaymentTypeCreateWithoutPurchaseItemsInput, PaymentTypeUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type ProductionInputCreateWithoutPurchaseItemInput = {
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutInputsInput
    purchase: PurchaseCreateNestedOneWithoutProductionInputsInput
    product: ProductCreateNestedOneWithoutProductionInputsInput
    warehouse: WarehouseCreateNestedOneWithoutProductionInputsInput
    loadedBy: UserCreateNestedOneWithoutProductionInputsInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputUncheckedCreateWithoutPurchaseItemInput = {
    id?: number
    productionDocId: number
    purchaseId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputCreateOrConnectWithoutPurchaseItemInput = {
    where: ProductionInputWhereUniqueInput
    create: XOR<ProductionInputCreateWithoutPurchaseItemInput, ProductionInputUncheckedCreateWithoutPurchaseItemInput>
  }

  export type ProductionInputCreateManyPurchaseItemInputEnvelope = {
    data: ProductionInputCreateManyPurchaseItemInput | ProductionInputCreateManyPurchaseItemInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseUpsertWithoutItemsInput = {
    update: XOR<PurchaseUpdateWithoutItemsInput, PurchaseUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutItemsInput, PurchaseUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseUpdateWithoutItemsInput = {
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    suppliers?: PurchaseSupplierUpdateManyWithoutPurchaseNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdByUserId?: IntFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: PurchaseSupplierUncheckedUpdateManyWithoutPurchaseNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type SupplierUpsertWithoutPurchaseItemsInput = {
    update: XOR<SupplierUpdateWithoutPurchaseItemsInput, SupplierUncheckedUpdateWithoutPurchaseItemsInput>
    create: XOR<SupplierCreateWithoutPurchaseItemsInput, SupplierUncheckedCreateWithoutPurchaseItemsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseItemsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseItemsInput, SupplierUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type SupplierUpdateWithoutPurchaseItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchaseItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ProductUpsertWithoutPurchaseItemsRelInput = {
    update: XOR<ProductUpdateWithoutPurchaseItemsRelInput, ProductUncheckedUpdateWithoutPurchaseItemsRelInput>
    create: XOR<ProductCreateWithoutPurchaseItemsRelInput, ProductUncheckedCreateWithoutPurchaseItemsRelInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseItemsRelInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseItemsRelInput, ProductUncheckedUpdateWithoutPurchaseItemsRelInput>
  }

  export type ProductUpdateWithoutPurchaseItemsRelInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseItemsRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PaymentTypeUpsertWithoutPurchaseItemsInput = {
    update: XOR<PaymentTypeUpdateWithoutPurchaseItemsInput, PaymentTypeUncheckedUpdateWithoutPurchaseItemsInput>
    create: XOR<PaymentTypeCreateWithoutPurchaseItemsInput, PaymentTypeUncheckedCreateWithoutPurchaseItemsInput>
    where?: PaymentTypeWhereInput
  }

  export type PaymentTypeUpdateToOneWithWhereWithoutPurchaseItemsInput = {
    where?: PaymentTypeWhereInput
    data: XOR<PaymentTypeUpdateWithoutPurchaseItemsInput, PaymentTypeUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type PaymentTypeUpdateWithoutPurchaseItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTypeUncheckedUpdateWithoutPurchaseItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionInputUpsertWithWhereUniqueWithoutPurchaseItemInput = {
    where: ProductionInputWhereUniqueInput
    update: XOR<ProductionInputUpdateWithoutPurchaseItemInput, ProductionInputUncheckedUpdateWithoutPurchaseItemInput>
    create: XOR<ProductionInputCreateWithoutPurchaseItemInput, ProductionInputUncheckedCreateWithoutPurchaseItemInput>
  }

  export type ProductionInputUpdateWithWhereUniqueWithoutPurchaseItemInput = {
    where: ProductionInputWhereUniqueInput
    data: XOR<ProductionInputUpdateWithoutPurchaseItemInput, ProductionInputUncheckedUpdateWithoutPurchaseItemInput>
  }

  export type ProductionInputUpdateManyWithWhereWithoutPurchaseItemInput = {
    where: ProductionInputScalarWhereInput
    data: XOR<ProductionInputUpdateManyMutationInput, ProductionInputUncheckedUpdateManyWithoutPurchaseItemInput>
  }

  export type TelegramOrderDraftCreateWithoutGroupInput = {
    messageId: string
    messageText: string
    messageDate: Date | string
    senderName?: string | null
    senderId?: string | null
    parsedOrderNumber?: string | null
    parsedCustomer?: string | null
    parsedAddress?: string | null
    status?: string
    transferredOrderId?: number | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TelegramOrderDraftItemCreateNestedManyWithoutDraftInput
  }

  export type TelegramOrderDraftUncheckedCreateWithoutGroupInput = {
    id?: number
    messageId: string
    messageText: string
    messageDate: Date | string
    senderName?: string | null
    senderId?: string | null
    parsedOrderNumber?: string | null
    parsedCustomer?: string | null
    parsedAddress?: string | null
    status?: string
    transferredOrderId?: number | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TelegramOrderDraftItemUncheckedCreateNestedManyWithoutDraftInput
  }

  export type TelegramOrderDraftCreateOrConnectWithoutGroupInput = {
    where: TelegramOrderDraftWhereUniqueInput
    create: XOR<TelegramOrderDraftCreateWithoutGroupInput, TelegramOrderDraftUncheckedCreateWithoutGroupInput>
  }

  export type TelegramOrderDraftCreateManyGroupInputEnvelope = {
    data: TelegramOrderDraftCreateManyGroupInput | TelegramOrderDraftCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type TelegramOrderDraftUpsertWithWhereUniqueWithoutGroupInput = {
    where: TelegramOrderDraftWhereUniqueInput
    update: XOR<TelegramOrderDraftUpdateWithoutGroupInput, TelegramOrderDraftUncheckedUpdateWithoutGroupInput>
    create: XOR<TelegramOrderDraftCreateWithoutGroupInput, TelegramOrderDraftUncheckedCreateWithoutGroupInput>
  }

  export type TelegramOrderDraftUpdateWithWhereUniqueWithoutGroupInput = {
    where: TelegramOrderDraftWhereUniqueInput
    data: XOR<TelegramOrderDraftUpdateWithoutGroupInput, TelegramOrderDraftUncheckedUpdateWithoutGroupInput>
  }

  export type TelegramOrderDraftUpdateManyWithWhereWithoutGroupInput = {
    where: TelegramOrderDraftScalarWhereInput
    data: XOR<TelegramOrderDraftUpdateManyMutationInput, TelegramOrderDraftUncheckedUpdateManyWithoutGroupInput>
  }

  export type TelegramOrderDraftScalarWhereInput = {
    AND?: TelegramOrderDraftScalarWhereInput | TelegramOrderDraftScalarWhereInput[]
    OR?: TelegramOrderDraftScalarWhereInput[]
    NOT?: TelegramOrderDraftScalarWhereInput | TelegramOrderDraftScalarWhereInput[]
    id?: IntFilter<"TelegramOrderDraft"> | number
    groupId?: IntFilter<"TelegramOrderDraft"> | number
    messageId?: StringFilter<"TelegramOrderDraft"> | string
    messageText?: StringFilter<"TelegramOrderDraft"> | string
    messageDate?: DateTimeFilter<"TelegramOrderDraft"> | Date | string
    senderName?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    senderId?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    parsedOrderNumber?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    parsedCustomer?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    parsedAddress?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    status?: StringFilter<"TelegramOrderDraft"> | string
    transferredOrderId?: IntNullableFilter<"TelegramOrderDraft"> | number | null
    approvedBy?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    approvedAt?: DateTimeNullableFilter<"TelegramOrderDraft"> | Date | string | null
    rejectedReason?: StringNullableFilter<"TelegramOrderDraft"> | string | null
    createdAt?: DateTimeFilter<"TelegramOrderDraft"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramOrderDraft"> | Date | string
  }

  export type TelegramGroupCreateWithoutOrderDraftsInput = {
    chatId: string
    title: string
    username?: string | null
    isActive?: boolean
    lastMessageId?: number | null
    parsePatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramGroupUncheckedCreateWithoutOrderDraftsInput = {
    id?: number
    chatId: string
    title: string
    username?: string | null
    isActive?: boolean
    lastMessageId?: number | null
    parsePatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramGroupCreateOrConnectWithoutOrderDraftsInput = {
    where: TelegramGroupWhereUniqueInput
    create: XOR<TelegramGroupCreateWithoutOrderDraftsInput, TelegramGroupUncheckedCreateWithoutOrderDraftsInput>
  }

  export type TelegramOrderDraftItemCreateWithoutDraftInput = {
    rawProductName: string
    rawQuantity: string
    rawPrice?: string | null
    productId?: number | null
    quantity?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramOrderDraftItemUncheckedCreateWithoutDraftInput = {
    id?: number
    rawProductName: string
    rawQuantity: string
    rawPrice?: string | null
    productId?: number | null
    quantity?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramOrderDraftItemCreateOrConnectWithoutDraftInput = {
    where: TelegramOrderDraftItemWhereUniqueInput
    create: XOR<TelegramOrderDraftItemCreateWithoutDraftInput, TelegramOrderDraftItemUncheckedCreateWithoutDraftInput>
  }

  export type TelegramOrderDraftItemCreateManyDraftInputEnvelope = {
    data: TelegramOrderDraftItemCreateManyDraftInput | TelegramOrderDraftItemCreateManyDraftInput[]
    skipDuplicates?: boolean
  }

  export type TelegramGroupUpsertWithoutOrderDraftsInput = {
    update: XOR<TelegramGroupUpdateWithoutOrderDraftsInput, TelegramGroupUncheckedUpdateWithoutOrderDraftsInput>
    create: XOR<TelegramGroupCreateWithoutOrderDraftsInput, TelegramGroupUncheckedCreateWithoutOrderDraftsInput>
    where?: TelegramGroupWhereInput
  }

  export type TelegramGroupUpdateToOneWithWhereWithoutOrderDraftsInput = {
    where?: TelegramGroupWhereInput
    data: XOR<TelegramGroupUpdateWithoutOrderDraftsInput, TelegramGroupUncheckedUpdateWithoutOrderDraftsInput>
  }

  export type TelegramGroupUpdateWithoutOrderDraftsInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    parsePatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramGroupUncheckedUpdateWithoutOrderDraftsInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    parsePatterns?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramOrderDraftItemUpsertWithWhereUniqueWithoutDraftInput = {
    where: TelegramOrderDraftItemWhereUniqueInput
    update: XOR<TelegramOrderDraftItemUpdateWithoutDraftInput, TelegramOrderDraftItemUncheckedUpdateWithoutDraftInput>
    create: XOR<TelegramOrderDraftItemCreateWithoutDraftInput, TelegramOrderDraftItemUncheckedCreateWithoutDraftInput>
  }

  export type TelegramOrderDraftItemUpdateWithWhereUniqueWithoutDraftInput = {
    where: TelegramOrderDraftItemWhereUniqueInput
    data: XOR<TelegramOrderDraftItemUpdateWithoutDraftInput, TelegramOrderDraftItemUncheckedUpdateWithoutDraftInput>
  }

  export type TelegramOrderDraftItemUpdateManyWithWhereWithoutDraftInput = {
    where: TelegramOrderDraftItemScalarWhereInput
    data: XOR<TelegramOrderDraftItemUpdateManyMutationInput, TelegramOrderDraftItemUncheckedUpdateManyWithoutDraftInput>
  }

  export type TelegramOrderDraftItemScalarWhereInput = {
    AND?: TelegramOrderDraftItemScalarWhereInput | TelegramOrderDraftItemScalarWhereInput[]
    OR?: TelegramOrderDraftItemScalarWhereInput[]
    NOT?: TelegramOrderDraftItemScalarWhereInput | TelegramOrderDraftItemScalarWhereInput[]
    id?: IntFilter<"TelegramOrderDraftItem"> | number
    draftId?: IntFilter<"TelegramOrderDraftItem"> | number
    rawProductName?: StringFilter<"TelegramOrderDraftItem"> | string
    rawQuantity?: StringFilter<"TelegramOrderDraftItem"> | string
    rawPrice?: StringNullableFilter<"TelegramOrderDraftItem"> | string | null
    productId?: IntNullableFilter<"TelegramOrderDraftItem"> | number | null
    quantity?: FloatNullableFilter<"TelegramOrderDraftItem"> | number | null
    price?: DecimalNullableFilter<"TelegramOrderDraftItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"TelegramOrderDraftItem"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramOrderDraftItem"> | Date | string
  }

  export type TelegramOrderDraftCreateWithoutItemsInput = {
    messageId: string
    messageText: string
    messageDate: Date | string
    senderName?: string | null
    senderId?: string | null
    parsedOrderNumber?: string | null
    parsedCustomer?: string | null
    parsedAddress?: string | null
    status?: string
    transferredOrderId?: number | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    group: TelegramGroupCreateNestedOneWithoutOrderDraftsInput
  }

  export type TelegramOrderDraftUncheckedCreateWithoutItemsInput = {
    id?: number
    groupId: number
    messageId: string
    messageText: string
    messageDate: Date | string
    senderName?: string | null
    senderId?: string | null
    parsedOrderNumber?: string | null
    parsedCustomer?: string | null
    parsedAddress?: string | null
    status?: string
    transferredOrderId?: number | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramOrderDraftCreateOrConnectWithoutItemsInput = {
    where: TelegramOrderDraftWhereUniqueInput
    create: XOR<TelegramOrderDraftCreateWithoutItemsInput, TelegramOrderDraftUncheckedCreateWithoutItemsInput>
  }

  export type TelegramOrderDraftUpsertWithoutItemsInput = {
    update: XOR<TelegramOrderDraftUpdateWithoutItemsInput, TelegramOrderDraftUncheckedUpdateWithoutItemsInput>
    create: XOR<TelegramOrderDraftCreateWithoutItemsInput, TelegramOrderDraftUncheckedCreateWithoutItemsInput>
    where?: TelegramOrderDraftWhereInput
  }

  export type TelegramOrderDraftUpdateToOneWithWhereWithoutItemsInput = {
    where?: TelegramOrderDraftWhereInput
    data: XOR<TelegramOrderDraftUpdateWithoutItemsInput, TelegramOrderDraftUncheckedUpdateWithoutItemsInput>
  }

  export type TelegramOrderDraftUpdateWithoutItemsInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parsedCustomer?: NullableStringFieldUpdateOperationsInput | string | null
    parsedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferredOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: TelegramGroupUpdateOneRequiredWithoutOrderDraftsNestedInput
  }

  export type TelegramOrderDraftUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    messageId?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parsedCustomer?: NullableStringFieldUpdateOperationsInput | string | null
    parsedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferredOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutWarehousesInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutCreatedByUserInput
    productionDocs?: ProductionDocCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutWarehousesInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffUncheckedCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatedByUserInput
    productionDocs?: ProductionDocUncheckedCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutWarehousesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWarehousesInput, UserUncheckedCreateWithoutWarehousesInput>
  }

  export type ProductionDocCreateWithoutWarehouseInput = {
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProductionDocsInput
    inputs?: ProductionInputCreateNestedManyWithoutProductionDocInput
    outputs?: ProductionOutputCreateNestedManyWithoutProductionDocInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocUncheckedCreateWithoutWarehouseInput = {
    id?: number
    date: Date | string
    status?: string
    createdByUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: ProductionInputUncheckedCreateNestedManyWithoutProductionDocInput
    outputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductionDocInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocCreateOrConnectWithoutWarehouseInput = {
    where: ProductionDocWhereUniqueInput
    create: XOR<ProductionDocCreateWithoutWarehouseInput, ProductionDocUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductionDocCreateManyWarehouseInputEnvelope = {
    data: ProductionDocCreateManyWarehouseInput | ProductionDocCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type ProductionInputCreateWithoutWarehouseInput = {
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutInputsInput
    purchase: PurchaseCreateNestedOneWithoutProductionInputsInput
    purchaseItem: PurchaseItemCreateNestedOneWithoutProductionInputsInput
    product: ProductCreateNestedOneWithoutProductionInputsInput
    loadedBy: UserCreateNestedOneWithoutProductionInputsInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputUncheckedCreateWithoutWarehouseInput = {
    id?: number
    productionDocId: number
    purchaseId: number
    purchaseItemId: number
    productId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputCreateOrConnectWithoutWarehouseInput = {
    where: ProductionInputWhereUniqueInput
    create: XOR<ProductionInputCreateWithoutWarehouseInput, ProductionInputUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductionInputCreateManyWarehouseInputEnvelope = {
    data: ProductionInputCreateManyWarehouseInput | ProductionInputCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWarehousesInput = {
    update: XOR<UserUpdateWithoutWarehousesInput, UserUncheckedUpdateWithoutWarehousesInput>
    create: XOR<UserCreateWithoutWarehousesInput, UserUncheckedCreateWithoutWarehousesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWarehousesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWarehousesInput, UserUncheckedUpdateWithoutWarehousesInput>
  }

  export type UserUpdateWithoutWarehousesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatedByUserNestedInput
    productionDocs?: ProductionDocUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWarehousesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUncheckedUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatedByUserNestedInput
    productionDocs?: ProductionDocUncheckedUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProductionDocUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: ProductionDocWhereUniqueInput
    update: XOR<ProductionDocUpdateWithoutWarehouseInput, ProductionDocUncheckedUpdateWithoutWarehouseInput>
    create: XOR<ProductionDocCreateWithoutWarehouseInput, ProductionDocUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductionDocUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: ProductionDocWhereUniqueInput
    data: XOR<ProductionDocUpdateWithoutWarehouseInput, ProductionDocUncheckedUpdateWithoutWarehouseInput>
  }

  export type ProductionDocUpdateManyWithWhereWithoutWarehouseInput = {
    where: ProductionDocScalarWhereInput
    data: XOR<ProductionDocUpdateManyMutationInput, ProductionDocUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type ProductionInputUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: ProductionInputWhereUniqueInput
    update: XOR<ProductionInputUpdateWithoutWarehouseInput, ProductionInputUncheckedUpdateWithoutWarehouseInput>
    create: XOR<ProductionInputCreateWithoutWarehouseInput, ProductionInputUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductionInputUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: ProductionInputWhereUniqueInput
    data: XOR<ProductionInputUpdateWithoutWarehouseInput, ProductionInputUncheckedUpdateWithoutWarehouseInput>
  }

  export type ProductionInputUpdateManyWithWhereWithoutWarehouseInput = {
    where: ProductionInputScalarWhereInput
    data: XOR<ProductionInputUpdateManyMutationInput, ProductionInputUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type SvodLineCreateWithoutSvodInput = {
    shortName?: string | null
    category?: string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    orderQty?: Decimal | DecimalJsLike | number | string
    productionInQty?: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string
    openingStockIsManual?: boolean
    afterPurchaseStock?: Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: Decimal | DecimalJsLike | number | string | null
    qtyToShip?: Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: Decimal | DecimalJsLike | number | string | null
    weightToShip?: Decimal | DecimalJsLike | number | string | null
    planFactDiff?: Decimal | DecimalJsLike | number | string | null
    underOver?: Decimal | DecimalJsLike | number | string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSvodLinesInput
  }

  export type SvodLineUncheckedCreateWithoutSvodInput = {
    id?: number
    productId: number
    shortName?: string | null
    category?: string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    orderQty?: Decimal | DecimalJsLike | number | string
    productionInQty?: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string
    openingStockIsManual?: boolean
    afterPurchaseStock?: Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: Decimal | DecimalJsLike | number | string | null
    qtyToShip?: Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: Decimal | DecimalJsLike | number | string | null
    weightToShip?: Decimal | DecimalJsLike | number | string | null
    planFactDiff?: Decimal | DecimalJsLike | number | string | null
    underOver?: Decimal | DecimalJsLike | number | string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodLineCreateOrConnectWithoutSvodInput = {
    where: SvodLineWhereUniqueInput
    create: XOR<SvodLineCreateWithoutSvodInput, SvodLineUncheckedCreateWithoutSvodInput>
  }

  export type SvodLineCreateManySvodInputEnvelope = {
    data: SvodLineCreateManySvodInput | SvodLineCreateManySvodInput[]
    skipDuplicates?: boolean
  }

  export type SvodSupplierColCreateWithoutSvodInput = {
    colIndex: number
    supplierName: string
    totalPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutSvodSupplierColsInput
  }

  export type SvodSupplierColUncheckedCreateWithoutSvodInput = {
    id?: number
    colIndex: number
    supplierId: number
    supplierName: string
    totalPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SvodSupplierColCreateOrConnectWithoutSvodInput = {
    where: SvodSupplierColWhereUniqueInput
    create: XOR<SvodSupplierColCreateWithoutSvodInput, SvodSupplierColUncheckedCreateWithoutSvodInput>
  }

  export type SvodSupplierColCreateManySvodInputEnvelope = {
    data: SvodSupplierColCreateManySvodInput | SvodSupplierColCreateManySvodInput[]
    skipDuplicates?: boolean
  }

  export type SvodSupplierValueCreateWithoutSvodInput = {
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSvodSupplierValuesInput
    supplier: SupplierCreateNestedOneWithoutSvodSupplierValuesInput
  }

  export type SvodSupplierValueUncheckedCreateWithoutSvodInput = {
    id?: number
    productId: number
    supplierId: number
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodSupplierValueCreateOrConnectWithoutSvodInput = {
    where: SvodSupplierValueWhereUniqueInput
    create: XOR<SvodSupplierValueCreateWithoutSvodInput, SvodSupplierValueUncheckedCreateWithoutSvodInput>
  }

  export type SvodSupplierValueCreateManySvodInputEnvelope = {
    data: SvodSupplierValueCreateManySvodInput | SvodSupplierValueCreateManySvodInput[]
    skipDuplicates?: boolean
  }

  export type SvodLineUpsertWithWhereUniqueWithoutSvodInput = {
    where: SvodLineWhereUniqueInput
    update: XOR<SvodLineUpdateWithoutSvodInput, SvodLineUncheckedUpdateWithoutSvodInput>
    create: XOR<SvodLineCreateWithoutSvodInput, SvodLineUncheckedCreateWithoutSvodInput>
  }

  export type SvodLineUpdateWithWhereUniqueWithoutSvodInput = {
    where: SvodLineWhereUniqueInput
    data: XOR<SvodLineUpdateWithoutSvodInput, SvodLineUncheckedUpdateWithoutSvodInput>
  }

  export type SvodLineUpdateManyWithWhereWithoutSvodInput = {
    where: SvodLineScalarWhereInput
    data: XOR<SvodLineUpdateManyMutationInput, SvodLineUncheckedUpdateManyWithoutSvodInput>
  }

  export type SvodSupplierColUpsertWithWhereUniqueWithoutSvodInput = {
    where: SvodSupplierColWhereUniqueInput
    update: XOR<SvodSupplierColUpdateWithoutSvodInput, SvodSupplierColUncheckedUpdateWithoutSvodInput>
    create: XOR<SvodSupplierColCreateWithoutSvodInput, SvodSupplierColUncheckedCreateWithoutSvodInput>
  }

  export type SvodSupplierColUpdateWithWhereUniqueWithoutSvodInput = {
    where: SvodSupplierColWhereUniqueInput
    data: XOR<SvodSupplierColUpdateWithoutSvodInput, SvodSupplierColUncheckedUpdateWithoutSvodInput>
  }

  export type SvodSupplierColUpdateManyWithWhereWithoutSvodInput = {
    where: SvodSupplierColScalarWhereInput
    data: XOR<SvodSupplierColUpdateManyMutationInput, SvodSupplierColUncheckedUpdateManyWithoutSvodInput>
  }

  export type SvodSupplierValueUpsertWithWhereUniqueWithoutSvodInput = {
    where: SvodSupplierValueWhereUniqueInput
    update: XOR<SvodSupplierValueUpdateWithoutSvodInput, SvodSupplierValueUncheckedUpdateWithoutSvodInput>
    create: XOR<SvodSupplierValueCreateWithoutSvodInput, SvodSupplierValueUncheckedCreateWithoutSvodInput>
  }

  export type SvodSupplierValueUpdateWithWhereUniqueWithoutSvodInput = {
    where: SvodSupplierValueWhereUniqueInput
    data: XOR<SvodSupplierValueUpdateWithoutSvodInput, SvodSupplierValueUncheckedUpdateWithoutSvodInput>
  }

  export type SvodSupplierValueUpdateManyWithWhereWithoutSvodInput = {
    where: SvodSupplierValueScalarWhereInput
    data: XOR<SvodSupplierValueUpdateManyMutationInput, SvodSupplierValueUncheckedUpdateManyWithoutSvodInput>
  }

  export type SvodHeaderCreateWithoutLinesInput = {
    svodDate: Date | string
    status?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    supplierCols?: SvodSupplierColCreateNestedManyWithoutSvodInput
    supplierValues?: SvodSupplierValueCreateNestedManyWithoutSvodInput
  }

  export type SvodHeaderUncheckedCreateWithoutLinesInput = {
    id?: number
    svodDate: Date | string
    status?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    supplierCols?: SvodSupplierColUncheckedCreateNestedManyWithoutSvodInput
    supplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutSvodInput
  }

  export type SvodHeaderCreateOrConnectWithoutLinesInput = {
    where: SvodHeaderWhereUniqueInput
    create: XOR<SvodHeaderCreateWithoutLinesInput, SvodHeaderUncheckedCreateWithoutLinesInput>
  }

  export type ProductCreateWithoutSvodLinesInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSvodLinesInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSvodLinesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSvodLinesInput, ProductUncheckedCreateWithoutSvodLinesInput>
  }

  export type SvodHeaderUpsertWithoutLinesInput = {
    update: XOR<SvodHeaderUpdateWithoutLinesInput, SvodHeaderUncheckedUpdateWithoutLinesInput>
    create: XOR<SvodHeaderCreateWithoutLinesInput, SvodHeaderUncheckedCreateWithoutLinesInput>
    where?: SvodHeaderWhereInput
  }

  export type SvodHeaderUpdateToOneWithWhereWithoutLinesInput = {
    where?: SvodHeaderWhereInput
    data: XOR<SvodHeaderUpdateWithoutLinesInput, SvodHeaderUncheckedUpdateWithoutLinesInput>
  }

  export type SvodHeaderUpdateWithoutLinesInput = {
    svodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    supplierCols?: SvodSupplierColUpdateManyWithoutSvodNestedInput
    supplierValues?: SvodSupplierValueUpdateManyWithoutSvodNestedInput
  }

  export type SvodHeaderUncheckedUpdateWithoutLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    supplierCols?: SvodSupplierColUncheckedUpdateManyWithoutSvodNestedInput
    supplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutSvodNestedInput
  }

  export type ProductUpsertWithoutSvodLinesInput = {
    update: XOR<ProductUpdateWithoutSvodLinesInput, ProductUncheckedUpdateWithoutSvodLinesInput>
    create: XOR<ProductCreateWithoutSvodLinesInput, ProductUncheckedCreateWithoutSvodLinesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSvodLinesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSvodLinesInput, ProductUncheckedUpdateWithoutSvodLinesInput>
  }

  export type ProductUpdateWithoutSvodLinesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSvodLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SvodHeaderCreateWithoutSupplierColsInput = {
    svodDate: Date | string
    status?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    lines?: SvodLineCreateNestedManyWithoutSvodInput
    supplierValues?: SvodSupplierValueCreateNestedManyWithoutSvodInput
  }

  export type SvodHeaderUncheckedCreateWithoutSupplierColsInput = {
    id?: number
    svodDate: Date | string
    status?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    lines?: SvodLineUncheckedCreateNestedManyWithoutSvodInput
    supplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutSvodInput
  }

  export type SvodHeaderCreateOrConnectWithoutSupplierColsInput = {
    where: SvodHeaderWhereUniqueInput
    create: XOR<SvodHeaderCreateWithoutSupplierColsInput, SvodHeaderUncheckedCreateWithoutSupplierColsInput>
  }

  export type SupplierCreateWithoutSvodSupplierColsInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutSvodSupplierColsInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutSvodSupplierColsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutSvodSupplierColsInput, SupplierUncheckedCreateWithoutSvodSupplierColsInput>
  }

  export type SvodHeaderUpsertWithoutSupplierColsInput = {
    update: XOR<SvodHeaderUpdateWithoutSupplierColsInput, SvodHeaderUncheckedUpdateWithoutSupplierColsInput>
    create: XOR<SvodHeaderCreateWithoutSupplierColsInput, SvodHeaderUncheckedCreateWithoutSupplierColsInput>
    where?: SvodHeaderWhereInput
  }

  export type SvodHeaderUpdateToOneWithWhereWithoutSupplierColsInput = {
    where?: SvodHeaderWhereInput
    data: XOR<SvodHeaderUpdateWithoutSupplierColsInput, SvodHeaderUncheckedUpdateWithoutSupplierColsInput>
  }

  export type SvodHeaderUpdateWithoutSupplierColsInput = {
    svodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lines?: SvodLineUpdateManyWithoutSvodNestedInput
    supplierValues?: SvodSupplierValueUpdateManyWithoutSvodNestedInput
  }

  export type SvodHeaderUncheckedUpdateWithoutSupplierColsInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lines?: SvodLineUncheckedUpdateManyWithoutSvodNestedInput
    supplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutSvodNestedInput
  }

  export type SupplierUpsertWithoutSvodSupplierColsInput = {
    update: XOR<SupplierUpdateWithoutSvodSupplierColsInput, SupplierUncheckedUpdateWithoutSvodSupplierColsInput>
    create: XOR<SupplierCreateWithoutSvodSupplierColsInput, SupplierUncheckedCreateWithoutSvodSupplierColsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutSvodSupplierColsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutSvodSupplierColsInput, SupplierUncheckedUpdateWithoutSvodSupplierColsInput>
  }

  export type SupplierUpdateWithoutSvodSupplierColsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutSvodSupplierColsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SvodHeaderCreateWithoutSupplierValuesInput = {
    svodDate: Date | string
    status?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    lines?: SvodLineCreateNestedManyWithoutSvodInput
    supplierCols?: SvodSupplierColCreateNestedManyWithoutSvodInput
  }

  export type SvodHeaderUncheckedCreateWithoutSupplierValuesInput = {
    id?: number
    svodDate: Date | string
    status?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    lines?: SvodLineUncheckedCreateNestedManyWithoutSvodInput
    supplierCols?: SvodSupplierColUncheckedCreateNestedManyWithoutSvodInput
  }

  export type SvodHeaderCreateOrConnectWithoutSupplierValuesInput = {
    where: SvodHeaderWhereUniqueInput
    create: XOR<SvodHeaderCreateWithoutSupplierValuesInput, SvodHeaderUncheckedCreateWithoutSupplierValuesInput>
  }

  export type ProductCreateWithoutSvodSupplierValuesInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSvodSupplierValuesInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSvodSupplierValuesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSvodSupplierValuesInput, ProductUncheckedCreateWithoutSvodSupplierValuesInput>
  }

  export type SupplierCreateWithoutSvodSupplierValuesInput = {
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryMml?: ProductionMmlCreateNestedOneWithoutSuppliersWithPrimaryMmlInput
    products?: SupplierProductCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutSvodSupplierValuesInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    primaryMmlId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutSupplierInput
    purchases?: PurchaseSupplierUncheckedCreateNestedManyWithoutSupplierInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutSupplierInput
    svodSupplierCols?: SvodSupplierColUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutSvodSupplierValuesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutSvodSupplierValuesInput, SupplierUncheckedCreateWithoutSvodSupplierValuesInput>
  }

  export type SvodHeaderUpsertWithoutSupplierValuesInput = {
    update: XOR<SvodHeaderUpdateWithoutSupplierValuesInput, SvodHeaderUncheckedUpdateWithoutSupplierValuesInput>
    create: XOR<SvodHeaderCreateWithoutSupplierValuesInput, SvodHeaderUncheckedCreateWithoutSupplierValuesInput>
    where?: SvodHeaderWhereInput
  }

  export type SvodHeaderUpdateToOneWithWhereWithoutSupplierValuesInput = {
    where?: SvodHeaderWhereInput
    data: XOR<SvodHeaderUpdateWithoutSupplierValuesInput, SvodHeaderUncheckedUpdateWithoutSupplierValuesInput>
  }

  export type SvodHeaderUpdateWithoutSupplierValuesInput = {
    svodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lines?: SvodLineUpdateManyWithoutSvodNestedInput
    supplierCols?: SvodSupplierColUpdateManyWithoutSvodNestedInput
  }

  export type SvodHeaderUncheckedUpdateWithoutSupplierValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lines?: SvodLineUncheckedUpdateManyWithoutSvodNestedInput
    supplierCols?: SvodSupplierColUncheckedUpdateManyWithoutSvodNestedInput
  }

  export type ProductUpsertWithoutSvodSupplierValuesInput = {
    update: XOR<ProductUpdateWithoutSvodSupplierValuesInput, ProductUncheckedUpdateWithoutSvodSupplierValuesInput>
    create: XOR<ProductCreateWithoutSvodSupplierValuesInput, ProductUncheckedCreateWithoutSvodSupplierValuesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSvodSupplierValuesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSvodSupplierValuesInput, ProductUncheckedUpdateWithoutSvodSupplierValuesInput>
  }

  export type ProductUpdateWithoutSvodSupplierValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSvodSupplierValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SupplierUpsertWithoutSvodSupplierValuesInput = {
    update: XOR<SupplierUpdateWithoutSvodSupplierValuesInput, SupplierUncheckedUpdateWithoutSvodSupplierValuesInput>
    create: XOR<SupplierCreateWithoutSvodSupplierValuesInput, SupplierUncheckedCreateWithoutSvodSupplierValuesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutSvodSupplierValuesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutSvodSupplierValuesInput, SupplierUncheckedUpdateWithoutSvodSupplierValuesInput>
  }

  export type SupplierUpdateWithoutSvodSupplierValuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryMml?: ProductionMmlUpdateOneWithoutSuppliersWithPrimaryMmlNestedInput
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutSvodSupplierValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type WarehouseCreateWithoutProductionDocsInput = {
    code: string
    name: string
    address: string
    phone?: string | null
    comment?: string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutWarehousesInput
    productionInputs?: ProductionInputCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutProductionDocsInput = {
    id?: number
    code: string
    name: string
    address: string
    phone?: string | null
    responsibleUserId?: number | null
    comment?: string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutProductionDocsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutProductionDocsInput, WarehouseUncheckedCreateWithoutProductionDocsInput>
  }

  export type UserCreateWithoutProductionDocsInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseCreateNestedManyWithoutResponsibleUserInput
    productionInputs?: ProductionInputCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutProductionDocsInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffUncheckedCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutResponsibleUserInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutLoadedByInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutProductionDocsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductionDocsInput, UserUncheckedCreateWithoutProductionDocsInput>
  }

  export type ProductionInputCreateWithoutProductionDocInput = {
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutProductionInputsInput
    purchaseItem: PurchaseItemCreateNestedOneWithoutProductionInputsInput
    product: ProductCreateNestedOneWithoutProductionInputsInput
    warehouse: WarehouseCreateNestedOneWithoutProductionInputsInput
    loadedBy: UserCreateNestedOneWithoutProductionInputsInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputUncheckedCreateWithoutProductionDocInput = {
    id?: number
    purchaseId: number
    purchaseItemId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionInputInput
  }

  export type ProductionInputCreateOrConnectWithoutProductionDocInput = {
    where: ProductionInputWhereUniqueInput
    create: XOR<ProductionInputCreateWithoutProductionDocInput, ProductionInputUncheckedCreateWithoutProductionDocInput>
  }

  export type ProductionInputCreateManyProductionDocInputEnvelope = {
    data: ProductionInputCreateManyProductionDocInput | ProductionInputCreateManyProductionDocInput[]
    skipDuplicates?: boolean
  }

  export type ProductionOutputCreateWithoutProductionDocInput = {
    qtyOut: Decimal | DecimalJsLike | number | string
    uom?: string
    costTotal?: Decimal | DecimalJsLike | number | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionOutputsInput
  }

  export type ProductionOutputUncheckedCreateWithoutProductionDocInput = {
    id?: number
    productId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    uom?: string
    costTotal?: Decimal | DecimalJsLike | number | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionOutputCreateOrConnectWithoutProductionDocInput = {
    where: ProductionOutputWhereUniqueInput
    create: XOR<ProductionOutputCreateWithoutProductionDocInput, ProductionOutputUncheckedCreateWithoutProductionDocInput>
  }

  export type ProductionOutputCreateManyProductionDocInputEnvelope = {
    data: ProductionOutputCreateManyProductionDocInput | ProductionOutputCreateManyProductionDocInput[]
    skipDuplicates?: boolean
  }

  export type ProductionCuttingLineCreateWithoutProductionDocInput = {
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    productionInput: ProductionInputCreateNestedOneWithoutCuttingLinesInput
    mml: ProductionMmlCreateNestedOneWithoutCuttingLinesInput
    outProduct: ProductCreateNestedOneWithoutCuttingLineOutputsInput
    createdBy: UserCreateNestedOneWithoutCuttingLinesInput
  }

  export type ProductionCuttingLineUncheckedCreateWithoutProductionDocInput = {
    id?: number
    productionInputId: number
    mmlId: number
    outProductId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdByUserId: number
  }

  export type ProductionCuttingLineCreateOrConnectWithoutProductionDocInput = {
    where: ProductionCuttingLineWhereUniqueInput
    create: XOR<ProductionCuttingLineCreateWithoutProductionDocInput, ProductionCuttingLineUncheckedCreateWithoutProductionDocInput>
  }

  export type ProductionCuttingLineCreateManyProductionDocInputEnvelope = {
    data: ProductionCuttingLineCreateManyProductionDocInput | ProductionCuttingLineCreateManyProductionDocInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutProductionDocsInput = {
    update: XOR<WarehouseUpdateWithoutProductionDocsInput, WarehouseUncheckedUpdateWithoutProductionDocsInput>
    create: XOR<WarehouseCreateWithoutProductionDocsInput, WarehouseUncheckedCreateWithoutProductionDocsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutProductionDocsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutProductionDocsInput, WarehouseUncheckedUpdateWithoutProductionDocsInput>
  }

  export type WarehouseUpdateWithoutProductionDocsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutWarehousesNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutProductionDocsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type UserUpsertWithoutProductionDocsInput = {
    update: XOR<UserUpdateWithoutProductionDocsInput, UserUncheckedUpdateWithoutProductionDocsInput>
    create: XOR<UserCreateWithoutProductionDocsInput, UserUncheckedCreateWithoutProductionDocsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductionDocsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductionDocsInput, UserUncheckedUpdateWithoutProductionDocsInput>
  }

  export type UserUpdateWithoutProductionDocsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUpdateManyWithoutResponsibleUserNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProductionDocsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUncheckedUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutResponsibleUserNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutLoadedByNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProductionInputUpsertWithWhereUniqueWithoutProductionDocInput = {
    where: ProductionInputWhereUniqueInput
    update: XOR<ProductionInputUpdateWithoutProductionDocInput, ProductionInputUncheckedUpdateWithoutProductionDocInput>
    create: XOR<ProductionInputCreateWithoutProductionDocInput, ProductionInputUncheckedCreateWithoutProductionDocInput>
  }

  export type ProductionInputUpdateWithWhereUniqueWithoutProductionDocInput = {
    where: ProductionInputWhereUniqueInput
    data: XOR<ProductionInputUpdateWithoutProductionDocInput, ProductionInputUncheckedUpdateWithoutProductionDocInput>
  }

  export type ProductionInputUpdateManyWithWhereWithoutProductionDocInput = {
    where: ProductionInputScalarWhereInput
    data: XOR<ProductionInputUpdateManyMutationInput, ProductionInputUncheckedUpdateManyWithoutProductionDocInput>
  }

  export type ProductionOutputUpsertWithWhereUniqueWithoutProductionDocInput = {
    where: ProductionOutputWhereUniqueInput
    update: XOR<ProductionOutputUpdateWithoutProductionDocInput, ProductionOutputUncheckedUpdateWithoutProductionDocInput>
    create: XOR<ProductionOutputCreateWithoutProductionDocInput, ProductionOutputUncheckedCreateWithoutProductionDocInput>
  }

  export type ProductionOutputUpdateWithWhereUniqueWithoutProductionDocInput = {
    where: ProductionOutputWhereUniqueInput
    data: XOR<ProductionOutputUpdateWithoutProductionDocInput, ProductionOutputUncheckedUpdateWithoutProductionDocInput>
  }

  export type ProductionOutputUpdateManyWithWhereWithoutProductionDocInput = {
    where: ProductionOutputScalarWhereInput
    data: XOR<ProductionOutputUpdateManyMutationInput, ProductionOutputUncheckedUpdateManyWithoutProductionDocInput>
  }

  export type ProductionCuttingLineUpsertWithWhereUniqueWithoutProductionDocInput = {
    where: ProductionCuttingLineWhereUniqueInput
    update: XOR<ProductionCuttingLineUpdateWithoutProductionDocInput, ProductionCuttingLineUncheckedUpdateWithoutProductionDocInput>
    create: XOR<ProductionCuttingLineCreateWithoutProductionDocInput, ProductionCuttingLineUncheckedCreateWithoutProductionDocInput>
  }

  export type ProductionCuttingLineUpdateWithWhereUniqueWithoutProductionDocInput = {
    where: ProductionCuttingLineWhereUniqueInput
    data: XOR<ProductionCuttingLineUpdateWithoutProductionDocInput, ProductionCuttingLineUncheckedUpdateWithoutProductionDocInput>
  }

  export type ProductionCuttingLineUpdateManyWithWhereWithoutProductionDocInput = {
    where: ProductionCuttingLineScalarWhereInput
    data: XOR<ProductionCuttingLineUpdateManyMutationInput, ProductionCuttingLineUncheckedUpdateManyWithoutProductionDocInput>
  }

  export type ProductionDocCreateWithoutInputsInput = {
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutProductionDocsInput
    createdBy: UserCreateNestedOneWithoutProductionDocsInput
    outputs?: ProductionOutputCreateNestedManyWithoutProductionDocInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocUncheckedCreateWithoutInputsInput = {
    id?: number
    date: Date | string
    warehouseId: number
    status?: string
    createdByUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    outputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductionDocInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocCreateOrConnectWithoutInputsInput = {
    where: ProductionDocWhereUniqueInput
    create: XOR<ProductionDocCreateWithoutInputsInput, ProductionDocUncheckedCreateWithoutInputsInput>
  }

  export type PurchaseCreateWithoutProductionInputsInput = {
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUser: UserCreateNestedOneWithoutPurchasesInput
    suppliers?: PurchaseSupplierCreateNestedManyWithoutPurchaseInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutProductionInputsInput = {
    id?: number
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    createdByUserId: number
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: PurchaseSupplierUncheckedCreateNestedManyWithoutPurchaseInput
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutProductionInputsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutProductionInputsInput, PurchaseUncheckedCreateWithoutProductionInputsInput>
  }

  export type PurchaseItemCreateWithoutProductionInputsInput = {
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    supplier: SupplierCreateNestedOneWithoutPurchaseItemsInput
    product: ProductCreateNestedOneWithoutPurchaseItemsRelInput
    paymentType?: PaymentTypeCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseItemUncheckedCreateWithoutProductionInputsInput = {
    id?: number
    purchaseId: number
    supplierId: number
    productId: number
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    paymentTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemCreateOrConnectWithoutProductionInputsInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutProductionInputsInput, PurchaseItemUncheckedCreateWithoutProductionInputsInput>
  }

  export type ProductCreateWithoutProductionInputsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductionInputsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductionInputsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductionInputsInput, ProductUncheckedCreateWithoutProductionInputsInput>
  }

  export type WarehouseCreateWithoutProductionInputsInput = {
    code: string
    name: string
    address: string
    phone?: string | null
    comment?: string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    responsibleUser?: UserCreateNestedOneWithoutWarehousesInput
    productionDocs?: ProductionDocCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutProductionInputsInput = {
    id?: number
    code: string
    name: string
    address: string
    phone?: string | null
    responsibleUserId?: number | null
    comment?: string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productionDocs?: ProductionDocUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutProductionInputsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutProductionInputsInput, WarehouseUncheckedCreateWithoutProductionInputsInput>
  }

  export type UserCreateWithoutProductionInputsInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocCreateNestedManyWithoutCreatedByInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutProductionInputsInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffUncheckedCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocUncheckedCreateNestedManyWithoutCreatedByInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutProductionInputsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductionInputsInput, UserUncheckedCreateWithoutProductionInputsInput>
  }

  export type ProductionCuttingLineCreateWithoutProductionInputInput = {
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutCuttingLinesInput
    mml: ProductionMmlCreateNestedOneWithoutCuttingLinesInput
    outProduct: ProductCreateNestedOneWithoutCuttingLineOutputsInput
    createdBy: UserCreateNestedOneWithoutCuttingLinesInput
  }

  export type ProductionCuttingLineUncheckedCreateWithoutProductionInputInput = {
    id?: number
    productionDocId: number
    mmlId: number
    outProductId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdByUserId: number
  }

  export type ProductionCuttingLineCreateOrConnectWithoutProductionInputInput = {
    where: ProductionCuttingLineWhereUniqueInput
    create: XOR<ProductionCuttingLineCreateWithoutProductionInputInput, ProductionCuttingLineUncheckedCreateWithoutProductionInputInput>
  }

  export type ProductionCuttingLineCreateManyProductionInputInputEnvelope = {
    data: ProductionCuttingLineCreateManyProductionInputInput | ProductionCuttingLineCreateManyProductionInputInput[]
    skipDuplicates?: boolean
  }

  export type ProductionDocUpsertWithoutInputsInput = {
    update: XOR<ProductionDocUpdateWithoutInputsInput, ProductionDocUncheckedUpdateWithoutInputsInput>
    create: XOR<ProductionDocCreateWithoutInputsInput, ProductionDocUncheckedCreateWithoutInputsInput>
    where?: ProductionDocWhereInput
  }

  export type ProductionDocUpdateToOneWithWhereWithoutInputsInput = {
    where?: ProductionDocWhereInput
    data: XOR<ProductionDocUpdateWithoutInputsInput, ProductionDocUncheckedUpdateWithoutInputsInput>
  }

  export type ProductionDocUpdateWithoutInputsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionDocsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutProductionDocsNestedInput
    outputs?: ProductionOutputUpdateManyWithoutProductionDocNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionDocNestedInput
  }

  export type ProductionDocUncheckedUpdateWithoutInputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputs?: ProductionOutputUncheckedUpdateManyWithoutProductionDocNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionDocNestedInput
  }

  export type PurchaseUpsertWithoutProductionInputsInput = {
    update: XOR<PurchaseUpdateWithoutProductionInputsInput, PurchaseUncheckedUpdateWithoutProductionInputsInput>
    create: XOR<PurchaseCreateWithoutProductionInputsInput, PurchaseUncheckedCreateWithoutProductionInputsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutProductionInputsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutProductionInputsInput, PurchaseUncheckedUpdateWithoutProductionInputsInput>
  }

  export type PurchaseUpdateWithoutProductionInputsInput = {
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    suppliers?: PurchaseSupplierUpdateManyWithoutPurchaseNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutProductionInputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdByUserId?: IntFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: PurchaseSupplierUncheckedUpdateManyWithoutPurchaseNestedInput
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseItemUpsertWithoutProductionInputsInput = {
    update: XOR<PurchaseItemUpdateWithoutProductionInputsInput, PurchaseItemUncheckedUpdateWithoutProductionInputsInput>
    create: XOR<PurchaseItemCreateWithoutProductionInputsInput, PurchaseItemUncheckedCreateWithoutProductionInputsInput>
    where?: PurchaseItemWhereInput
  }

  export type PurchaseItemUpdateToOneWithWhereWithoutProductionInputsInput = {
    where?: PurchaseItemWhereInput
    data: XOR<PurchaseItemUpdateWithoutProductionInputsInput, PurchaseItemUncheckedUpdateWithoutProductionInputsInput>
  }

  export type PurchaseItemUpdateWithoutProductionInputsInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsRelNestedInput
    paymentType?: PaymentTypeUpdateOneWithoutPurchaseItemsNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutProductionInputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutProductionInputsInput = {
    update: XOR<ProductUpdateWithoutProductionInputsInput, ProductUncheckedUpdateWithoutProductionInputsInput>
    create: XOR<ProductCreateWithoutProductionInputsInput, ProductUncheckedCreateWithoutProductionInputsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductionInputsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductionInputsInput, ProductUncheckedUpdateWithoutProductionInputsInput>
  }

  export type ProductUpdateWithoutProductionInputsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductionInputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseUpsertWithoutProductionInputsInput = {
    update: XOR<WarehouseUpdateWithoutProductionInputsInput, WarehouseUncheckedUpdateWithoutProductionInputsInput>
    create: XOR<WarehouseCreateWithoutProductionInputsInput, WarehouseUncheckedCreateWithoutProductionInputsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutProductionInputsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutProductionInputsInput, WarehouseUncheckedUpdateWithoutProductionInputsInput>
  }

  export type WarehouseUpdateWithoutProductionInputsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleUser?: UserUpdateOneWithoutWarehousesNestedInput
    productionDocs?: ProductionDocUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutProductionInputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDocs?: ProductionDocUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type UserUpsertWithoutProductionInputsInput = {
    update: XOR<UserUpdateWithoutProductionInputsInput, UserUncheckedUpdateWithoutProductionInputsInput>
    create: XOR<UserCreateWithoutProductionInputsInput, UserUncheckedCreateWithoutProductionInputsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductionInputsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductionInputsInput, UserUncheckedUpdateWithoutProductionInputsInput>
  }

  export type UserUpdateWithoutProductionInputsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUpdateManyWithoutCreatedByNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProductionInputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUncheckedUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUncheckedUpdateManyWithoutCreatedByNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProductionCuttingLineUpsertWithWhereUniqueWithoutProductionInputInput = {
    where: ProductionCuttingLineWhereUniqueInput
    update: XOR<ProductionCuttingLineUpdateWithoutProductionInputInput, ProductionCuttingLineUncheckedUpdateWithoutProductionInputInput>
    create: XOR<ProductionCuttingLineCreateWithoutProductionInputInput, ProductionCuttingLineUncheckedCreateWithoutProductionInputInput>
  }

  export type ProductionCuttingLineUpdateWithWhereUniqueWithoutProductionInputInput = {
    where: ProductionCuttingLineWhereUniqueInput
    data: XOR<ProductionCuttingLineUpdateWithoutProductionInputInput, ProductionCuttingLineUncheckedUpdateWithoutProductionInputInput>
  }

  export type ProductionCuttingLineUpdateManyWithWhereWithoutProductionInputInput = {
    where: ProductionCuttingLineScalarWhereInput
    data: XOR<ProductionCuttingLineUpdateManyMutationInput, ProductionCuttingLineUncheckedUpdateManyWithoutProductionInputInput>
  }

  export type ProductionDocCreateWithoutOutputsInput = {
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutProductionDocsInput
    createdBy: UserCreateNestedOneWithoutProductionDocsInput
    inputs?: ProductionInputCreateNestedManyWithoutProductionDocInput
    cuttingLines?: ProductionCuttingLineCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocUncheckedCreateWithoutOutputsInput = {
    id?: number
    date: Date | string
    warehouseId: number
    status?: string
    createdByUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: ProductionInputUncheckedCreateNestedManyWithoutProductionDocInput
    cuttingLines?: ProductionCuttingLineUncheckedCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocCreateOrConnectWithoutOutputsInput = {
    where: ProductionDocWhereUniqueInput
    create: XOR<ProductionDocCreateWithoutOutputsInput, ProductionDocUncheckedCreateWithoutOutputsInput>
  }

  export type ProductCreateWithoutProductionOutputsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductionOutputsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedCreateNestedManyWithoutOutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductionOutputsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductionOutputsInput, ProductUncheckedCreateWithoutProductionOutputsInput>
  }

  export type ProductionDocUpsertWithoutOutputsInput = {
    update: XOR<ProductionDocUpdateWithoutOutputsInput, ProductionDocUncheckedUpdateWithoutOutputsInput>
    create: XOR<ProductionDocCreateWithoutOutputsInput, ProductionDocUncheckedCreateWithoutOutputsInput>
    where?: ProductionDocWhereInput
  }

  export type ProductionDocUpdateToOneWithWhereWithoutOutputsInput = {
    where?: ProductionDocWhereInput
    data: XOR<ProductionDocUpdateWithoutOutputsInput, ProductionDocUncheckedUpdateWithoutOutputsInput>
  }

  export type ProductionDocUpdateWithoutOutputsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionDocsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutProductionDocsNestedInput
    inputs?: ProductionInputUpdateManyWithoutProductionDocNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionDocNestedInput
  }

  export type ProductionDocUncheckedUpdateWithoutOutputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: ProductionInputUncheckedUpdateManyWithoutProductionDocNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionDocNestedInput
  }

  export type ProductUpsertWithoutProductionOutputsInput = {
    update: XOR<ProductUpdateWithoutProductionOutputsInput, ProductUncheckedUpdateWithoutProductionOutputsInput>
    create: XOR<ProductCreateWithoutProductionOutputsInput, ProductUncheckedCreateWithoutProductionOutputsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductionOutputsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductionOutputsInput, ProductUncheckedUpdateWithoutProductionOutputsInput>
  }

  export type ProductUpdateWithoutProductionOutputsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductionOutputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    cuttingLineOutputs?: ProductionCuttingLineUncheckedUpdateManyWithoutOutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductionDocCreateWithoutCuttingLinesInput = {
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutProductionDocsInput
    createdBy: UserCreateNestedOneWithoutProductionDocsInput
    inputs?: ProductionInputCreateNestedManyWithoutProductionDocInput
    outputs?: ProductionOutputCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocUncheckedCreateWithoutCuttingLinesInput = {
    id?: number
    date: Date | string
    warehouseId: number
    status?: string
    createdByUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: ProductionInputUncheckedCreateNestedManyWithoutProductionDocInput
    outputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductionDocInput
  }

  export type ProductionDocCreateOrConnectWithoutCuttingLinesInput = {
    where: ProductionDocWhereUniqueInput
    create: XOR<ProductionDocCreateWithoutCuttingLinesInput, ProductionDocUncheckedCreateWithoutCuttingLinesInput>
  }

  export type ProductionInputCreateWithoutCuttingLinesInput = {
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    productionDoc: ProductionDocCreateNestedOneWithoutInputsInput
    purchase: PurchaseCreateNestedOneWithoutProductionInputsInput
    purchaseItem: PurchaseItemCreateNestedOneWithoutProductionInputsInput
    product: ProductCreateNestedOneWithoutProductionInputsInput
    warehouse: WarehouseCreateNestedOneWithoutProductionInputsInput
    loadedBy: UserCreateNestedOneWithoutProductionInputsInput
  }

  export type ProductionInputUncheckedCreateWithoutCuttingLinesInput = {
    id?: number
    productionDocId: number
    purchaseId: number
    purchaseItemId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
  }

  export type ProductionInputCreateOrConnectWithoutCuttingLinesInput = {
    where: ProductionInputWhereUniqueInput
    create: XOR<ProductionInputCreateWithoutCuttingLinesInput, ProductionInputUncheckedCreateWithoutCuttingLinesInput>
  }

  export type ProductionMmlCreateWithoutCuttingLinesInput = {
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductionMmlsInput
    creator: UserCreateNestedOneWithoutCreatedMmlsInput
    nodes?: ProductionMmlNodeCreateNestedManyWithoutMmlInput
    runs?: ProductionRunCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlUncheckedCreateWithoutCuttingLinesInput = {
    id?: number
    productId: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    nodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutMmlInput
    runs?: ProductionRunUncheckedCreateNestedManyWithoutMmlInput
    suppliersWithPrimaryMml?: SupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedCreateNestedManyWithoutPrimaryMmlInput
  }

  export type ProductionMmlCreateOrConnectWithoutCuttingLinesInput = {
    where: ProductionMmlWhereUniqueInput
    create: XOR<ProductionMmlCreateWithoutCuttingLinesInput, ProductionMmlUncheckedCreateWithoutCuttingLinesInput>
  }

  export type ProductCreateWithoutCuttingLineOutputsInput = {
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stock?: StockCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemCreateNestedManyWithoutProductInput
    svodLines?: SvodLineCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputCreateNestedManyWithoutProductInput
    customerProducts?: CustomerProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCuttingLineOutputsInput = {
    id?: number
    code: string
    name: string
    altName?: string | null
    priceListName?: string | null
    category?: string | null
    status?: string
    coefficient?: number
    lossNorm?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    stockTransactions?: StockTransactionUncheckedCreateNestedManyWithoutProductInput
    suppliers?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedCreateNestedManyWithoutProductInput
    productionItems?: ProductionItemUncheckedCreateNestedManyWithoutProductInput
    purchasePriceItems?: PurchasePriceItemUncheckedCreateNestedManyWithoutProductInput
    salesPriceItems?: SalesPriceItemUncheckedCreateNestedManyWithoutProductInput
    productionMmls?: ProductionMmlUncheckedCreateNestedManyWithoutProductInput
    mmlNodes?: ProductionMmlNodeUncheckedCreateNestedManyWithoutProductInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutProductInput
    runValueSnapshots?: ProductionRunValueUncheckedCreateNestedManyWithoutSnapshotProductInput
    purchaseItemsRel?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
    svodLines?: SvodLineUncheckedCreateNestedManyWithoutProductInput
    svodSupplierValues?: SvodSupplierValueUncheckedCreateNestedManyWithoutProductInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutProductInput
    productionOutputs?: ProductionOutputUncheckedCreateNestedManyWithoutProductInput
    customerProducts?: CustomerProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCuttingLineOutputsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCuttingLineOutputsInput, ProductUncheckedCreateWithoutCuttingLineOutputsInput>
  }

  export type UserCreateWithoutCuttingLinesInput = {
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunCreateNestedManyWithoutUserInput
    purchases?: PurchaseCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputCreateNestedManyWithoutLoadedByInput
  }

  export type UserUncheckedCreateWithoutCuttingLinesInput = {
    id?: number
    username: string
    password: string
    name: string
    role?: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productionStaff?: ProductionStaffUncheckedCreateNestedOneWithoutUserInput
    createdMmls?: ProductionMmlUncheckedCreateNestedManyWithoutCreatorInput
    productionRuns?: ProductionRunUncheckedCreateNestedManyWithoutUserInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatedByUserInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutResponsibleUserInput
    productionDocs?: ProductionDocUncheckedCreateNestedManyWithoutCreatedByInput
    productionInputs?: ProductionInputUncheckedCreateNestedManyWithoutLoadedByInput
  }

  export type UserCreateOrConnectWithoutCuttingLinesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCuttingLinesInput, UserUncheckedCreateWithoutCuttingLinesInput>
  }

  export type ProductionDocUpsertWithoutCuttingLinesInput = {
    update: XOR<ProductionDocUpdateWithoutCuttingLinesInput, ProductionDocUncheckedUpdateWithoutCuttingLinesInput>
    create: XOR<ProductionDocCreateWithoutCuttingLinesInput, ProductionDocUncheckedCreateWithoutCuttingLinesInput>
    where?: ProductionDocWhereInput
  }

  export type ProductionDocUpdateToOneWithWhereWithoutCuttingLinesInput = {
    where?: ProductionDocWhereInput
    data: XOR<ProductionDocUpdateWithoutCuttingLinesInput, ProductionDocUncheckedUpdateWithoutCuttingLinesInput>
  }

  export type ProductionDocUpdateWithoutCuttingLinesInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionDocsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutProductionDocsNestedInput
    inputs?: ProductionInputUpdateManyWithoutProductionDocNestedInput
    outputs?: ProductionOutputUpdateManyWithoutProductionDocNestedInput
  }

  export type ProductionDocUncheckedUpdateWithoutCuttingLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: ProductionInputUncheckedUpdateManyWithoutProductionDocNestedInput
    outputs?: ProductionOutputUncheckedUpdateManyWithoutProductionDocNestedInput
  }

  export type ProductionInputUpsertWithoutCuttingLinesInput = {
    update: XOR<ProductionInputUpdateWithoutCuttingLinesInput, ProductionInputUncheckedUpdateWithoutCuttingLinesInput>
    create: XOR<ProductionInputCreateWithoutCuttingLinesInput, ProductionInputUncheckedCreateWithoutCuttingLinesInput>
    where?: ProductionInputWhereInput
  }

  export type ProductionInputUpdateToOneWithWhereWithoutCuttingLinesInput = {
    where?: ProductionInputWhereInput
    data: XOR<ProductionInputUpdateWithoutCuttingLinesInput, ProductionInputUncheckedUpdateWithoutCuttingLinesInput>
  }

  export type ProductionInputUpdateWithoutCuttingLinesInput = {
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutInputsNestedInput
    purchase?: PurchaseUpdateOneRequiredWithoutProductionInputsNestedInput
    purchaseItem?: PurchaseItemUpdateOneRequiredWithoutProductionInputsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductionInputsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionInputsNestedInput
    loadedBy?: UserUpdateOneRequiredWithoutProductionInputsNestedInput
  }

  export type ProductionInputUncheckedUpdateWithoutCuttingLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionMmlUpsertWithoutCuttingLinesInput = {
    update: XOR<ProductionMmlUpdateWithoutCuttingLinesInput, ProductionMmlUncheckedUpdateWithoutCuttingLinesInput>
    create: XOR<ProductionMmlCreateWithoutCuttingLinesInput, ProductionMmlUncheckedCreateWithoutCuttingLinesInput>
    where?: ProductionMmlWhereInput
  }

  export type ProductionMmlUpdateToOneWithWhereWithoutCuttingLinesInput = {
    where?: ProductionMmlWhereInput
    data: XOR<ProductionMmlUpdateWithoutCuttingLinesInput, ProductionMmlUncheckedUpdateWithoutCuttingLinesInput>
  }

  export type ProductionMmlUpdateWithoutCuttingLinesInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutCuttingLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
  }

  export type ProductUpsertWithoutCuttingLineOutputsInput = {
    update: XOR<ProductUpdateWithoutCuttingLineOutputsInput, ProductUncheckedUpdateWithoutCuttingLineOutputsInput>
    create: XOR<ProductCreateWithoutCuttingLineOutputsInput, ProductUncheckedCreateWithoutCuttingLineOutputsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCuttingLineOutputsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCuttingLineOutputsInput, ProductUncheckedUpdateWithoutCuttingLineOutputsInput>
  }

  export type ProductUpdateWithoutCuttingLineOutputsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stock?: StockUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUpdateManyWithoutProductNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCuttingLineOutputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    priceListName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    lossNorm?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutProductNestedInput
    suppliers?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutProductNestedInput
    productionItems?: ProductionItemUncheckedUpdateManyWithoutProductNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutProductNestedInput
    salesPriceItems?: SalesPriceItemUncheckedUpdateManyWithoutProductNestedInput
    productionMmls?: ProductionMmlUncheckedUpdateManyWithoutProductNestedInput
    mmlNodes?: ProductionMmlNodeUncheckedUpdateManyWithoutProductNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutProductNestedInput
    runValueSnapshots?: ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductNestedInput
    purchaseItemsRel?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    svodLines?: SvodLineUncheckedUpdateManyWithoutProductNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutProductNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutProductNestedInput
    productionOutputs?: ProductionOutputUncheckedUpdateManyWithoutProductNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutCuttingLinesInput = {
    update: XOR<UserUpdateWithoutCuttingLinesInput, UserUncheckedUpdateWithoutCuttingLinesInput>
    create: XOR<UserCreateWithoutCuttingLinesInput, UserUncheckedCreateWithoutCuttingLinesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCuttingLinesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCuttingLinesInput, UserUncheckedUpdateWithoutCuttingLinesInput>
  }

  export type UserUpdateWithoutCuttingLinesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutLoadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCuttingLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionStaff?: ProductionStaffUncheckedUpdateOneWithoutUserNestedInput
    createdMmls?: ProductionMmlUncheckedUpdateManyWithoutCreatorNestedInput
    productionRuns?: ProductionRunUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatedByUserNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutResponsibleUserNestedInput
    productionDocs?: ProductionDocUncheckedUpdateManyWithoutCreatedByNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutLoadedByNestedInput
  }

  export type ProductionMmlCreateManyCreatorInput = {
    id?: number
    productId: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunCreateManyUserInput = {
    id?: number
    productId: number
    mmlId: number
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyCreatedByUserInput = {
    id?: number
    purchaseDate: Date | string
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseCreateManyResponsibleUserInput = {
    id?: number
    code: string
    name: string
    address: string
    phone?: string | null
    comment?: string | null
    isDisabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionDocCreateManyCreatedByInput = {
    id?: number
    date: Date | string
    warehouseId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionInputCreateManyLoadedByInput = {
    id?: number
    productionDocId: number
    purchaseId: number
    purchaseItemId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
  }

  export type ProductionCuttingLineCreateManyCreatedByInput = {
    id?: number
    productionDocId: number
    productionInputId: number
    mmlId: number
    outProductId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ProductionMmlUpdateWithoutCreatorInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunUpdateWithoutUserInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionRunsNestedInput
    mml?: ProductionMmlUpdateOneRequiredWithoutRunsNestedInput
    values?: ProductionRunValueUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: ProductionRunValueUncheckedUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutCreatedByUserInput = {
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: PurchaseSupplierUpdateManyWithoutPurchaseNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutCreatedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: PurchaseSupplierUncheckedUpdateManyWithoutPurchaseNestedInput
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUpdateWithoutResponsibleUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDocs?: ProductionDocUpdateManyWithoutWarehouseNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutResponsibleUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDocs?: ProductionDocUncheckedUpdateManyWithoutWarehouseNestedInput
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateManyWithoutResponsibleUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDocUpdateWithoutCreatedByInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionDocsNestedInput
    inputs?: ProductionInputUpdateManyWithoutProductionDocNestedInput
    outputs?: ProductionOutputUpdateManyWithoutProductionDocNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionDocNestedInput
  }

  export type ProductionDocUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: ProductionInputUncheckedUpdateManyWithoutProductionDocNestedInput
    outputs?: ProductionOutputUncheckedUpdateManyWithoutProductionDocNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionDocNestedInput
  }

  export type ProductionDocUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionInputUpdateWithoutLoadedByInput = {
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutInputsNestedInput
    purchase?: PurchaseUpdateOneRequiredWithoutProductionInputsNestedInput
    purchaseItem?: PurchaseItemUpdateOneRequiredWithoutProductionInputsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductionInputsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionInputsNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateWithoutLoadedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateManyWithoutLoadedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionCuttingLineUpdateWithoutCreatedByInput = {
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutCuttingLinesNestedInput
    productionInput?: ProductionInputUpdateOneRequiredWithoutCuttingLinesNestedInput
    mml?: ProductionMmlUpdateOneRequiredWithoutCuttingLinesNestedInput
    outProduct?: ProductUpdateOneRequiredWithoutCuttingLineOutputsNestedInput
  }

  export type ProductionCuttingLineUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    productionInputId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    outProductId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionCuttingLineUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    productionInputId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    outProductId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateManyDistrictInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateWithoutDistrictInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateManyManagerInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    districtId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateWithoutManagerInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    summaryJournalEntries?: SummaryOrderJournalUncheckedUpdateManyWithoutCustomerNestedInput
    salesPriceLists?: SalesPriceListUncheckedUpdateManyWithoutCustomerNestedInput
    customerProducts?: CustomerProductUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: number
    orderId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type StockTransactionCreateManyProductInput = {
    id?: number
    type: string
    quantity: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SupplierProductCreateManyProductInput = {
    supplierId: number
  }

  export type SummaryOrderJournalCreateManyProductInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerId?: number | null
    customerName: string
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    preAssemblyStatus?: string | null
    assemblyStartedAt?: Date | string | null
    assemblyStartedBy?: string | null
    assemblyReturnedAt?: Date | string | null
    assemblyReturnedBy?: string | null
    assemblyReturnReason?: string | null
    assemblyReturnComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionItemCreateManyProductInput = {
    id?: number
    journalId: number
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type PurchasePriceItemCreateManyProductInput = {
    id?: number
    priceListId: number
    supplierId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesPriceItemCreateManyProductInput = {
    id?: number
    priceListId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionMmlCreateManyProductInput = {
    id?: number
    createdBy: number
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionMmlNodeCreateManyProductInput = {
    id?: number
    mmlId: number
    parentNodeId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunCreateManyProductInput = {
    id?: number
    mmlId: number
    userId: number
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueCreateManySnapshotProductInput = {
    id?: number
    productionRunId: number
    mmlNodeId: number
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemCreateManyProductInput = {
    id?: number
    purchaseId: number
    supplierId: number
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    paymentTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodLineCreateManyProductInput = {
    id?: number
    svodId: number
    shortName?: string | null
    category?: string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    orderQty?: Decimal | DecimalJsLike | number | string
    productionInQty?: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string
    openingStockIsManual?: boolean
    afterPurchaseStock?: Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: Decimal | DecimalJsLike | number | string | null
    qtyToShip?: Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: Decimal | DecimalJsLike | number | string | null
    weightToShip?: Decimal | DecimalJsLike | number | string | null
    planFactDiff?: Decimal | DecimalJsLike | number | string | null
    underOver?: Decimal | DecimalJsLike | number | string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodSupplierValueCreateManyProductInput = {
    id?: number
    svodId: number
    supplierId: number
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionInputCreateManyProductInput = {
    id?: number
    productionDocId: number
    purchaseId: number
    purchaseItemId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
  }

  export type ProductionOutputCreateManyProductInput = {
    id?: number
    productionDocId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    uom?: string
    costTotal?: Decimal | DecimalJsLike | number | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionCuttingLineCreateManyOutProductInput = {
    id?: number
    productionDocId: number
    productionInputId: number
    mmlId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdByUserId: number
  }

  export type CustomerProductCreateManyProductInput = {
    id?: number
    customerId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StockTransactionUpdateWithoutProductInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutStockTransactionsNestedInput
  }

  export type StockTransactionUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierProductUpdateWithoutProductInput = {
    supplier?: SupplierUpdateOneRequiredWithoutProductsNestedInput
  }

  export type SupplierProductUncheckedUpdateWithoutProductInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierProductUncheckedUpdateManyWithoutProductInput = {
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type SummaryOrderJournalUpdateWithoutProductInput = {
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutSummaryJournalEntriesNestedInput
    events?: SummaryOrderEventUpdateManyWithoutSummaryOrderNestedInput
  }

  export type SummaryOrderJournalUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: SummaryOrderEventUncheckedUpdateManyWithoutSummaryOrderNestedInput
  }

  export type SummaryOrderJournalUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionItemUpdateWithoutProductInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: ProductionJournalUpdateOneRequiredWithoutItemsNestedInput
    values?: ProductionItemValueUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    journalId?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    values?: ProductionItemValueUncheckedUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    journalId?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceItemUpdateWithoutProductInput = {
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutItemsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
  }

  export type PurchasePriceItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesPriceItemUpdateWithoutProductInput = {
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    priceList?: SalesPriceListUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SalesPriceItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionMmlUpdateWithoutProductInput = {
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedMmlsNestedInput
    nodes?: ProductionMmlNodeUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nodes?: ProductionMmlNodeUncheckedUpdateManyWithoutMmlNestedInput
    runs?: ProductionRunUncheckedUpdateManyWithoutMmlNestedInput
    suppliersWithPrimaryMml?: SupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    priceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutMmlNestedInput
  }

  export type ProductionMmlUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionMmlNodeUpdateWithoutProductInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutNodesNestedInput
    parentNode?: ProductionMmlNodeUpdateOneWithoutChildrenNestedInput
    children?: ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput
    runValues?: ProductionRunValueUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput
    runValues?: ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunUpdateWithoutProductInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutRunsNestedInput
    user?: UserUpdateOneRequiredWithoutProductionRunsNestedInput
    values?: ProductionRunValueUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: ProductionRunValueUncheckedUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueUpdateWithoutSnapshotProductInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: ProductionRunUpdateOneRequiredWithoutValuesNestedInput
    node?: ProductionMmlNodeUpdateOneRequiredWithoutRunValuesNestedInput
  }

  export type ProductionRunValueUncheckedUpdateWithoutSnapshotProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionRunId?: IntFieldUpdateOperationsInput | number
    mmlNodeId?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueUncheckedUpdateManyWithoutSnapshotProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionRunId?: IntFieldUpdateOperationsInput | number
    mmlNodeId?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUpdateWithoutProductInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseItemsNestedInput
    paymentType?: PaymentTypeUpdateOneWithoutPurchaseItemsNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodLineUpdateWithoutProductInput = {
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFieldUpdateOperationsInput | boolean
    afterPurchaseStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    underOver?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    svod?: SvodHeaderUpdateOneRequiredWithoutLinesNestedInput
  }

  export type SvodLineUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFieldUpdateOperationsInput | boolean
    afterPurchaseStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    underOver?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodLineUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFieldUpdateOperationsInput | boolean
    afterPurchaseStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    underOver?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierValueUpdateWithoutProductInput = {
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    svod?: SvodHeaderUpdateOneRequiredWithoutSupplierValuesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutSvodSupplierValuesNestedInput
  }

  export type SvodSupplierValueUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierValueUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionInputUpdateWithoutProductInput = {
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutInputsNestedInput
    purchase?: PurchaseUpdateOneRequiredWithoutProductionInputsNestedInput
    purchaseItem?: PurchaseItemUpdateOneRequiredWithoutProductionInputsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionInputsNestedInput
    loadedBy?: UserUpdateOneRequiredWithoutProductionInputsNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionOutputUpdateWithoutProductInput = {
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    costTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutOutputsNestedInput
  }

  export type ProductionOutputUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    costTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOutputUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    costTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionCuttingLineUpdateWithoutOutProductInput = {
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutCuttingLinesNestedInput
    productionInput?: ProductionInputUpdateOneRequiredWithoutCuttingLinesNestedInput
    mml?: ProductionMmlUpdateOneRequiredWithoutCuttingLinesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCuttingLinesNestedInput
  }

  export type ProductionCuttingLineUncheckedUpdateWithoutOutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    productionInputId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionCuttingLineUncheckedUpdateManyWithoutOutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    productionInputId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerProductUpdateWithoutProductInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerProductsNestedInput
  }

  export type CustomerProductUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    expeditorId?: number | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SummaryOrderJournalCreateManyCustomerInput = {
    id?: number
    idn: string
    shipDate: Date | string
    paymentType?: string | null
    customerName: string
    productId?: number | null
    productCode?: string | null
    productFullName: string
    category?: string | null
    shortNameMorning?: string | null
    priceType?: string | null
    price?: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    orderQty?: number
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    distributionCoef?: number | null
    weightToDistribute?: number | null
    managerId?: string | null
    managerName?: string | null
    district?: string | null
    pointAddress?: string | null
    status?: string
    preAssemblyStatus?: string | null
    assemblyStartedAt?: Date | string | null
    assemblyStartedBy?: string | null
    assemblyReturnedAt?: Date | string | null
    assemblyReturnedBy?: string | null
    assemblyReturnReason?: string | null
    assemblyReturnComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesPriceListCreateManyCustomerInput = {
    id?: number
    listType: string
    title?: string | null
    effectiveDate: Date | string
    status?: string
    isCurrent?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type CustomerProductCreateManyCustomerInput = {
    id?: number
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expeditor?: ExpeditorUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    expeditorId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrderJournalUpdateWithoutCustomerInput = {
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutSummaryJournalEntriesNestedInput
    events?: SummaryOrderEventUpdateManyWithoutSummaryOrderNestedInput
  }

  export type SummaryOrderJournalUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: SummaryOrderEventUncheckedUpdateManyWithoutSummaryOrderNestedInput
  }

  export type SummaryOrderJournalUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: StringFieldUpdateOperationsInput | string
    shipDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCode?: NullableStringFieldUpdateOperationsInput | string | null
    productFullName?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shortNameMorning?: NullableStringFieldUpdateOperationsInput | string | null
    priceType?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    orderQty?: FloatFieldUpdateOperationsInput | number
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    pointAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    preAssemblyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assemblyReturnedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnReason?: NullableStringFieldUpdateOperationsInput | string | null
    assemblyReturnComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesPriceListUpdateWithoutCustomerInput = {
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: SalesPriceItemUpdateManyWithoutPriceListNestedInput
  }

  export type SalesPriceListUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: SalesPriceItemUncheckedUpdateManyWithoutPriceListNestedInput
  }

  export type SalesPriceListUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    listType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerProductUpdateWithoutCustomerInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCustomerProductsNestedInput
  }

  export type CustomerProductUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierProductCreateManySupplierInput = {
    productId: number
  }

  export type PurchasePriceListSupplierCreateManySupplierInput = {
    id?: number
    priceListId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceItemCreateManySupplierInput = {
    id?: number
    priceListId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseSupplierCreateManySupplierInput = {
    id?: number
    purchaseId: number
    createdAt?: Date | string
  }

  export type PurchaseItemCreateManySupplierInput = {
    id?: number
    purchaseId: number
    productId: number
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    paymentTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodSupplierColCreateManySupplierInput = {
    id?: number
    svodId: number
    colIndex: number
    supplierName: string
    totalPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SvodSupplierValueCreateManySupplierInput = {
    id?: number
    svodId: number
    productId: number
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierProductUpdateWithoutSupplierInput = {
    product?: ProductUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type SupplierProductUncheckedUpdateWithoutSupplierInput = {
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierProductUncheckedUpdateManyWithoutSupplierInput = {
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type PurchasePriceListSupplierUpdateWithoutSupplierInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutSuppliersNestedInput
    primaryMml?: ProductionMmlUpdateOneWithoutPriceListSuppliersNestedInput
  }

  export type PurchasePriceListSupplierUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUpdateWithoutSupplierInput = {
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
  }

  export type PurchasePriceItemUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseSupplierUpdateWithoutSupplierInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type PurchaseSupplierUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseSupplierUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUpdateWithoutSupplierInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsRelNestedInput
    paymentType?: PaymentTypeUpdateOneWithoutPurchaseItemsNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierColUpdateWithoutSupplierInput = {
    colIndex?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    totalPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    svod?: SvodHeaderUpdateOneRequiredWithoutSupplierColsNestedInput
  }

  export type SvodSupplierColUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    colIndex?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    totalPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierColUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    colIndex?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    totalPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierValueUpdateWithoutSupplierInput = {
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    svod?: SvodHeaderUpdateOneRequiredWithoutSupplierValuesNestedInput
    product?: ProductUpdateOneRequiredWithoutSvodSupplierValuesNestedInput
  }

  export type SvodSupplierValueUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierValueUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    svodId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    productId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    shippedQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributionCoef?: number | null
    sumWithRevaluation?: Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: number | null
  }

  export type StockTransactionCreateManyOrderInput = {
    id?: number
    productId: number
    type: string
    quantity: number
    note?: string | null
    createdAt?: Date | string
  }

  export type OrderAttachmentCreateManyOrderInput = {
    id?: number
    type: string
    filename: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippedQty?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributionCoef?: NullableFloatFieldUpdateOperationsInput | number | null
    sumWithRevaluation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToDistribute?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StockTransactionUpdateWithoutOrderInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockTransactionsNestedInput
  }

  export type StockTransactionUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransactionUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentUpdateWithoutOrderInput = {
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAttachmentUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyExpeditorInput = {
    id?: number
    idn?: string | null
    date?: Date | string
    status?: string
    paymentType?: string | null
    customerId: number
    totalAmount?: Decimal | DecimalJsLike | number | string
    totalWeight?: number
    isDisabled?: boolean
    deliveryAddress?: string | null
    assignedAt?: Date | string | null
    deliveryStatus?: string
    completedAt?: Date | string | null
    signatureUrl?: string | null
    signedInvoiceUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutExpeditorInput = {
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutExpeditorInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    stockTransactions?: StockTransactionUncheckedUpdateManyWithoutOrderNestedInput
    attachments?: OrderAttachmentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutExpeditorInput = {
    id?: IntFieldUpdateOperationsInput | number
    idn?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalWeight?: FloatFieldUpdateOperationsInput | number
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummaryOrderEventCreateManySummaryOrderInput = {
    id?: number
    eventType: string
    fromStatus?: string | null
    toStatus?: string | null
    reason?: string | null
    comment?: string | null
    createdAt?: Date | string
    createdBy: string
    payload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SummaryOrderEventUpdateWithoutSummaryOrderInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableStringFieldUpdateOperationsInput | string | null
    toStatus?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SummaryOrderEventUncheckedUpdateWithoutSummaryOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableStringFieldUpdateOperationsInput | string | null
    toStatus?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SummaryOrderEventUncheckedUpdateManyWithoutSummaryOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    fromStatus?: NullableStringFieldUpdateOperationsInput | string | null
    toStatus?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductionJournalCreateManyStaffInput = {
    id?: number
    productionDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionJournalUpdateWithoutStaffInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ProductionItemUpdateManyWithoutJournalNestedInput
  }

  export type ProductionJournalUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ProductionItemUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type ProductionJournalUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemCreateManyJournalInput = {
    id?: number
    productId?: number | null
    productName?: string | null
    state?: string
    sortOrder?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type ProductionItemUpdateWithoutJournalInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneWithoutProductionItemsNestedInput
    values?: ProductionItemValueUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemUncheckedUpdateWithoutJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    values?: ProductionItemValueUncheckedUpdateManyWithoutProductionItemNestedInput
  }

  export type ProductionItemUncheckedUpdateManyWithoutJournalInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueCreateManyProductionItemInput = {
    id?: number
    fieldKey: string
    fieldValue?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProductionItemValueUpdateWithoutProductionItemInput = {
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueUncheckedUpdateWithoutProductionItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionItemValueUncheckedUpdateManyWithoutProductionItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldValue?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchasePriceListSupplierCreateManyPriceListInput = {
    id?: number
    supplierId: number
    primaryMmlId?: number | null
    createdAt?: Date | string
  }

  export type PurchasePriceItemCreateManyPriceListInput = {
    id?: number
    supplierId: number
    productId: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceListSupplierUpdateWithoutPriceListInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceListSuppliersNestedInput
    primaryMml?: ProductionMmlUpdateOneWithoutPriceListSuppliersNestedInput
  }

  export type PurchasePriceListSupplierUncheckedUpdateWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    primaryMmlId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUpdateWithoutPriceListInput = {
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchasePriceItemsNestedInput
  }

  export type PurchasePriceItemUncheckedUpdateWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceItemUncheckedUpdateManyWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesPriceItemCreateManyPriceListInput = {
    id?: number
    productId: number
    salePrice: Decimal | DecimalJsLike | number | string
    rowDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SalesPriceItemUpdateWithoutPriceListInput = {
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutSalesPriceItemsNestedInput
  }

  export type SalesPriceItemUncheckedUpdateWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesPriceItemUncheckedUpdateManyWithoutPriceListInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionMmlNodeCreateManyMmlInput = {
    id?: number
    parentNodeId?: number | null
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunCreateManyMmlInput = {
    id?: number
    productId: number
    userId: number
    productionDate?: Date | string
    plannedWeight?: Decimal | DecimalJsLike | number | string | null
    actualWeight?: Decimal | DecimalJsLike | number | string | null
    isLocked?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateManyPrimaryMmlInput = {
    id?: number
    code: string
    name: string
    legalName?: string | null
    altName?: string | null
    phone?: string | null
    telegram?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePriceListSupplierCreateManyPrimaryMmlInput = {
    id?: number
    priceListId: number
    supplierId: number
    createdAt?: Date | string
  }

  export type ProductionCuttingLineCreateManyMmlInput = {
    id?: number
    productionDocId: number
    productionInputId: number
    outProductId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdByUserId: number
  }

  export type ProductionMmlNodeUpdateWithoutMmlInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentNode?: ProductionMmlNodeUpdateOneWithoutChildrenNestedInput
    children?: ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput
    product?: ProductUpdateOneRequiredWithoutMmlNodesNestedInput
    runValues?: ProductionRunValueUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateWithoutMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput
    runValues?: ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentNodeId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunUpdateWithoutMmlInput = {
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionRunsNestedInput
    user?: UserUpdateOneRequiredWithoutProductionRunsNestedInput
    values?: ProductionRunValueUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateWithoutMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: ProductionRunValueUncheckedUpdateManyWithoutRunNestedInput
  }

  export type ProductionRunUncheckedUpdateManyWithoutMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpdateWithoutPrimaryMmlInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPrimaryMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceListSuppliers?: PurchasePriceListSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchasePriceItems?: PurchasePriceItemUncheckedUpdateManyWithoutSupplierNestedInput
    purchases?: PurchaseSupplierUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierCols?: SvodSupplierColUncheckedUpdateManyWithoutSupplierNestedInput
    svodSupplierValues?: SvodSupplierValueUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutPrimaryMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    altName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierUpdateWithoutPrimaryMmlInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceList?: PurchasePriceListUpdateOneRequiredWithoutSuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchasePriceListSuppliersNestedInput
  }

  export type PurchasePriceListSupplierUncheckedUpdateWithoutPrimaryMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePriceListSupplierUncheckedUpdateManyWithoutPrimaryMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    priceListId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionCuttingLineUpdateWithoutMmlInput = {
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutCuttingLinesNestedInput
    productionInput?: ProductionInputUpdateOneRequiredWithoutCuttingLinesNestedInput
    outProduct?: ProductUpdateOneRequiredWithoutCuttingLineOutputsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCuttingLinesNestedInput
  }

  export type ProductionCuttingLineUncheckedUpdateWithoutMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    productionInputId?: IntFieldUpdateOperationsInput | number
    outProductId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionCuttingLineUncheckedUpdateManyWithoutMmlInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    productionInputId?: IntFieldUpdateOperationsInput | number
    outProductId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionMmlNodeCreateManyParentNodeInput = {
    id?: number
    mmlId: number
    productId: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueCreateManyNodeInput = {
    id?: number
    productionRunId: number
    snapshotProductId?: number | null
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionMmlNodeUpdateWithoutParentNodeInput = {
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mml?: ProductionMmlUpdateOneRequiredWithoutNodesNestedInput
    children?: ProductionMmlNodeUpdateManyWithoutParentNodeNestedInput
    product?: ProductUpdateOneRequiredWithoutMmlNodesNestedInput
    runValues?: ProductionRunValueUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateWithoutParentNodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeNestedInput
    runValues?: ProductionRunValueUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type ProductionMmlNodeUncheckedUpdateManyWithoutParentNodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueUpdateWithoutNodeInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: ProductionRunUpdateOneRequiredWithoutValuesNestedInput
    snapshotProduct?: ProductUpdateOneWithoutRunValueSnapshotsNestedInput
  }

  export type ProductionRunValueUncheckedUpdateWithoutNodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionRunId?: IntFieldUpdateOperationsInput | number
    snapshotProductId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueUncheckedUpdateManyWithoutNodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionRunId?: IntFieldUpdateOperationsInput | number
    snapshotProductId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueCreateManyRunInput = {
    id?: number
    mmlNodeId: number
    snapshotProductId?: number | null
    value?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionRunValueUpdateWithoutRunInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: ProductionMmlNodeUpdateOneRequiredWithoutRunValuesNestedInput
    snapshotProduct?: ProductUpdateOneWithoutRunValueSnapshotsNestedInput
  }

  export type ProductionRunValueUncheckedUpdateWithoutRunInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlNodeId?: IntFieldUpdateOperationsInput | number
    snapshotProductId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRunValueUncheckedUpdateManyWithoutRunInput = {
    id?: IntFieldUpdateOperationsInput | number
    mmlNodeId?: IntFieldUpdateOperationsInput | number
    snapshotProductId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateManyPaymentTypeInput = {
    id?: number
    purchaseId: number
    supplierId: number
    productId: number
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemUpdateWithoutPaymentTypeInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsRelNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutPaymentTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPaymentTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseSupplierCreateManyPurchaseInput = {
    id?: number
    supplierId: number
    createdAt?: Date | string
  }

  export type PurchaseItemCreateManyPurchaseInput = {
    id?: number
    supplierId: number
    productId: number
    price: Decimal | DecimalJsLike | number | string
    qty: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    paymentTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionInputCreateManyPurchaseInput = {
    id?: number
    productionDocId: number
    purchaseItemId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
  }

  export type PurchaseSupplierUpdateWithoutPurchaseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseSupplierUncheckedUpdateWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseSupplierUncheckedUpdateManyWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemUpdateWithoutPurchaseInput = {
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsRelNestedInput
    paymentType?: PaymentTypeUpdateOneWithoutPurchaseItemsNestedInput
    productionInputs?: ProductionInputUpdateManyWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionInputs?: ProductionInputUncheckedUpdateManyWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionInputUpdateWithoutPurchaseInput = {
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutInputsNestedInput
    purchaseItem?: PurchaseItemUpdateOneRequiredWithoutProductionInputsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductionInputsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionInputsNestedInput
    loadedBy?: UserUpdateOneRequiredWithoutProductionInputsNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateManyWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionInputCreateManyPurchaseItemInput = {
    id?: number
    productionDocId: number
    purchaseId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
  }

  export type ProductionInputUpdateWithoutPurchaseItemInput = {
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutInputsNestedInput
    purchase?: PurchaseUpdateOneRequiredWithoutProductionInputsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductionInputsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionInputsNestedInput
    loadedBy?: UserUpdateOneRequiredWithoutProductionInputsNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateWithoutPurchaseItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateManyWithoutPurchaseItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TelegramOrderDraftCreateManyGroupInput = {
    id?: number
    messageId: string
    messageText: string
    messageDate: Date | string
    senderName?: string | null
    senderId?: string | null
    parsedOrderNumber?: string | null
    parsedCustomer?: string | null
    parsedAddress?: string | null
    status?: string
    transferredOrderId?: number | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramOrderDraftUpdateWithoutGroupInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parsedCustomer?: NullableStringFieldUpdateOperationsInput | string | null
    parsedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferredOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TelegramOrderDraftItemUpdateManyWithoutDraftNestedInput
  }

  export type TelegramOrderDraftUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parsedCustomer?: NullableStringFieldUpdateOperationsInput | string | null
    parsedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferredOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TelegramOrderDraftItemUncheckedUpdateManyWithoutDraftNestedInput
  }

  export type TelegramOrderDraftUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parsedCustomer?: NullableStringFieldUpdateOperationsInput | string | null
    parsedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferredOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramOrderDraftItemCreateManyDraftInput = {
    id?: number
    rawProductName: string
    rawQuantity: string
    rawPrice?: string | null
    productId?: number | null
    quantity?: number | null
    price?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramOrderDraftItemUpdateWithoutDraftInput = {
    rawProductName?: StringFieldUpdateOperationsInput | string
    rawQuantity?: StringFieldUpdateOperationsInput | string
    rawPrice?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramOrderDraftItemUncheckedUpdateWithoutDraftInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawProductName?: StringFieldUpdateOperationsInput | string
    rawQuantity?: StringFieldUpdateOperationsInput | string
    rawPrice?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramOrderDraftItemUncheckedUpdateManyWithoutDraftInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawProductName?: StringFieldUpdateOperationsInput | string
    rawQuantity?: StringFieldUpdateOperationsInput | string
    rawPrice?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDocCreateManyWarehouseInput = {
    id?: number
    date: Date | string
    status?: string
    createdByUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionInputCreateManyWarehouseInput = {
    id?: number
    productionDocId: number
    purchaseId: number
    purchaseItemId: number
    productId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
  }

  export type ProductionDocUpdateWithoutWarehouseInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProductionDocsNestedInput
    inputs?: ProductionInputUpdateManyWithoutProductionDocNestedInput
    outputs?: ProductionOutputUpdateManyWithoutProductionDocNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionDocNestedInput
  }

  export type ProductionDocUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: ProductionInputUncheckedUpdateManyWithoutProductionDocNestedInput
    outputs?: ProductionOutputUncheckedUpdateManyWithoutProductionDocNestedInput
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionDocNestedInput
  }

  export type ProductionDocUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionInputUpdateWithoutWarehouseInput = {
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutInputsNestedInput
    purchase?: PurchaseUpdateOneRequiredWithoutProductionInputsNestedInput
    purchaseItem?: PurchaseItemUpdateOneRequiredWithoutProductionInputsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductionInputsNestedInput
    loadedBy?: UserUpdateOneRequiredWithoutProductionInputsNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type SvodLineCreateManySvodInput = {
    id?: number
    productId: number
    shortName?: string | null
    category?: string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    orderQty?: Decimal | DecimalJsLike | number | string
    productionInQty?: Decimal | DecimalJsLike | number | string
    openingStock?: Decimal | DecimalJsLike | number | string
    openingStockIsManual?: boolean
    afterPurchaseStock?: Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: Decimal | DecimalJsLike | number | string | null
    qtyToShip?: Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: Decimal | DecimalJsLike | number | string | null
    weightToShip?: Decimal | DecimalJsLike | number | string | null
    planFactDiff?: Decimal | DecimalJsLike | number | string | null
    underOver?: Decimal | DecimalJsLike | number | string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodSupplierColCreateManySvodInput = {
    id?: number
    colIndex: number
    supplierId: number
    supplierName: string
    totalPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SvodSupplierValueCreateManySvodInput = {
    id?: number
    productId: number
    supplierId: number
    purchaseQty?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SvodLineUpdateWithoutSvodInput = {
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFieldUpdateOperationsInput | boolean
    afterPurchaseStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    underOver?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSvodLinesNestedInput
  }

  export type SvodLineUncheckedUpdateWithoutSvodInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFieldUpdateOperationsInput | boolean
    afterPurchaseStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    underOver?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodLineUncheckedUpdateManyWithoutSvodInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productionInQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingStockIsManual?: BoolFieldUpdateOperationsInput | boolean
    afterPurchaseStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    afterShipmentStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factMinusWaste?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightToShip?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    planFactDiff?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    underOver?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierColUpdateWithoutSvodInput = {
    colIndex?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    totalPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutSvodSupplierColsNestedInput
  }

  export type SvodSupplierColUncheckedUpdateWithoutSvodInput = {
    id?: IntFieldUpdateOperationsInput | number
    colIndex?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    totalPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierColUncheckedUpdateManyWithoutSvodInput = {
    id?: IntFieldUpdateOperationsInput | number
    colIndex?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    totalPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierValueUpdateWithoutSvodInput = {
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSvodSupplierValuesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutSvodSupplierValuesNestedInput
  }

  export type SvodSupplierValueUncheckedUpdateWithoutSvodInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SvodSupplierValueUncheckedUpdateManyWithoutSvodInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    purchaseQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionInputCreateManyProductionDocInput = {
    id?: number
    purchaseId: number
    purchaseItemId: number
    productId: number
    warehouseId: number
    qtyIn: Decimal | DecimalJsLike | number | string
    qtyUsed?: Decimal | DecimalJsLike | number | string
    priceIn?: Decimal | DecimalJsLike | number | string | null
    loadedAt?: Date | string
    loadedByUserId: number
  }

  export type ProductionOutputCreateManyProductionDocInput = {
    id?: number
    productId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    uom?: string
    costTotal?: Decimal | DecimalJsLike | number | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionCuttingLineCreateManyProductionDocInput = {
    id?: number
    productionInputId: number
    mmlId: number
    outProductId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdByUserId: number
  }

  export type ProductionInputUpdateWithoutProductionDocInput = {
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutProductionInputsNestedInput
    purchaseItem?: PurchaseItemUpdateOneRequiredWithoutProductionInputsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductionInputsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionInputsNestedInput
    loadedBy?: UserUpdateOneRequiredWithoutProductionInputsNestedInput
    cuttingLines?: ProductionCuttingLineUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateWithoutProductionDocInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
    cuttingLines?: ProductionCuttingLineUncheckedUpdateManyWithoutProductionInputNestedInput
  }

  export type ProductionInputUncheckedUpdateManyWithoutProductionDocInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseId?: IntFieldUpdateOperationsInput | number
    purchaseItemId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loadedByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionOutputUpdateWithoutProductionDocInput = {
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    costTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductionOutputsNestedInput
  }

  export type ProductionOutputUncheckedUpdateWithoutProductionDocInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    costTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOutputUncheckedUpdateManyWithoutProductionDocInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    costTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionCuttingLineUpdateWithoutProductionDocInput = {
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionInput?: ProductionInputUpdateOneRequiredWithoutCuttingLinesNestedInput
    mml?: ProductionMmlUpdateOneRequiredWithoutCuttingLinesNestedInput
    outProduct?: ProductUpdateOneRequiredWithoutCuttingLineOutputsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCuttingLinesNestedInput
  }

  export type ProductionCuttingLineUncheckedUpdateWithoutProductionDocInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionInputId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    outProductId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionCuttingLineUncheckedUpdateManyWithoutProductionDocInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionInputId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    outProductId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionCuttingLineCreateManyProductionInputInput = {
    id?: number
    productionDocId: number
    mmlId: number
    outProductId: number
    qtyOut: Decimal | DecimalJsLike | number | string
    qtyInConsumed: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    createdByUserId: number
  }

  export type ProductionCuttingLineUpdateWithoutProductionInputInput = {
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionDoc?: ProductionDocUpdateOneRequiredWithoutCuttingLinesNestedInput
    mml?: ProductionMmlUpdateOneRequiredWithoutCuttingLinesNestedInput
    outProduct?: ProductUpdateOneRequiredWithoutCuttingLineOutputsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCuttingLinesNestedInput
  }

  export type ProductionCuttingLineUncheckedUpdateWithoutProductionInputInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    outProductId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionCuttingLineUncheckedUpdateManyWithoutProductionInputInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionDocId?: IntFieldUpdateOperationsInput | number
    mmlId?: IntFieldUpdateOperationsInput | number
    outProductId?: IntFieldUpdateOperationsInput | number
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyInConsumed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}